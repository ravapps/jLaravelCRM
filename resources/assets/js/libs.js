/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function (global, factory) {

    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory(global, true) :
            function (w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

    var arr = [];

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};


    var
        // Use the correct document accordingly with window argument (sandbox)
        document = window.document,

        version = "2.1.3",

        // Define a local copy of jQuery
        jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        },

        // Support: Android<4.1
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function () {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {
            return num != null ?

                // Return just the one element from the set
                ( num < 0 ? this[num + this.length] : this[num] ) :

                // Return all the elements in a clean array
                slice.call(this);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },

        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        eq: function (i) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function () {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) )) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function (msg) {
            throw new Error(msg);
        },

        noop: function () {
        },

        isFunction: function (obj) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray,

        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },

        isNumeric: function (obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
        },

        isPlainObject: function (obj) {
            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            if (obj.constructor &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false;
            }

            // If the function hasn't returned already, we're confident that
            // |obj| is a plain object, created by {} or constructed with new Object
            return true;
        },

        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        type: function (obj) {
            if (obj == null) {
                return obj + "";
            }
            // Support: Android<4.0, iOS<6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[toString.call(obj)] || "object" :
                typeof obj;
        },

        // Evaluates a script in a global context
        globalEval: function (code) {
            var script,
                indirect = eval;

            code = jQuery.trim(code);

            if (code) {
                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval
                    indirect(code);
                }
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE9-11+
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function (string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },

        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function (obj, callback, args) {
            var value,
                i = 0,
                length = obj.length,
                isArray = isArraylike(obj);

            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);

                        if (value === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);

                        if (value === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1
        trim: function (text) {
            return text == null ?
                "" :
                ( text + "" ).replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret,
                        typeof arr === "string" ?
                            [arr] : arr
                    );
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        merge: function (first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var value,
                i = 0,
                length = elems.length,
                isArray = isArraylike(elems),
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function (fn, context) {
            var tmp, args, proxy;

            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: Date.now,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

// Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArraylike(obj) {
        var length = obj.length,
            type = jQuery.type(obj);

        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }

        if (obj.nodeType === 1 && length) {
            return true;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }

    var Sizzle =
        /*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
        (function (window) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // General-purpose constants
                MAX_NEGATIVE = 1 << 31,

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // http://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace("w", "w#"),

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + characterEncoding + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),

                matchExpr = {
                    "ID": new RegExp("^#(" + characterEncoding + ")"),
                    "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                    "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                    "ATTR": new RegExp("^" + attributes),
                    "PSEUDO": new RegExp("^" + pseudos),
                    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },

                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,
                rescape = /'|\\/g,

                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                funescape = function (_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode(high + 0x10000) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                    setDocument();
                };

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call(preferredDoc.childNodes)),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ?

                        // Leverage slice if possible
                        function (target, els) {
                            push_native.apply(target, slice.call(els));
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function (target, els) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ((target[j++] = els[i++])) {
                            }
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;

                if (( context ? context.ownerDocument || context : preferredDoc ) !== document) {
                    setDocument(context);
                }

                context = context || document;
                results = results || [];
                nodeType = context.nodeType;

                if (typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                    return results;
                }

                if (!seed && documentIsHTML) {

                    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        // Speed-up: Sizzle("#ID")
                        if ((m = match[1])) {
                            if (nodeType === 9) {
                                elem = context.getElementById(m);
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document (jQuery #6963)
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE, Opera, and Webkit return items
                                    // by name instead of ID
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                // Context is not a document
                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                    contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }

                            // Speed-up: Sizzle("TAG")
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;

                            // Speed-up: Sizzle(".CLASS")
                        } else if ((m = match[3]) && support.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }

                    // QSA path
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType !== 1 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);

                            if ((old = context.getAttribute("id"))) {
                                nid = old.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid);
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + toSelector(groups[i]);
                            }
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            newSelector = groups.join(",");
                        }

                        if (newSelector) {
                            try {
                                push.apply(results,
                                    newContext.querySelectorAll(newSelector)
                                );
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (!old) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }

                // All others
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }

            /**
             * Create key-value caches of limited size
             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
             *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *    deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + " ") > Expr.cacheLength) {
                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                }

                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert(fn) {
                var div = document.createElement("div");

                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    // release memory in IE
                    div = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split("|"),
                    i = attrs.length;

                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        ( ~b.sourceIndex || MAX_NEGATIVE ) -
                        ( ~a.sourceIndex || MAX_NEGATIVE );

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }

                // Check if b follows a
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j,
                            matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

// Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function (elem) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, parent,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // If no document and documentElement is available, return
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }

                // Set our document
                document = doc;
                docElem = doc.documentElement;
                parent = doc.defaultView;

                // Support: IE>8
                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                // IE6-8 do not support the defaultView property so parent will be undefined
                if (parent && parent !== parent.top) {
                    // IE11 does not have attachEvent, so all must suffer
                    if (parent.addEventListener) {
                        parent.addEventListener("unload", unloadHandler, false);
                    } else if (parent.attachEvent) {
                        parent.attachEvent("onunload", unloadHandler);
                    }
                }

                /* Support tests
	---------------------------------------------------------------------- */
                documentIsHTML = !isXML(doc);

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (div) {
                    div.className = "i";
                    return !div.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (div) {
                    div.appendChild(doc.createComment(""));
                    return !div.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                });

                // ID find and filter
                if (support.getById) {
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var m = context.getElementById(id);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [m] : [];
                        }
                    };
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find["ID"];

                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function (tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);

                            // DocumentFragment nodes don't have gEBTN
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } :

                    function (tag, context) {
                        var elem,
                            tmp = [],
                            i = 0,
                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                    if (documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ((support.qsa = rnative.test(doc.querySelectorAll))) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (div) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\f]' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if (div.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!div.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                        }

                        // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                        if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                            rbuggyQSA.push("~=");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibing-combinator selector` fails
                        if (!div.querySelectorAll("a#" + expando + "+*").length) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });

                    assert(function (div) {
                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = doc.createElement("input");
                        input.setAttribute("type", "hidden");
                        div.appendChild(input).setAttribute("name", "D");

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if (div.querySelectorAll("[name=d]").length) {
                            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(":enabled").length) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                        docElem.webkitMatchesSelector ||
                        docElem.mozMatchesSelector ||
                        docElem.oMatchesSelector ||
                        docElem.msMatchesSelector)))) {

                    assert(function (div) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(div, "div");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(div, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos);
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition);

                // Element contains another
                // Purposefully does not implement inclusive descendent
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test(docElem.contains) ?
                    function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!( bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                        ));
                    } :
                    function (a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function (a, b) {

                        // Flag for duplicate removal
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                            a.compareDocumentPosition(b) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if (compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                            // Choose the first element that is related to our preferred document
                            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                ( indexOf(sortInput, a) - indexOf(sortInput, b) ) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function (a, b) {
                        // Exit early if the nodes are identical
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];

                        // Parentless nodes are either documents or disconnected
                        if (!aup || !bup) {
                            return a === doc ? -1 :
                                b === doc ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                ( indexOf(sortInput, a) - indexOf(sortInput, b) ) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck(ap[i], bp[i]) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return doc;
            };

            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };

            Sizzle.matchesSelector = function (elem, expr) {
                // Set document vars if needed
                if (( elem.ownerDocument || elem ) !== document) {
                    setDocument(elem);
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace(rattributeQuotes, "='$1']");

                if (support.matchesSelector && documentIsHTML &&
                    ( !rbuggyMatches || !rbuggyMatches.test(expr) ) &&
                    ( !rbuggyQSA || !rbuggyQSA.test(expr) )) {

                    try {
                        var ret = matches.call(elem, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                    }
                }

                return Sizzle(expr, document, null, [elem]).length > 0;
            };

            Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                if (( context.ownerDocument || context ) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };

            Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                if (( elem.ownerDocument || elem ) !== document) {
                    setDocument(elem);
                }

                var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                        fn(elem, name, !documentIsHTML) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute(name) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.error = function (msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);

                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {
                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": {dir: "parentNode", first: true},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: true},
                    "~": {dir: "previousSibling"}
                },

                preFilter: {
                    "ATTR": function (match) {
                        match[1] = match[1].replace(runescape, funescape);

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = ( match[3] || match[4] || match[5] || "" ).replace(runescape, funescape);

                        if (match[2] === "~=") {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice(0, 4);
                    },

                    "CHILD": function (match) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if (match[1].slice(0, 3) === "nth") {
                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                            match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                            // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }

                        return match;
                    },

                    "PSEUDO": function (match) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if (matchExpr["CHILD"].test(match[0])) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if (match[3]) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if (unquoted && rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    }
                },

                filter: {

                    "TAG": function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function () {
                                return true;
                            } :
                            function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function (className) {
                        var pattern = classCache[className + " "];

                        return pattern ||
                            (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                            classCache(className, function (elem) {
                                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                            });
                    },

                    "ATTR": function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);

                            if (result == null) {
                                return operator === "!=";
                            }
                            if (!operator) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                            operator === "$=" ? check && result.slice(-check.length) === check :
                                                operator === "~=" ? ( " " + result.replace(rwhitespace, " ") + " " ).indexOf(check) > -1 :
                                                    operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function (elem) {
                                return !!elem.parentNode;
                            } :

                            function (elem, context, xml) {
                                var cache, outerCache, node, diff, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;

                                if (parent) {

                                    // :(first|last|only)-(child|of-type)
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while ((node = node[dir])) {
                                                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [forward ? parent.firstChild : parent.lastChild];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (forward && useCache) {
                                        // Seek `elem` from a previously-cached index
                                        outerCache = parent[expando] || (parent[expando] = {});
                                        cache = outerCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];

                                        while ((node = ++nodeIndex && node && node[dir] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop())) {

                                            // When found, cache indexes on `parent` and break
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                outerCache[type] = [dirruns, nodeIndex, diff];
                                                break;
                                            }
                                        }

                                        // Use previously-cached element index if available
                                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                        diff = cache[1];

                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                    } else {
                                        // Use the same loop as above to seek `elem` from the start
                                        while ((node = ++nodeIndex && node && node[dir] ||
                                            (diff = nodeIndex = 0) || start.pop())) {

                                            if (( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff) {
                                                // Cache the index of each encountered element
                                                if (useCache) {
                                                    (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                                }

                                                if (node === elem) {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                }
                            };
                    },

                    "PSEUDO": function (pseudo, argument) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }

                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, "", argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                markFunction(function (seed, matches) {
                                    var idx,
                                        matched = fn(seed, argument),
                                        i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !( matches[idx] = matched[i] );
                                    }
                                }) :
                                function (elem) {
                                    return fn(elem, 0, args);
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function (selector) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, "$1"));

                        return matcher[expando] ?
                            markFunction(function (seed, matches, context, xml) {
                                var elem,
                                    unmatched = matcher(seed, null, xml, []),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while (i--) {
                                    if ((elem = unmatched[i])) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function (elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),

                    "contains": markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return ( elem.textContent || elem.innerText || getText(elem) ).indexOf(text) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction(function (lang) {
                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || "")) {
                            Sizzle.error("unsupported lang: " + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ?
                                        elem.lang :
                                        elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },

                    "root": function (elem) {
                        return elem === docElem;
                    },

                    "focus": function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": function (elem) {
                        return elem.disabled === false;
                    },

                    "disabled": function (elem) {
                        return elem.disabled === true;
                    },

                    "checked": function (elem) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function (elem) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function (elem) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function (elem) {
                        return !Expr.pseudos["empty"](elem);
                    },

                    // Element/input types
                    "header": function (elem) {
                        return rheader.test(elem.nodeName);
                    },

                    "input": function (elem) {
                        return rinputs.test(elem.nodeName);
                    },

                    "button": function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function () {
                        return [0];
                    }),

                    "last": createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),

                    "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),

                    "even": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
            for (i in {radio: true, checkbox: true, file: true, password: true, image: true}) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {submit: true, reset: true}) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

// Easy API for creating new setFilters
            function setFilters() {
            }

            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[selector + " "];

                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while (soFar) {

                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace(rtrim, " ")
                        });
                        soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }

                    if (!matched) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error(selector) :
                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function (elem, context, xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                    } :

                    // Check against all ancestor/preceding elements
                    function (elem, context, xml) {
                        var oldCache, outerCache,
                            newCache = [dirruns, doneName];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                        if (xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});
                                    if ((oldCache = outerCache[dir]) &&
                                        oldCache[0] === dirruns && oldCache[1] === doneName) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[2] = oldCache[2]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        outerCache[dir] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ((newCache[2] = matcher(elem, context, xml))) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ?
                    function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && ( seed || !selector ) ?
                            condense(elems, preMap, preFilter, context, xml) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }

                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice(preexisting, matcherOut.length) :
                                matcherOut
                        );
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true),
                    matchAnyContext = addCombinator(function (elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true),
                    matchers = [function (elem, context, xml) {
                        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                            (checkContext = context).nodeType ?
                                matchContext(elem, context, xml) :
                                matchAnyContext(elem, context, xml) );
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    }];

                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher(matchers),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})
                                ).replace(rtrim, "$1"),
                                matcher,
                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                j < len && toSelector(tokens)
                            );
                        }
                        matchers.push(matcher);
                    }
                }

                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, outermost) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if (outermost) {
                            outermostContext = context !== document && context;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if (bySet) {
                                // They will have gone through all possible matchers
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }

                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }

                            if (seed) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }

                            // Add matches to results
                            push.apply(results, setMatched);

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 &&
                                ( matchedCount + setMatchers.length ) > 1) {

                                Sizzle.uniqueSort(results);
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction(superMatcher) :
                    superMatcher;
            }

            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];

                if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));

                results = results || [];

                // Try to minimize operations if there is no seed and only one group
                if (match.length === 1) {

                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        support.getById && context.nodeType === 9 && documentIsHTML &&
                        Expr.relative[tokens[1].type]) {

                        context = ( Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [] )[0];
                        if (!context) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if (compiled) {
                            context = context.parentNode;
                        }

                        selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
                                    token.matches[0].replace(runescape, funescape),
                                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                ))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                ( compiled || compile(selector, match) )(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    rsibling.test(selector) && testContext(context.parentNode) || context
                );
                return results;
            };

// One-time assignments

// Sort stability
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
            setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (div1) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition(document.createElement("div")) & 1;
            });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!assert(function (div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#";
                })) {
                addHandle("type|href|height|width", function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                    }
                });
            }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
            if (!support.attributes || !assert(function (div) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute("value", "");
                    return div.firstChild.getAttribute("value") === "";
                })) {
                addHandle("value", function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue;
                    }
                });
            }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
            if (!assert(function (div) {
                    return div.getAttribute("disabled") == null;
                })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })(window);


    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;


    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);


    var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });

        }

        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return ( elem === qualifier ) !== not;
            });

        }

        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }

            qualifier = jQuery.filter(qualifier, elements);
        }

        return jQuery.grep(elements, function (elem) {
            return ( indexOf.call(qualifier, elem) >= 0 ) !== not;
        });
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ?
            jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
            jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                return elem.nodeType === 1;
            }));
    };

    jQuery.fn.extend({
        find: function (selector) {
            var i,
                len = this.length,
                ret = [],
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ?
                    jQuery(selector) :
                    selector || [],
                false
            ).length;
        }
    });


// Initialize a jQuery object


// A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

        init = jQuery.fn.init = function (selector, context) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                // Properties of context are called as methods if possible
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        // Support: Blackberry 4.6
                        // gEBID returns nodes no longer in the document (#6963)
                        if (elem && elem.parentNode) {
                            // Inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return ( context || rootjQuery ).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== "undefined" ?
                    rootjQuery.ready(selector) :
                    // Execute immediately if ready is not present
                    selector(jQuery);
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray(selector, this);
        };

// Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

// Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [],
                truncate = until !== undefined;

            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },

        sibling: function (n, elem) {
            var matched = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }

            return matched;
        }
    });

    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function (selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                    jQuery(selectors, context || this.context) :
                    0;

            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    // Always skip document fragments
                    if (cur.nodeType < 11 && (pos ?
                            pos.index(cur) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors))) {

                        matched.push(cur);
                        break;
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
            );
        },

        add: function (selector, context) {
            return this.pushStack(
                jQuery.unique(
                    jQuery.merge(this.get(), jQuery(selector, context))
                )
            );
        },

        addBack: function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function (elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(( elem.parentNode || {} ).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnotwhite = (/\S+/g);


// String to Object options format cache
    var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            ( optionsCache[options] || createOptions(options) ) :
            jQuery.extend({}, options);

        var // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // Flag to know if list is currently firing
            firing,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function () {
                    if (list) {
                        // First, we save the current length
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === "function") {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== "string") {
                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if (firing) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while (( index = jQuery.inArray(arg, list, index) ) > -1) {
                                list.splice(index, 1);
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!( list && list.length );
                },
                // Remove all callbacks from the list
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                // Have the list do nothing anymore
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function () {
                    return !list;
                },
                // Lock the list in its current state
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function () {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                    if (list && ( !fired || stack )) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function () {
                    return !!fired;
                }
            };

        return self;
    };


    jQuery.extend({

        Deferred: function (func) {
            var tuples = [
                    // action, add listener, listener list, final state
                    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.Callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function (/* fnDone, fnFail, fnProgress */) {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise()
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject)
                                            .progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function () {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (subordinate /* , ..., subordinateN */) {
            var i = 0,
                resolveValues = slice.call(arguments),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || ( subordinate && jQuery.isFunction(subordinate.promise) ) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!( --remaining )) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // Add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise()
                            .done(updateFunc(i, resolveContexts, resolveValues))
                            .fail(deferred.reject)
                            .progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // If we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
    });


// The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function (fn) {
        // Add the callback
        jQuery.ready.promise().done(fn);

        return this;
    };

    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function (wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
    }

    jQuery.ready.promise = function (obj) {
        if (!readyList) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // We once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready);

            } else {

                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed, false);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed, false);
            }
        }
        return readyList.promise(obj);
    };

// Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!jQuery.isFunction(value)) {
                raw = true;
            }

            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn.call(elems) :
                len ? fn(elems[0], key) : emptyGet;
    };


    /**
     * Determines whether an object can have data
     */
    jQuery.acceptData = function (owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };


    function Data() {
        // Support: Android<4,
        // Old WebKit does not have Object.preventExtensions/freeze method,
        // return new empty object instead with no [[set]] accessor
        Object.defineProperty(this.cache = {}, 0, {
            get: function () {
                return {};
            }
        });

        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;
    Data.accepts = jQuery.acceptData;

    Data.prototype = {
        key: function (owner) {
            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return the key for a frozen object.
            if (!Data.accepts(owner)) {
                return 0;
            }

            var descriptor = {},
                // Check if the owner object already has a cache key
                unlock = owner[this.expando];

            // If not, create one
            if (!unlock) {
                unlock = Data.uid++;

                // Secure it in a non-enumerable, non-writable property
                try {
                    descriptor[this.expando] = {value: unlock};
                    Object.defineProperties(owner, descriptor);

                    // Support: Android<4
                    // Fallback to a less secure definition
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }

            // Ensure the cache object
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }

            return unlock;
        },
        set: function (owner, data, value) {
            var prop,
                // There may be an unlock assigned to this node,
                // if there is no entry for this "owner", create one inline
                // and set the unlock as though an owner entry had always existed
                unlock = this.key(owner),
                cache = this.cache[unlock];

            // Handle: [ owner, key, value ] args
            if (typeof data === "string") {
                cache[data] = value;

                // Handle: [ owner, { properties } ] args
            } else {
                // Fresh assignments by object are shallow copied
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                    // Otherwise, copy the properties one-by-one to the cache object
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function (owner, key) {
            // Either a valid cache is found, or will be created.
            // New caches will be created and the unlock returned,
            // allowing direct access to the newly created
            // empty data object. A valid owner object must be provided.
            var cache = this.cache[this.key(owner)];

            return key === undefined ?
                cache : cache[key];
        },
        access: function (owner, key, value) {
            var stored;
            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined ||
                ((key && typeof key === "string") && value === undefined)) {

                stored = this.get(owner, key);

                return stored !== undefined ?
                    stored : this.get(owner, jQuery.camelCase(key));
            }

            // [*]When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, name, camel,
                unlock = this.key(owner),
                cache = this.cache[unlock];

            if (key === undefined) {
                this.cache[unlock] = {};

            } else {
                // Support array or space separated string of keys
                if (jQuery.isArray(key)) {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    // Try the string as a key before any manipulation
                    if (key in cache) {
                        name = [key, camel];
                    } else {
                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ?
                            [name] : ( name.match(rnotwhite) || [] );
                    }
                }

                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function (owner) {
            return !jQuery.isEmptyObject(
                this.cache[owner[this.expando]] || {}
            );
        },
        discard: function (owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();

    var data_user = new Data();


//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                            data === "null" ? null :
                                // Only convert to a number if it doesn't change the string
                                +data + "" === data ? +data :
                                    rbrace.test(data) ? jQuery.parseJSON(data) :
                                        data;
                } catch (e) {
                }

                // Make sure we set the data so it isn't changed later
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function (elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },

        data: function (elem, name, data) {
            return data_user.access(elem, name, data);
        },

        removeData: function (elem, name) {
            data_user.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to data_priv methods, these can be deprecated.
        _data: function (elem, name, data) {
            return data_priv.access(elem, name, data);
        },

        _removeData: function (elem, name) {
            data_priv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);

                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function () {
                    data_user.set(this, key);
                });
            }

            return access(this, function (value) {
                var data,
                    camelKey = jQuery.camelCase(key);

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {
                    // Attempt to get data from the cache
                    // with the key as-is
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to get data from the cache
                    // with the key camelized
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function () {
                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = data_user.get(this, camelKey);

                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    data_user.set(this, camelKey, value);

                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function (key) {
            return this.each(function () {
                data_user.remove(this, key);
            });
        }
    });


    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = ( type || "fx" ) + "queue";
                queue = data_priv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    data_priv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
                this :
                this.each(function () {
                    var queue = jQuery.queue(this, type, data);

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type);

                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                    if (!( --count )) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHidden = function (elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };

    var rcheckableType = (/^(?:checkbox|radio)$/i);


    (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // Support: Safari<=5.1
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Safari<=5.1, Android<4.2
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE<=11+
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var strundefined = typeof undefined;


    support.focusinBubbles = "onfocusin" in window;


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function (elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = data_priv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = ( types || "" ).match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = data_priv.hasData(elem) && data_priv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if (( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !tmp || tmp.test(handleObj.namespace) ) &&
                        ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector )) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, "events");
            }
        },

        trigger: function (event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special,
                eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ?
                event :
                new jQuery.Event(type, typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ?
                new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [event] :
                jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = ( data_priv.get(cur, "events") || {} )[event.type] && data_priv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &&
                    jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function (event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);

            var i, j, ret, matched, handleObj,
                handlerQueue = [],
                args = slice.call(arguments),
                handlers = ( data_priv.get(this, "events") || {} )[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ( (jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler )
                            .apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function (event, handlers) {
            var i, matches, sel, handleObj,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ?
                                    jQuery(sel, this).index(cur) >= 0 :
                                    jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({elem: cur, handlers: matches});
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({elem: this, handlers: handlers.slice(delegateCount)});
            }

            return handlerQueue;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (event, original) {
                var eventDoc, doc, body,
                    button = original.button;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY + ( doc && doc.scrollTop || body && body.scrollTop || 0 ) - ( doc && doc.clientTop || body && body.clientTop || 0 );
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }

                return event;
            }
        },

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook =
                    rmouseEvent.test(type) ? this.mouseHooks :
                        rkeyEvent.test(type) ? this.keyHooks :
                            {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome<28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function () {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function (event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function (event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },

        simulate: function (type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };

    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&
            // Support: Android<4.0
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,

        preventDefault: function () {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
    if (!support.focusinBubbles) {
        jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };

            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, ( attaches || 0 ) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);

                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function (types, selector, data, fn, /*INTERNAL*/ one) {
            var origFn, type;

            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });


    var
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

        // We have to close these tags to support XHTML (#13200)
        wrapMap = {

            // Support: IE9
            option: [1, "<select multiple='multiple'>", "</select>"],

            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

            _default: [0, "", ""]
        };

// Support: IE9
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") &&
        jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

            elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild(elem.ownerDocument.createElement("tbody")) :
            elem;
    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);

        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

// Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            data_priv.set(
                elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
            );
        }
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);

            data_user.set(dest, udataCur);
        }
    }

    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
            context.querySelectorAll ? context.querySelectorAll(tag || "*") :
                [];

        return tag === undefined || tag && jQuery.nodeName(context, tag) ?
            jQuery.merge([context], ret) :
            ret;
    }

// Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
                !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        buildFragment: function (elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j,
                fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;

            for (; i < l; i++) {
                elem = elems[i];

                if (elem || elem === 0) {

                    // Add nodes directly
                    if (jQuery.type(elem) === "object") {
                        // Support: QtWebKit, PhantomJS
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                        // Convert non-html into a text node
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));

                        // Convert html into DOM nodes
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"));

                        // Deserialize a standard representation
                        tag = ( rtagName.exec(elem) || ["", ""] )[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }

                        // Support: QtWebKit, PhantomJS
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(nodes, tmp.childNodes);

                        // Remember the top-level container
                        tmp = fragment.firstChild;

                        // Ensure the created nodes are orphaned (#12392)
                        tmp.textContent = "";
                    }
                }
            }

            // Remove wrapper from fragment
            fragment.textContent = "";

            i = 0;
            while ((elem = nodes[i++])) {

                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }

                contains = jQuery.contains(elem.ownerDocument, elem);

                // Append to fragment
                tmp = getAll(fragment.appendChild(elem), "script");

                // Preserve script evaluation history
                if (contains) {
                    setGlobalEval(tmp);
                }

                // Capture executables
                if (scripts) {
                    j = 0;
                    while ((elem = tmp[j++])) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }

            return fragment;
        },

        cleanData: function (elems) {
            var data, elem, type, key,
                special = jQuery.event.special,
                i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];

                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            // Discard any remaining `private` data
                            delete data_priv.cache[key];
                        }
                    }
                }
                // Discard any remaining `user` data
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });

    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ?
                    jQuery.text(this) :
                    this.empty().each(function () {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
            }, null, value, arguments.length);
        },

        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        remove: function (selector, keepData /* Internal Use Only */) {
            var elem,
                elems = selector ? jQuery.filter(selector, this) : this,
                i = 0;

            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }

                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }

            return this;
        },

        empty: function () {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                    !wrapMap[( rtagName.exec(value) || ["", ""] )[1].toLowerCase()]) {

                    value = value.replace(rxhtmlTag, "<$1></$2>");

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {
                    }
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function () {
            var arg = arguments[0];

            // Make the changes, replacing each context element with the new content
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;

                jQuery.cleanData(getAll(this));

                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });

            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, callback) {

            // Flatten any nested arrays
            args = concat.apply([], args);

            var fragment, first, scripts, hasScripts, node, doc,
                i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction(value);

            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test(value) )) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }

            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }

                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for (; i < l; i++) {
                        node = fragment;

                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);

                            // Keep references to cloned scripts for later restoration
                            if (hasScripts) {
                                // Support: QtWebKit
                                // jQuery.merge because push.apply(_, arraylike) throws
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }

                        callback.call(this[i], node, i);
                    }

                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;

                        // Reenable scripts
                        jQuery.map(scripts, restoreScript);

                        // Evaluate executable scripts on first document insertion
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") &&
                                !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                                if (node.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                }
            }

            return this;
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
                ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });


    var iframe,
        elemdisplay = {};

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
// Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style,
            elem = jQuery(doc.createElement(name)).appendTo(doc.body),

            // getDefaultComputedStyle might be reliably used only on attached element
            display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle(elem[0]) ) ?

                // Use of this method is a temporary fix (more like optimization) until something better comes along,
                // since it was removed from specification and supported only in FF
                style.display : jQuery.css(elem[0], "display");

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];

        if (!display) {
            display = actualDisplay(nodeName, doc);

            // If the simple way fails, read from inside an iframe
            if (display === "none" || !display) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[0].contentDocument;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return display;
    }

    var rmargin = (/^margin/);

    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {
        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }

        return window.getComputedStyle(elem, null);
    };


    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles(elem);

        // Support: IE9
        // getPropertyValue is only needed for .css('filter') (#12537)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }

        if (computed) {

            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }

            // Support: iOS < 6
            // A tribute to the "awesome hack by Dean Edwards"
            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if (rnumnonpx.test(ret) && rmargin.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?
            // Support: IE
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function () {
                if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }


    (function () {
        var pixelPositionVal, boxSizingReliableVal,
            docElem = document.documentElement,
            container = document.createElement("div"),
            div = document.createElement("div");

        if (!div.style) {
            return;
        }

        // Support: IE9-11+
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
            "position:absolute";
        container.appendChild(div);

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                "border:1px;padding:1px;width:4px;position:absolute";
            div.innerHTML = "";
            docElem.appendChild(container);

            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== "1%";
            boxSizingReliableVal = divStyle.width === "4px";

            docElem.removeChild(container);
        }

        // Support: node.js jsdom
        // Don't assume that getComputedStyle is a property of the global object
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function () {

                    // This test is executed only once but we still do memoizing
                    // since we can use the boxSizingReliable pre-computing.
                    // No need to check if the test was already performed, though.
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function () {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function () {

                    // Support: Android 2.3
                    // Check if div with explicit width and no margin-right incorrectly
                    // gets computed margin-right based on width of container. (#3333)
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // This support function is only executed once so no memoizing is needed.
                    var ret,
                        marginDiv = div.appendChild(document.createElement("div"));

                    // Reset CSS: box-sizing; display; margin; border; padding
                    marginDiv.style.cssText = div.style.cssText =
                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                        "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                    marginDiv.style.marginRight = marginDiv.style.width = "0";
                    div.style.width = "1px";
                    docElem.appendChild(container);

                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);

                    docElem.removeChild(container);
                    div.removeChild(marginDiv);

                    return ret;
                }
            });
        }
    })();


// A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };


    var
        // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
        rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),

        cssShow = {position: "absolute", visibility: "hidden", display: "block"},
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = ["Webkit", "O", "Moz", "ms"];

// Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {

        // Shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }

        return origName;
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ?
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[1] - ( subtract || 0 )) + ( matches[2] || "px" ) :
            value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === ( isBorderBox ? "border" : "content" ) ?
            // If we already have the right measurement, avoid augmentation
            4 :
            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,

            val = 0;

        for (; i < 4; i += 2) {
            // Both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }

            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // At this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                // At this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // At this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // Check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox &&
                ( support.boxSizingReliable() || val === elem.style[name] );

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // Use the active box-sizing model to add/subtract irrelevant styles
        return ( val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
            )
        ) + "px";
    }

    function showHide(elements, show) {
        var display, elem, hidden,
            values = [],
            index = 0,
            length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            values[index] = data_priv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);

                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase(name),
                style = elem.style;

            name = jQuery.cssProps[origName] || ( jQuery.cssProps[origName] = vendorPropName(style, origName) );

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = ( ret[1] + 1 ) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // Support: IE9-11+
                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra, styles) {
            var val, num, hooks,
                origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || ( jQuery.cssProps[origName] = vendorPropName(elem.style, origName) );

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ?
                        jQuery.swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, name, extra);
                        }) :
                        getWidthOrHeight(elem, name, extra);
                }
            },

            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ?
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                        styles
                    ) : 0
                );
            }
        };
    });

// Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
        function (elem, computed) {
            if (computed) {
                return jQuery.swap(elem, {"display": "inline-block"},
                    curCSS, [elem, "marginRight"]);
            }
        }
    );

// These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len,
                    map = {},
                    i = 0;

                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style(elem, name, value) :
                    jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });


    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }

    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[prop] ? "" : "px" );
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
                hooks.get(this) :
                Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                if (tween.elem[tween.prop] != null &&
                    (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function (tween) {
                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && ( tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop] )) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

// Support: IE9
// Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };

    jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
    jQuery.fx.step = {};


    var
        fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value),
                    target = tween.cur(),
                    parts = rfxnum.exec(value),
                    unit = parts && parts[3] || ( jQuery.cssNumber[prop] ? "" : "px" ),

                    // Starting value computation is required for potential unit mismatches
                    start = ( jQuery.cssNumber[prop] || unit !== "px" && +target ) &&
                        rfxnum.exec(jQuery.css(tween.elem, prop)),
                    scale = 1,
                    maxIterations = 20;

                if (start && start[3] !== unit) {
                    // Trust units reported by jQuery.css
                    unit = unit || start[3];

                    // Make sure we update the tween properties later on
                    parts = parts || [];

                    // Iteratively approximate from a nonzero starting point
                    start = +target || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery.style(tween.elem, prop, start + unit);

                        // Update scale, tolerating zero or NaN from tween.cur(),
                        // break the loop if scale is unchanged or perfect, or if we've just had enough
                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                }

                // Update tween properties
                if (parts) {
                    start = tween.start = +start || +target || 0;
                    tween.unit = unit;
                    // If a +=/-= token was provided, we're doing a relative animation
                    tween.end = parts[1] ?
                        start + ( parts[1] + 1 ) * parts[2] :
                        +parts[2];
                }

                return tween;
            }]
        };

// Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return ( fxNow = jQuery.now() );
    }

// Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {height: type};

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = ( tweeners[prop] || [] ).concat(tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = data_priv.get(elem, "fxshow");

        // Handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {
                // Ensure the complete handler is called before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Height/width overflow pass
        if (elem.nodeType === 1 && ( "height" in props || "width" in props )) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, "display");

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ?
                data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === ( hidden ? "hide" : "show" )) {

                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {});
            }

            // Store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;

                data_priv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                if (!( prop in dataShow )) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!( index in props )) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function () {
                // Don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    // Support: Android 2.3
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {specialEasing: {}}, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                        animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0,
                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(
            jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        // attach callbacks from options
        return animation.progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.split(" ");
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },

        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
            jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show()

            // Animate to the value specified
                .end().animate({opacity: to}, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || data_priv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = data_priv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function () {
                var index,
                    data = data_priv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply(this, arguments) :
                this.animate(genFx(name, true), speed, easing, callback);
        };
    });

// Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };

    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };


    (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: iOS<=5.1, Android<=4.2+
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE<=11+
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: Android<=2.3
        // Options inside disabled selects are incorrectly marked as disabled
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Support: IE<=11+
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var nodeHook, boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] ||
                    ( jQuery.expr.match.bool.test(name) ? boolHook : nodeHook );
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);

                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }

            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {
                ret = jQuery.find.attr(elem, name);

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function (elem, value) {
            var name, propName,
                i = 0,
                attrNames = value && value.match(rnotwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;

                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                        // Set corresponding property to false
                        elem[propName] = false;
                    }

                    elem.removeAttribute(name);
                }
            }
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === "radio" &&
                        jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });

// Hooks for boolean attributes
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });


    var rfocusable = /^(?:input|select|textarea|button)$/i;

    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },

        prop: function (elem, name, value) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ?
                    ret :
                    ( elem[name] = value );

            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ?
                    ret :
                    elem[name];
            }
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
                        elem.tabIndex :
                        -1;
                }
            }
        }
    });

    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });


    var rclass = /[\t\r\n\f]/g;

    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue,
                proceed = typeof value === "string" && value,
                i = 0,
                len = this.length;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (proceed) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = ( value || "" ).match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace(rclass, " ") :
                            " "
                    );

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue,
                proceed = arguments.length === 0 || typeof value === "string" && value,
                i = 0,
                len = this.length;

            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = ( value || "" ).match(rnotwhite) || [];

                for (; i < len; i++) {
                    elem = this[i];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace(rclass, " ") :
                            ""
                    );

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value;

            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // Toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery(this),
                        classNames = value.match(rnotwhite) || [];

                    while ((className = classNames[i++])) {
                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        data_priv.set(this, "__className__", this.className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }

            return false;
        }
    });


    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // Handle most common string cases
                        ret.replace(rreturn, "") :
                        // Handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ?
                        val :
                        // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                            max :
                            one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // IE6-9 doesn't update selected after form reset (#2551)
                        if (( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup") )) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];
                        if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
                            optionSet = true;
                        }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

// Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return ( elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 );
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });


// Return jQuery for attributes-only inclusion


    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ?
                this.on(name, null, data, fn) :
                this.trigger(name);
        };
    });

    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });


    var nonce = jQuery.now();

    var rquery = (/\?/);


// Support: Android 2.3
// Workaround failure to string-cast null input
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + "");
    };


// Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE9
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };


    var
        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*"),

        // Document location
        ajaxLocation = window.location.href,

        // Segment location into parts
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {
                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
            seekingTransport = ( structure === transports );

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !( selected = dataTypeOrTransport );
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                ( flatOptions[key] ? target : ( deep || (deep = {}) ) )[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
                                    converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return {state: "success", data: response};
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            return settings ?

                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                // Extending ajaxSettings
                ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,
                // URL without anti-cache param
                cacheURL,
                // Response headers
                responseHeadersString,
                responseHeaders,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery(callbackContext) :
                    jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = "canceled",
                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            } else {
                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace(rhash, "")
                .replace(rprotocol, ajaxLocParts[1] + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!( parts &&
                    ( parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                        ( parts[3] || ( parts[1] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[3] || ( ajaxLocParts[1] === "http:" ? "80" : "443" ) ) )
                );
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    cacheURL = ( s.url += ( rquery.test(cacheURL) ? "&" : "?" ) + s.data );
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ?

                        // If there is already a '_' parameter, set its value
                        cacheURL.replace(rts, "$1_=" + nonce++) :

                        // Otherwise add one to the end
                        cacheURL + ( rquery.test(cacheURL) ? "&" : "?" ) + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                    s.accepts[s.dataTypes[0]] + ( s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts["*"]
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && ( s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2 )) {
                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for (i in {success: 1, error: 1, complete: 1}) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                        [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!( --jQuery.active )) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            // Shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });


    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };


    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;

            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });


    jQuery.expr.filters.hidden = function (elem) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };


    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add);
                }
            });

        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

// Serialize an array of form elements or a set of
// key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function (key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : ( value == null ? "" : value );
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || ( a.jquery && !jQuery.isPlainObject(a) )) {
            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function () {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery(this).is(":disabled") &&
                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                        ( this.checked || !rcheckableType.test(type) );
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    return val == null ?
                        null :
                        jQuery.isArray(val) ?
                            jQuery.map(val, function (val) {
                                return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                            }) :
                            {name: elem.name, value: val.replace(rCRLF, "\r\n")};
                }).get();
        }
    });


    jQuery.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest();
        } catch (e) {
        }
    };

    var xhrId = 0,
        xhrCallbacks = {},
        xhrSuccessStatus = {
            // file protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
    if (window.attachEvent) {
        window.attachEvent("onunload", function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }

    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
        var callback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId;

                    xhr.open(options.type, options.url, options.async, options.username, options.password);

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    complete(
                                        // file: protocol always yields status 0; see #8605, #14207
                                        xhr.status,
                                        xhr.statusText
                                    );
                                } else {
                                    complete(
                                        xhrSuccessStatus[xhr.status] || xhr.status,
                                        xhr.statusText,
                                        // Support: IE9
                                        // Accessing binary-data responseText throws an exception
                                        // (#11426)
                                        typeof xhr.responseText === "string" ? {
                                            text: xhr.responseText
                                        } : undefined,
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    xhr.onerror = callback("error");

                    // Create the abort callback
                    callback = xhrCallbacks[id] = callback("abort");

                    try {
                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


// Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

// Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

// Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on(
                        "load error",
                        callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === "error" ? 404 : 200, evt.type);
                            }
                        }
                    );
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });


    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
            this[callback] = true;
            return callback;
        }
    });

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test(s.url) ?
                    "url" :
                    typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += ( rquery.test(s.url) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {
                // Restore preexisting value
                window[callbackName] = overwritten;

                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });


// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = jQuery.buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };


// Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }

        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function (responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                    // Otherwise use the full result
                    responseText);

            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
            });
        }

        return this;
    };


// Attach a bunch of functions for handling common AJAX events
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });


    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };


    var docElem = window.document.documentElement;

    /**
     * Gets a window from an element
     */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                ( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if (options.left != null) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);

            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ?
                    this :
                    this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
            }

            var docElem, win,
                elem = this[0],
                box = {top: 0, left: 0},
                doc = elem && elem.ownerDocument;

            if (!doc) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }

            // Support: BlackBerry 5, iOS 3 (original iPhone)
            // If we don't have gBCR, just use 0,0 rather than error
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },

        position: function () {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset,
                elem = this[0],
                parentOffset = {top: 0, left: 0};

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") {
                // Assume getBoundingClientRect is there when computed position is fixed
                offset = elem.getBoundingClientRect();

            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;

                while (offsetParent && ( !jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static" )) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || docElem;
            });
        }
    });

// Create scrollLeft and scrollTop methods
    jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(
                        !top ? val : window.pageXOffset,
                        top ? val : window.pageYOffset
                    );

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
            function (elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);
                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test(computed) ?
                        jQuery(elem).position()[prop] + "px" :
                        computed;
                }
            }
        );
    });


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({Height: "height", Width: "width"}, function (name, type) {
        jQuery.each({padding: "inner" + name, content: type, "": "outer" + name}, function (defaultExtra, funcName) {
            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                return access(this, function (elem, type, value) {
                    var doc;

                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(
                            elem.body["scroll" + name], doc["scroll" + name],
                            elem.body["offset" + name], doc["offset" + name],
                            doc["client" + name]
                        );
                    }

                    return value === undefined ?
                        // Get width or height on the element, requesting but not forcing parseFloat
                        jQuery.css(elem, type, extra) :

                        // Set width or height on the element
                        jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });


// The number of elements contained in the matched element set
    jQuery.fn.size = function () {
        return this.length;
    };

    jQuery.fn.andSelf = jQuery.fn.addBack;


// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
        define("jquery", [], function () {
            return jQuery;
        });
    }


    var
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }


    return jQuery;

}));

/*! jQuery UI - v1.11.4 - 2015-03-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function (e) {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
})(function (e) {
    function t(t, s) {
        var n, a, o, r = t.nodeName.toLowerCase();
        return "area" === r ? (n = t.parentNode, a = n.name, t.href && a && "map" === n.nodeName.toLowerCase() ? (o = e("img[usemap='#" + a + "']")[0], !!o && i(o)) : !1) : (/^(input|select|textarea|button|object)$/.test(r) ? !t.disabled : "a" === r ? t.href || s : s) && i(t)
    }

    function i(t) {
        return e.expr.filters.visible(t) && !e(t).parents().addBack().filter(function () {
            return "hidden" === e.css(this, "visibility")
        }).length
    }

    function s(e) {
        for (var t, i; e.length && e[0] !== document;) {
            if (t = e.css("position"), ("absolute" === t || "relative" === t || "fixed" === t) && (i = parseInt(e.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
            e = e.parent()
        }
        return 0
    }

    function n() {
        this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: !1,
            showMonthAfterYear: !1,
            yearSuffix: ""
        }, this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: !1,
            hideIfNoPrevNext: !1,
            navigationAsDateFormat: !1,
            gotoCurrent: !1,
            changeMonth: !1,
            changeYear: !1,
            yearRange: "c-10:c+10",
            showOtherMonths: !1,
            selectOtherMonths: !1,
            showWeek: !1,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: !0,
            showButtonPanel: !1,
            autoSize: !1,
            disabled: !1
        }, e.extend(this._defaults, this.regional[""]), this.regional.en = e.extend(!0, {}, this.regional[""]), this.regional["en-US"] = e.extend(!0, {}, this.regional.en), this.dpDiv = a(e("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
    }

    function a(t) {
        var i = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return t.delegate(i, "mouseout", function () {
            e(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && e(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && e(this).removeClass("ui-datepicker-next-hover")
        }).delegate(i, "mouseover", o)
    }

    function o() {
        e.datepicker._isDisabledDatepicker(v.inline ? v.dpDiv.parent()[0] : v.input[0]) || (e(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), e(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && e(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && e(this).addClass("ui-datepicker-next-hover"))
    }

    function r(t, i) {
        e.extend(t, i);
        for (var s in i) null == i[s] && (t[s] = i[s]);
        return t
    }

    function h(e) {
        return function () {
            var t = this.element.val();
            e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change")
        }
    }

    e.ui = e.ui || {}, e.extend(e.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), e.fn.extend({
        scrollParent: function (t) {
            var i = this.css("position"), s = "absolute" === i, n = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                a = this.parents().filter(function () {
                    var t = e(this);
                    return s && "static" === t.css("position") ? !1 : n.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"))
                }).eq(0);
            return "fixed" !== i && a.length ? a : e(this[0].ownerDocument || document)
        }, uniqueId: function () {
            var e = 0;
            return function () {
                return this.each(function () {
                    this.id || (this.id = "ui-id-" + ++e)
                })
            }
        }(), removeUniqueId: function () {
            return this.each(function () {
                /^ui-id-\d+$/.test(this.id) && e(this).removeAttr("id")
            })
        }
    }), e.extend(e.expr[":"], {
        data: e.expr.createPseudo ? e.expr.createPseudo(function (t) {
            return function (i) {
                return !!e.data(i, t)
            }
        }) : function (t, i, s) {
            return !!e.data(t, s[3])
        }, focusable: function (i) {
            return t(i, !isNaN(e.attr(i, "tabindex")))
        }, tabbable: function (i) {
            var s = e.attr(i, "tabindex"), n = isNaN(s);
            return (n || s >= 0) && t(i, !n)
        }
    }), e("<a>").outerWidth(1).jquery || e.each(["Width", "Height"], function (t, i) {
        function s(t, i, s, a) {
            return e.each(n, function () {
                i -= parseFloat(e.css(t, "padding" + this)) || 0, s && (i -= parseFloat(e.css(t, "border" + this + "Width")) || 0), a && (i -= parseFloat(e.css(t, "margin" + this)) || 0)
            }), i
        }

        var n = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"], a = i.toLowerCase(), o = {
            innerWidth: e.fn.innerWidth,
            innerHeight: e.fn.innerHeight,
            outerWidth: e.fn.outerWidth,
            outerHeight: e.fn.outerHeight
        };
        e.fn["inner" + i] = function (t) {
            return void 0 === t ? o["inner" + i].call(this) : this.each(function () {
                e(this).css(a, s(this, t) + "px")
            })
        }, e.fn["outer" + i] = function (t, n) {
            return "number" != typeof t ? o["outer" + i].call(this, t) : this.each(function () {
                e(this).css(a, s(this, t, !0, n) + "px")
            })
        }
    }), e.fn.addBack || (e.fn.addBack = function (e) {
        return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
    }), e("<a>").data("a-b", "a").removeData("a-b").data("a-b") && (e.fn.removeData = function (t) {
        return function (i) {
            return arguments.length ? t.call(this, e.camelCase(i)) : t.call(this)
        }
    }(e.fn.removeData)), e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), e.fn.extend({
        focus: function (t) {
            return function (i, s) {
                return "number" == typeof i ? this.each(function () {
                    var t = this;
                    setTimeout(function () {
                        e(t).focus(), s && s.call(t)
                    }, i)
                }) : t.apply(this, arguments)
            }
        }(e.fn.focus), disableSelection: function () {
            var e = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function () {
                return this.bind(e + ".ui-disableSelection", function (e) {
                    e.preventDefault()
                })
            }
        }(), enableSelection: function () {
            return this.unbind(".ui-disableSelection")
        }, zIndex: function (t) {
            if (void 0 !== t) return this.css("zIndex", t);
            if (this.length) for (var i, s, n = e(this[0]); n.length && n[0] !== document;) {
                if (i = n.css("position"), ("absolute" === i || "relative" === i || "fixed" === i) && (s = parseInt(n.css("zIndex"), 10), !isNaN(s) && 0 !== s)) return s;
                n = n.parent()
            }
            return 0
        }
    }), e.ui.plugin = {
        add: function (t, i, s) {
            var n, a = e.ui[t].prototype;
            for (n in s) a.plugins[n] = a.plugins[n] || [], a.plugins[n].push([i, s[n]])
        }, call: function (e, t, i, s) {
            var n, a = e.plugins[t];
            if (a && (s || e.element[0].parentNode && 11 !== e.element[0].parentNode.nodeType)) for (n = 0; a.length > n; n++) e.options[a[n][0]] && a[n][1].apply(e.element, i)
        }
    };
    var l = 0, u = Array.prototype.slice;
    e.cleanData = function (t) {
        return function (i) {
            var s, n, a;
            for (a = 0; null != (n = i[a]); a++) try {
                s = e._data(n, "events"), s && s.remove && e(n).triggerHandler("remove")
            } catch (o) {
            }
            t(i)
        }
    }(e.cleanData), e.widget = function (t, i, s) {
        var n, a, o, r, h = {}, l = t.split(".")[0];
        return t = t.split(".")[1], n = l + "-" + t, s || (s = i, i = e.Widget), e.expr[":"][n.toLowerCase()] = function (t) {
            return !!e.data(t, n)
        }, e[l] = e[l] || {}, a = e[l][t], o = e[l][t] = function (e, t) {
            return this._createWidget ? (arguments.length && this._createWidget(e, t), void 0) : new o(e, t)
        }, e.extend(o, a, {
            version: s.version,
            _proto: e.extend({}, s),
            _childConstructors: []
        }), r = new i, r.options = e.widget.extend({}, r.options), e.each(s, function (t, s) {
            return e.isFunction(s) ? (h[t] = function () {
                var e = function () {
                    return i.prototype[t].apply(this, arguments)
                }, n = function (e) {
                    return i.prototype[t].apply(this, e)
                };
                return function () {
                    var t, i = this._super, a = this._superApply;
                    return this._super = e, this._superApply = n, t = s.apply(this, arguments), this._super = i, this._superApply = a, t
                }
            }(), void 0) : (h[t] = s, void 0)
        }), o.prototype = e.widget.extend(r, {widgetEventPrefix: a ? r.widgetEventPrefix || t : t}, h, {
            constructor: o,
            namespace: l,
            widgetName: t,
            widgetFullName: n
        }), a ? (e.each(a._childConstructors, function (t, i) {
            var s = i.prototype;
            e.widget(s.namespace + "." + s.widgetName, o, i._proto)
        }), delete a._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o), o
    }, e.widget.extend = function (t) {
        for (var i, s, n = u.call(arguments, 1), a = 0, o = n.length; o > a; a++) for (i in n[a]) s = n[a][i], n[a].hasOwnProperty(i) && void 0 !== s && (t[i] = e.isPlainObject(s) ? e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], s) : e.widget.extend({}, s) : s);
        return t
    }, e.widget.bridge = function (t, i) {
        var s = i.prototype.widgetFullName || t;
        e.fn[t] = function (n) {
            var a = "string" == typeof n, o = u.call(arguments, 1), r = this;
            return a ? this.each(function () {
                var i, a = e.data(this, s);
                return "instance" === n ? (r = a, !1) : a ? e.isFunction(a[n]) && "_" !== n.charAt(0) ? (i = a[n].apply(a, o), i !== a && void 0 !== i ? (r = i && i.jquery ? r.pushStack(i.get()) : i, !1) : void 0) : e.error("no such method '" + n + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; " + "attempted to call method '" + n + "'")
            }) : (o.length && (n = e.widget.extend.apply(null, [n].concat(o))), this.each(function () {
                var t = e.data(this, s);
                t ? (t.option(n || {}), t._init && t._init()) : e.data(this, s, new i(n, this))
            })), r
        }
    }, e.Widget = function () {
    }, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {disabled: !1, create: null},
        _createWidget: function (t, i) {
            i = e(i || this.defaultElement || this)[0], this.element = e(i), this.uuid = l++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), this.hoverable = e(), this.focusable = e(), i !== this && (e.data(i, this.widgetFullName, this), this._on(!0, this.element, {
                remove: function (e) {
                    e.target === i && this.destroy()
                }
            }), this.document = e(i.style ? i.ownerDocument : i.document || i), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init()
        },
        _getCreateOptions: e.noop,
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function () {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")
        },
        _destroy: e.noop,
        widget: function () {
            return this.element
        },
        option: function (t, i) {
            var s, n, a, o = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t) if (o = {}, s = t.split("."), t = s.shift(), s.length) {
                for (n = o[t] = e.widget.extend({}, this.options[t]), a = 0; s.length - 1 > a; a++) n[s[a]] = n[s[a]] || {}, n = n[s[a]];
                if (t = s.pop(), 1 === arguments.length) return void 0 === n[t] ? null : n[t];
                n[t] = i
            } else {
                if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                o[t] = i
            }
            return this._setOptions(o), this
        },
        _setOptions: function (e) {
            var t;
            for (t in e) this._setOption(t, e[t]);
            return this
        },
        _setOption: function (e, t) {
            return this.options[e] = t, "disabled" === e && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!t), t && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))), this
        },
        enable: function () {
            return this._setOptions({disabled: !1})
        },
        disable: function () {
            return this._setOptions({disabled: !0})
        },
        _on: function (t, i, s) {
            var n, a = this;
            "boolean" != typeof t && (s = i, i = t, t = !1), s ? (i = n = e(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), e.each(s, function (s, o) {
                function r() {
                    return t || a.options.disabled !== !0 && !e(this).hasClass("ui-state-disabled") ? ("string" == typeof o ? a[o] : o).apply(a, arguments) : void 0
                }

                "string" != typeof o && (r.guid = o.guid = o.guid || r.guid || e.guid++);
                var h = s.match(/^([\w:-]*)\s*(.*)$/), l = h[1] + a.eventNamespace, u = h[2];
                u ? n.delegate(u, l, r) : i.bind(l, r)
            })
        },
        _off: function (t, i) {
            i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.unbind(i).undelegate(i), this.bindings = e(this.bindings.not(t).get()), this.focusable = e(this.focusable.not(t).get()), this.hoverable = e(this.hoverable.not(t).get())
        },
        _delay: function (e, t) {
            function i() {
                return ("string" == typeof e ? s[e] : e).apply(s, arguments)
            }

            var s = this;
            return setTimeout(i, t || 0)
        },
        _hoverable: function (t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function (t) {
                    e(t.currentTarget).addClass("ui-state-hover")
                }, mouseleave: function (t) {
                    e(t.currentTarget).removeClass("ui-state-hover")
                }
            })
        },
        _focusable: function (t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function (t) {
                    e(t.currentTarget).addClass("ui-state-focus")
                }, focusout: function (t) {
                    e(t.currentTarget).removeClass("ui-state-focus")
                }
            })
        },
        _trigger: function (t, i, s) {
            var n, a, o = this.options[t];
            if (s = s || {}, i = e.Event(i), i.type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), i.target = this.element[0], a = i.originalEvent) for (n in a) n in i || (i[n] = a[n]);
            return this.element.trigger(i, s), !(e.isFunction(o) && o.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented())
        }
    }, e.each({show: "fadeIn", hide: "fadeOut"}, function (t, i) {
        e.Widget.prototype["_" + t] = function (s, n, a) {
            "string" == typeof n && (n = {effect: n});
            var o, r = n ? n === !0 || "number" == typeof n ? i : n.effect || i : t;
            n = n || {}, "number" == typeof n && (n = {duration: n}), o = !e.isEmptyObject(n), n.complete = a, n.delay && s.delay(n.delay), o && e.effects && e.effects.effect[r] ? s[t](n) : r !== t && s[r] ? s[r](n.duration, n.easing, a) : s.queue(function (i) {
                e(this)[t](), a && a.call(s[0]), i()
            })
        }
    }), e.widget;
    var d = !1;
    e(document).mouseup(function () {
        d = !1
    }), e.widget("ui.mouse", {
        version: "1.11.4",
        options: {cancel: "input,textarea,button,select,option", distance: 1, delay: 0},
        _mouseInit: function () {
            var t = this;
            this.element.bind("mousedown." + this.widgetName, function (e) {
                return t._mouseDown(e)
            }).bind("click." + this.widgetName, function (i) {
                return !0 === e.data(i.target, t.widgetName + ".preventClickEvent") ? (e.removeData(i.target, t.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1) : void 0
            }), this.started = !1
        },
        _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate)
        },
        _mouseDown: function (t) {
            if (!d) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
                var i = this, s = 1 === t.which,
                    n = "string" == typeof this.options.cancel && t.target.nodeName ? e(t.target).closest(this.options.cancel).length : !1;
                return s && !n && this._mouseCapture(t) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
                    i.mouseDelayMet = !0
                }, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(t) !== !1, !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (e) {
                    return i._mouseMove(e)
                }, this._mouseUpDelegate = function (e) {
                    return i._mouseUp(e)
                }, this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), d = !0, !0)) : !0
            }
        },
        _mouseMove: function (t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || 9 > document.documentMode) && !t.button) return this._mouseUp(t);
                if (!t.which) return this._mouseUp(t)
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, t) !== !1, this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
        },
        _mouseUp: function (t) {
            return this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), d = !1, !1
        },
        _mouseDistanceMet: function (e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance
        },
        _mouseDelayMet: function () {
            return this.mouseDelayMet
        },
        _mouseStart: function () {
        },
        _mouseDrag: function () {
        },
        _mouseStop: function () {
        },
        _mouseCapture: function () {
            return !0
        }
    }), function () {
        function t(e, t, i) {
            return [parseFloat(e[0]) * (p.test(e[0]) ? t / 100 : 1), parseFloat(e[1]) * (p.test(e[1]) ? i / 100 : 1)]
        }

        function i(t, i) {
            return parseInt(e.css(t, i), 10) || 0
        }

        function s(t) {
            var i = t[0];
            return 9 === i.nodeType ? {
                width: t.width(),
                height: t.height(),
                offset: {top: 0, left: 0}
            } : e.isWindow(i) ? {
                width: t.width(),
                height: t.height(),
                offset: {top: t.scrollTop(), left: t.scrollLeft()}
            } : i.preventDefault ? {
                width: 0,
                height: 0,
                offset: {top: i.pageY, left: i.pageX}
            } : {width: t.outerWidth(), height: t.outerHeight(), offset: t.offset()}
        }

        e.ui = e.ui || {};
        var n, a, o = Math.max, r = Math.abs, h = Math.round, l = /left|center|right/, u = /top|center|bottom/,
            d = /[\+\-]\d+(\.[\d]+)?%?/, c = /^\w+/, p = /%$/, f = e.fn.position;
        e.position = {
            scrollbarWidth: function () {
                if (void 0 !== n) return n;
                var t, i,
                    s = e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                    a = s.children()[0];
                return e("body").append(s), t = a.offsetWidth, s.css("overflow", "scroll"), i = a.offsetWidth, t === i && (i = s[0].clientWidth), s.remove(), n = t - i
            }, getScrollInfo: function (t) {
                var i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x"),
                    s = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y"),
                    n = "scroll" === i || "auto" === i && t.width < t.element[0].scrollWidth,
                    a = "scroll" === s || "auto" === s && t.height < t.element[0].scrollHeight;
                return {width: a ? e.position.scrollbarWidth() : 0, height: n ? e.position.scrollbarWidth() : 0}
            }, getWithinInfo: function (t) {
                var i = e(t || window), s = e.isWindow(i[0]), n = !!i[0] && 9 === i[0].nodeType;
                return {
                    element: i,
                    isWindow: s,
                    isDocument: n,
                    offset: i.offset() || {left: 0, top: 0},
                    scrollLeft: i.scrollLeft(),
                    scrollTop: i.scrollTop(),
                    width: s || n ? i.width() : i.outerWidth(),
                    height: s || n ? i.height() : i.outerHeight()
                }
            }
        }, e.fn.position = function (n) {
            if (!n || !n.of) return f.apply(this, arguments);
            n = e.extend({}, n);
            var p, m, g, v, y, b, _ = e(n.of), x = e.position.getWithinInfo(n.within), w = e.position.getScrollInfo(x),
                k = (n.collision || "flip").split(" "), T = {};
            return b = s(_), _[0].preventDefault && (n.at = "left top"), m = b.width, g = b.height, v = b.offset, y = e.extend({}, v), e.each(["my", "at"], function () {
                var e, t, i = (n[this] || "").split(" ");
                1 === i.length && (i = l.test(i[0]) ? i.concat(["center"]) : u.test(i[0]) ? ["center"].concat(i) : ["center", "center"]), i[0] = l.test(i[0]) ? i[0] : "center", i[1] = u.test(i[1]) ? i[1] : "center", e = d.exec(i[0]), t = d.exec(i[1]), T[this] = [e ? e[0] : 0, t ? t[0] : 0], n[this] = [c.exec(i[0])[0], c.exec(i[1])[0]]
            }), 1 === k.length && (k[1] = k[0]), "right" === n.at[0] ? y.left += m : "center" === n.at[0] && (y.left += m / 2), "bottom" === n.at[1] ? y.top += g : "center" === n.at[1] && (y.top += g / 2), p = t(T.at, m, g), y.left += p[0], y.top += p[1], this.each(function () {
                var s, l, u = e(this), d = u.outerWidth(), c = u.outerHeight(), f = i(this, "marginLeft"),
                    b = i(this, "marginTop"), D = d + f + i(this, "marginRight") + w.width,
                    S = c + b + i(this, "marginBottom") + w.height, M = e.extend({}, y),
                    C = t(T.my, u.outerWidth(), u.outerHeight());
                "right" === n.my[0] ? M.left -= d : "center" === n.my[0] && (M.left -= d / 2), "bottom" === n.my[1] ? M.top -= c : "center" === n.my[1] && (M.top -= c / 2), M.left += C[0], M.top += C[1], a || (M.left = h(M.left), M.top = h(M.top)), s = {
                    marginLeft: f,
                    marginTop: b
                }, e.each(["left", "top"], function (t, i) {
                    e.ui.position[k[t]] && e.ui.position[k[t]][i](M, {
                        targetWidth: m,
                        targetHeight: g,
                        elemWidth: d,
                        elemHeight: c,
                        collisionPosition: s,
                        collisionWidth: D,
                        collisionHeight: S,
                        offset: [p[0] + C[0], p[1] + C[1]],
                        my: n.my,
                        at: n.at,
                        within: x,
                        elem: u
                    })
                }), n.using && (l = function (e) {
                    var t = v.left - M.left, i = t + m - d, s = v.top - M.top, a = s + g - c, h = {
                        target: {element: _, left: v.left, top: v.top, width: m, height: g},
                        element: {element: u, left: M.left, top: M.top, width: d, height: c},
                        horizontal: 0 > i ? "left" : t > 0 ? "right" : "center",
                        vertical: 0 > a ? "top" : s > 0 ? "bottom" : "middle"
                    };
                    d > m && m > r(t + i) && (h.horizontal = "center"), c > g && g > r(s + a) && (h.vertical = "middle"), h.important = o(r(t), r(i)) > o(r(s), r(a)) ? "horizontal" : "vertical", n.using.call(this, e, h)
                }), u.offset(e.extend(M, {using: l}))
            })
        }, e.ui.position = {
            fit: {
                left: function (e, t) {
                    var i, s = t.within, n = s.isWindow ? s.scrollLeft : s.offset.left, a = s.width,
                        r = e.left - t.collisionPosition.marginLeft, h = n - r, l = r + t.collisionWidth - a - n;
                    t.collisionWidth > a ? h > 0 && 0 >= l ? (i = e.left + h + t.collisionWidth - a - n, e.left += h - i) : e.left = l > 0 && 0 >= h ? n : h > l ? n + a - t.collisionWidth : n : h > 0 ? e.left += h : l > 0 ? e.left -= l : e.left = o(e.left - r, e.left)
                }, top: function (e, t) {
                    var i, s = t.within, n = s.isWindow ? s.scrollTop : s.offset.top, a = t.within.height,
                        r = e.top - t.collisionPosition.marginTop, h = n - r, l = r + t.collisionHeight - a - n;
                    t.collisionHeight > a ? h > 0 && 0 >= l ? (i = e.top + h + t.collisionHeight - a - n, e.top += h - i) : e.top = l > 0 && 0 >= h ? n : h > l ? n + a - t.collisionHeight : n : h > 0 ? e.top += h : l > 0 ? e.top -= l : e.top = o(e.top - r, e.top)
                }
            }, flip: {
                left: function (e, t) {
                    var i, s, n = t.within, a = n.offset.left + n.scrollLeft, o = n.width,
                        h = n.isWindow ? n.scrollLeft : n.offset.left, l = e.left - t.collisionPosition.marginLeft,
                        u = l - h, d = l + t.collisionWidth - o - h,
                        c = "left" === t.my[0] ? -t.elemWidth : "right" === t.my[0] ? t.elemWidth : 0,
                        p = "left" === t.at[0] ? t.targetWidth : "right" === t.at[0] ? -t.targetWidth : 0,
                        f = -2 * t.offset[0];
                    0 > u ? (i = e.left + c + p + f + t.collisionWidth - o - a, (0 > i || r(u) > i) && (e.left += c + p + f)) : d > 0 && (s = e.left - t.collisionPosition.marginLeft + c + p + f - h, (s > 0 || d > r(s)) && (e.left += c + p + f))
                }, top: function (e, t) {
                    var i, s, n = t.within, a = n.offset.top + n.scrollTop, o = n.height,
                        h = n.isWindow ? n.scrollTop : n.offset.top, l = e.top - t.collisionPosition.marginTop,
                        u = l - h, d = l + t.collisionHeight - o - h, c = "top" === t.my[1],
                        p = c ? -t.elemHeight : "bottom" === t.my[1] ? t.elemHeight : 0,
                        f = "top" === t.at[1] ? t.targetHeight : "bottom" === t.at[1] ? -t.targetHeight : 0,
                        m = -2 * t.offset[1];
                    0 > u ? (s = e.top + p + f + m + t.collisionHeight - o - a, (0 > s || r(u) > s) && (e.top += p + f + m)) : d > 0 && (i = e.top - t.collisionPosition.marginTop + p + f + m - h, (i > 0 || d > r(i)) && (e.top += p + f + m))
                }
            }, flipfit: {
                left: function () {
                    e.ui.position.flip.left.apply(this, arguments), e.ui.position.fit.left.apply(this, arguments)
                }, top: function () {
                    e.ui.position.flip.top.apply(this, arguments), e.ui.position.fit.top.apply(this, arguments)
                }
            }
        }, function () {
            var t, i, s, n, o, r = document.getElementsByTagName("body")[0], h = document.createElement("div");
            t = document.createElement(r ? "div" : "body"), s = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            }, r && e.extend(s, {position: "absolute", left: "-1000px", top: "-1000px"});
            for (o in s) t.style[o] = s[o];
            t.appendChild(h), i = r || document.documentElement, i.insertBefore(t, i.firstChild), h.style.cssText = "position: absolute; left: 10.7432222px;", n = e(h).offset().left, a = n > 10 && 11 > n, t.innerHTML = "", i.removeChild(t)
        }()
    }(), e.ui.position, e.widget("ui.accordion", {
        version: "1.11.4",
        options: {
            active: 0,
            animate: {},
            collapsible: !1,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {activeHeader: "ui-icon-triangle-1-s", header: "ui-icon-triangle-1-e"},
            activate: null,
            beforeActivate: null
        },
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
        _create: function () {
            var t = this.options;
            this.prevShow = this.prevHide = e(), this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist"), t.collapsible || t.active !== !1 && null != t.active || (t.active = 0), this._processPanels(), 0 > t.active && (t.active += this.headers.length), this._refresh()
        },
        _getCreateEventData: function () {
            return {header: this.active, panel: this.active.length ? this.active.next() : e()}
        },
        _createIcons: function () {
            var t = this.options.icons;
            t && (e("<span>").addClass("ui-accordion-header-icon ui-icon " + t.header).prependTo(this.headers), this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader), this.headers.addClass("ui-accordion-icons"))
        },
        _destroyIcons: function () {
            this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()
        },
        _destroy: function () {
            var e;
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"), this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId(), this._destroyIcons(), e = this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display", "").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && e.css("height", "")
        },
        _setOption: function (e, t) {
            return "active" === e ? (this._activate(t), void 0) : ("event" === e && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(t)), this._super(e, t), "collapsible" !== e || t || this.options.active !== !1 || this._activate(0), "icons" === e && (this._destroyIcons(), t && this._createIcons()), "disabled" === e && (this.element.toggleClass("ui-state-disabled", !!t).attr("aria-disabled", t), this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!t)), void 0)
        },
        _keydown: function (t) {
            if (!t.altKey && !t.ctrlKey) {
                var i = e.ui.keyCode, s = this.headers.length, n = this.headers.index(t.target), a = !1;
                switch (t.keyCode) {
                    case i.RIGHT:
                    case i.DOWN:
                        a = this.headers[(n + 1) % s];
                        break;
                    case i.LEFT:
                    case i.UP:
                        a = this.headers[(n - 1 + s) % s];
                        break;
                    case i.SPACE:
                    case i.ENTER:
                        this._eventHandler(t);
                        break;
                    case i.HOME:
                        a = this.headers[0];
                        break;
                    case i.END:
                        a = this.headers[s - 1]
                }
                a && (e(t.target).attr("tabIndex", -1), e(a).attr("tabIndex", 0), a.focus(), t.preventDefault())
            }
        },
        _panelKeyDown: function (t) {
            t.keyCode === e.ui.keyCode.UP && t.ctrlKey && e(t.currentTarget).prev().focus()
        },
        refresh: function () {
            var t = this.options;
            this._processPanels(), t.active === !1 && t.collapsible === !0 || !this.headers.length ? (t.active = !1, this.active = e()) : t.active === !1 ? this._activate(0) : this.active.length && !e.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (t.active = !1, this.active = e()) : this._activate(Math.max(0, t.active - 1)) : t.active = this.headers.index(this.active), this._destroyIcons(), this._refresh()
        },
        _processPanels: function () {
            var e = this.headers, t = this.panels;
            this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all"), this.panels = this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide(), t && (this._off(e.not(this.headers)), this._off(t.not(this.panels)))
        },
        _refresh: function () {
            var t, i = this.options, s = i.heightStyle, n = this.element.parent();
            this.active = this._findActive(i.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"), this.active.next().addClass("ui-accordion-content-active").show(), this.headers.attr("role", "tab").each(function () {
                var t = e(this), i = t.uniqueId().attr("id"), s = t.next(), n = s.uniqueId().attr("id");
                t.attr("aria-controls", n), s.attr("aria-labelledby", i)
            }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }).next().attr({"aria-hidden": "true"}).hide(), this.active.length ? this.active.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }).next().attr({"aria-hidden": "false"}) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(i.event), "fill" === s ? (t = n.height(), this.element.siblings(":visible").each(function () {
                var i = e(this), s = i.css("position");
                "absolute" !== s && "fixed" !== s && (t -= i.outerHeight(!0))
            }), this.headers.each(function () {
                t -= e(this).outerHeight(!0)
            }), this.headers.next().each(function () {
                e(this).height(Math.max(0, t - e(this).innerHeight() + e(this).height()))
            }).css("overflow", "auto")) : "auto" === s && (t = 0, this.headers.next().each(function () {
                t = Math.max(t, e(this).css("height", "").height())
            }).height(t))
        },
        _activate: function (t) {
            var i = this._findActive(t)[0];
            i !== this.active[0] && (i = i || this.active[0], this._eventHandler({
                target: i,
                currentTarget: i,
                preventDefault: e.noop
            }))
        },
        _findActive: function (t) {
            return "number" == typeof t ? this.headers.eq(t) : e()
        },
        _setupEvents: function (t) {
            var i = {keydown: "_keydown"};
            t && e.each(t.split(" "), function (e, t) {
                i[t] = "_eventHandler"
            }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i), this._on(this.headers.next(), {keydown: "_panelKeyDown"}), this._hoverable(this.headers), this._focusable(this.headers)
        },
        _eventHandler: function (t) {
            var i = this.options, s = this.active, n = e(t.currentTarget), a = n[0] === s[0], o = a && i.collapsible,
                r = o ? e() : n.next(), h = s.next(),
                l = {oldHeader: s, oldPanel: h, newHeader: o ? e() : n, newPanel: r};
            t.preventDefault(), a && !i.collapsible || this._trigger("beforeActivate", t, l) === !1 || (i.active = o ? !1 : this.headers.index(n), this.active = a ? e() : n, this._toggle(l), s.removeClass("ui-accordion-header-active ui-state-active"), i.icons && s.children(".ui-accordion-header-icon").removeClass(i.icons.activeHeader).addClass(i.icons.header), a || (n.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"), i.icons && n.children(".ui-accordion-header-icon").removeClass(i.icons.header).addClass(i.icons.activeHeader), n.next().addClass("ui-accordion-content-active")))
        },
        _toggle: function (t) {
            var i = t.newPanel, s = this.prevShow.length ? this.prevShow : t.oldPanel;
            this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = i, this.prevHide = s, this.options.animate ? this._animate(i, s, t) : (s.hide(), i.show(), this._toggleComplete(t)), s.attr({"aria-hidden": "true"}), s.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), i.length && s.length ? s.prev().attr({
                tabIndex: -1,
                "aria-expanded": "false"
            }) : i.length && this.headers.filter(function () {
                return 0 === parseInt(e(this).attr("tabIndex"), 10)
            }).attr("tabIndex", -1), i.attr("aria-hidden", "false").prev().attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            })
        },
        _animate: function (e, t, i) {
            var s, n, a, o = this, r = 0, h = e.css("box-sizing"), l = e.length && (!t.length || e.index() < t.index()),
                u = this.options.animate || {}, d = l && u.down || u, c = function () {
                    o._toggleComplete(i)
                };
            return "number" == typeof d && (a = d), "string" == typeof d && (n = d), n = n || d.easing || u.easing, a = a || d.duration || u.duration, t.length ? e.length ? (s = e.show().outerHeight(), t.animate(this.hideProps, {
                duration: a,
                easing: n,
                step: function (e, t) {
                    t.now = Math.round(e)
                }
            }), e.hide().animate(this.showProps, {
                duration: a, easing: n, complete: c, step: function (e, i) {
                    i.now = Math.round(e), "height" !== i.prop ? "content-box" === h && (r += i.now) : "content" !== o.options.heightStyle && (i.now = Math.round(s - t.outerHeight() - r), r = 0)
                }
            }), void 0) : t.animate(this.hideProps, a, n, c) : e.animate(this.showProps, a, n, c)
        },
        _toggleComplete: function (e) {
            var t = e.oldPanel;
            t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"), t.length && (t.parent()[0].className = t.parent()[0].className), this._trigger("activate", null, e)
        }
    }), e.widget("ui.menu", {
        version: "1.11.4",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {submenu: "ui-icon-carat-1-e"},
            items: "> *",
            menus: "ul",
            position: {my: "left-1 top", at: "right top"},
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create: function () {
            this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                role: this.options.role,
                tabIndex: 0
            }), this.options.disabled && this.element.addClass("ui-state-disabled").attr("aria-disabled", "true"), this._on({
                "mousedown .ui-menu-item": function (e) {
                    e.preventDefault()
                }, "click .ui-menu-item": function (t) {
                    var i = e(t.target);
                    !this.mouseHandled && i.not(".ui-state-disabled").length && (this.select(t), t.isPropagationStopped() || (this.mouseHandled = !0), i.has(".ui-menu").length ? this.expand(t) : !this.element.is(":focus") && e(this.document[0].activeElement).closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)))
                }, "mouseenter .ui-menu-item": function (t) {
                    if (!this.previousFilter) {
                        var i = e(t.currentTarget);
                        i.siblings(".ui-state-active").removeClass("ui-state-active"), this.focus(t, i)
                    }
                }, mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function (e, t) {
                    var i = this.active || this.element.find(this.options.items).eq(0);
                    t || this.focus(e, i)
                }, blur: function (t) {
                    this._delay(function () {
                        e.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(t)
                    })
                }, keydown: "_keydown"
            }), this.refresh(), this._on(this.document, {
                click: function (e) {
                    this._closeOnDocumentClick(e) && this.collapseAll(e), this.mouseHandled = !1
                }
            })
        },
        _destroy: function () {
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(), this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function () {
                var t = e(this);
                t.data("ui-menu-submenu-carat") && t.remove()
            }), this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")
        },
        _keydown: function (t) {
            var i, s, n, a, o = !0;
            switch (t.keyCode) {
                case e.ui.keyCode.PAGE_UP:
                    this.previousPage(t);
                    break;
                case e.ui.keyCode.PAGE_DOWN:
                    this.nextPage(t);
                    break;
                case e.ui.keyCode.HOME:
                    this._move("first", "first", t);
                    break;
                case e.ui.keyCode.END:
                    this._move("last", "last", t);
                    break;
                case e.ui.keyCode.UP:
                    this.previous(t);
                    break;
                case e.ui.keyCode.DOWN:
                    this.next(t);
                    break;
                case e.ui.keyCode.LEFT:
                    this.collapse(t);
                    break;
                case e.ui.keyCode.RIGHT:
                    this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
                    break;
                case e.ui.keyCode.ENTER:
                case e.ui.keyCode.SPACE:
                    this._activate(t);
                    break;
                case e.ui.keyCode.ESCAPE:
                    this.collapse(t);
                    break;
                default:
                    o = !1, s = this.previousFilter || "", n = String.fromCharCode(t.keyCode), a = !1, clearTimeout(this.filterTimer), n === s ? a = !0 : n = s + n, i = this._filterMenuItems(n), i = a && -1 !== i.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : i, i.length || (n = String.fromCharCode(t.keyCode), i = this._filterMenuItems(n)), i.length ? (this.focus(t, i), this.previousFilter = n, this.filterTimer = this._delay(function () {
                        delete this.previousFilter
                    }, 1e3)) : delete this.previousFilter
            }
            o && t.preventDefault()
        },
        _activate: function (e) {
            this.active.is(".ui-state-disabled") || (this.active.is("[aria-haspopup='true']") ? this.expand(e) : this.select(e))
        },
        refresh: function () {
            var t, i, s = this, n = this.options.icons.submenu, a = this.element.find(this.options.menus);
            this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length), a.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            }).each(function () {
                var t = e(this), i = t.parent(),
                    s = e("<span>").addClass("ui-menu-icon ui-icon " + n).data("ui-menu-submenu-carat", !0);
                i.attr("aria-haspopup", "true").prepend(s), t.attr("aria-labelledby", i.attr("id"))
            }), t = a.add(this.element), i = t.find(this.options.items), i.not(".ui-menu-item").each(function () {
                var t = e(this);
                s._isDivider(t) && t.addClass("ui-widget-content ui-menu-divider")
            }), i.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({
                tabIndex: -1,
                role: this._itemRole()
            }), i.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !e.contains(this.element[0], this.active[0]) && this.blur()
        },
        _itemRole: function () {
            return {menu: "menuitem", listbox: "option"}[this.options.role]
        },
        _setOption: function (e, t) {
            "icons" === e && this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(t.submenu), "disabled" === e && this.element.toggleClass("ui-state-disabled", !!t).attr("aria-disabled", t), this._super(e, t)
        },
        focus: function (e, t) {
            var i, s;
            this.blur(e, e && "focus" === e.type), this._scrollIntoView(t), this.active = t.first(), s = this.active.addClass("ui-state-focus").removeClass("ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", s.attr("id")), this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"), e && "keydown" === e.type ? this._close() : this.timer = this._delay(function () {
                this._close()
            }, this.delay), i = t.children(".ui-menu"), i.length && e && /^mouse/.test(e.type) && this._startOpening(i), this.activeMenu = t.parent(), this._trigger("focus", e, {item: t})
        },
        _scrollIntoView: function (t) {
            var i, s, n, a, o, r;
            this._hasScroll() && (i = parseFloat(e.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(e.css(this.activeMenu[0], "paddingTop")) || 0, n = t.offset().top - this.activeMenu.offset().top - i - s, a = this.activeMenu.scrollTop(), o = this.activeMenu.height(), r = t.outerHeight(), 0 > n ? this.activeMenu.scrollTop(a + n) : n + r > o && this.activeMenu.scrollTop(a + n - o + r))
        },
        blur: function (e, t) {
            t || clearTimeout(this.timer), this.active && (this.active.removeClass("ui-state-focus"), this.active = null, this._trigger("blur", e, {item: this.active}))
        },
        _startOpening: function (e) {
            clearTimeout(this.timer), "true" === e.attr("aria-hidden") && (this.timer = this._delay(function () {
                this._close(), this._open(e)
            }, this.delay))
        },
        _open: function (t) {
            var i = e.extend({of: this.active}, this.options.position);
            clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(i)
        },
        collapseAll: function (t, i) {
            clearTimeout(this.timer), this.timer = this._delay(function () {
                var s = i ? this.element : e(t && t.target).closest(this.element.find(".ui-menu"));
                s.length || (s = this.element), this._close(s), this.blur(t), this.activeMenu = s
            }, this.delay)
        },
        _close: function (e) {
            e || (e = this.active ? this.active.parent() : this.element), e.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active")
        },
        _closeOnDocumentClick: function (t) {
            return !e(t.target).closest(".ui-menu").length
        },
        _isDivider: function (e) {
            return !/[^\-\u2014\u2013\s]/.test(e.text())
        },
        collapse: function (e) {
            var t = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            t && t.length && (this._close(), this.focus(e, t))
        },
        expand: function (e) {
            var t = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
            t && t.length && (this._open(t.parent()), this._delay(function () {
                this.focus(e, t)
            }))
        },
        next: function (e) {
            this._move("next", "first", e)
        },
        previous: function (e) {
            this._move("prev", "last", e)
        },
        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length
        },
        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length
        },
        _move: function (e, t, i) {
            var s;
            this.active && (s = "first" === e || "last" === e ? this.active["first" === e ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[e + "All"](".ui-menu-item").eq(0)), s && s.length && this.active || (s = this.activeMenu.find(this.options.items)[t]()), this.focus(i, s)
        },
        nextPage: function (t) {
            var i, s, n;
            return this.active ? (this.isLastItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
                return i = e(this), 0 > i.offset().top - s - n
            }), this.focus(t, i)) : this.focus(t, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]())), void 0) : (this.next(t), void 0)
        },
        previousPage: function (t) {
            var i, s, n;
            return this.active ? (this.isFirstItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
                return i = e(this), i.offset().top - s + n > 0
            }), this.focus(t, i)) : this.focus(t, this.activeMenu.find(this.options.items).first())), void 0) : (this.next(t), void 0)
        },
        _hasScroll: function () {
            return this.element.outerHeight() < this.element.prop("scrollHeight")
        },
        select: function (t) {
            this.active = this.active || e(t.target).closest(".ui-menu-item");
            var i = {item: this.active};
            this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, i)
        },
        _filterMenuItems: function (t) {
            var i = t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), s = RegExp("^" + i, "i");
            return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function () {
                return s.test(e.trim(e(this).text()))
            })
        }
    }), e.widget("ui.autocomplete", {
        version: "1.11.4",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: !1,
            delay: 300,
            minLength: 1,
            position: {my: "left top", at: "left bottom", collision: "none"},
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        requestIndex: 0,
        pending: 0,
        _create: function () {
            var t, i, s, n = this.element[0].nodeName.toLowerCase(), a = "textarea" === n, o = "input" === n;
            this.isMultiLine = a ? !0 : o ? !1 : this.element.prop("isContentEditable"), this.valueMethod = this.element[a || o ? "val" : "text"], this.isNewMenu = !0, this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off"), this._on(this.element, {
                keydown: function (n) {
                    if (this.element.prop("readOnly")) return t = !0, s = !0, i = !0, void 0;
                    t = !1, s = !1, i = !1;
                    var a = e.ui.keyCode;
                    switch (n.keyCode) {
                        case a.PAGE_UP:
                            t = !0, this._move("previousPage", n);
                            break;
                        case a.PAGE_DOWN:
                            t = !0, this._move("nextPage", n);
                            break;
                        case a.UP:
                            t = !0, this._keyEvent("previous", n);
                            break;
                        case a.DOWN:
                            t = !0, this._keyEvent("next", n);
                            break;
                        case a.ENTER:
                            this.menu.active && (t = !0, n.preventDefault(), this.menu.select(n));
                            break;
                        case a.TAB:
                            this.menu.active && this.menu.select(n);
                            break;
                        case a.ESCAPE:
                            this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(n), n.preventDefault());
                            break;
                        default:
                            i = !0, this._searchTimeout(n)
                    }
                }, keypress: function (s) {
                    if (t) return t = !1, (!this.isMultiLine || this.menu.element.is(":visible")) && s.preventDefault(), void 0;
                    if (!i) {
                        var n = e.ui.keyCode;
                        switch (s.keyCode) {
                            case n.PAGE_UP:
                                this._move("previousPage", s);
                                break;
                            case n.PAGE_DOWN:
                                this._move("nextPage", s);
                                break;
                            case n.UP:
                                this._keyEvent("previous", s);
                                break;
                            case n.DOWN:
                                this._keyEvent("next", s)
                        }
                    }
                }, input: function (e) {
                    return s ? (s = !1, e.preventDefault(), void 0) : (this._searchTimeout(e), void 0)
                }, focus: function () {
                    this.selectedItem = null, this.previous = this._value()
                }, blur: function (e) {
                    return this.cancelBlur ? (delete this.cancelBlur, void 0) : (clearTimeout(this.searching), this.close(e), this._change(e), void 0)
                }
            }), this._initSource(), this.menu = e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role: null}).hide().menu("instance"), this._on(this.menu.element, {
                mousedown: function (t) {
                    t.preventDefault(), this.cancelBlur = !0, this._delay(function () {
                        delete this.cancelBlur
                    });
                    var i = this.menu.element[0];
                    e(t.target).closest(".ui-menu-item").length || this._delay(function () {
                        var t = this;
                        this.document.one("mousedown", function (s) {
                            s.target === t.element[0] || s.target === i || e.contains(i, s.target) || t.close()
                        })
                    })
                }, menufocus: function (t, i) {
                    var s, n;
                    return this.isNewMenu && (this.isNewMenu = !1, t.originalEvent && /^mouse/.test(t.originalEvent.type)) ? (this.menu.blur(), this.document.one("mousemove", function () {
                        e(t.target).trigger(t.originalEvent)
                    }), void 0) : (n = i.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", t, {item: n}) && t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(n.value), s = i.item.attr("aria-label") || n.value, s && e.trim(s).length && (this.liveRegion.children().hide(), e("<div>").text(s).appendTo(this.liveRegion)), void 0)
                }, menuselect: function (e, t) {
                    var i = t.item.data("ui-autocomplete-item"), s = this.previous;
                    this.element[0] !== this.document[0].activeElement && (this.element.focus(), this.previous = s, this._delay(function () {
                        this.previous = s, this.selectedItem = i
                    })), !1 !== this._trigger("select", e, {item: i}) && this._value(i.value), this.term = this._value(), this.close(e), this.selectedItem = i
                }
            }), this.liveRegion = e("<span>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body), this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _destroy: function () {
            clearTimeout(this.searching), this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
        },
        _setOption: function (e, t) {
            this._super(e, t), "source" === e && this._initSource(), "appendTo" === e && this.menu.element.appendTo(this._appendTo()), "disabled" === e && t && this.xhr && this.xhr.abort()
        },
        _appendTo: function () {
            var t = this.options.appendTo;
            return t && (t = t.jquery || t.nodeType ? e(t) : this.document.find(t).eq(0)), t && t[0] || (t = this.element.closest(".ui-front")), t.length || (t = this.document[0].body), t
        },
        _initSource: function () {
            var t, i, s = this;
            e.isArray(this.options.source) ? (t = this.options.source, this.source = function (i, s) {
                s(e.ui.autocomplete.filter(t, i.term))
            }) : "string" == typeof this.options.source ? (i = this.options.source, this.source = function (t, n) {
                s.xhr && s.xhr.abort(), s.xhr = e.ajax({
                    url: i, data: t, dataType: "json", success: function (e) {
                        n(e)
                    }, error: function () {
                        n([])
                    }
                })
            }) : this.source = this.options.source
        },
        _searchTimeout: function (e) {
            clearTimeout(this.searching), this.searching = this._delay(function () {
                var t = this.term === this._value(), i = this.menu.element.is(":visible"),
                    s = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;
                (!t || t && !i && !s) && (this.selectedItem = null, this.search(null, e))
            }, this.options.delay)
        },
        search: function (e, t) {
            return e = null != e ? e : this._value(), this.term = this._value(), e.length < this.options.minLength ? this.close(t) : this._trigger("search", t) !== !1 ? this._search(e) : void 0
        },
        _search: function (e) {
            this.pending++, this.element.addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({term: e}, this._response())
        },
        _response: function () {
            var t = ++this.requestIndex;
            return e.proxy(function (e) {
                t === this.requestIndex && this.__response(e), this.pending--, this.pending || this.element.removeClass("ui-autocomplete-loading")
            }, this)
        },
        __response: function (e) {
            e && (e = this._normalize(e)), this._trigger("response", null, {content: e}), !this.options.disabled && e && e.length && !this.cancelSearch ? (this._suggest(e), this._trigger("open")) : this._close()
        },
        close: function (e) {
            this.cancelSearch = !0, this._close(e)
        },
        _close: function (e) {
            this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", e))
        },
        _change: function (e) {
            this.previous !== this._value() && this._trigger("change", e, {item: this.selectedItem})
        },
        _normalize: function (t) {
            return t.length && t[0].label && t[0].value ? t : e.map(t, function (t) {
                return "string" == typeof t ? {label: t, value: t} : e.extend({}, t, {
                    label: t.label || t.value,
                    value: t.value || t.label
                })
            })
        },
        _suggest: function (t) {
            var i = this.menu.element.empty();
            this._renderMenu(i, t), this.isNewMenu = !0, this.menu.refresh(), i.show(), this._resizeMenu(), i.position(e.extend({of: this.element}, this.options.position)), this.options.autoFocus && this.menu.next()
        },
        _resizeMenu: function () {
            var e = this.menu.element;
            e.outerWidth(Math.max(e.width("").outerWidth() + 1, this.element.outerWidth()))
        },
        _renderMenu: function (t, i) {
            var s = this;
            e.each(i, function (e, i) {
                s._renderItemData(t, i)
            })
        },
        _renderItemData: function (e, t) {
            return this._renderItem(e, t).data("ui-autocomplete-item", t)
        },
        _renderItem: function (t, i) {
            return e("<li>").text(i.label).appendTo(t)
        },
        _move: function (e, t) {
            return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(e) || this.menu.isLastItem() && /^next/.test(e) ? (this.isMultiLine || this._value(this.term), this.menu.blur(), void 0) : (this.menu[e](t), void 0) : (this.search(null, t), void 0)
        },
        widget: function () {
            return this.menu.element
        },
        _value: function () {
            return this.valueMethod.apply(this.element, arguments)
        },
        _keyEvent: function (e, t) {
            (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(e, t), t.preventDefault())
        }
    }), e.extend(e.ui.autocomplete, {
        escapeRegex: function (e) {
            return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
        }, filter: function (t, i) {
            var s = RegExp(e.ui.autocomplete.escapeRegex(i), "i");
            return e.grep(t, function (e) {
                return s.test(e.label || e.value || e)
            })
        }
    }), e.widget("ui.autocomplete", e.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (e) {
                    return e + (e > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
                }
            }
        }, __response: function (t) {
            var i;
            this._superApply(arguments), this.options.disabled || this.cancelSearch || (i = t && t.length ? this.options.messages.results(t.length) : this.options.messages.noResults, this.liveRegion.children().hide(), e("<div>").text(i).appendTo(this.liveRegion))
        }
    }), e.ui.autocomplete;
    var c, p = "ui-button ui-widget ui-state-default ui-corner-all",
        f = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
        m = function () {
            var t = e(this);
            setTimeout(function () {
                t.find(":ui-button").button("refresh")
            }, 1)
        }, g = function (t) {
            var i = t.name, s = t.form, n = e([]);
            return i && (i = i.replace(/'/g, "\\'"), n = s ? e(s).find("[name='" + i + "'][type=radio]") : e("[name='" + i + "'][type=radio]", t.ownerDocument).filter(function () {
                return !this.form
            })), n
        };
    e.widget("ui.button", {
        version: "1.11.4",
        defaultElement: "<button>",
        options: {disabled: null, text: !0, label: null, icons: {primary: null, secondary: null}},
        _create: function () {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, m), "boolean" != typeof this.options.disabled ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
            var t = this, i = this.options, s = "checkbox" === this.type || "radio" === this.type,
                n = s ? "" : "ui-state-active";
            null === i.label && (i.label = "input" === this.type ? this.buttonElement.val() : this.buttonElement.html()), this._hoverable(this.buttonElement), this.buttonElement.addClass(p).attr("role", "button").bind("mouseenter" + this.eventNamespace, function () {
                i.disabled || this === c && e(this).addClass("ui-state-active")
            }).bind("mouseleave" + this.eventNamespace, function () {
                i.disabled || e(this).removeClass(n)
            }).bind("click" + this.eventNamespace, function (e) {
                i.disabled && (e.preventDefault(), e.stopImmediatePropagation())
            }), this._on({
                focus: function () {
                    this.buttonElement.addClass("ui-state-focus")
                }, blur: function () {
                    this.buttonElement.removeClass("ui-state-focus")
                }
            }), s && this.element.bind("change" + this.eventNamespace, function () {
                t.refresh()
            }), "checkbox" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                return i.disabled ? !1 : void 0
            }) : "radio" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                if (i.disabled) return !1;
                e(this).addClass("ui-state-active"), t.buttonElement.attr("aria-pressed", "true");
                var s = t.element[0];
                g(s).not(s).map(function () {
                    return e(this).button("widget")[0]
                }).removeClass("ui-state-active").attr("aria-pressed", "false")
            }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function () {
                return i.disabled ? !1 : (e(this).addClass("ui-state-active"), c = this, t.document.one("mouseup", function () {
                    c = null
                }), void 0)
            }).bind("mouseup" + this.eventNamespace, function () {
                return i.disabled ? !1 : (e(this).removeClass("ui-state-active"), void 0)
            }).bind("keydown" + this.eventNamespace, function (t) {
                return i.disabled ? !1 : ((t.keyCode === e.ui.keyCode.SPACE || t.keyCode === e.ui.keyCode.ENTER) && e(this).addClass("ui-state-active"), void 0)
            }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function () {
                e(this).removeClass("ui-state-active")
            }), this.buttonElement.is("a") && this.buttonElement.keyup(function (t) {
                t.keyCode === e.ui.keyCode.SPACE && e(this).click()
            })), this._setOption("disabled", i.disabled), this._resetButton()
        },
        _determineButtonType: function () {
            var e, t, i;
            this.type = this.element.is("[type=checkbox]") ? "checkbox" : this.element.is("[type=radio]") ? "radio" : this.element.is("input") ? "input" : "button", "checkbox" === this.type || "radio" === this.type ? (e = this.element.parents().last(), t = "label[for='" + this.element.attr("id") + "']", this.buttonElement = e.find(t), this.buttonElement.length || (e = e.length ? e.siblings() : this.element.siblings(), this.buttonElement = e.filter(t), this.buttonElement.length || (this.buttonElement = e.find(t))), this.element.addClass("ui-helper-hidden-accessible"), i = this.element.is(":checked"), i && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", i)) : this.buttonElement = this.element
        },
        widget: function () {
            return this.buttonElement
        },
        _destroy: function () {
            this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(p + " ui-state-active " + f).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), this.hasTitle || this.buttonElement.removeAttr("title")
        },
        _setOption: function (e, t) {
            return this._super(e, t), "disabled" === e ? (this.widget().toggleClass("ui-state-disabled", !!t), this.element.prop("disabled", !!t), t && ("checkbox" === this.type || "radio" === this.type ? this.buttonElement.removeClass("ui-state-focus") : this.buttonElement.removeClass("ui-state-focus ui-state-active")), void 0) : (this._resetButton(), void 0)
        },
        refresh: function () {
            var t = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
            t !== this.options.disabled && this._setOption("disabled", t), "radio" === this.type ? g(this.element[0]).each(function () {
                e(this).is(":checked") ? e(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false")
            }) : "checkbox" === this.type && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"))
        },
        _resetButton: function () {
            if ("input" === this.type) return this.options.label && this.element.val(this.options.label), void 0;
            var t = this.buttonElement.removeClass(f),
                i = e("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),
                s = this.options.icons, n = s.primary && s.secondary, a = [];
            s.primary || s.secondary ? (this.options.text && a.push("ui-button-text-icon" + (n ? "s" : s.primary ? "-primary" : "-secondary")), s.primary && t.prepend("<span class='ui-button-icon-primary ui-icon " + s.primary + "'></span>"), s.secondary && t.append("<span class='ui-button-icon-secondary ui-icon " + s.secondary + "'></span>"), this.options.text || (a.push(n ? "ui-button-icons-only" : "ui-button-icon-only"), this.hasTitle || t.attr("title", e.trim(i)))) : a.push("ui-button-text-only"), t.addClass(a.join(" "))
        }
    }), e.widget("ui.buttonset", {
        version: "1.11.4",
        options: {items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},
        _create: function () {
            this.element.addClass("ui-buttonset")
        },
        _init: function () {
            this.refresh()
        },
        _setOption: function (e, t) {
            "disabled" === e && this.buttons.button("option", e, t), this._super(e, t)
        },
        refresh: function () {
            var t = "rtl" === this.element.css("direction"), i = this.element.find(this.options.items),
                s = i.filter(":ui-button");
            i.not(":ui-button").button(), s.button("refresh"), this.buttons = i.map(function () {
                return e(this).button("widget")[0]
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(t ? "ui-corner-left" : "ui-corner-right").end().end()
        },
        _destroy: function () {
            this.element.removeClass("ui-buttonset"), this.buttons.map(function () {
                return e(this).button("widget")[0]
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy")
        }
    }), e.ui.button, e.extend(e.ui, {datepicker: {version: "1.11.4"}});
    var v;
    e.extend(n.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function () {
            return this.dpDiv
        },
        setDefaults: function (e) {
            return r(this._defaults, e || {}), this
        },
        _attachDatepicker: function (t, i) {
            var s, n, a;
            s = t.nodeName.toLowerCase(), n = "div" === s || "span" === s, t.id || (this.uuid += 1, t.id = "dp" + this.uuid), a = this._newInst(e(t), n), a.settings = e.extend({}, i || {}), "input" === s ? this._connectDatepicker(t, a) : n && this._inlineDatepicker(t, a)
        },
        _newInst: function (t, i) {
            var s = t[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: s,
                input: t,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: i,
                dpDiv: i ? a(e("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
            }
        },
        _connectDatepicker: function (t, i) {
            var s = e(t);
            i.append = e([]), i.trigger = e([]), s.hasClass(this.markerClassName) || (this._attachments(s, i), s.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp), this._autoSize(i), e.data(t, "datepicker", i), i.settings.disabled && this._disableDatepicker(t))
        },
        _attachments: function (t, i) {
            var s, n, a, o = this._get(i, "appendText"), r = this._get(i, "isRTL");
            i.append && i.append.remove(), o && (i.append = e("<span class='" + this._appendClass + "'>" + o + "</span>"), t[r ? "before" : "after"](i.append)), t.unbind("focus", this._showDatepicker), i.trigger && i.trigger.remove(), s = this._get(i, "showOn"), ("focus" === s || "both" === s) && t.focus(this._showDatepicker), ("button" === s || "both" === s) && (n = this._get(i, "buttonText"), a = this._get(i, "buttonImage"), i.trigger = e(this._get(i, "buttonImageOnly") ? e("<img/>").addClass(this._triggerClass).attr({
                src: a,
                alt: n,
                title: n
            }) : e("<button type='button'></button>").addClass(this._triggerClass).html(a ? e("<img/>").attr({
                src: a,
                alt: n,
                title: n
            }) : n)), t[r ? "before" : "after"](i.trigger), i.trigger.click(function () {
                return e.datepicker._datepickerShowing && e.datepicker._lastInput === t[0] ? e.datepicker._hideDatepicker() : e.datepicker._datepickerShowing && e.datepicker._lastInput !== t[0] ? (e.datepicker._hideDatepicker(), e.datepicker._showDatepicker(t[0])) : e.datepicker._showDatepicker(t[0]), !1
            }))
        },
        _autoSize: function (e) {
            if (this._get(e, "autoSize") && !e.inline) {
                var t, i, s, n, a = new Date(2009, 11, 20), o = this._get(e, "dateFormat");
                o.match(/[DM]/) && (t = function (e) {
                    for (i = 0, s = 0, n = 0; e.length > n; n++) e[n].length > i && (i = e[n].length, s = n);
                    return s
                }, a.setMonth(t(this._get(e, o.match(/MM/) ? "monthNames" : "monthNamesShort"))), a.setDate(t(this._get(e, o.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - a.getDay())), e.input.attr("size", this._formatDate(e, a).length)
            }
        },
        _inlineDatepicker: function (t, i) {
            var s = e(t);
            s.hasClass(this.markerClassName) || (s.addClass(this.markerClassName).append(i.dpDiv), e.data(t, "datepicker", i), this._setDate(i, this._getDefaultDate(i), !0), this._updateDatepicker(i), this._updateAlternate(i), i.settings.disabled && this._disableDatepicker(t), i.dpDiv.css("display", "block"))
        },
        _dialogDatepicker: function (t, i, s, n, a) {
            var o, h, l, u, d, c = this._dialogInst;
            return c || (this.uuid += 1, o = "dp" + this.uuid, this._dialogInput = e("<input type='text' id='" + o + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.keydown(this._doKeyDown), e("body").append(this._dialogInput), c = this._dialogInst = this._newInst(this._dialogInput, !1), c.settings = {}, e.data(this._dialogInput[0], "datepicker", c)), r(c.settings, n || {}), i = i && i.constructor === Date ? this._formatDate(c, i) : i, this._dialogInput.val(i), this._pos = a ? a.length ? a : [a.pageX, a.pageY] : null, this._pos || (h = document.documentElement.clientWidth, l = document.documentElement.clientHeight, u = document.documentElement.scrollLeft || document.body.scrollLeft, d = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [h / 2 - 100 + u, l / 2 - 150 + d]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), c.settings.onSelect = s, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), e.blockUI && e.blockUI(this.dpDiv), e.data(this._dialogInput[0], "datepicker", c), this
        },
        _destroyDatepicker: function (t) {
            var i, s = e(t), n = e.data(t, "datepicker");
            s.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), e.removeData(t, "datepicker"), "input" === i ? (n.append.remove(), n.trigger.remove(), s.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : ("div" === i || "span" === i) && s.removeClass(this.markerClassName).empty(), v === n && (v = null))
        },
        _enableDatepicker: function (t) {
            var i, s, n = e(t), a = e.data(t, "datepicker");
            n.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), "input" === i ? (t.disabled = !1, a.trigger.filter("button").each(function () {
                this.disabled = !1
            }).end().filter("img").css({
                opacity: "1.0",
                cursor: ""
            })) : ("div" === i || "span" === i) && (s = n.children("." + this._inlineClass), s.children().removeClass("ui-state-disabled"), s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = e.map(this._disabledInputs, function (e) {
                return e === t ? null : e
            }))
        },
        _disableDatepicker: function (t) {
            var i, s, n = e(t), a = e.data(t, "datepicker");
            n.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), "input" === i ? (t.disabled = !0, a.trigger.filter("button").each(function () {
                this.disabled = !0
            }).end().filter("img").css({
                opacity: "0.5",
                cursor: "default"
            })) : ("div" === i || "span" === i) && (s = n.children("." + this._inlineClass), s.children().addClass("ui-state-disabled"), s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = e.map(this._disabledInputs, function (e) {
                return e === t ? null : e
            }), this._disabledInputs[this._disabledInputs.length] = t)
        },
        _isDisabledDatepicker: function (e) {
            if (!e) return !1;
            for (var t = 0; this._disabledInputs.length > t; t++) if (this._disabledInputs[t] === e) return !0;
            return !1
        },
        _getInst: function (t) {
            try {
                return e.data(t, "datepicker")
            } catch (i) {
                throw"Missing instance data for this datepicker"
            }
        },
        _optionDatepicker: function (t, i, s) {
            var n, a, o, h, l = this._getInst(t);
            return 2 === arguments.length && "string" == typeof i ? "defaults" === i ? e.extend({}, e.datepicker._defaults) : l ? "all" === i ? e.extend({}, l.settings) : this._get(l, i) : null : (n = i || {}, "string" == typeof i && (n = {}, n[i] = s), l && (this._curInst === l && this._hideDatepicker(), a = this._getDateDatepicker(t, !0), o = this._getMinMaxDate(l, "min"), h = this._getMinMaxDate(l, "max"), r(l.settings, n), null !== o && void 0 !== n.dateFormat && void 0 === n.minDate && (l.settings.minDate = this._formatDate(l, o)), null !== h && void 0 !== n.dateFormat && void 0 === n.maxDate && (l.settings.maxDate = this._formatDate(l, h)), "disabled" in n && (n.disabled ? this._disableDatepicker(t) : this._enableDatepicker(t)), this._attachments(e(t), l), this._autoSize(l), this._setDate(l, a), this._updateAlternate(l), this._updateDatepicker(l)), void 0)
        },
        _changeDatepicker: function (e, t, i) {
            this._optionDatepicker(e, t, i)
        },
        _refreshDatepicker: function (e) {
            var t = this._getInst(e);
            t && this._updateDatepicker(t)
        },
        _setDateDatepicker: function (e, t) {
            var i = this._getInst(e);
            i && (this._setDate(i, t), this._updateDatepicker(i), this._updateAlternate(i))
        },
        _getDateDatepicker: function (e, t) {
            var i = this._getInst(e);
            return i && !i.inline && this._setDateFromField(i, t), i ? this._getDate(i) : null
        },
        _doKeyDown: function (t) {
            var i, s, n, a = e.datepicker._getInst(t.target), o = !0, r = a.dpDiv.is(".ui-datepicker-rtl");
            if (a._keyEvent = !0, e.datepicker._datepickerShowing) switch (t.keyCode) {
                case 9:
                    e.datepicker._hideDatepicker(), o = !1;
                    break;
                case 13:
                    return n = e("td." + e.datepicker._dayOverClass + ":not(." + e.datepicker._currentClass + ")", a.dpDiv), n[0] && e.datepicker._selectDay(t.target, a.selectedMonth, a.selectedYear, n[0]), i = e.datepicker._get(a, "onSelect"), i ? (s = e.datepicker._formatDate(a), i.apply(a.input ? a.input[0] : null, [s, a])) : e.datepicker._hideDatepicker(), !1;
                case 27:
                    e.datepicker._hideDatepicker();
                    break;
                case 33:
                    e.datepicker._adjustDate(t.target, t.ctrlKey ? -e.datepicker._get(a, "stepBigMonths") : -e.datepicker._get(a, "stepMonths"), "M");
                    break;
                case 34:
                    e.datepicker._adjustDate(t.target, t.ctrlKey ? +e.datepicker._get(a, "stepBigMonths") : +e.datepicker._get(a, "stepMonths"), "M");
                    break;
                case 35:
                    (t.ctrlKey || t.metaKey) && e.datepicker._clearDate(t.target), o = t.ctrlKey || t.metaKey;
                    break;
                case 36:
                    (t.ctrlKey || t.metaKey) && e.datepicker._gotoToday(t.target), o = t.ctrlKey || t.metaKey;
                    break;
                case 37:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, r ? 1 : -1, "D"), o = t.ctrlKey || t.metaKey, t.originalEvent.altKey && e.datepicker._adjustDate(t.target, t.ctrlKey ? -e.datepicker._get(a, "stepBigMonths") : -e.datepicker._get(a, "stepMonths"), "M");
                    break;
                case 38:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, -7, "D"), o = t.ctrlKey || t.metaKey;
                    break;
                case 39:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, r ? -1 : 1, "D"), o = t.ctrlKey || t.metaKey, t.originalEvent.altKey && e.datepicker._adjustDate(t.target, t.ctrlKey ? +e.datepicker._get(a, "stepBigMonths") : +e.datepicker._get(a, "stepMonths"), "M");
                    break;
                case 40:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, 7, "D"), o = t.ctrlKey || t.metaKey;
                    break;
                default:
                    o = !1
            } else 36 === t.keyCode && t.ctrlKey ? e.datepicker._showDatepicker(this) : o = !1;
            o && (t.preventDefault(), t.stopPropagation())
        },
        _doKeyPress: function (t) {
            var i, s, n = e.datepicker._getInst(t.target);
            return e.datepicker._get(n, "constrainInput") ? (i = e.datepicker._possibleChars(e.datepicker._get(n, "dateFormat")), s = String.fromCharCode(null == t.charCode ? t.keyCode : t.charCode), t.ctrlKey || t.metaKey || " " > s || !i || i.indexOf(s) > -1) : void 0
        },
        _doKeyUp: function (t) {
            var i, s = e.datepicker._getInst(t.target);
            if (s.input.val() !== s.lastVal) try {
                i = e.datepicker.parseDate(e.datepicker._get(s, "dateFormat"), s.input ? s.input.val() : null, e.datepicker._getFormatConfig(s)), i && (e.datepicker._setDateFromField(s), e.datepicker._updateAlternate(s), e.datepicker._updateDatepicker(s))
            } catch (n) {
            }
            return !0
        },
        _showDatepicker: function (t) {
            if (t = t.target || t, "input" !== t.nodeName.toLowerCase() && (t = e("input", t.parentNode)[0]), !e.datepicker._isDisabledDatepicker(t) && e.datepicker._lastInput !== t) {
                var i, n, a, o, h, l, u;
                i = e.datepicker._getInst(t), e.datepicker._curInst && e.datepicker._curInst !== i && (e.datepicker._curInst.dpDiv.stop(!0, !0), i && e.datepicker._datepickerShowing && e.datepicker._hideDatepicker(e.datepicker._curInst.input[0])), n = e.datepicker._get(i, "beforeShow"), a = n ? n.apply(t, [t, i]) : {}, a !== !1 && (r(i.settings, a), i.lastVal = null, e.datepicker._lastInput = t, e.datepicker._setDateFromField(i), e.datepicker._inDialog && (t.value = ""), e.datepicker._pos || (e.datepicker._pos = e.datepicker._findPos(t), e.datepicker._pos[1] += t.offsetHeight), o = !1, e(t).parents().each(function () {
                    return o |= "fixed" === e(this).css("position"), !o
                }), h = {
                    left: e.datepicker._pos[0],
                    top: e.datepicker._pos[1]
                }, e.datepicker._pos = null, i.dpDiv.empty(), i.dpDiv.css({
                    position: "absolute",
                    display: "block",
                    top: "-1000px"
                }), e.datepicker._updateDatepicker(i), h = e.datepicker._checkOffset(i, h, o), i.dpDiv.css({
                    position: e.datepicker._inDialog && e.blockUI ? "static" : o ? "fixed" : "absolute",
                    display: "none",
                    left: h.left + "px",
                    top: h.top + "px"
                }), i.inline || (l = e.datepicker._get(i, "showAnim"), u = e.datepicker._get(i, "duration"), i.dpDiv.css("z-index", s(e(t)) + 1), e.datepicker._datepickerShowing = !0, e.effects && e.effects.effect[l] ? i.dpDiv.show(l, e.datepicker._get(i, "showOptions"), u) : i.dpDiv[l || "show"](l ? u : null), e.datepicker._shouldFocusInput(i) && i.input.focus(), e.datepicker._curInst = i))
            }
        },
        _updateDatepicker: function (t) {
            this.maxRows = 4, v = t, t.dpDiv.empty().append(this._generateHTML(t)), this._attachHandlers(t);
            var i, s = this._getNumberOfMonths(t), n = s[1], a = 17, r = t.dpDiv.find("." + this._dayOverClass + " a");
            r.length > 0 && o.apply(r.get(0)), t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), n > 1 && t.dpDiv.addClass("ui-datepicker-multi-" + n).css("width", a * n + "em"), t.dpDiv[(1 !== s[0] || 1 !== s[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), t.dpDiv[(this._get(t, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), t === e.datepicker._curInst && e.datepicker._datepickerShowing && e.datepicker._shouldFocusInput(t) && t.input.focus(), t.yearshtml && (i = t.yearshtml, setTimeout(function () {
                i === t.yearshtml && t.yearshtml && t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml), i = t.yearshtml = null
            }, 0))
        },
        _shouldFocusInput: function (e) {
            return e.input && e.input.is(":visible") && !e.input.is(":disabled") && !e.input.is(":focus")
        },
        _checkOffset: function (t, i, s) {
            var n = t.dpDiv.outerWidth(), a = t.dpDiv.outerHeight(), o = t.input ? t.input.outerWidth() : 0,
                r = t.input ? t.input.outerHeight() : 0,
                h = document.documentElement.clientWidth + (s ? 0 : e(document).scrollLeft()),
                l = document.documentElement.clientHeight + (s ? 0 : e(document).scrollTop());
            return i.left -= this._get(t, "isRTL") ? n - o : 0, i.left -= s && i.left === t.input.offset().left ? e(document).scrollLeft() : 0, i.top -= s && i.top === t.input.offset().top + r ? e(document).scrollTop() : 0, i.left -= Math.min(i.left, i.left + n > h && h > n ? Math.abs(i.left + n - h) : 0), i.top -= Math.min(i.top, i.top + a > l && l > a ? Math.abs(a + r) : 0), i
        },
        _findPos: function (t) {
            for (var i, s = this._getInst(t), n = this._get(s, "isRTL"); t && ("hidden" === t.type || 1 !== t.nodeType || e.expr.filters.hidden(t));) t = t[n ? "previousSibling" : "nextSibling"];
            return i = e(t).offset(), [i.left, i.top]
        },
        _hideDatepicker: function (t) {
            var i, s, n, a, o = this._curInst;
            !o || t && o !== e.data(t, "datepicker") || this._datepickerShowing && (i = this._get(o, "showAnim"), s = this._get(o, "duration"), n = function () {
                e.datepicker._tidyDialog(o)
            }, e.effects && (e.effects.effect[i] || e.effects[i]) ? o.dpDiv.hide(i, e.datepicker._get(o, "showOptions"), s, n) : o.dpDiv["slideDown" === i ? "slideUp" : "fadeIn" === i ? "fadeOut" : "hide"](i ? s : null, n), i || n(), this._datepickerShowing = !1, a = this._get(o, "onClose"), a && a.apply(o.input ? o.input[0] : null, [o.input ? o.input.val() : "", o]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
                position: "absolute",
                left: "0",
                top: "-100px"
            }), e.blockUI && (e.unblockUI(), e("body").append(this.dpDiv))), this._inDialog = !1)
        },
        _tidyDialog: function (e) {
            e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")
        },
        _checkExternalClick: function (t) {
            if (e.datepicker._curInst) {
                var i = e(t.target), s = e.datepicker._getInst(i[0]);
                (i[0].id !== e.datepicker._mainDivId && 0 === i.parents("#" + e.datepicker._mainDivId).length && !i.hasClass(e.datepicker.markerClassName) && !i.closest("." + e.datepicker._triggerClass).length && e.datepicker._datepickerShowing && (!e.datepicker._inDialog || !e.blockUI) || i.hasClass(e.datepicker.markerClassName) && e.datepicker._curInst !== s) && e.datepicker._hideDatepicker()
            }
        },
        _adjustDate: function (t, i, s) {
            var n = e(t), a = this._getInst(n[0]);
            this._isDisabledDatepicker(n[0]) || (this._adjustInstDate(a, i + ("M" === s ? this._get(a, "showCurrentAtPos") : 0), s), this._updateDatepicker(a))
        },
        _gotoToday: function (t) {
            var i, s = e(t), n = this._getInst(s[0]);
            this._get(n, "gotoCurrent") && n.currentDay ? (n.selectedDay = n.currentDay, n.drawMonth = n.selectedMonth = n.currentMonth, n.drawYear = n.selectedYear = n.currentYear) : (i = new Date, n.selectedDay = i.getDate(), n.drawMonth = n.selectedMonth = i.getMonth(), n.drawYear = n.selectedYear = i.getFullYear()), this._notifyChange(n), this._adjustDate(s)
        },
        _selectMonthYear: function (t, i, s) {
            var n = e(t), a = this._getInst(n[0]);
            a["selected" + ("M" === s ? "Month" : "Year")] = a["draw" + ("M" === s ? "Month" : "Year")] = parseInt(i.options[i.selectedIndex].value, 10), this._notifyChange(a), this._adjustDate(n)
        },
        _selectDay: function (t, i, s, n) {
            var a, o = e(t);
            e(n).hasClass(this._unselectableClass) || this._isDisabledDatepicker(o[0]) || (a = this._getInst(o[0]), a.selectedDay = a.currentDay = e("a", n).html(), a.selectedMonth = a.currentMonth = i, a.selectedYear = a.currentYear = s, this._selectDate(t, this._formatDate(a, a.currentDay, a.currentMonth, a.currentYear)))
        },
        _clearDate: function (t) {
            var i = e(t);
            this._selectDate(i, "")
        },
        _selectDate: function (t, i) {
            var s, n = e(t), a = this._getInst(n[0]);
            i = null != i ? i : this._formatDate(a), a.input && a.input.val(i), this._updateAlternate(a), s = this._get(a, "onSelect"), s ? s.apply(a.input ? a.input[0] : null, [i, a]) : a.input && a.input.trigger("change"), a.inline ? this._updateDatepicker(a) : (this._hideDatepicker(), this._lastInput = a.input[0], "object" != typeof a.input[0] && a.input.focus(), this._lastInput = null)
        },
        _updateAlternate: function (t) {
            var i, s, n, a = this._get(t, "altField");
            a && (i = this._get(t, "altFormat") || this._get(t, "dateFormat"), s = this._getDate(t), n = this.formatDate(i, s, this._getFormatConfig(t)), e(a).each(function () {
                e(this).val(n)
            }))
        },
        noWeekends: function (e) {
            var t = e.getDay();
            return [t > 0 && 6 > t, ""]
        },
        iso8601Week: function (e) {
            var t, i = new Date(e.getTime());
            return i.setDate(i.getDate() + 4 - (i.getDay() || 7)), t = i.getTime(), i.setMonth(0), i.setDate(1), Math.floor(Math.round((t - i) / 864e5) / 7) + 1
        },
        parseDate: function (t, i, s) {
            if (null == t || null == i) throw"Invalid arguments";
            if (i = "object" == typeof i ? "" + i : i + "", "" === i) return null;
            var n, a, o, r, h = 0, l = (s ? s.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                u = "string" != typeof l ? l : (new Date).getFullYear() % 100 + parseInt(l, 10),
                d = (s ? s.dayNamesShort : null) || this._defaults.dayNamesShort,
                c = (s ? s.dayNames : null) || this._defaults.dayNames,
                p = (s ? s.monthNamesShort : null) || this._defaults.monthNamesShort,
                f = (s ? s.monthNames : null) || this._defaults.monthNames, m = -1, g = -1, v = -1, y = -1, b = !1,
                _ = function (e) {
                    var i = t.length > n + 1 && t.charAt(n + 1) === e;
                    return i && n++, i
                }, x = function (e) {
                    var t = _(e), s = "@" === e ? 14 : "!" === e ? 20 : "y" === e && t ? 4 : "o" === e ? 3 : 2,
                        n = "y" === e ? s : 1, a = RegExp("^\\d{" + n + "," + s + "}"), o = i.substring(h).match(a);
                    if (!o) throw"Missing number at position " + h;
                    return h += o[0].length, parseInt(o[0], 10)
                }, w = function (t, s, n) {
                    var a = -1, o = e.map(_(t) ? n : s, function (e, t) {
                        return [[t, e]]
                    }).sort(function (e, t) {
                        return -(e[1].length - t[1].length)
                    });
                    if (e.each(o, function (e, t) {
                            var s = t[1];
                            return i.substr(h, s.length).toLowerCase() === s.toLowerCase() ? (a = t[0], h += s.length, !1) : void 0
                        }), -1 !== a) return a + 1;
                    throw"Unknown name at position " + h
                }, k = function () {
                    if (i.charAt(h) !== t.charAt(n)) throw"Unexpected literal at position " + h;
                    h++
                };
            for (n = 0; t.length > n; n++) if (b) "'" !== t.charAt(n) || _("'") ? k() : b = !1; else switch (t.charAt(n)) {
                case"d":
                    v = x("d");
                    break;
                case"D":
                    w("D", d, c);
                    break;
                case"o":
                    y = x("o");
                    break;
                case"m":
                    g = x("m");
                    break;
                case"M":
                    g = w("M", p, f);
                    break;
                case"y":
                    m = x("y");
                    break;
                case"@":
                    r = new Date(x("@")), m = r.getFullYear(), g = r.getMonth() + 1, v = r.getDate();
                    break;
                case"!":
                    r = new Date((x("!") - this._ticksTo1970) / 1e4), m = r.getFullYear(), g = r.getMonth() + 1, v = r.getDate();
                    break;
                case"'":
                    _("'") ? k() : b = !0;
                    break;
                default:
                    k()
            }
            if (i.length > h && (o = i.substr(h), !/^\s+/.test(o))) throw"Extra/unparsed characters found in date: " + o;
            if (-1 === m ? m = (new Date).getFullYear() : 100 > m && (m += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (u >= m ? 0 : -100)), y > -1) for (g = 1, v = y; ;) {
                if (a = this._getDaysInMonth(m, g - 1), a >= v) break;
                g++, v -= a
            }
            if (r = this._daylightSavingAdjust(new Date(m, g - 1, v)), r.getFullYear() !== m || r.getMonth() + 1 !== g || r.getDate() !== v) throw"Invalid date";
            return r
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: 1e7 * 60 * 60 * 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)),
        formatDate: function (e, t, i) {
            if (!t) return "";
            var s, n = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort,
                a = (i ? i.dayNames : null) || this._defaults.dayNames,
                o = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort,
                r = (i ? i.monthNames : null) || this._defaults.monthNames, h = function (t) {
                    var i = e.length > s + 1 && e.charAt(s + 1) === t;
                    return i && s++, i
                }, l = function (e, t, i) {
                    var s = "" + t;
                    if (h(e)) for (; i > s.length;) s = "0" + s;
                    return s
                }, u = function (e, t, i, s) {
                    return h(e) ? s[t] : i[t]
                }, d = "", c = !1;
            if (t) for (s = 0; e.length > s; s++) if (c) "'" !== e.charAt(s) || h("'") ? d += e.charAt(s) : c = !1; else switch (e.charAt(s)) {
                case"d":
                    d += l("d", t.getDate(), 2);
                    break;
                case"D":
                    d += u("D", t.getDay(), n, a);
                    break;
                case"o":
                    d += l("o", Math.round((new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() - new Date(t.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                    break;
                case"m":
                    d += l("m", t.getMonth() + 1, 2);
                    break;
                case"M":
                    d += u("M", t.getMonth(), o, r);
                    break;
                case"y":
                    d += h("y") ? t.getFullYear() : (10 > t.getYear() % 100 ? "0" : "") + t.getYear() % 100;
                    break;
                case"@":
                    d += t.getTime();
                    break;
                case"!":
                    d += 1e4 * t.getTime() + this._ticksTo1970;
                    break;
                case"'":
                    h("'") ? d += "'" : c = !0;
                    break;
                default:
                    d += e.charAt(s)
            }
            return d
        },
        _possibleChars: function (e) {
            var t, i = "", s = !1, n = function (i) {
                var s = e.length > t + 1 && e.charAt(t + 1) === i;
                return s && t++, s
            };
            for (t = 0; e.length > t; t++) if (s) "'" !== e.charAt(t) || n("'") ? i += e.charAt(t) : s = !1; else switch (e.charAt(t)) {
                case"d":
                case"m":
                case"y":
                case"@":
                    i += "0123456789";
                    break;
                case"D":
                case"M":
                    return null;
                case"'":
                    n("'") ? i += "'" : s = !0;
                    break;
                default:
                    i += e.charAt(t)
            }
            return i
        },
        _get: function (e, t) {
            return void 0 !== e.settings[t] ? e.settings[t] : this._defaults[t]
        },
        _setDateFromField: function (e, t) {
            if (e.input.val() !== e.lastVal) {
                var i = this._get(e, "dateFormat"), s = e.lastVal = e.input ? e.input.val() : null,
                    n = this._getDefaultDate(e), a = n, o = this._getFormatConfig(e);
                try {
                    a = this.parseDate(i, s, o) || n
                } catch (r) {
                    s = t ? "" : s
                }
                e.selectedDay = a.getDate(), e.drawMonth = e.selectedMonth = a.getMonth(), e.drawYear = e.selectedYear = a.getFullYear(), e.currentDay = s ? a.getDate() : 0, e.currentMonth = s ? a.getMonth() : 0, e.currentYear = s ? a.getFullYear() : 0, this._adjustInstDate(e)
            }
        },
        _getDefaultDate: function (e) {
            return this._restrictMinMax(e, this._determineDate(e, this._get(e, "defaultDate"), new Date))
        },
        _determineDate: function (t, i, s) {
            var n = function (e) {
                    var t = new Date;
                    return t.setDate(t.getDate() + e), t
                }, a = function (i) {
                    try {
                        return e.datepicker.parseDate(e.datepicker._get(t, "dateFormat"), i, e.datepicker._getFormatConfig(t))
                    } catch (s) {
                    }
                    for (var n = (i.toLowerCase().match(/^c/) ? e.datepicker._getDate(t) : null) || new Date, a = n.getFullYear(), o = n.getMonth(), r = n.getDate(), h = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, l = h.exec(i); l;) {
                        switch (l[2] || "d") {
                            case"d":
                            case"D":
                                r += parseInt(l[1], 10);
                                break;
                            case"w":
                            case"W":
                                r += 7 * parseInt(l[1], 10);
                                break;
                            case"m":
                            case"M":
                                o += parseInt(l[1], 10), r = Math.min(r, e.datepicker._getDaysInMonth(a, o));
                                break;
                            case"y":
                            case"Y":
                                a += parseInt(l[1], 10), r = Math.min(r, e.datepicker._getDaysInMonth(a, o))
                        }
                        l = h.exec(i)
                    }
                    return new Date(a, o, r)
                },
                o = null == i || "" === i ? s : "string" == typeof i ? a(i) : "number" == typeof i ? isNaN(i) ? s : n(i) : new Date(i.getTime());
            return o = o && "Invalid Date" == "" + o ? s : o, o && (o.setHours(0), o.setMinutes(0), o.setSeconds(0), o.setMilliseconds(0)), this._daylightSavingAdjust(o)
        },
        _daylightSavingAdjust: function (e) {
            return e ? (e.setHours(e.getHours() > 12 ? e.getHours() + 2 : 0), e) : null
        },
        _setDate: function (e, t, i) {
            var s = !t, n = e.selectedMonth, a = e.selectedYear,
                o = this._restrictMinMax(e, this._determineDate(e, t, new Date));
            e.selectedDay = e.currentDay = o.getDate(), e.drawMonth = e.selectedMonth = e.currentMonth = o.getMonth(), e.drawYear = e.selectedYear = e.currentYear = o.getFullYear(), n === e.selectedMonth && a === e.selectedYear || i || this._notifyChange(e), this._adjustInstDate(e), e.input && e.input.val(s ? "" : this._formatDate(e))
        },
        _getDate: function (e) {
            var t = !e.currentYear || e.input && "" === e.input.val() ? null : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
            return t
        },
        _attachHandlers: function (t) {
            var i = this._get(t, "stepMonths"), s = "#" + t.id.replace(/\\\\/g, "\\");
            t.dpDiv.find("[data-handler]").map(function () {
                var t = {
                    prev: function () {
                        e.datepicker._adjustDate(s, -i, "M")
                    }, next: function () {
                        e.datepicker._adjustDate(s, +i, "M")
                    }, hide: function () {
                        e.datepicker._hideDatepicker()
                    }, today: function () {
                        e.datepicker._gotoToday(s)
                    }, selectDay: function () {
                        return e.datepicker._selectDay(s, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
                    }, selectMonth: function () {
                        return e.datepicker._selectMonthYear(s, this, "M"), !1
                    }, selectYear: function () {
                        return e.datepicker._selectMonthYear(s, this, "Y"), !1
                    }
                };
                e(this).bind(this.getAttribute("data-event"), t[this.getAttribute("data-handler")])
            })
        },
        _generateHTML: function (e) {
            var t, i, s, n, a, o, r, h, l, u, d, c, p, f, m, g, v, y, b, _, x, w, k, T, D, S, M, C, N, A, P, I, H, z, F,
                E, O, j, W, L = new Date,
                R = this._daylightSavingAdjust(new Date(L.getFullYear(), L.getMonth(), L.getDate())),
                Y = this._get(e, "isRTL"), B = this._get(e, "showButtonPanel"), J = this._get(e, "hideIfNoPrevNext"),
                q = this._get(e, "navigationAsDateFormat"), K = this._getNumberOfMonths(e),
                V = this._get(e, "showCurrentAtPos"), U = this._get(e, "stepMonths"), Q = 1 !== K[0] || 1 !== K[1],
                G = this._daylightSavingAdjust(e.currentDay ? new Date(e.currentYear, e.currentMonth, e.currentDay) : new Date(9999, 9, 9)),
                X = this._getMinMaxDate(e, "min"), $ = this._getMinMaxDate(e, "max"), Z = e.drawMonth - V,
                et = e.drawYear;
            if (0 > Z && (Z += 12, et--), $) for (t = this._daylightSavingAdjust(new Date($.getFullYear(), $.getMonth() - K[0] * K[1] + 1, $.getDate())), t = X && X > t ? X : t; this._daylightSavingAdjust(new Date(et, Z, 1)) > t;) Z--, 0 > Z && (Z = 11, et--);
            for (e.drawMonth = Z, e.drawYear = et, i = this._get(e, "prevText"), i = q ? this.formatDate(i, this._daylightSavingAdjust(new Date(et, Z - U, 1)), this._getFormatConfig(e)) : i, s = this._canAdjustMonth(e, -1, et, Z) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + i + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "e" : "w") + "'>" + i + "</span></a>" : J ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + i + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "e" : "w") + "'>" + i + "</span></a>", n = this._get(e, "nextText"), n = q ? this.formatDate(n, this._daylightSavingAdjust(new Date(et, Z + U, 1)), this._getFormatConfig(e)) : n, a = this._canAdjustMonth(e, 1, et, Z) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + n + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "w" : "e") + "'>" + n + "</span></a>" : J ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + n + "'><span class='ui-icon ui-icon-circle-triangle-" + (Y ? "w" : "e") + "'>" + n + "</span></a>", o = this._get(e, "currentText"), r = this._get(e, "gotoCurrent") && e.currentDay ? G : R, o = q ? this.formatDate(o, r, this._getFormatConfig(e)) : o, h = e.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(e, "closeText") + "</button>", l = B ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (Y ? h : "") + (this._isInRange(e, r) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + o + "</button>" : "") + (Y ? "" : h) + "</div>" : "", u = parseInt(this._get(e, "firstDay"), 10), u = isNaN(u) ? 0 : u, d = this._get(e, "showWeek"), c = this._get(e, "dayNames"), p = this._get(e, "dayNamesMin"), f = this._get(e, "monthNames"), m = this._get(e, "monthNamesShort"), g = this._get(e, "beforeShowDay"), v = this._get(e, "showOtherMonths"), y = this._get(e, "selectOtherMonths"), b = this._getDefaultDate(e), _ = "", w = 0; K[0] > w; w++) {
                for (k = "", this.maxRows = 4, T = 0; K[1] > T; T++) {
                    if (D = this._daylightSavingAdjust(new Date(et, Z, e.selectedDay)), S = " ui-corner-all", M = "", Q) {
                        if (M += "<div class='ui-datepicker-group", K[1] > 1) switch (T) {
                            case 0:
                                M += " ui-datepicker-group-first", S = " ui-corner-" + (Y ? "right" : "left");
                                break;
                            case K[1] - 1:
                                M += " ui-datepicker-group-last", S = " ui-corner-" + (Y ? "left" : "right");
                                break;
                            default:
                                M += " ui-datepicker-group-middle", S = ""
                        }
                        M += "'>"
                    }
                    for (M += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + S + "'>" + (/all|left/.test(S) && 0 === w ? Y ? a : s : "") + (/all|right/.test(S) && 0 === w ? Y ? s : a : "") + this._generateMonthYearHeader(e, Z, et, X, $, w > 0 || T > 0, f, m) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>", C = d ? "<th class='ui-datepicker-week-col'>" + this._get(e, "weekHeader") + "</th>" : "", x = 0; 7 > x; x++) N = (x + u) % 7, C += "<th scope='col'" + ((x + u + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + c[N] + "'>" + p[N] + "</span></th>";
                    for (M += C + "</tr></thead><tbody>", A = this._getDaysInMonth(et, Z), et === e.selectedYear && Z === e.selectedMonth && (e.selectedDay = Math.min(e.selectedDay, A)), P = (this._getFirstDayOfMonth(et, Z) - u + 7) % 7, I = Math.ceil((P + A) / 7), H = Q ? this.maxRows > I ? this.maxRows : I : I, this.maxRows = H, z = this._daylightSavingAdjust(new Date(et, Z, 1 - P)), F = 0; H > F; F++) {
                        for (M += "<tr>", E = d ? "<td class='ui-datepicker-week-col'>" + this._get(e, "calculateWeek")(z) + "</td>" : "", x = 0; 7 > x; x++) O = g ? g.apply(e.input ? e.input[0] : null, [z]) : [!0, ""], j = z.getMonth() !== Z, W = j && !y || !O[0] || X && X > z || $ && z > $, E += "<td class='" + ((x + u + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (j ? " ui-datepicker-other-month" : "") + (z.getTime() === D.getTime() && Z === e.selectedMonth && e._keyEvent || b.getTime() === z.getTime() && b.getTime() === D.getTime() ? " " + this._dayOverClass : "") + (W ? " " + this._unselectableClass + " ui-state-disabled" : "") + (j && !v ? "" : " " + O[1] + (z.getTime() === G.getTime() ? " " + this._currentClass : "") + (z.getTime() === R.getTime() ? " ui-datepicker-today" : "")) + "'" + (j && !v || !O[2] ? "" : " title='" + O[2].replace(/'/g, "&#39;") + "'") + (W ? "" : " data-handler='selectDay' data-event='click' data-month='" + z.getMonth() + "' data-year='" + z.getFullYear() + "'") + ">" + (j && !v ? "&#xa0;" : W ? "<span class='ui-state-default'>" + z.getDate() + "</span>" : "<a class='ui-state-default" + (z.getTime() === R.getTime() ? " ui-state-highlight" : "") + (z.getTime() === G.getTime() ? " ui-state-active" : "") + (j ? " ui-priority-secondary" : "") + "' href='#'>" + z.getDate() + "</a>") + "</td>", z.setDate(z.getDate() + 1), z = this._daylightSavingAdjust(z);
                        M += E + "</tr>"
                    }
                    Z++, Z > 11 && (Z = 0, et++), M += "</tbody></table>" + (Q ? "</div>" + (K[0] > 0 && T === K[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : ""), k += M
                }
                _ += k
            }
            return _ += l, e._keyEvent = !1, _
        },
        _generateMonthYearHeader: function (e, t, i, s, n, a, o, r) {
            var h, l, u, d, c, p, f, m, g = this._get(e, "changeMonth"), v = this._get(e, "changeYear"),
                y = this._get(e, "showMonthAfterYear"), b = "<div class='ui-datepicker-title'>", _ = "";
            if (a || !g) _ += "<span class='ui-datepicker-month'>" + o[t] + "</span>"; else {
                for (h = s && s.getFullYear() === i, l = n && n.getFullYear() === i, _ += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", u = 0; 12 > u; u++) (!h || u >= s.getMonth()) && (!l || n.getMonth() >= u) && (_ += "<option value='" + u + "'" + (u === t ? " selected='selected'" : "") + ">" + r[u] + "</option>");
                _ += "</select>"
            }
            if (y || (b += _ + (!a && g && v ? "" : "&#xa0;")), !e.yearshtml) if (e.yearshtml = "", a || !v) b += "<span class='ui-datepicker-year'>" + i + "</span>"; else {
                for (d = this._get(e, "yearRange").split(":"), c = (new Date).getFullYear(), p = function (e) {
                    var t = e.match(/c[+\-].*/) ? i + parseInt(e.substring(1), 10) : e.match(/[+\-].*/) ? c + parseInt(e, 10) : parseInt(e, 10);
                    return isNaN(t) ? c : t
                }, f = p(d[0]), m = Math.max(f, p(d[1] || "")), f = s ? Math.max(f, s.getFullYear()) : f, m = n ? Math.min(m, n.getFullYear()) : m, e.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; m >= f; f++) e.yearshtml += "<option value='" + f + "'" + (f === i ? " selected='selected'" : "") + ">" + f + "</option>";
                e.yearshtml += "</select>", b += e.yearshtml, e.yearshtml = null
            }
            return b += this._get(e, "yearSuffix"), y && (b += (!a && g && v ? "" : "&#xa0;") + _), b += "</div>"
        },
        _adjustInstDate: function (e, t, i) {
            var s = e.drawYear + ("Y" === i ? t : 0), n = e.drawMonth + ("M" === i ? t : 0),
                a = Math.min(e.selectedDay, this._getDaysInMonth(s, n)) + ("D" === i ? t : 0),
                o = this._restrictMinMax(e, this._daylightSavingAdjust(new Date(s, n, a)));
            e.selectedDay = o.getDate(), e.drawMonth = e.selectedMonth = o.getMonth(), e.drawYear = e.selectedYear = o.getFullYear(), ("M" === i || "Y" === i) && this._notifyChange(e)
        },
        _restrictMinMax: function (e, t) {
            var i = this._getMinMaxDate(e, "min"), s = this._getMinMaxDate(e, "max"), n = i && i > t ? i : t;
            return s && n > s ? s : n
        },
        _notifyChange: function (e) {
            var t = this._get(e, "onChangeMonthYear");
            t && t.apply(e.input ? e.input[0] : null, [e.selectedYear, e.selectedMonth + 1, e])
        },
        _getNumberOfMonths: function (e) {
            var t = this._get(e, "numberOfMonths");
            return null == t ? [1, 1] : "number" == typeof t ? [1, t] : t
        },
        _getMinMaxDate: function (e, t) {
            return this._determineDate(e, this._get(e, t + "Date"), null)
        },
        _getDaysInMonth: function (e, t) {
            return 32 - this._daylightSavingAdjust(new Date(e, t, 32)).getDate()
        },
        _getFirstDayOfMonth: function (e, t) {
            return new Date(e, t, 1).getDay()
        },
        _canAdjustMonth: function (e, t, i, s) {
            var n = this._getNumberOfMonths(e),
                a = this._daylightSavingAdjust(new Date(i, s + (0 > t ? t : n[0] * n[1]), 1));
            return 0 > t && a.setDate(this._getDaysInMonth(a.getFullYear(), a.getMonth())), this._isInRange(e, a)
        },
        _isInRange: function (e, t) {
            var i, s, n = this._getMinMaxDate(e, "min"), a = this._getMinMaxDate(e, "max"), o = null, r = null,
                h = this._get(e, "yearRange");
            return h && (i = h.split(":"), s = (new Date).getFullYear(), o = parseInt(i[0], 10), r = parseInt(i[1], 10), i[0].match(/[+\-].*/) && (o += s), i[1].match(/[+\-].*/) && (r += s)), (!n || t.getTime() >= n.getTime()) && (!a || t.getTime() <= a.getTime()) && (!o || t.getFullYear() >= o) && (!r || r >= t.getFullYear())
        },
        _getFormatConfig: function (e) {
            var t = this._get(e, "shortYearCutoff");
            return t = "string" != typeof t ? t : (new Date).getFullYear() % 100 + parseInt(t, 10), {
                shortYearCutoff: t,
                dayNamesShort: this._get(e, "dayNamesShort"),
                dayNames: this._get(e, "dayNames"),
                monthNamesShort: this._get(e, "monthNamesShort"),
                monthNames: this._get(e, "monthNames")
            }
        },
        _formatDate: function (e, t, i, s) {
            t || (e.currentDay = e.selectedDay, e.currentMonth = e.selectedMonth, e.currentYear = e.selectedYear);
            var n = t ? "object" == typeof t ? t : this._daylightSavingAdjust(new Date(s, i, t)) : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay));
            return this.formatDate(this._get(e, "dateFormat"), n, this._getFormatConfig(e))
        }
    }), e.fn.datepicker = function (t) {
        if (!this.length) return this;
        e.datepicker.initialized || (e(document).mousedown(e.datepicker._checkExternalClick), e.datepicker.initialized = !0), 0 === e("#" + e.datepicker._mainDivId).length && e("body").append(e.datepicker.dpDiv);
        var i = Array.prototype.slice.call(arguments, 1);
        return "string" != typeof t || "isDisabled" !== t && "getDate" !== t && "widget" !== t ? "option" === t && 2 === arguments.length && "string" == typeof arguments[1] ? e.datepicker["_" + t + "Datepicker"].apply(e.datepicker, [this[0]].concat(i)) : this.each(function () {
            "string" == typeof t ? e.datepicker["_" + t + "Datepicker"].apply(e.datepicker, [this].concat(i)) : e.datepicker._attachDatepicker(this, t)
        }) : e.datepicker["_" + t + "Datepicker"].apply(e.datepicker, [this[0]].concat(i))
    }, e.datepicker = new n, e.datepicker.initialized = !1, e.datepicker.uuid = (new Date).getTime(), e.datepicker.version = "1.11.4", e.datepicker, e.widget("ui.draggable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            drag: null,
            start: null,
            stop: null
        },
        _create: function () {
            "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._setHandleClassName(), this._mouseInit()
        },
        _setOption: function (e, t) {
            this._super(e, t), "handle" === e && (this._removeHandleClassName(), this._setHandleClassName())
        },
        _destroy: function () {
            return (this.helper || this.element).is(".ui-draggable-dragging") ? (this.destroyOnClear = !0, void 0) : (this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), this._removeHandleClassName(), this._mouseDestroy(), void 0)
        },
        _mouseCapture: function (t) {
            var i = this.options;
            return this._blurActiveElement(t), this.helper || i.disabled || e(t.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(t), this.handle ? (this._blockFrames(i.iframeFix === !0 ? "iframe" : i.iframeFix), !0) : !1)
        },
        _blockFrames: function (t) {
            this.iframeBlocks = this.document.find(t).map(function () {
                var t = e(this);
                return e("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]
            })
        },
        _unblockFrames: function () {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
        },
        _blurActiveElement: function (t) {
            var i = this.document[0];
            if (this.handleElement.is(t.target)) try {
                i.activeElement && "body" !== i.activeElement.nodeName.toLowerCase() && e(i.activeElement).blur()
            } catch (s) {
            }
        },
        _mouseStart: function (t) {
            var i = this.options;
            return this.helper = this._createHelper(t), this.helper.addClass("ui-draggable-dragging"), this._cacheHelperProportions(), e.ui.ddmanager && (e.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function () {
                return "fixed" === e(this).css("position")
            }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(t), this.originalPosition = this.position = this._generatePosition(t, !1), this.originalPageX = t.pageX, this.originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), this._setContainment(), this._trigger("start", t) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this._normalizeRightBottom(), this._mouseDrag(t, !0), e.ui.ddmanager && e.ui.ddmanager.dragStart(this, t), !0)
        },
        _refreshOffsets: function (e) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: !1,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }, this.offset.click = {left: e.pageX - this.offset.left, top: e.pageY - this.offset.top}
        },
        _mouseDrag: function (t, i) {
            if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t, !0), this.positionAbs = this._convertPositionTo("absolute"), !i) {
                var s = this._uiHash();
                if (this._trigger("drag", t, s) === !1) return this._mouseUp({}), !1;
                this.position = s.position
            }
            return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", e.ui.ddmanager && e.ui.ddmanager.drag(this, t), !1
        },
        _mouseStop: function (t) {
            var i = this, s = !1;
            return e.ui.ddmanager && !this.options.dropBehaviour && (s = e.ui.ddmanager.drop(this, t)), this.dropped && (s = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !s || "valid" === this.options.revert && s || this.options.revert === !0 || e.isFunction(this.options.revert) && this.options.revert.call(this.element, s) ? e(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                i._trigger("stop", t) !== !1 && i._clear()
            }) : this._trigger("stop", t) !== !1 && this._clear(), !1
        },
        _mouseUp: function (t) {
            return this._unblockFrames(), e.ui.ddmanager && e.ui.ddmanager.dragStop(this, t), this.handleElement.is(t.target) && this.element.focus(), e.ui.mouse.prototype._mouseUp.call(this, t)
        },
        cancel: function () {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), this
        },
        _getHandle: function (t) {
            return this.options.handle ? !!e(t.target).closest(this.element.find(this.options.handle)).length : !0
        },
        _setHandleClassName: function () {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this.handleElement.addClass("ui-draggable-handle")
        },
        _removeHandleClassName: function () {
            this.handleElement.removeClass("ui-draggable-handle")
        },
        _createHelper: function (t) {
            var i = this.options, s = e.isFunction(i.helper),
                n = s ? e(i.helper.apply(this.element[0], [t])) : "clone" === i.helper ? this.element.clone().removeAttr("id") : this.element;
            return n.parents("body").length || n.appendTo("parent" === i.appendTo ? this.element[0].parentNode : i.appendTo), s && n[0] === this.element[0] && this._setPositionRelative(), n[0] === this.element[0] || /(fixed|absolute)/.test(n.css("position")) || n.css("position", "absolute"), n
        },
        _setPositionRelative: function () {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative")
        },
        _adjustOffsetFromHelper: function (t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
        },
        _isRootNode: function (e) {
            return /(html|body)/i.test(e.tagName) || e === this.document[0]
        },
        _getParentOffset: function () {
            var t = this.offsetParent.offset(), i = this.document[0];
            return "absolute" === this.cssPosition && this.scrollParent[0] !== i && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function () {
            if ("relative" !== this.cssPosition) return {top: 0, left: 0};
            var e = this.element.position(), t = this._isRootNode(this.scrollParent[0]);
            return {
                top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + (t ? 0 : this.scrollParent.scrollTop()),
                left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + (t ? 0 : this.scrollParent.scrollLeft())
            }
        },
        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            }
        },
        _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
            var t, i, s, n = this.options, a = this.document[0];
            return this.relativeContainer = null, n.containment ? "window" === n.containment ? (this.containment = [e(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, e(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, e(window).scrollLeft() + e(window).width() - this.helperProportions.width - this.margins.left, e(window).scrollTop() + (e(window).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : "document" === n.containment ? (this.containment = [0, 0, e(a).width() - this.helperProportions.width - this.margins.left, (e(a).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top], void 0) : n.containment.constructor === Array ? (this.containment = n.containment, void 0) : ("parent" === n.containment && (n.containment = this.helper[0].parentNode), i = e(n.containment), s = i[0], s && (t = /(scroll|auto)/.test(i.css("overflow")), this.containment = [(parseInt(i.css("borderLeftWidth"), 10) || 0) + (parseInt(i.css("paddingLeft"), 10) || 0), (parseInt(i.css("borderTopWidth"), 10) || 0) + (parseInt(i.css("paddingTop"), 10) || 0), (t ? Math.max(s.scrollWidth, s.offsetWidth) : s.offsetWidth) - (parseInt(i.css("borderRightWidth"), 10) || 0) - (parseInt(i.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(s.scrollHeight, s.offsetHeight) : s.offsetHeight) - (parseInt(i.css("borderBottomWidth"), 10) || 0) - (parseInt(i.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = i), void 0) : (this.containment = null, void 0)
        },
        _convertPositionTo: function (e, t) {
            t || (t = this.position);
            var i = "absolute" === e ? 1 : -1, s = this._isRootNode(this.scrollParent[0]);
            return {
                top: t.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top) * i,
                left: t.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left) * i
            }
        },
        _generatePosition: function (e, t) {
            var i, s, n, a, o = this.options, r = this._isRootNode(this.scrollParent[0]), h = e.pageX, l = e.pageY;
            return r && this.offset.scroll || (this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            }), t && (this.containment && (this.relativeContainer ? (s = this.relativeContainer.offset(), i = [this.containment[0] + s.left, this.containment[1] + s.top, this.containment[2] + s.left, this.containment[3] + s.top]) : i = this.containment, e.pageX - this.offset.click.left < i[0] && (h = i[0] + this.offset.click.left), e.pageY - this.offset.click.top < i[1] && (l = i[1] + this.offset.click.top), e.pageX - this.offset.click.left > i[2] && (h = i[2] + this.offset.click.left), e.pageY - this.offset.click.top > i[3] && (l = i[3] + this.offset.click.top)), o.grid && (n = o.grid[1] ? this.originalPageY + Math.round((l - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, l = i ? n - this.offset.click.top >= i[1] || n - this.offset.click.top > i[3] ? n : n - this.offset.click.top >= i[1] ? n - o.grid[1] : n + o.grid[1] : n, a = o.grid[0] ? this.originalPageX + Math.round((h - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, h = i ? a - this.offset.click.left >= i[0] || a - this.offset.click.left > i[2] ? a : a - this.offset.click.left >= i[0] ? a - o.grid[0] : a + o.grid[0] : a), "y" === o.axis && (h = this.originalPageX), "x" === o.axis && (l = this.originalPageY)), {
                top: l - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : r ? 0 : this.offset.scroll.top),
                left: h - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : r ? 0 : this.offset.scroll.left)
            }
        },
        _clear: function () {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy()
        },
        _normalizeRightBottom: function () {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this.helper.width(this.helper.width()), this.helper.css("right", "auto")), "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this.helper.height(this.helper.height()), this.helper.css("bottom", "auto"))
        },
        _trigger: function (t, i, s) {
            return s = s || this._uiHash(), e.ui.plugin.call(this, t, [i, s, this], !0), /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"), s.offset = this.positionAbs), e.Widget.prototype._trigger.call(this, t, i, s)
        },
        plugins: {},
        _uiHash: function () {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            }
        }
    }), e.ui.plugin.add("draggable", "connectToSortable", {
        start: function (t, i, s) {
            var n = e.extend({}, i, {item: s.element});
            s.sortables = [], e(s.options.connectToSortable).each(function () {
                var i = e(this).sortable("instance");
                i && !i.options.disabled && (s.sortables.push(i), i.refreshPositions(), i._trigger("activate", t, n))
            })
        }, stop: function (t, i, s) {
            var n = e.extend({}, i, {item: s.element});
            s.cancelHelperRemoval = !1, e.each(s.sortables, function () {
                var e = this;
                e.isOver ? (e.isOver = 0, s.cancelHelperRemoval = !0, e.cancelHelperRemoval = !1, e._storedCSS = {
                    position: e.placeholder.css("position"),
                    top: e.placeholder.css("top"),
                    left: e.placeholder.css("left")
                }, e._mouseStop(t), e.options.helper = e.options._helper) : (e.cancelHelperRemoval = !0, e._trigger("deactivate", t, n))
            })
        }, drag: function (t, i, s) {
            e.each(s.sortables, function () {
                var n = !1, a = this;
                a.positionAbs = s.positionAbs, a.helperProportions = s.helperProportions, a.offset.click = s.offset.click, a._intersectsWith(a.containerCache) && (n = !0, e.each(s.sortables, function () {
                    return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions, this.offset.click = s.offset.click, this !== a && this._intersectsWith(this.containerCache) && e.contains(a.element[0], this.element[0]) && (n = !1), n
                })), n ? (a.isOver || (a.isOver = 1, s._parent = i.helper.parent(), a.currentItem = i.helper.appendTo(a.element).data("ui-sortable-item", !0), a.options._helper = a.options.helper, a.options.helper = function () {
                    return i.helper[0]
                }, t.target = a.currentItem[0], a._mouseCapture(t, !0), a._mouseStart(t, !0, !0), a.offset.click.top = s.offset.click.top, a.offset.click.left = s.offset.click.left, a.offset.parent.left -= s.offset.parent.left - a.offset.parent.left, a.offset.parent.top -= s.offset.parent.top - a.offset.parent.top, s._trigger("toSortable", t), s.dropped = a.element, e.each(s.sortables, function () {
                    this.refreshPositions()
                }), s.currentItem = s.element, a.fromOutside = s), a.currentItem && (a._mouseDrag(t), i.position = a.position)) : a.isOver && (a.isOver = 0, a.cancelHelperRemoval = !0, a.options._revert = a.options.revert, a.options.revert = !1, a._trigger("out", t, a._uiHash(a)), a._mouseStop(t, !0), a.options.revert = a.options._revert, a.options.helper = a.options._helper, a.placeholder && a.placeholder.remove(), i.helper.appendTo(s._parent), s._refreshOffsets(t), i.position = s._generatePosition(t, !0), s._trigger("fromSortable", t), s.dropped = !1, e.each(s.sortables, function () {
                    this.refreshPositions()
                }))
            })
        }
    }), e.ui.plugin.add("draggable", "cursor", {
        start: function (t, i, s) {
            var n = e("body"), a = s.options;
            n.css("cursor") && (a._cursor = n.css("cursor")), n.css("cursor", a.cursor)
        }, stop: function (t, i, s) {
            var n = s.options;
            n._cursor && e("body").css("cursor", n._cursor)
        }
    }), e.ui.plugin.add("draggable", "opacity", {
        start: function (t, i, s) {
            var n = e(i.helper), a = s.options;
            n.css("opacity") && (a._opacity = n.css("opacity")), n.css("opacity", a.opacity)
        }, stop: function (t, i, s) {
            var n = s.options;
            n._opacity && e(i.helper).css("opacity", n._opacity)
        }
    }), e.ui.plugin.add("draggable", "scroll", {
        start: function (e, t, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset())
        }, drag: function (t, i, s) {
            var n = s.options, a = !1, o = s.scrollParentNotHidden[0], r = s.document[0];
            o !== r && "HTML" !== o.tagName ? (n.axis && "x" === n.axis || (s.overflowOffset.top + o.offsetHeight - t.pageY < n.scrollSensitivity ? o.scrollTop = a = o.scrollTop + n.scrollSpeed : t.pageY - s.overflowOffset.top < n.scrollSensitivity && (o.scrollTop = a = o.scrollTop - n.scrollSpeed)), n.axis && "y" === n.axis || (s.overflowOffset.left + o.offsetWidth - t.pageX < n.scrollSensitivity ? o.scrollLeft = a = o.scrollLeft + n.scrollSpeed : t.pageX - s.overflowOffset.left < n.scrollSensitivity && (o.scrollLeft = a = o.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (t.pageY - e(r).scrollTop() < n.scrollSensitivity ? a = e(r).scrollTop(e(r).scrollTop() - n.scrollSpeed) : e(window).height() - (t.pageY - e(r).scrollTop()) < n.scrollSensitivity && (a = e(r).scrollTop(e(r).scrollTop() + n.scrollSpeed))), n.axis && "y" === n.axis || (t.pageX - e(r).scrollLeft() < n.scrollSensitivity ? a = e(r).scrollLeft(e(r).scrollLeft() - n.scrollSpeed) : e(window).width() - (t.pageX - e(r).scrollLeft()) < n.scrollSensitivity && (a = e(r).scrollLeft(e(r).scrollLeft() + n.scrollSpeed)))), a !== !1 && e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(s, t)
        }
    }), e.ui.plugin.add("draggable", "snap", {
        start: function (t, i, s) {
            var n = s.options;
            s.snapElements = [], e(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function () {
                var t = e(this), i = t.offset();
                this !== s.element[0] && s.snapElements.push({
                    item: this,
                    width: t.outerWidth(),
                    height: t.outerHeight(),
                    top: i.top,
                    left: i.left
                })
            })
        }, drag: function (t, i, s) {
            var n, a, o, r, h, l, u, d, c, p, f = s.options, m = f.snapTolerance, g = i.offset.left,
                v = g + s.helperProportions.width, y = i.offset.top, b = y + s.helperProportions.height;
            for (c = s.snapElements.length - 1; c >= 0; c--) h = s.snapElements[c].left - s.margins.left, l = h + s.snapElements[c].width, u = s.snapElements[c].top - s.margins.top, d = u + s.snapElements[c].height, h - m > v || g > l + m || u - m > b || y > d + m || !e.contains(s.snapElements[c].item.ownerDocument, s.snapElements[c].item) ? (s.snapElements[c].snapping && s.options.snap.release && s.options.snap.release.call(s.element, t, e.extend(s._uiHash(), {snapItem: s.snapElements[c].item})), s.snapElements[c].snapping = !1) : ("inner" !== f.snapMode && (n = m >= Math.abs(u - b), a = m >= Math.abs(d - y), o = m >= Math.abs(h - v), r = m >= Math.abs(l - g), n && (i.position.top = s._convertPositionTo("relative", {
                top: u - s.helperProportions.height,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h - s.helperProportions.width
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l
            }).left)), p = n || a || o || r, "outer" !== f.snapMode && (n = m >= Math.abs(u - y), a = m >= Math.abs(d - b), o = m >= Math.abs(h - g), r = m >= Math.abs(l - v), n && (i.position.top = s._convertPositionTo("relative", {
                top: u,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d - s.helperProportions.height,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l - s.helperProportions.width
            }).left)), !s.snapElements[c].snapping && (n || a || o || r || p) && s.options.snap.snap && s.options.snap.snap.call(s.element, t, e.extend(s._uiHash(), {snapItem: s.snapElements[c].item})), s.snapElements[c].snapping = n || a || o || r || p)
        }
    }), e.ui.plugin.add("draggable", "stack", {
        start: function (t, i, s) {
            var n, a = s.options, o = e.makeArray(e(a.stack)).sort(function (t, i) {
                return (parseInt(e(t).css("zIndex"), 10) || 0) - (parseInt(e(i).css("zIndex"), 10) || 0)
            });
            o.length && (n = parseInt(e(o[0]).css("zIndex"), 10) || 0, e(o).each(function (t) {
                e(this).css("zIndex", n + t)
            }), this.css("zIndex", n + o.length))
        }
    }), e.ui.plugin.add("draggable", "zIndex", {
        start: function (t, i, s) {
            var n = e(i.helper), a = s.options;
            n.css("zIndex") && (a._zIndex = n.css("zIndex")), n.css("zIndex", a.zIndex)
        }, stop: function (t, i, s) {
            var n = s.options;
            n._zIndex && e(i.helper).css("zIndex", n._zIndex)
        }
    }), e.ui.draggable, e.widget("ui.resizable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function (e) {
            return parseInt(e, 10) || 0
        },
        _isNumber: function (e) {
            return !isNaN(parseInt(e, 10))
        },
        _hasScroll: function (t, i) {
            if ("hidden" === e(t).css("overflow")) return !1;
            var s = i && "left" === i ? "scrollLeft" : "scrollTop", n = !1;
            return t[s] > 0 ? !0 : (t[s] = 1, n = t[s] > 0, t[s] = 0, n)
        },
        _create: function () {
            var t, i, s, n, a, o = this, r = this.options;
            if (this.element.addClass("ui-resizable"), e.extend(this, {
                    _aspectRatio: !!r.aspectRatio,
                    aspectRatio: r.aspectRatio,
                    originalElement: this.element,
                    _proportionallyResizeElements: [],
                    _helper: r.helper || r.ghost || r.animate ? r.helper || "ui-resizable-helper" : null
                }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = !0, this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                }), this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                })), this.originalElement.css({margin: this.originalElement.css("margin")}), this._proportionallyResize()), this.handles = r.handles || (e(".ui-resizable-handle", this.element).length ? {
                    n: ".ui-resizable-n",
                    e: ".ui-resizable-e",
                    s: ".ui-resizable-s",
                    w: ".ui-resizable-w",
                    se: ".ui-resizable-se",
                    sw: ".ui-resizable-sw",
                    ne: ".ui-resizable-ne",
                    nw: ".ui-resizable-nw"
                } : "e,s,se"), this._handles = e(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), t = this.handles.split(","), this.handles = {}, i = 0; t.length > i; i++) s = e.trim(t[i]), a = "ui-resizable-" + s, n = e("<div class='ui-resizable-handle " + a + "'></div>"), n.css({zIndex: r.zIndex}), "se" === s && n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[s] = ".ui-resizable-" + s, this.element.append(n);
            this._renderAxis = function (t) {
                var i, s, n, a;
                t = t || this.element;
                for (i in this.handles) this.handles[i].constructor === String ? this.handles[i] = this.element.children(this.handles[i]).first().show() : (this.handles[i].jquery || this.handles[i].nodeType) && (this.handles[i] = e(this.handles[i]), this._on(this.handles[i], {mousedown: o._mouseDown})), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (s = e(this.handles[i], this.element), a = /sw|ne|nw|se|n|s/.test(i) ? s.outerHeight() : s.outerWidth(), n = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join(""), t.css(n, a), this._proportionallyResize()), this._handles = this._handles.add(this.handles[i])
            }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.mouseover(function () {
                o.resizing || (this.className && (n = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), o.axis = n && n[1] ? n[1] : "se")
            }), r.autoHide && (this._handles.hide(), e(this.element).addClass("ui-resizable-autohide").mouseenter(function () {
                r.disabled || (e(this).removeClass("ui-resizable-autohide"), o._handles.show())
            }).mouseleave(function () {
                r.disabled || o.resizing || (e(this).addClass("ui-resizable-autohide"), o._handles.hide())
            })), this._mouseInit()
        },
        _destroy: function () {
            this._mouseDestroy();
            var t, i = function (t) {
                e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()
            };
            return this.elementIsWrapper && (i(this.element), t = this.element, this.originalElement.css({
                position: t.css("position"),
                width: t.outerWidth(),
                height: t.outerHeight(),
                top: t.css("top"),
                left: t.css("left")
            }).insertAfter(t), t.remove()), this.originalElement.css("resize", this.originalResizeStyle), i(this.originalElement), this
        },
        _mouseCapture: function (t) {
            var i, s, n = !1;
            for (i in this.handles) s = e(this.handles[i])[0], (s === t.target || e.contains(s, t.target)) && (n = !0);
            return !this.options.disabled && n
        },
        _mouseStart: function (t) {
            var i, s, n, a = this.options, o = this.element;
            return this.resizing = !0, this._renderProxy(), i = this._num(this.helper.css("left")), s = this._num(this.helper.css("top")), a.containment && (i += e(a.containment).scrollLeft() || 0, s += e(a.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
                left: i,
                top: s
            }, this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {width: o.width(), height: o.height()}, this.originalSize = this._helper ? {
                width: o.outerWidth(),
                height: o.outerHeight()
            } : {width: o.width(), height: o.height()}, this.sizeDiff = {
                width: o.outerWidth() - o.width(),
                height: o.outerHeight() - o.height()
            }, this.originalPosition = {left: i, top: s}, this.originalMousePosition = {
                left: t.pageX,
                top: t.pageY
            }, this.aspectRatio = "number" == typeof a.aspectRatio ? a.aspectRatio : this.originalSize.width / this.originalSize.height || 1, n = e(".ui-resizable-" + this.axis).css("cursor"), e("body").css("cursor", "auto" === n ? this.axis + "-resize" : n), o.addClass("ui-resizable-resizing"), this._propagate("start", t), !0
        },
        _mouseDrag: function (t) {
            var i, s, n = this.originalMousePosition, a = this.axis, o = t.pageX - n.left || 0,
                r = t.pageY - n.top || 0, h = this._change[a];
            return this._updatePrevProperties(), h ? (i = h.apply(this, [t, o, r]), this._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t.shiftKey) && (i = this._updateRatio(i, t)), i = this._respectSize(i, t), this._updateCache(i), this._propagate("resize", t), s = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), e.isEmptyObject(s) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()), this._applyChanges()), !1) : !1
        },
        _mouseStop: function (t) {
            this.resizing = !1;
            var i, s, n, a, o, r, h, l = this.options, u = this;
            return this._helper && (i = this._proportionallyResizeElements, s = i.length && /textarea/i.test(i[0].nodeName), n = s && this._hasScroll(i[0], "left") ? 0 : u.sizeDiff.height, a = s ? 0 : u.sizeDiff.width, o = {
                width: u.helper.width() - a,
                height: u.helper.height() - n
            }, r = parseInt(u.element.css("left"), 10) + (u.position.left - u.originalPosition.left) || null, h = parseInt(u.element.css("top"), 10) + (u.position.top - u.originalPosition.top) || null, l.animate || this.element.css(e.extend(o, {
                top: h,
                left: r
            })), u.helper.height(u.size.height), u.helper.width(u.size.width), this._helper && !l.animate && this._proportionallyResize()), e("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1
        },
        _updatePrevProperties: function () {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            }, this.prevSize = {width: this.size.width, height: this.size.height}
        },
        _applyChanges: function () {
            var e = {};
            return this.position.top !== this.prevPosition.top && (e.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (e.left = this.position.left + "px"), this.size.width !== this.prevSize.width && (e.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (e.height = this.size.height + "px"), this.helper.css(e), e
        },
        _updateVirtualBoundaries: function (e) {
            var t, i, s, n, a, o = this.options;
            a = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : 1 / 0,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : 1 / 0
            }, (this._aspectRatio || e) && (t = a.minHeight * this.aspectRatio, s = a.minWidth / this.aspectRatio, i = a.maxHeight * this.aspectRatio, n = a.maxWidth / this.aspectRatio, t > a.minWidth && (a.minWidth = t), s > a.minHeight && (a.minHeight = s), a.maxWidth > i && (a.maxWidth = i), a.maxHeight > n && (a.maxHeight = n)), this._vBoundaries = a
        },
        _updateCache: function (e) {
            this.offset = this.helper.offset(), this._isNumber(e.left) && (this.position.left = e.left), this._isNumber(e.top) && (this.position.top = e.top), this._isNumber(e.height) && (this.size.height = e.height), this._isNumber(e.width) && (this.size.width = e.width)
        },
        _updateRatio: function (e) {
            var t = this.position, i = this.size, s = this.axis;
            return this._isNumber(e.height) ? e.width = e.height * this.aspectRatio : this._isNumber(e.width) && (e.height = e.width / this.aspectRatio), "sw" === s && (e.left = t.left + (i.width - e.width), e.top = null), "nw" === s && (e.top = t.top + (i.height - e.height), e.left = t.left + (i.width - e.width)), e
        },
        _respectSize: function (e) {
            var t = this._vBoundaries, i = this.axis, s = this._isNumber(e.width) && t.maxWidth && t.maxWidth < e.width,
                n = this._isNumber(e.height) && t.maxHeight && t.maxHeight < e.height,
                a = this._isNumber(e.width) && t.minWidth && t.minWidth > e.width,
                o = this._isNumber(e.height) && t.minHeight && t.minHeight > e.height,
                r = this.originalPosition.left + this.originalSize.width, h = this.position.top + this.size.height,
                l = /sw|nw|w/.test(i), u = /nw|ne|n/.test(i);
            return a && (e.width = t.minWidth), o && (e.height = t.minHeight), s && (e.width = t.maxWidth), n && (e.height = t.maxHeight), a && l && (e.left = r - t.minWidth), s && l && (e.left = r - t.maxWidth), o && u && (e.top = h - t.minHeight), n && u && (e.top = h - t.maxHeight), e.width || e.height || e.left || !e.top ? e.width || e.height || e.top || !e.left || (e.left = null) : e.top = null, e
        },
        _getPaddingPlusBorderDimensions: function (e) {
            for (var t = 0, i = [], s = [e.css("borderTopWidth"), e.css("borderRightWidth"), e.css("borderBottomWidth"), e.css("borderLeftWidth")], n = [e.css("paddingTop"), e.css("paddingRight"), e.css("paddingBottom"), e.css("paddingLeft")]; 4 > t; t++) i[t] = parseInt(s[t], 10) || 0, i[t] += parseInt(n[t], 10) || 0;
            return {height: i[0] + i[2], width: i[1] + i[3]}
        },
        _proportionallyResize: function () {
            if (this._proportionallyResizeElements.length) for (var e, t = 0, i = this.helper || this.element; this._proportionallyResizeElements.length > t; t++) e = this._proportionallyResizeElements[t], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(e)), e.css({
                height: i.height() - this.outerDimensions.height || 0,
                width: i.width() - this.outerDimensions.width || 0
            })
        },
        _renderProxy: function () {
            var t = this.element, i = this.options;
            this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || e("<div style='overflow:hidden;'></div>"), this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left + "px",
                top: this.elementOffset.top + "px",
                zIndex: ++i.zIndex
            }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element
        },
        _change: {
            e: function (e, t) {
                return {width: this.originalSize.width + t}
            }, w: function (e, t) {
                var i = this.originalSize, s = this.originalPosition;
                return {left: s.left + t, width: i.width - t}
            }, n: function (e, t, i) {
                var s = this.originalSize, n = this.originalPosition;
                return {top: n.top + i, height: s.height - i}
            }, s: function (e, t, i) {
                return {height: this.originalSize.height + i}
            }, se: function (t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, i, s]))
            }, sw: function (t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, i, s]))
            }, ne: function (t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, i, s]))
            }, nw: function (t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, i, s]))
            }
        },
        _propagate: function (t, i) {
            e.ui.plugin.call(this, t, [i, this.ui()]), "resize" !== t && this._trigger(t, i, this.ui())
        },
        plugins: {},
        ui: function () {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            }
        }
    }), e.ui.plugin.add("resizable", "animate", {
        stop: function (t) {
            var i = e(this).resizable("instance"), s = i.options, n = i._proportionallyResizeElements,
                a = n.length && /textarea/i.test(n[0].nodeName),
                o = a && i._hasScroll(n[0], "left") ? 0 : i.sizeDiff.height, r = a ? 0 : i.sizeDiff.width,
                h = {width: i.size.width - r, height: i.size.height - o},
                l = parseInt(i.element.css("left"), 10) + (i.position.left - i.originalPosition.left) || null,
                u = parseInt(i.element.css("top"), 10) + (i.position.top - i.originalPosition.top) || null;
            i.element.animate(e.extend(h, u && l ? {top: u, left: l} : {}), {
                duration: s.animateDuration,
                easing: s.animateEasing,
                step: function () {
                    var s = {
                        width: parseInt(i.element.css("width"), 10),
                        height: parseInt(i.element.css("height"), 10),
                        top: parseInt(i.element.css("top"), 10),
                        left: parseInt(i.element.css("left"), 10)
                    };
                    n && n.length && e(n[0]).css({
                        width: s.width,
                        height: s.height
                    }), i._updateCache(s), i._propagate("resize", t)
                }
            })
        }
    }), e.ui.plugin.add("resizable", "containment", {
        start: function () {
            var t, i, s, n, a, o, r, h = e(this).resizable("instance"), l = h.options, u = h.element, d = l.containment,
                c = d instanceof e ? d.get(0) : /parent/.test(d) ? u.parent().get(0) : d;
            c && (h.containerElement = e(c), /document/.test(d) || d === document ? (h.containerOffset = {
                left: 0,
                top: 0
            }, h.containerPosition = {left: 0, top: 0}, h.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document).width(),
                height: e(document).height() || document.body.parentNode.scrollHeight
            }) : (t = e(c), i = [], e(["Top", "Right", "Left", "Bottom"]).each(function (e, s) {
                i[e] = h._num(t.css("padding" + s))
            }), h.containerOffset = t.offset(), h.containerPosition = t.position(), h.containerSize = {
                height: t.innerHeight() - i[3],
                width: t.innerWidth() - i[1]
            }, s = h.containerOffset, n = h.containerSize.height, a = h.containerSize.width, o = h._hasScroll(c, "left") ? c.scrollWidth : a, r = h._hasScroll(c) ? c.scrollHeight : n, h.parentData = {
                element: c,
                left: s.left,
                top: s.top,
                width: o,
                height: r
            }))
        }, resize: function (t) {
            var i, s, n, a, o = e(this).resizable("instance"), r = o.options, h = o.containerOffset, l = o.position,
                u = o._aspectRatio || t.shiftKey, d = {top: 0, left: 0}, c = o.containerElement, p = !0;
            c[0] !== document && /static/.test(c.css("position")) && (d = h), l.left < (o._helper ? h.left : 0) && (o.size.width = o.size.width + (o._helper ? o.position.left - h.left : o.position.left - d.left), u && (o.size.height = o.size.width / o.aspectRatio, p = !1), o.position.left = r.helper ? h.left : 0), l.top < (o._helper ? h.top : 0) && (o.size.height = o.size.height + (o._helper ? o.position.top - h.top : o.position.top), u && (o.size.width = o.size.height * o.aspectRatio, p = !1), o.position.top = o._helper ? h.top : 0), n = o.containerElement.get(0) === o.element.parent().get(0), a = /relative|absolute/.test(o.containerElement.css("position")), n && a ? (o.offset.left = o.parentData.left + o.position.left, o.offset.top = o.parentData.top + o.position.top) : (o.offset.left = o.element.offset().left, o.offset.top = o.element.offset().top), i = Math.abs(o.sizeDiff.width + (o._helper ? o.offset.left - d.left : o.offset.left - h.left)), s = Math.abs(o.sizeDiff.height + (o._helper ? o.offset.top - d.top : o.offset.top - h.top)), i + o.size.width >= o.parentData.width && (o.size.width = o.parentData.width - i, u && (o.size.height = o.size.width / o.aspectRatio, p = !1)), s + o.size.height >= o.parentData.height && (o.size.height = o.parentData.height - s, u && (o.size.width = o.size.height * o.aspectRatio, p = !1)), p || (o.position.left = o.prevPosition.left, o.position.top = o.prevPosition.top, o.size.width = o.prevSize.width, o.size.height = o.prevSize.height)
        }, stop: function () {
            var t = e(this).resizable("instance"), i = t.options, s = t.containerOffset, n = t.containerPosition,
                a = t.containerElement, o = e(t.helper), r = o.offset(), h = o.outerWidth() - t.sizeDiff.width,
                l = o.outerHeight() - t.sizeDiff.height;
            t._helper && !i.animate && /relative/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: l
            }), t._helper && !i.animate && /static/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: l
            })
        }
    }), e.ui.plugin.add("resizable", "alsoResize", {
        start: function () {
            var t = e(this).resizable("instance"), i = t.options;
            e(i.alsoResize).each(function () {
                var t = e(this);
                t.data("ui-resizable-alsoresize", {
                    width: parseInt(t.width(), 10),
                    height: parseInt(t.height(), 10),
                    left: parseInt(t.css("left"), 10),
                    top: parseInt(t.css("top"), 10)
                })
            })
        }, resize: function (t, i) {
            var s = e(this).resizable("instance"), n = s.options, a = s.originalSize, o = s.originalPosition, r = {
                height: s.size.height - a.height || 0,
                width: s.size.width - a.width || 0,
                top: s.position.top - o.top || 0,
                left: s.position.left - o.left || 0
            };
            e(n.alsoResize).each(function () {
                var t = e(this), s = e(this).data("ui-resizable-alsoresize"), n = {},
                    a = t.parents(i.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                e.each(a, function (e, t) {
                    var i = (s[t] || 0) + (r[t] || 0);
                    i && i >= 0 && (n[t] = i || null)
                }), t.css(n)
            })
        }, stop: function () {
            e(this).removeData("resizable-alsoresize")
        }
    }), e.ui.plugin.add("resizable", "ghost", {
        start: function () {
            var t = e(this).resizable("instance"), i = t.options, s = t.size;
            t.ghost = t.originalElement.clone(), t.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: s.height,
                width: s.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass("string" == typeof i.ghost ? i.ghost : ""), t.ghost.appendTo(t.helper)
        }, resize: function () {
            var t = e(this).resizable("instance");
            t.ghost && t.ghost.css({position: "relative", height: t.size.height, width: t.size.width})
        }, stop: function () {
            var t = e(this).resizable("instance");
            t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0))
        }
    }), e.ui.plugin.add("resizable", "grid", {
        resize: function () {
            var t, i = e(this).resizable("instance"), s = i.options, n = i.size, a = i.originalSize,
                o = i.originalPosition, r = i.axis, h = "number" == typeof s.grid ? [s.grid, s.grid] : s.grid,
                l = h[0] || 1, u = h[1] || 1, d = Math.round((n.width - a.width) / l) * l,
                c = Math.round((n.height - a.height) / u) * u, p = a.width + d, f = a.height + c,
                m = s.maxWidth && p > s.maxWidth, g = s.maxHeight && f > s.maxHeight, v = s.minWidth && s.minWidth > p,
                y = s.minHeight && s.minHeight > f;
            s.grid = h, v && (p += l), y && (f += u), m && (p -= l), g && (f -= u), /^(se|s|e)$/.test(r) ? (i.size.width = p, i.size.height = f) : /^(ne)$/.test(r) ? (i.size.width = p, i.size.height = f, i.position.top = o.top - c) : /^(sw)$/.test(r) ? (i.size.width = p, i.size.height = f, i.position.left = o.left - d) : ((0 >= f - u || 0 >= p - l) && (t = i._getPaddingPlusBorderDimensions(this)), f - u > 0 ? (i.size.height = f, i.position.top = o.top - c) : (f = u - t.height, i.size.height = f, i.position.top = o.top + a.height - f), p - l > 0 ? (i.size.width = p, i.position.left = o.left - d) : (p = l - t.width, i.size.width = p, i.position.left = o.left + a.width - p))
        }
    }), e.ui.resizable, e.widget("ui.dialog", {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoOpen: !0,
            buttons: [],
            closeOnEscape: !0,
            closeText: "Close",
            dialogClass: "",
            draggable: !0,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: !1,
            position: {
                my: "center", at: "center", of: window, collision: "fit", using: function (t) {
                    var i = e(this).css(t).offset().top;
                    0 > i && e(this).css("top", t.top - i)
                }
            },
            resizable: !0,
            show: null,
            title: null,
            width: 300,
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        sizeRelatedOptions: {
            buttons: !0,
            height: !0,
            maxHeight: !0,
            maxWidth: !0,
            minHeight: !0,
            minWidth: !0,
            width: !0
        },
        resizableRelatedOptions: {maxHeight: !0, maxWidth: !0, minHeight: !0, minWidth: !0},
        _create: function () {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            }, this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            }, this.originalTitle = this.element.attr("title"), this.options.title = this.options.title || this.originalTitle, this._createWrapper(), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog), this._createTitlebar(), this._createButtonPane(), this.options.draggable && e.fn.draggable && this._makeDraggable(), this.options.resizable && e.fn.resizable && this._makeResizable(), this._isOpen = !1, this._trackFocus()
        },
        _init: function () {
            this.options.autoOpen && this.open()
        },
        _appendTo: function () {
            var t = this.options.appendTo;
            return t && (t.jquery || t.nodeType) ? e(t) : this.document.find(t || "body").eq(0)
        },
        _destroy: function () {
            var e, t = this.originalPosition;
            this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(), this.uiDialog.stop(!0, !0).remove(), this.originalTitle && this.element.attr("title", this.originalTitle), e = t.parent.children().eq(t.index), e.length && e[0] !== this.element[0] ? e.before(this.element) : t.parent.append(this.element)
        },
        widget: function () {
            return this.uiDialog
        },
        disable: e.noop,
        enable: e.noop,
        close: function (t) {
            var i, s = this;
            if (this._isOpen && this._trigger("beforeClose", t) !== !1) {
                if (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), !this.opener.filter(":focusable").focus().length) try {
                    i = this.document[0].activeElement, i && "body" !== i.nodeName.toLowerCase() && e(i).blur()
                } catch (n) {
                }
                this._hide(this.uiDialog, this.options.hide, function () {
                    s._trigger("close", t)
                })
            }
        },
        isOpen: function () {
            return this._isOpen
        },
        moveToTop: function () {
            this._moveToTop()
        },
        _moveToTop: function (t, i) {
            var s = !1, n = this.uiDialog.siblings(".ui-front:visible").map(function () {
                return +e(this).css("z-index")
            }).get(), a = Math.max.apply(null, n);
            return a >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", a + 1), s = !0), s && !i && this._trigger("focus", t), s
        },
        open: function () {
            var t = this;
            return this._isOpen ? (this._moveToTop() && this._focusTabbable(), void 0) : (this._isOpen = !0, this.opener = e(this.document[0].activeElement), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function () {
                t._focusTabbable(), t._trigger("focus")
            }), this._makeFocusTarget(), this._trigger("open"), void 0)
        },
        _focusTabbable: function () {
            var e = this._focusedElement;
            e || (e = this.element.find("[autofocus]")), e.length || (e = this.element.find(":tabbable")), e.length || (e = this.uiDialogButtonPane.find(":tabbable")), e.length || (e = this.uiDialogTitlebarClose.filter(":tabbable")), e.length || (e = this.uiDialog), e.eq(0).focus()
        },
        _keepFocus: function (t) {
            function i() {
                var t = this.document[0].activeElement, i = this.uiDialog[0] === t || e.contains(this.uiDialog[0], t);
                i || this._focusTabbable()
            }

            t.preventDefault(), i.call(this), this._delay(i)
        },
        _createWrapper: function () {
            this.uiDialog = e("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo()), this._on(this.uiDialog, {
                keydown: function (t) {
                    if (this.options.closeOnEscape && !t.isDefaultPrevented() && t.keyCode && t.keyCode === e.ui.keyCode.ESCAPE) return t.preventDefault(), this.close(t), void 0;
                    if (t.keyCode === e.ui.keyCode.TAB && !t.isDefaultPrevented()) {
                        var i = this.uiDialog.find(":tabbable"), s = i.filter(":first"), n = i.filter(":last");
                        t.target !== n[0] && t.target !== this.uiDialog[0] || t.shiftKey ? t.target !== s[0] && t.target !== this.uiDialog[0] || !t.shiftKey || (this._delay(function () {
                            n.focus()
                        }), t.preventDefault()) : (this._delay(function () {
                            s.focus()
                        }), t.preventDefault())
                    }
                }, mousedown: function (e) {
                    this._moveToTop(e) && this._focusTabbable()
                }
            }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({"aria-describedby": this.element.uniqueId().attr("id")})
        },
        _createTitlebar: function () {
            var t;
            this.uiDialogTitlebar = e("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog), this._on(this.uiDialogTitlebar, {
                mousedown: function (t) {
                    e(t.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.focus()
                }
            }), this.uiDialogTitlebarClose = e("<button type='button'></button>").button({
                label: this.options.closeText,
                icons: {primary: "ui-icon-closethick"},
                text: !1
            }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar), this._on(this.uiDialogTitlebarClose, {
                click: function (e) {
                    e.preventDefault(), this.close(e)
                }
            }), t = e("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar), this._title(t), this.uiDialog.attr({"aria-labelledby": t.attr("id")})
        },
        _title: function (e) {
            this.options.title || e.html("&#160;"), e.text(this.options.title)
        },
        _createButtonPane: function () {
            this.uiDialogButtonPane = e("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), this.uiButtonSet = e("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane), this._createButtons()
        },
        _createButtons: function () {
            var t = this, i = this.options.buttons;
            return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), e.isEmptyObject(i) || e.isArray(i) && !i.length ? (this.uiDialog.removeClass("ui-dialog-buttons"), void 0) : (e.each(i, function (i, s) {
                var n, a;
                s = e.isFunction(s) ? {
                    click: s,
                    text: i
                } : s, s = e.extend({type: "button"}, s), n = s.click, s.click = function () {
                    n.apply(t.element[0], arguments)
                }, a = {
                    icons: s.icons,
                    text: s.showText
                }, delete s.icons, delete s.showText, e("<button></button>", s).button(a).appendTo(t.uiButtonSet)
            }), this.uiDialog.addClass("ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog), void 0)
        },
        _makeDraggable: function () {
            function t(e) {
                return {position: e.position, offset: e.offset}
            }

            var i = this, s = this.options;
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function (s, n) {
                    e(this).addClass("ui-dialog-dragging"), i._blockFrames(), i._trigger("dragStart", s, t(n))
                },
                drag: function (e, s) {
                    i._trigger("drag", e, t(s))
                },
                stop: function (n, a) {
                    var o = a.offset.left - i.document.scrollLeft(), r = a.offset.top - i.document.scrollTop();
                    s.position = {
                        my: "left top",
                        at: "left" + (o >= 0 ? "+" : "") + o + " " + "top" + (r >= 0 ? "+" : "") + r,
                        of: i.window
                    }, e(this).removeClass("ui-dialog-dragging"), i._unblockFrames(), i._trigger("dragStop", n, t(a))
                }
            })
        },
        _makeResizable: function () {
            function t(e) {
                return {
                    originalPosition: e.originalPosition,
                    originalSize: e.originalSize,
                    position: e.position,
                    size: e.size
                }
            }

            var i = this, s = this.options, n = s.resizable, a = this.uiDialog.css("position"),
                o = "string" == typeof n ? n : "n,e,s,w,se,sw,ne,nw";
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: s.maxWidth,
                maxHeight: s.maxHeight,
                minWidth: s.minWidth,
                minHeight: this._minHeight(),
                handles: o,
                start: function (s, n) {
                    e(this).addClass("ui-dialog-resizing"), i._blockFrames(), i._trigger("resizeStart", s, t(n))
                },
                resize: function (e, s) {
                    i._trigger("resize", e, t(s))
                },
                stop: function (n, a) {
                    var o = i.uiDialog.offset(), r = o.left - i.document.scrollLeft(),
                        h = o.top - i.document.scrollTop();
                    s.height = i.uiDialog.height(), s.width = i.uiDialog.width(), s.position = {
                        my: "left top",
                        at: "left" + (r >= 0 ? "+" : "") + r + " " + "top" + (h >= 0 ? "+" : "") + h,
                        of: i.window
                    }, e(this).removeClass("ui-dialog-resizing"), i._unblockFrames(), i._trigger("resizeStop", n, t(a))
                }
            }).css("position", a)
        },
        _trackFocus: function () {
            this._on(this.widget(), {
                focusin: function (t) {
                    this._makeFocusTarget(), this._focusedElement = e(t.target)
                }
            })
        },
        _makeFocusTarget: function () {
            this._untrackInstance(), this._trackingInstances().unshift(this)
        },
        _untrackInstance: function () {
            var t = this._trackingInstances(), i = e.inArray(this, t);
            -1 !== i && t.splice(i, 1)
        },
        _trackingInstances: function () {
            var e = this.document.data("ui-dialog-instances");
            return e || (e = [], this.document.data("ui-dialog-instances", e)), e
        },
        _minHeight: function () {
            var e = this.options;
            return "auto" === e.height ? e.minHeight : Math.min(e.minHeight, e.height)
        },
        _position: function () {
            var e = this.uiDialog.is(":visible");
            e || this.uiDialog.show(), this.uiDialog.position(this.options.position), e || this.uiDialog.hide()
        },
        _setOptions: function (t) {
            var i = this, s = !1, n = {};
            e.each(t, function (e, t) {
                i._setOption(e, t), e in i.sizeRelatedOptions && (s = !0), e in i.resizableRelatedOptions && (n[e] = t)
            }), s && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", n)
        },
        _setOption: function (e, t) {
            var i, s, n = this.uiDialog;
            "dialogClass" === e && n.removeClass(this.options.dialogClass).addClass(t), "disabled" !== e && (this._super(e, t), "appendTo" === e && this.uiDialog.appendTo(this._appendTo()), "buttons" === e && this._createButtons(), "closeText" === e && this.uiDialogTitlebarClose.button({label: "" + t}), "draggable" === e && (i = n.is(":data(ui-draggable)"), i && !t && n.draggable("destroy"), !i && t && this._makeDraggable()), "position" === e && this._position(), "resizable" === e && (s = n.is(":data(ui-resizable)"), s && !t && n.resizable("destroy"), s && "string" == typeof t && n.resizable("option", "handles", t), s || t === !1 || this._makeResizable()), "title" === e && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
        },
        _size: function () {
            var e, t, i, s = this.options;
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            }), s.minWidth > s.width && (s.width = s.minWidth), e = this.uiDialog.css({
                height: "auto",
                width: s.width
            }).outerHeight(), t = Math.max(0, s.minHeight - e), i = "number" == typeof s.maxHeight ? Math.max(0, s.maxHeight - e) : "none", "auto" === s.height ? this.element.css({
                minHeight: t,
                maxHeight: i,
                height: "auto"
            }) : this.element.height(Math.max(0, s.height - e)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
        },
        _blockFrames: function () {
            this.iframeBlocks = this.document.find("iframe").map(function () {
                var t = e(this);
                return e("<div>").css({
                    position: "absolute",
                    width: t.outerWidth(),
                    height: t.outerHeight()
                }).appendTo(t.parent()).offset(t.offset())[0]
            })
        },
        _unblockFrames: function () {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
        },
        _allowInteraction: function (t) {
            return e(t.target).closest(".ui-dialog").length ? !0 : !!e(t.target).closest(".ui-datepicker").length
        },
        _createOverlay: function () {
            if (this.options.modal) {
                var t = !0;
                this._delay(function () {
                    t = !1
                }), this.document.data("ui-dialog-overlays") || this._on(this.document, {
                    focusin: function (e) {
                        t || this._allowInteraction(e) || (e.preventDefault(), this._trackingInstances()[0]._focusTabbable())
                    }
                }), this.overlay = e("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()), this._on(this.overlay, {mousedown: "_keepFocus"}), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1)
            }
        },
        _destroyOverlay: function () {
            if (this.options.modal && this.overlay) {
                var e = this.document.data("ui-dialog-overlays") - 1;
                e ? this.document.data("ui-dialog-overlays", e) : this.document.unbind("focusin").removeData("ui-dialog-overlays"), this.overlay.remove(), this.overlay = null
            }
        }
    }), e.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function () {
            var t, i = this.options, s = i.accept;
            this.isover = !1, this.isout = !0, this.accept = e.isFunction(s) ? s : function (e) {
                return e.is(s)
            }, this.proportions = function () {
                return arguments.length ? (t = arguments[0], void 0) : t ? t : t = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                }
            }, this._addToManager(i.scope), i.addClasses && this.element.addClass("ui-droppable")
        },
        _addToManager: function (t) {
            e.ui.ddmanager.droppables[t] = e.ui.ddmanager.droppables[t] || [], e.ui.ddmanager.droppables[t].push(this)
        },
        _splice: function (e) {
            for (var t = 0; e.length > t; t++) e[t] === this && e.splice(t, 1)
        },
        _destroy: function () {
            var t = e.ui.ddmanager.droppables[this.options.scope];
            this._splice(t), this.element.removeClass("ui-droppable ui-droppable-disabled")
        },
        _setOption: function (t, i) {
            if ("accept" === t) this.accept = e.isFunction(i) ? i : function (e) {
                return e.is(i)
            }; else if ("scope" === t) {
                var s = e.ui.ddmanager.droppables[this.options.scope];
                this._splice(s), this._addToManager(i)
            }
            this._super(t, i)
        },
        _activate: function (t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), i && this._trigger("activate", t, this.ui(i))
        },
        _deactivate: function (t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass), i && this._trigger("deactivate", t, this.ui(i))
        },
        _over: function (t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), this._trigger("over", t, this.ui(i)))
        },
        _out: function (t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("out", t, this.ui(i)))
        },
        _drop: function (t, i) {
            var s = i || e.ui.ddmanager.current, n = !1;
            return s && (s.currentItem || s.element)[0] !== this.element[0] ? (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
                var i = e(this).droppable("instance");
                return i.options.greedy && !i.options.disabled && i.options.scope === s.options.scope && i.accept.call(i.element[0], s.currentItem || s.element) && e.ui.intersect(s, e.extend(i, {offset: i.element.offset()}), i.options.tolerance, t) ? (n = !0, !1) : void 0
            }), n ? !1 : this.accept.call(this.element[0], s.currentItem || s.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", t, this.ui(s)), this.element) : !1) : !1
        },
        ui: function (e) {
            return {
                draggable: e.currentItem || e.element,
                helper: e.helper,
                position: e.position,
                offset: e.positionAbs
            }
        }
    }), e.ui.intersect = function () {
        function e(e, t, i) {
            return e >= t && t + i > e
        }

        return function (t, i, s, n) {
            if (!i.offset) return !1;
            var a = (t.positionAbs || t.position.absolute).left + t.margins.left,
                o = (t.positionAbs || t.position.absolute).top + t.margins.top, r = a + t.helperProportions.width,
                h = o + t.helperProportions.height, l = i.offset.left, u = i.offset.top, d = l + i.proportions().width,
                c = u + i.proportions().height;
            switch (s) {
                case"fit":
                    return a >= l && d >= r && o >= u && c >= h;
                case"intersect":
                    return a + t.helperProportions.width / 2 > l && d > r - t.helperProportions.width / 2 && o + t.helperProportions.height / 2 > u && c > h - t.helperProportions.height / 2;
                case"pointer":
                    return e(n.pageY, u, i.proportions().height) && e(n.pageX, l, i.proportions().width);
                case"touch":
                    return (o >= u && c >= o || h >= u && c >= h || u > o && h > c) && (a >= l && d >= a || r >= l && d >= r || l > a && r > d);
                default:
                    return !1
            }
        }
    }(), e.ui.ddmanager = {
        current: null, droppables: {"default": []}, prepareOffsets: function (t, i) {
            var s, n, a = e.ui.ddmanager.droppables[t.options.scope] || [], o = i ? i.type : null,
                r = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            e:for (s = 0; a.length > s; s++) if (!(a[s].options.disabled || t && !a[s].accept.call(a[s].element[0], t.currentItem || t.element))) {
                for (n = 0; r.length > n; n++) if (r[n] === a[s].element[0]) {
                    a[s].proportions().height = 0;
                    continue e
                }
                a[s].visible = "none" !== a[s].element.css("display"), a[s].visible && ("mousedown" === o && a[s]._activate.call(a[s], i), a[s].offset = a[s].element.offset(), a[s].proportions({
                    width: a[s].element[0].offsetWidth,
                    height: a[s].element[0].offsetHeight
                }))
            }
        }, drop: function (t, i) {
            var s = !1;
            return e.each((e.ui.ddmanager.droppables[t.options.scope] || []).slice(), function () {
                this.options && (!this.options.disabled && this.visible && e.ui.intersect(t, this, this.options.tolerance, i) && (s = this._drop.call(this, i) || s), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, i)))
            }), s
        }, dragStart: function (t, i) {
            t.element.parentsUntil("body").bind("scroll.droppable", function () {
                t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i)
            })
        }, drag: function (t, i) {
            t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, i), e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function () {
                if (!this.options.disabled && !this.greedyChild && this.visible) {
                    var s, n, a, o = e.ui.intersect(t, this, this.options.tolerance, i),
                        r = !o && this.isover ? "isout" : o && !this.isover ? "isover" : null;
                    r && (this.options.greedy && (n = this.options.scope, a = this.element.parents(":data(ui-droppable)").filter(function () {
                        return e(this).droppable("instance").options.scope === n
                    }), a.length && (s = e(a[0]).droppable("instance"), s.greedyChild = "isover" === r)), s && "isover" === r && (s.isover = !1, s.isout = !0, s._out.call(s, i)), this[r] = !0, this["isout" === r ? "isover" : "isout"] = !1, this["isover" === r ? "_over" : "_out"].call(this, i), s && "isout" === r && (s.isout = !1, s.isover = !0, s._over.call(s, i)))
                }
            })
        }, dragStop: function (t, i) {
            t.element.parentsUntil("body").unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i)
        }
    }, e.ui.droppable;
    var y = "ui-effects-", b = e;
    e.effects = {effect: {}}, function (e, t) {
        function i(e, t, i) {
            var s = d[t.type] || {};
            return null == e ? i || !t.def ? null : t.def : (e = s.floor ? ~~e : parseFloat(e), isNaN(e) ? t.def : s.mod ? (e + s.mod) % s.mod : 0 > e ? 0 : e > s.max ? s.max : e)
        }

        function s(i) {
            var s = l(), n = s._rgba = [];
            return i = i.toLowerCase(), f(h, function (e, a) {
                var o, r = a.re.exec(i), h = r && a.parse(r), l = a.space || "rgba";
                return h ? (o = s[l](h), s[u[l].cache] = o[u[l].cache], n = s._rgba = o._rgba, !1) : t
            }), n.length ? ("0,0,0,0" === n.join() && e.extend(n, a.transparent), s) : a[i]
        }

        function n(e, t, i) {
            return i = (i + 1) % 1, 1 > 6 * i ? e + 6 * (t - e) * i : 1 > 2 * i ? t : 2 > 3 * i ? e + 6 * (t - e) * (2 / 3 - i) : e
        }

        var a,
            o = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
            r = /^([\-+])=\s*(\d+\.?\d*)/, h = [{
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (e) {
                    return [e[1], e[2], e[3], e[4]]
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (e) {
                    return [2.55 * e[1], 2.55 * e[2], 2.55 * e[3], e[4]]
                }
            }, {
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse: function (e) {
                    return [parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16)]
                }
            }, {
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse: function (e) {
                    return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)]
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function (e) {
                    return [e[1], e[2] / 100, e[3] / 100, e[4]]
                }
            }], l = e.Color = function (t, i, s, n) {
                return new e.Color.fn.parse(t, i, s, n)
            }, u = {
                rgba: {
                    props: {
                        red: {idx: 0, type: "byte"},
                        green: {idx: 1, type: "byte"},
                        blue: {idx: 2, type: "byte"}
                    }
                },
                hsla: {
                    props: {
                        hue: {idx: 0, type: "degrees"},
                        saturation: {idx: 1, type: "percent"},
                        lightness: {idx: 2, type: "percent"}
                    }
                }
            }, d = {"byte": {floor: !0, max: 255}, percent: {max: 1}, degrees: {mod: 360, floor: !0}}, c = l.support = {},
            p = e("<p>")[0], f = e.each;
        p.style.cssText = "background-color:rgba(1,1,1,.5)", c.rgba = p.style.backgroundColor.indexOf("rgba") > -1, f(u, function (e, t) {
            t.cache = "_" + e, t.props.alpha = {idx: 3, type: "percent", def: 1}
        }), l.fn = e.extend(l.prototype, {
            parse: function (n, o, r, h) {
                if (n === t) return this._rgba = [null, null, null, null], this;
                (n.jquery || n.nodeType) && (n = e(n).css(o), o = t);
                var d = this, c = e.type(n), p = this._rgba = [];
                return o !== t && (n = [n, o, r, h], c = "array"), "string" === c ? this.parse(s(n) || a._default) : "array" === c ? (f(u.rgba.props, function (e, t) {
                    p[t.idx] = i(n[t.idx], t)
                }), this) : "object" === c ? (n instanceof l ? f(u, function (e, t) {
                    n[t.cache] && (d[t.cache] = n[t.cache].slice())
                }) : f(u, function (t, s) {
                    var a = s.cache;
                    f(s.props, function (e, t) {
                        if (!d[a] && s.to) {
                            if ("alpha" === e || null == n[e]) return;
                            d[a] = s.to(d._rgba)
                        }
                        d[a][t.idx] = i(n[e], t, !0)
                    }), d[a] && 0 > e.inArray(null, d[a].slice(0, 3)) && (d[a][3] = 1, s.from && (d._rgba = s.from(d[a])))
                }), this) : t
            }, is: function (e) {
                var i = l(e), s = !0, n = this;
                return f(u, function (e, a) {
                    var o, r = i[a.cache];
                    return r && (o = n[a.cache] || a.to && a.to(n._rgba) || [], f(a.props, function (e, i) {
                        return null != r[i.idx] ? s = r[i.idx] === o[i.idx] : t
                    })), s
                }), s
            }, _space: function () {
                var e = [], t = this;
                return f(u, function (i, s) {
                    t[s.cache] && e.push(i)
                }), e.pop()
            }, transition: function (e, t) {
                var s = l(e), n = s._space(), a = u[n], o = 0 === this.alpha() ? l("transparent") : this,
                    r = o[a.cache] || a.to(o._rgba), h = r.slice();
                return s = s[a.cache], f(a.props, function (e, n) {
                    var a = n.idx, o = r[a], l = s[a], u = d[n.type] || {};
                    null !== l && (null === o ? h[a] = l : (u.mod && (l - o > u.mod / 2 ? o += u.mod : o - l > u.mod / 2 && (o -= u.mod)), h[a] = i((l - o) * t + o, n)))
                }), this[n](h)
            }, blend: function (t) {
                if (1 === this._rgba[3]) return this;
                var i = this._rgba.slice(), s = i.pop(), n = l(t)._rgba;
                return l(e.map(i, function (e, t) {
                    return (1 - s) * n[t] + s * e
                }))
            }, toRgbaString: function () {
                var t = "rgba(", i = e.map(this._rgba, function (e, t) {
                    return null == e ? t > 2 ? 1 : 0 : e
                });
                return 1 === i[3] && (i.pop(), t = "rgb("), t + i.join() + ")"
            }, toHslaString: function () {
                var t = "hsla(", i = e.map(this.hsla(), function (e, t) {
                    return null == e && (e = t > 2 ? 1 : 0), t && 3 > t && (e = Math.round(100 * e) + "%"), e
                });
                return 1 === i[3] && (i.pop(), t = "hsl("), t + i.join() + ")"
            }, toHexString: function (t) {
                var i = this._rgba.slice(), s = i.pop();
                return t && i.push(~~(255 * s)), "#" + e.map(i, function (e) {
                    return e = (e || 0).toString(16), 1 === e.length ? "0" + e : e
                }).join("")
            }, toString: function () {
                return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
            }
        }), l.fn.parse.prototype = l.fn, u.hsla.to = function (e) {
            if (null == e[0] || null == e[1] || null == e[2]) return [null, null, null, e[3]];
            var t, i, s = e[0] / 255, n = e[1] / 255, a = e[2] / 255, o = e[3], r = Math.max(s, n, a),
                h = Math.min(s, n, a), l = r - h, u = r + h, d = .5 * u;
            return t = h === r ? 0 : s === r ? 60 * (n - a) / l + 360 : n === r ? 60 * (a - s) / l + 120 : 60 * (s - n) / l + 240, i = 0 === l ? 0 : .5 >= d ? l / u : l / (2 - u), [Math.round(t) % 360, i, d, null == o ? 1 : o]
        }, u.hsla.from = function (e) {
            if (null == e[0] || null == e[1] || null == e[2]) return [null, null, null, e[3]];
            var t = e[0] / 360, i = e[1], s = e[2], a = e[3], o = .5 >= s ? s * (1 + i) : s + i - s * i, r = 2 * s - o;
            return [Math.round(255 * n(r, o, t + 1 / 3)), Math.round(255 * n(r, o, t)), Math.round(255 * n(r, o, t - 1 / 3)), a]
        }, f(u, function (s, n) {
            var a = n.props, o = n.cache, h = n.to, u = n.from;
            l.fn[s] = function (s) {
                if (h && !this[o] && (this[o] = h(this._rgba)), s === t) return this[o].slice();
                var n, r = e.type(s), d = "array" === r || "object" === r ? s : arguments, c = this[o].slice();
                return f(a, function (e, t) {
                    var s = d["object" === r ? e : t.idx];
                    null == s && (s = c[t.idx]), c[t.idx] = i(s, t)
                }), u ? (n = l(u(c)), n[o] = c, n) : l(c)
            }, f(a, function (t, i) {
                l.fn[t] || (l.fn[t] = function (n) {
                    var a, o = e.type(n), h = "alpha" === t ? this._hsla ? "hsla" : "rgba" : s, l = this[h](),
                        u = l[i.idx];
                    return "undefined" === o ? u : ("function" === o && (n = n.call(this, u), o = e.type(n)), null == n && i.empty ? this : ("string" === o && (a = r.exec(n), a && (n = u + parseFloat(a[2]) * ("+" === a[1] ? 1 : -1))), l[i.idx] = n, this[h](l)))
                })
            })
        }), l.hook = function (t) {
            var i = t.split(" ");
            f(i, function (t, i) {
                e.cssHooks[i] = {
                    set: function (t, n) {
                        var a, o, r = "";
                        if ("transparent" !== n && ("string" !== e.type(n) || (a = s(n)))) {
                            if (n = l(a || n), !c.rgba && 1 !== n._rgba[3]) {
                                for (o = "backgroundColor" === i ? t.parentNode : t; ("" === r || "transparent" === r) && o && o.style;) try {
                                    r = e.css(o, "backgroundColor"), o = o.parentNode
                                } catch (h) {
                                }
                                n = n.blend(r && "transparent" !== r ? r : "_default")
                            }
                            n = n.toRgbaString()
                        }
                        try {
                            t.style[i] = n
                        } catch (h) {
                        }
                    }
                }, e.fx.step[i] = function (t) {
                    t.colorInit || (t.start = l(t.elem, i), t.end = l(t.end), t.colorInit = !0), e.cssHooks[i].set(t.elem, t.start.transition(t.end, t.pos))
                }
            })
        }, l.hook(o), e.cssHooks.borderColor = {
            expand: function (e) {
                var t = {};
                return f(["Top", "Right", "Bottom", "Left"], function (i, s) {
                    t["border" + s + "Color"] = e
                }), t
            }
        }, a = e.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [null, null, null, 0],
            _default: "#ffffff"
        }
    }(b), function () {
        function t(t) {
            var i, s,
                n = t.ownerDocument.defaultView ? t.ownerDocument.defaultView.getComputedStyle(t, null) : t.currentStyle,
                a = {};
            if (n && n.length && n[0] && n[n[0]]) for (s = n.length; s--;) i = n[s], "string" == typeof n[i] && (a[e.camelCase(i)] = n[i]); else for (i in n) "string" == typeof n[i] && (a[i] = n[i]);
            return a
        }

        function i(t, i) {
            var s, a, o = {};
            for (s in i) a = i[s], t[s] !== a && (n[s] || (e.fx.step[s] || !isNaN(parseFloat(a))) && (o[s] = a));
            return o
        }

        var s = ["add", "remove", "toggle"], n = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        e.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (t, i) {
            e.fx.step[i] = function (e) {
                ("none" !== e.end && !e.setAttr || 1 === e.pos && !e.setAttr) && (b.style(e.elem, i, e.end), e.setAttr = !0)
            }
        }), e.fn.addBack || (e.fn.addBack = function (e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }), e.effects.animateClass = function (n, a, o, r) {
            var h = e.speed(a, o, r);
            return this.queue(function () {
                var a, o = e(this), r = o.attr("class") || "", l = h.children ? o.find("*").addBack() : o;
                l = l.map(function () {
                    var i = e(this);
                    return {el: i, start: t(this)}
                }), a = function () {
                    e.each(s, function (e, t) {
                        n[t] && o[t + "Class"](n[t])
                    })
                }, a(), l = l.map(function () {
                    return this.end = t(this.el[0]), this.diff = i(this.start, this.end), this
                }), o.attr("class", r), l = l.map(function () {
                    var t = this, i = e.Deferred(), s = e.extend({}, h, {
                        queue: !1, complete: function () {
                            i.resolve(t)
                        }
                    });
                    return this.el.animate(this.diff, s), i.promise()
                }), e.when.apply(e, l.get()).done(function () {
                    a(), e.each(arguments, function () {
                        var t = this.el;
                        e.each(this.diff, function (e) {
                            t.css(e, "")
                        })
                    }), h.complete.call(o[0])
                })
            })
        }, e.fn.extend({
            addClass: function (t) {
                return function (i, s, n, a) {
                    return s ? e.effects.animateClass.call(this, {add: i}, s, n, a) : t.apply(this, arguments)
                }
            }(e.fn.addClass), removeClass: function (t) {
                return function (i, s, n, a) {
                    return arguments.length > 1 ? e.effects.animateClass.call(this, {remove: i}, s, n, a) : t.apply(this, arguments)
                }
            }(e.fn.removeClass), toggleClass: function (t) {
                return function (i, s, n, a, o) {
                    return "boolean" == typeof s || void 0 === s ? n ? e.effects.animateClass.call(this, s ? {add: i} : {remove: i}, n, a, o) : t.apply(this, arguments) : e.effects.animateClass.call(this, {toggle: i}, s, n, a)
                }
            }(e.fn.toggleClass), switchClass: function (t, i, s, n, a) {
                return e.effects.animateClass.call(this, {add: i, remove: t}, s, n, a)
            }
        })
    }(), function () {
        function t(t, i, s, n) {
            return e.isPlainObject(t) && (i = t, t = t.effect), t = {effect: t}, null == i && (i = {}), e.isFunction(i) && (n = i, s = null, i = {}), ("number" == typeof i || e.fx.speeds[i]) && (n = s, s = i, i = {}), e.isFunction(s) && (n = s, s = null), i && e.extend(t, i), s = s || i.duration, t.duration = e.fx.off ? 0 : "number" == typeof s ? s : s in e.fx.speeds ? e.fx.speeds[s] : e.fx.speeds._default, t.complete = n || i.complete, t
        }

        function i(t) {
            return !t || "number" == typeof t || e.fx.speeds[t] ? !0 : "string" != typeof t || e.effects.effect[t] ? e.isFunction(t) ? !0 : "object" != typeof t || t.effect ? !1 : !0 : !0
        }

        e.extend(e.effects, {
            version: "1.11.4", save: function (e, t) {
                for (var i = 0; t.length > i; i++) null !== t[i] && e.data(y + t[i], e[0].style[t[i]])
            }, restore: function (e, t) {
                var i, s;
                for (s = 0; t.length > s; s++) null !== t[s] && (i = e.data(y + t[s]), void 0 === i && (i = ""), e.css(t[s], i))
            }, setMode: function (e, t) {
                return "toggle" === t && (t = e.is(":hidden") ? "show" : "hide"), t
            }, getBaseline: function (e, t) {
                var i, s;
                switch (e[0]) {
                    case"top":
                        i = 0;
                        break;
                    case"middle":
                        i = .5;
                        break;
                    case"bottom":
                        i = 1;
                        break;
                    default:
                        i = e[0] / t.height
                }
                switch (e[1]) {
                    case"left":
                        s = 0;
                        break;
                    case"center":
                        s = .5;
                        break;
                    case"right":
                        s = 1;
                        break;
                    default:
                        s = e[1] / t.width
                }
                return {x: s, y: i}
            }, createWrapper: function (t) {
                if (t.parent().is(".ui-effects-wrapper")) return t.parent();
                var i = {width: t.outerWidth(!0), height: t.outerHeight(!0), "float": t.css("float")},
                    s = e("<div></div>").addClass("ui-effects-wrapper").css({
                        fontSize: "100%",
                        background: "transparent",
                        border: "none",
                        margin: 0,
                        padding: 0
                    }), n = {width: t.width(), height: t.height()}, a = document.activeElement;
                try {
                    a.id
                } catch (o) {
                    a = document.body
                }
                return t.wrap(s), (t[0] === a || e.contains(t[0], a)) && e(a).focus(), s = t.parent(), "static" === t.css("position") ? (s.css({position: "relative"}), t.css({position: "relative"})) : (e.extend(i, {
                    position: t.css("position"),
                    zIndex: t.css("z-index")
                }), e.each(["top", "left", "bottom", "right"], function (e, s) {
                    i[s] = t.css(s), isNaN(parseInt(i[s], 10)) && (i[s] = "auto")
                }), t.css({
                    position: "relative",
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                })), t.css(n), s.css(i).show()
            }, removeWrapper: function (t) {
                var i = document.activeElement;
                return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), (t[0] === i || e.contains(t[0], i)) && e(i).focus()), t
            }, setTransition: function (t, i, s, n) {
                return n = n || {}, e.each(i, function (e, i) {
                    var a = t.cssUnit(i);
                    a[0] > 0 && (n[i] = a[0] * s + a[1])
                }), n
            }
        }), e.fn.extend({
            effect: function () {
                function i(t) {
                    function i() {
                        e.isFunction(a) && a.call(n[0]), e.isFunction(t) && t()
                    }

                    var n = e(this), a = s.complete, r = s.mode;
                    (n.is(":hidden") ? "hide" === r : "show" === r) ? (n[r](), i()) : o.call(n[0], s, i)
                }

                var s = t.apply(this, arguments), n = s.mode, a = s.queue, o = e.effects.effect[s.effect];
                return e.fx.off || !o ? n ? this[n](s.duration, s.complete) : this.each(function () {
                    s.complete && s.complete.call(this)
                }) : a === !1 ? this.each(i) : this.queue(a || "fx", i)
            }, show: function (e) {
                return function (s) {
                    if (i(s)) return e.apply(this, arguments);
                    var n = t.apply(this, arguments);
                    return n.mode = "show", this.effect.call(this, n)
                }
            }(e.fn.show), hide: function (e) {
                return function (s) {
                    if (i(s)) return e.apply(this, arguments);
                    var n = t.apply(this, arguments);
                    return n.mode = "hide", this.effect.call(this, n)
                }
            }(e.fn.hide), toggle: function (e) {
                return function (s) {
                    if (i(s) || "boolean" == typeof s) return e.apply(this, arguments);
                    var n = t.apply(this, arguments);
                    return n.mode = "toggle", this.effect.call(this, n)
                }
            }(e.fn.toggle), cssUnit: function (t) {
                var i = this.css(t), s = [];
                return e.each(["em", "px", "%", "pt"], function (e, t) {
                    i.indexOf(t) > 0 && (s = [parseFloat(i), t])
                }), s
            }
        })
    }(), function () {
        var t = {};
        e.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (e, i) {
            t[i] = function (t) {
                return Math.pow(t, e + 2)
            }
        }), e.extend(t, {
            Sine: function (e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }, Circ: function (e) {
                return 1 - Math.sqrt(1 - e * e)
            }, Elastic: function (e) {
                return 0 === e || 1 === e ? e : -Math.pow(2, 8 * (e - 1)) * Math.sin((80 * (e - 1) - 7.5) * Math.PI / 15)
            }, Back: function (e) {
                return e * e * (3 * e - 2)
            }, Bounce: function (e) {
                for (var t, i = 4; ((t = Math.pow(2, --i)) - 1) / 11 > e;) ;
                return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * t - 2) / 22 - e, 2)
            }
        }), e.each(t, function (t, i) {
            e.easing["easeIn" + t] = i, e.easing["easeOut" + t] = function (e) {
                return 1 - i(1 - e)
            }, e.easing["easeInOut" + t] = function (e) {
                return .5 > e ? i(2 * e) / 2 : 1 - i(-2 * e + 2) / 2
            }
        })
    }(), e.effects, e.effects.effect.blind = function (t, i) {
        var s, n, a, o = e(this), r = /up|down|vertical/, h = /up|left|vertical|horizontal/,
            l = ["position", "top", "bottom", "left", "right", "height", "width"],
            u = e.effects.setMode(o, t.mode || "hide"), d = t.direction || "up", c = r.test(d),
            p = c ? "height" : "width", f = c ? "top" : "left", m = h.test(d), g = {}, v = "show" === u;
        o.parent().is(".ui-effects-wrapper") ? e.effects.save(o.parent(), l) : e.effects.save(o, l), o.show(), s = e.effects.createWrapper(o).css({overflow: "hidden"}), n = s[p](), a = parseFloat(s.css(f)) || 0, g[p] = v ? n : 0, m || (o.css(c ? "bottom" : "right", 0).css(c ? "top" : "left", "auto").css({position: "absolute"}), g[f] = v ? a : n + a), v && (s.css(p, 0), m || s.css(f, a + n)), s.animate(g, {
            duration: t.duration,
            easing: t.easing,
            queue: !1,
            complete: function () {
                "hide" === u && o.hide(), e.effects.restore(o, l), e.effects.removeWrapper(o), i()
            }
        })
    }, e.effects.effect.bounce = function (t, i) {
        var s, n, a, o = e(this), r = ["position", "top", "bottom", "left", "right", "height", "width"],
            h = e.effects.setMode(o, t.mode || "effect"), l = "hide" === h, u = "show" === h, d = t.direction || "up",
            c = t.distance, p = t.times || 5, f = 2 * p + (u || l ? 1 : 0), m = t.duration / f, g = t.easing,
            v = "up" === d || "down" === d ? "top" : "left", y = "up" === d || "left" === d, b = o.queue(),
            _ = b.length;
        for ((u || l) && r.push("opacity"), e.effects.save(o, r), o.show(), e.effects.createWrapper(o), c || (c = o["top" === v ? "outerHeight" : "outerWidth"]() / 3), u && (a = {opacity: 1}, a[v] = 0, o.css("opacity", 0).css(v, y ? 2 * -c : 2 * c).animate(a, m, g)), l && (c /= Math.pow(2, p - 1)), a = {}, a[v] = 0, s = 0; p > s; s++) n = {}, n[v] = (y ? "-=" : "+=") + c, o.animate(n, m, g).animate(a, m, g), c = l ? 2 * c : c / 2;
        l && (n = {opacity: 0}, n[v] = (y ? "-=" : "+=") + c, o.animate(n, m, g)), o.queue(function () {
            l && o.hide(), e.effects.restore(o, r), e.effects.removeWrapper(o), i()
        }), _ > 1 && b.splice.apply(b, [1, 0].concat(b.splice(_, f + 1))), o.dequeue()
    }, e.effects.effect.clip = function (t, i) {
        var s, n, a, o = e(this), r = ["position", "top", "bottom", "left", "right", "height", "width"],
            h = e.effects.setMode(o, t.mode || "hide"), l = "show" === h, u = t.direction || "vertical",
            d = "vertical" === u, c = d ? "height" : "width", p = d ? "top" : "left", f = {};
        e.effects.save(o, r), o.show(), s = e.effects.createWrapper(o).css({overflow: "hidden"}), n = "IMG" === o[0].tagName ? s : o, a = n[c](), l && (n.css(c, 0), n.css(p, a / 2)), f[c] = l ? a : 0, f[p] = l ? 0 : a / 2, n.animate(f, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                l || o.hide(), e.effects.restore(o, r), e.effects.removeWrapper(o), i()
            }
        })
    }, e.effects.effect.drop = function (t, i) {
        var s, n = e(this), a = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
            o = e.effects.setMode(n, t.mode || "hide"), r = "show" === o, h = t.direction || "left",
            l = "up" === h || "down" === h ? "top" : "left", u = "up" === h || "left" === h ? "pos" : "neg",
            d = {opacity: r ? 1 : 0};
        e.effects.save(n, a), n.show(), e.effects.createWrapper(n), s = t.distance || n["top" === l ? "outerHeight" : "outerWidth"](!0) / 2, r && n.css("opacity", 0).css(l, "pos" === u ? -s : s), d[l] = (r ? "pos" === u ? "+=" : "-=" : "pos" === u ? "-=" : "+=") + s, n.animate(d, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                "hide" === o && n.hide(), e.effects.restore(n, a), e.effects.removeWrapper(n), i()
            }
        })
    }, e.effects.effect.explode = function (t, i) {
        function s() {
            b.push(this), b.length === d * c && n()
        }

        function n() {
            p.css({visibility: "visible"}), e(b).remove(), m || p.hide(), i()
        }

        var a, o, r, h, l, u, d = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3, c = d, p = e(this),
            f = e.effects.setMode(p, t.mode || "hide"), m = "show" === f,
            g = p.show().css("visibility", "hidden").offset(), v = Math.ceil(p.outerWidth() / c),
            y = Math.ceil(p.outerHeight() / d), b = [];
        for (a = 0; d > a; a++) for (h = g.top + a * y, u = a - (d - 1) / 2, o = 0; c > o; o++) r = g.left + o * v, l = o - (c - 1) / 2, p.clone().appendTo("body").wrap("<div></div>").css({
            position: "absolute",
            visibility: "visible",
            left: -o * v,
            top: -a * y
        }).parent().addClass("ui-effects-explode").css({
            position: "absolute",
            overflow: "hidden",
            width: v,
            height: y,
            left: r + (m ? l * v : 0),
            top: h + (m ? u * y : 0),
            opacity: m ? 0 : 1
        }).animate({
            left: r + (m ? 0 : l * v),
            top: h + (m ? 0 : u * y),
            opacity: m ? 1 : 0
        }, t.duration || 500, t.easing, s)
    }, e.effects.effect.fade = function (t, i) {
        var s = e(this), n = e.effects.setMode(s, t.mode || "toggle");
        s.animate({opacity: n}, {queue: !1, duration: t.duration, easing: t.easing, complete: i})
    }, e.effects.effect.fold = function (t, i) {
        var s, n, a = e(this), o = ["position", "top", "bottom", "left", "right", "height", "width"],
            r = e.effects.setMode(a, t.mode || "hide"), h = "show" === r, l = "hide" === r, u = t.size || 15,
            d = /([0-9]+)%/.exec(u), c = !!t.horizFirst, p = h !== c, f = p ? ["width", "height"] : ["height", "width"],
            m = t.duration / 2, g = {}, v = {};
        e.effects.save(a, o), a.show(), s = e.effects.createWrapper(a).css({overflow: "hidden"}), n = p ? [s.width(), s.height()] : [s.height(), s.width()], d && (u = parseInt(d[1], 10) / 100 * n[l ? 0 : 1]), h && s.css(c ? {
            height: 0,
            width: u
        } : {
            height: u,
            width: 0
        }), g[f[0]] = h ? n[0] : u, v[f[1]] = h ? n[1] : 0, s.animate(g, m, t.easing).animate(v, m, t.easing, function () {
            l && a.hide(), e.effects.restore(a, o), e.effects.removeWrapper(a), i()
        })
    }, e.effects.effect.highlight = function (t, i) {
        var s = e(this), n = ["backgroundImage", "backgroundColor", "opacity"],
            a = e.effects.setMode(s, t.mode || "show"), o = {backgroundColor: s.css("backgroundColor")};
        "hide" === a && (o.opacity = 0), e.effects.save(s, n), s.show().css({
            backgroundImage: "none",
            backgroundColor: t.color || "#ffff99"
        }).animate(o, {
            queue: !1, duration: t.duration, easing: t.easing, complete: function () {
                "hide" === a && s.hide(), e.effects.restore(s, n), i()
            }
        })
    }, e.effects.effect.size = function (t, i) {
        var s, n, a, o = e(this),
            r = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
            h = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
            l = ["width", "height", "overflow"], u = ["fontSize"],
            d = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            c = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
            p = e.effects.setMode(o, t.mode || "effect"), f = t.restore || "effect" !== p, m = t.scale || "both",
            g = t.origin || ["middle", "center"], v = o.css("position"), y = f ? r : h,
            b = {height: 0, width: 0, outerHeight: 0, outerWidth: 0};
        "show" === p && o.show(), s = {
            height: o.height(),
            width: o.width(),
            outerHeight: o.outerHeight(),
            outerWidth: o.outerWidth()
        }, "toggle" === t.mode && "show" === p ? (o.from = t.to || b, o.to = t.from || s) : (o.from = t.from || ("show" === p ? b : s), o.to = t.to || ("hide" === p ? b : s)), a = {
            from: {
                y: o.from.height / s.height,
                x: o.from.width / s.width
            }, to: {y: o.to.height / s.height, x: o.to.width / s.width}
        }, ("box" === m || "both" === m) && (a.from.y !== a.to.y && (y = y.concat(d), o.from = e.effects.setTransition(o, d, a.from.y, o.from), o.to = e.effects.setTransition(o, d, a.to.y, o.to)), a.from.x !== a.to.x && (y = y.concat(c), o.from = e.effects.setTransition(o, c, a.from.x, o.from), o.to = e.effects.setTransition(o, c, a.to.x, o.to))), ("content" === m || "both" === m) && a.from.y !== a.to.y && (y = y.concat(u).concat(l), o.from = e.effects.setTransition(o, u, a.from.y, o.from), o.to = e.effects.setTransition(o, u, a.to.y, o.to)), e.effects.save(o, y), o.show(), e.effects.createWrapper(o), o.css("overflow", "hidden").css(o.from), g && (n = e.effects.getBaseline(g, s), o.from.top = (s.outerHeight - o.outerHeight()) * n.y, o.from.left = (s.outerWidth - o.outerWidth()) * n.x, o.to.top = (s.outerHeight - o.to.outerHeight) * n.y, o.to.left = (s.outerWidth - o.to.outerWidth) * n.x), o.css(o.from), ("content" === m || "both" === m) && (d = d.concat(["marginTop", "marginBottom"]).concat(u), c = c.concat(["marginLeft", "marginRight"]), l = r.concat(d).concat(c), o.find("*[width]").each(function () {
            var i = e(this),
                s = {height: i.height(), width: i.width(), outerHeight: i.outerHeight(), outerWidth: i.outerWidth()};
            f && e.effects.save(i, l), i.from = {
                height: s.height * a.from.y,
                width: s.width * a.from.x,
                outerHeight: s.outerHeight * a.from.y,
                outerWidth: s.outerWidth * a.from.x
            }, i.to = {
                height: s.height * a.to.y,
                width: s.width * a.to.x,
                outerHeight: s.height * a.to.y,
                outerWidth: s.width * a.to.x
            }, a.from.y !== a.to.y && (i.from = e.effects.setTransition(i, d, a.from.y, i.from), i.to = e.effects.setTransition(i, d, a.to.y, i.to)), a.from.x !== a.to.x && (i.from = e.effects.setTransition(i, c, a.from.x, i.from), i.to = e.effects.setTransition(i, c, a.to.x, i.to)), i.css(i.from), i.animate(i.to, t.duration, t.easing, function () {
                f && e.effects.restore(i, l)
            })
        })), o.animate(o.to, {
            queue: !1, duration: t.duration, easing: t.easing, complete: function () {
                0 === o.to.opacity && o.css("opacity", o.from.opacity), "hide" === p && o.hide(), e.effects.restore(o, y), f || ("static" === v ? o.css({
                    position: "relative",
                    top: o.to.top,
                    left: o.to.left
                }) : e.each(["top", "left"], function (e, t) {
                    o.css(t, function (t, i) {
                        var s = parseInt(i, 10), n = e ? o.to.left : o.to.top;
                        return "auto" === i ? n + "px" : s + n + "px"
                    })
                })), e.effects.removeWrapper(o), i()
            }
        })
    }, e.effects.effect.scale = function (t, i) {
        var s = e(this), n = e.extend(!0, {}, t), a = e.effects.setMode(s, t.mode || "effect"),
            o = parseInt(t.percent, 10) || (0 === parseInt(t.percent, 10) ? 0 : "hide" === a ? 0 : 100),
            r = t.direction || "both", h = t.origin,
            l = {height: s.height(), width: s.width(), outerHeight: s.outerHeight(), outerWidth: s.outerWidth()},
            u = {y: "horizontal" !== r ? o / 100 : 1, x: "vertical" !== r ? o / 100 : 1};
        n.effect = "size", n.queue = !1, n.complete = i, "effect" !== a && (n.origin = h || ["middle", "center"], n.restore = !0), n.from = t.from || ("show" === a ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : l), n.to = {
            height: l.height * u.y,
            width: l.width * u.x,
            outerHeight: l.outerHeight * u.y,
            outerWidth: l.outerWidth * u.x
        }, n.fade && ("show" === a && (n.from.opacity = 0, n.to.opacity = 1), "hide" === a && (n.from.opacity = 1, n.to.opacity = 0)), s.effect(n)
    }, e.effects.effect.puff = function (t, i) {
        var s = e(this), n = e.effects.setMode(s, t.mode || "hide"), a = "hide" === n,
            o = parseInt(t.percent, 10) || 150, r = o / 100,
            h = {height: s.height(), width: s.width(), outerHeight: s.outerHeight(), outerWidth: s.outerWidth()};
        e.extend(t, {
            effect: "scale",
            queue: !1,
            fade: !0,
            mode: n,
            complete: i,
            percent: a ? o : 100,
            from: a ? h : {
                height: h.height * r,
                width: h.width * r,
                outerHeight: h.outerHeight * r,
                outerWidth: h.outerWidth * r
            }
        }), s.effect(t)
    }, e.effects.effect.pulsate = function (t, i) {
        var s, n = e(this), a = e.effects.setMode(n, t.mode || "show"), o = "show" === a, r = "hide" === a,
            h = o || "hide" === a, l = 2 * (t.times || 5) + (h ? 1 : 0), u = t.duration / l, d = 0, c = n.queue(),
            p = c.length;
        for ((o || !n.is(":visible")) && (n.css("opacity", 0).show(), d = 1), s = 1; l > s; s++) n.animate({opacity: d}, u, t.easing), d = 1 - d;
        n.animate({opacity: d}, u, t.easing), n.queue(function () {
            r && n.hide(), i()
        }), p > 1 && c.splice.apply(c, [1, 0].concat(c.splice(p, l + 1))), n.dequeue()
    }, e.effects.effect.shake = function (t, i) {
        var s, n = e(this), a = ["position", "top", "bottom", "left", "right", "height", "width"],
            o = e.effects.setMode(n, t.mode || "effect"), r = t.direction || "left", h = t.distance || 20,
            l = t.times || 3, u = 2 * l + 1, d = Math.round(t.duration / u),
            c = "up" === r || "down" === r ? "top" : "left", p = "up" === r || "left" === r, f = {}, m = {}, g = {},
            v = n.queue(), y = v.length;
        for (e.effects.save(n, a), n.show(), e.effects.createWrapper(n), f[c] = (p ? "-=" : "+=") + h, m[c] = (p ? "+=" : "-=") + 2 * h, g[c] = (p ? "-=" : "+=") + 2 * h, n.animate(f, d, t.easing), s = 1; l > s; s++) n.animate(m, d, t.easing).animate(g, d, t.easing);
        n.animate(m, d, t.easing).animate(f, d / 2, t.easing).queue(function () {
            "hide" === o && n.hide(), e.effects.restore(n, a), e.effects.removeWrapper(n), i()
        }), y > 1 && v.splice.apply(v, [1, 0].concat(v.splice(y, u + 1))), n.dequeue()
    }, e.effects.effect.slide = function (t, i) {
        var s, n = e(this), a = ["position", "top", "bottom", "left", "right", "width", "height"],
            o = e.effects.setMode(n, t.mode || "show"), r = "show" === o, h = t.direction || "left",
            l = "up" === h || "down" === h ? "top" : "left", u = "up" === h || "left" === h, d = {};
        e.effects.save(n, a), n.show(), s = t.distance || n["top" === l ? "outerHeight" : "outerWidth"](!0), e.effects.createWrapper(n).css({overflow: "hidden"}), r && n.css(l, u ? isNaN(s) ? "-" + s : -s : s), d[l] = (r ? u ? "+=" : "-=" : u ? "-=" : "+=") + s, n.animate(d, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete: function () {
                "hide" === o && n.hide(), e.effects.restore(n, a), e.effects.removeWrapper(n), i()
            }
        })
    }, e.effects.effect.transfer = function (t, i) {
        var s = e(this), n = e(t.to), a = "fixed" === n.css("position"), o = e("body"), r = a ? o.scrollTop() : 0,
            h = a ? o.scrollLeft() : 0, l = n.offset(),
            u = {top: l.top - r, left: l.left - h, height: n.innerHeight(), width: n.innerWidth()}, d = s.offset(),
            c = e("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(t.className).css({
                top: d.top - r,
                left: d.left - h,
                height: s.innerHeight(),
                width: s.innerWidth(),
                position: a ? "fixed" : "absolute"
            }).animate(u, t.duration, t.easing, function () {
                c.remove(), i()
            })
    }, e.widget("ui.progressbar", {
        version: "1.11.4",
        options: {max: 100, value: 0, change: null, complete: null},
        min: 0,
        _create: function () {
            this.oldValue = this.options.value = this._constrainedValue(), this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                role: "progressbar",
                "aria-valuemin": this.min
            }), this.valueDiv = e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element), this._refreshValue()
        },
        _destroy: function () {
            this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.valueDiv.remove()
        },
        value: function (e) {
            return void 0 === e ? this.options.value : (this.options.value = this._constrainedValue(e), this._refreshValue(), void 0)
        },
        _constrainedValue: function (e) {
            return void 0 === e && (e = this.options.value), this.indeterminate = e === !1, "number" != typeof e && (e = 0), this.indeterminate ? !1 : Math.min(this.options.max, Math.max(this.min, e))
        },
        _setOptions: function (e) {
            var t = e.value;
            delete e.value, this._super(e), this.options.value = this._constrainedValue(t), this._refreshValue()
        },
        _setOption: function (e, t) {
            "max" === e && (t = Math.max(this.min, t)), "disabled" === e && this.element.toggleClass("ui-state-disabled", !!t).attr("aria-disabled", t), this._super(e, t)
        },
        _percentage: function () {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min)
        },
        _refreshValue: function () {
            var t = this.options.value, i = this._percentage();
            this.valueDiv.toggle(this.indeterminate || t > this.min).toggleClass("ui-corner-right", t === this.options.max).width(i.toFixed(0) + "%"), this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = e("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))) : (this.element.attr({
                "aria-valuemax": this.options.max,
                "aria-valuenow": t
            }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== t && (this.oldValue = t, this._trigger("change")), t === this.options.max && this._trigger("complete")
        }
    }), e.widget("ui.selectable", e.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: !0,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function () {
            var t, i = this;
            this.element.addClass("ui-selectable"), this.dragged = !1, this.refresh = function () {
                t = e(i.options.filter, i.element[0]), t.addClass("ui-selectee"), t.each(function () {
                    var t = e(this), i = t.offset();
                    e.data(this, "selectable-item", {
                        element: this,
                        $element: t,
                        left: i.left,
                        top: i.top,
                        right: i.left + t.outerWidth(),
                        bottom: i.top + t.outerHeight(),
                        startselected: !1,
                        selected: t.hasClass("ui-selected"),
                        selecting: t.hasClass("ui-selecting"),
                        unselecting: t.hasClass("ui-unselecting")
                    })
                })
            }, this.refresh(), this.selectees = t.addClass("ui-selectee"), this._mouseInit(), this.helper = e("<div class='ui-selectable-helper'></div>")
        },
        _destroy: function () {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"), this._mouseDestroy()
        },
        _mouseStart: function (t) {
            var i = this, s = this.options;
            this.opos = [t.pageX, t.pageY], this.options.disabled || (this.selectees = e(s.filter, this.element[0]), this._trigger("start", t), e(s.appendTo).append(this.helper), this.helper.css({
                left: t.pageX,
                top: t.pageY,
                width: 0,
                height: 0
            }), s.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
                var s = e.data(this, "selectable-item");
                s.startselected = !0, t.metaKey || t.ctrlKey || (s.$element.removeClass("ui-selected"), s.selected = !1, s.$element.addClass("ui-unselecting"), s.unselecting = !0, i._trigger("unselecting", t, {unselecting: s.element}))
            }), e(t.target).parents().addBack().each(function () {
                var s, n = e.data(this, "selectable-item");
                return n ? (s = !t.metaKey && !t.ctrlKey || !n.$element.hasClass("ui-selected"), n.$element.removeClass(s ? "ui-unselecting" : "ui-selected").addClass(s ? "ui-selecting" : "ui-unselecting"), n.unselecting = !s, n.selecting = s, n.selected = s, s ? i._trigger("selecting", t, {selecting: n.element}) : i._trigger("unselecting", t, {unselecting: n.element}), !1) : void 0
            }))
        },
        _mouseDrag: function (t) {
            if (this.dragged = !0, !this.options.disabled) {
                var i, s = this, n = this.options, a = this.opos[0], o = this.opos[1], r = t.pageX, h = t.pageY;
                return a > r && (i = r, r = a, a = i), o > h && (i = h, h = o, o = i), this.helper.css({
                    left: a,
                    top: o,
                    width: r - a,
                    height: h - o
                }), this.selectees.each(function () {
                    var i = e.data(this, "selectable-item"), l = !1;
                    i && i.element !== s.element[0] && ("touch" === n.tolerance ? l = !(i.left > r || a > i.right || i.top > h || o > i.bottom) : "fit" === n.tolerance && (l = i.left > a && r > i.right && i.top > o && h > i.bottom), l ? (i.selected && (i.$element.removeClass("ui-selected"), i.selected = !1), i.unselecting && (i.$element.removeClass("ui-unselecting"), i.unselecting = !1), i.selecting || (i.$element.addClass("ui-selecting"), i.selecting = !0, s._trigger("selecting", t, {selecting: i.element}))) : (i.selecting && ((t.metaKey || t.ctrlKey) && i.startselected ? (i.$element.removeClass("ui-selecting"), i.selecting = !1, i.$element.addClass("ui-selected"), i.selected = !0) : (i.$element.removeClass("ui-selecting"), i.selecting = !1, i.startselected && (i.$element.addClass("ui-unselecting"), i.unselecting = !0), s._trigger("unselecting", t, {unselecting: i.element}))), i.selected && (t.metaKey || t.ctrlKey || i.startselected || (i.$element.removeClass("ui-selected"), i.selected = !1, i.$element.addClass("ui-unselecting"), i.unselecting = !0, s._trigger("unselecting", t, {unselecting: i.element})))))
                }), !1
            }
        },
        _mouseStop: function (t) {
            var i = this;
            return this.dragged = !1, e(".ui-unselecting", this.element[0]).each(function () {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-unselecting"), s.unselecting = !1, s.startselected = !1, i._trigger("unselected", t, {unselected: s.element})
            }), e(".ui-selecting", this.element[0]).each(function () {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-selecting").addClass("ui-selected"), s.selecting = !1, s.selected = !0, s.startselected = !0, i._trigger("selected", t, {selected: s.element})
            }), this._trigger("stop", t), this.helper.remove(), !1
        }
    }), e.widget("ui.selectmenu", {
        version: "1.11.4",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            disabled: null,
            icons: {button: "ui-icon-triangle-1-s"},
            position: {my: "left top", at: "left bottom", collision: "none"},
            width: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
        _create: function () {
            var e = this.element.uniqueId().attr("id");
            this.ids = {
                element: e,
                button: e + "-button",
                menu: e + "-menu"
            }, this._drawButton(), this._drawMenu(), this.options.disabled && this.disable()
        },
        _drawButton: function () {
            var t = this;
            this.label = e("label[for='" + this.ids.element + "']").attr("for", this.ids.button), this._on(this.label, {
                click: function (e) {
                    this.button.focus(), e.preventDefault()
                }
            }), this.element.hide(), this.button = e("<span>", {
                "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true"
            }).insertAfter(this.element), e("<span>", {"class": "ui-icon " + this.options.icons.button}).prependTo(this.button), this.buttonText = e("<span>", {"class": "ui-selectmenu-text"}).appendTo(this.button), this._setText(this.buttonText, this.element.find("option:selected").text()), this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function () {
                t.menuItems || t._refreshMenu()
            }), this._hoverable(this.button), this._focusable(this.button)
        },
        _drawMenu: function () {
            var t = this;
            this.menu = e("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            }), this.menuWrap = e("<div>", {"class": "ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
                role: "listbox",
                select: function (e, i) {
                    e.preventDefault(), t._setSelection(), t._select(i.item.data("ui-selectmenu-item"), e)
                },
                focus: function (e, i) {
                    var s = i.item.data("ui-selectmenu-item");
                    null != t.focusIndex && s.index !== t.focusIndex && (t._trigger("focus", e, {item: s}), t.isOpen || t._select(s, e)), t.focusIndex = s.index, t.button.attr("aria-activedescendant", t.menuItems.eq(s.index).attr("id"))
                }
            }).menu("instance"), this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function () {
                return !1
            }, this.menuInstance._isDivider = function () {
                return !1
            }
        },
        refresh: function () {
            this._refreshMenu(), this._setText(this.buttonText, this._getSelectedItem().text()), this.options.width || this._resizeButton()
        },
        _refreshMenu: function () {
            this.menu.empty();
            var e, t = this.element.find("option");
            t.length && (this._parseOptions(t), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup"), e = this._getSelectedItem(), this.menuInstance.focus(null, e), this._setAria(e.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")))
        },
        open: function (e) {
            this.options.disabled || (this.menuItems ? (this.menu.find(".ui-state-focus").removeClass("ui-state-focus"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", e))
        },
        _position: function () {
            this.menuWrap.position(e.extend({of: this.button}, this.options.position))
        },
        close: function (e) {
            this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", e))
        },
        widget: function () {
            return this.button
        },
        menuWidget: function () {
            return this.menu
        },
        _renderMenu: function (t, i) {
            var s = this, n = "";
            e.each(i, function (i, a) {
                a.optgroup !== n && (e("<li>", {
                    "class": "ui-selectmenu-optgroup ui-menu-divider" + (a.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""),
                    text: a.optgroup
                }).appendTo(t), n = a.optgroup), s._renderItemData(t, a)
            })
        },
        _renderItemData: function (e, t) {
            return this._renderItem(e, t).data("ui-selectmenu-item", t)
        },
        _renderItem: function (t, i) {
            var s = e("<li>");
            return i.disabled && s.addClass("ui-state-disabled"), this._setText(s, i.label), s.appendTo(t)
        },
        _setText: function (e, t) {
            t ? e.text(t) : e.html("&#160;")
        },
        _move: function (e, t) {
            var i, s, n = ".ui-menu-item";
            this.isOpen ? i = this.menuItems.eq(this.focusIndex) : (i = this.menuItems.eq(this.element[0].selectedIndex), n += ":not(.ui-state-disabled)"), s = "first" === e || "last" === e ? i["first" === e ? "prevAll" : "nextAll"](n).eq(-1) : i[e + "All"](n).eq(0), s.length && this.menuInstance.focus(t, s)
        },
        _getSelectedItem: function () {
            return this.menuItems.eq(this.element[0].selectedIndex)
        },
        _toggle: function (e) {
            this[this.isOpen ? "close" : "open"](e)
        },
        _setSelection: function () {
            var e;
            this.range && (window.getSelection ? (e = window.getSelection(), e.removeAllRanges(), e.addRange(this.range)) : this.range.select(), this.button.focus())
        },
        _documentClick: {
            mousedown: function (t) {
                this.isOpen && (e(t.target).closest(".ui-selectmenu-menu, #" + this.ids.button).length || this.close(t))
            }
        },
        _buttonEvents: {
            mousedown: function () {
                var e;
                window.getSelection ? (e = window.getSelection(), e.rangeCount && (this.range = e.getRangeAt(0))) : this.range = document.selection.createRange()
            }, click: function (e) {
                this._setSelection(), this._toggle(e)
            }, keydown: function (t) {
                var i = !0;
                switch (t.keyCode) {
                    case e.ui.keyCode.TAB:
                    case e.ui.keyCode.ESCAPE:
                        this.close(t), i = !1;
                        break;
                    case e.ui.keyCode.ENTER:
                        this.isOpen && this._selectFocusedItem(t);
                        break;
                    case e.ui.keyCode.UP:
                        t.altKey ? this._toggle(t) : this._move("prev", t);
                        break;
                    case e.ui.keyCode.DOWN:
                        t.altKey ? this._toggle(t) : this._move("next", t);
                        break;
                    case e.ui.keyCode.SPACE:
                        this.isOpen ? this._selectFocusedItem(t) : this._toggle(t);
                        break;
                    case e.ui.keyCode.LEFT:
                        this._move("prev", t);
                        break;
                    case e.ui.keyCode.RIGHT:
                        this._move("next", t);
                        break;
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.PAGE_UP:
                        this._move("first", t);
                        break;
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_DOWN:
                        this._move("last", t);
                        break;
                    default:
                        this.menu.trigger(t), i = !1
                }
                i && t.preventDefault()
            }
        },
        _selectFocusedItem: function (e) {
            var t = this.menuItems.eq(this.focusIndex);
            t.hasClass("ui-state-disabled") || this._select(t.data("ui-selectmenu-item"), e)
        },
        _select: function (e, t) {
            var i = this.element[0].selectedIndex;
            this.element[0].selectedIndex = e.index, this._setText(this.buttonText, e.label), this._setAria(e), this._trigger("select", t, {item: e}), e.index !== i && this._trigger("change", t, {item: e}), this.close(t)
        },
        _setAria: function (e) {
            var t = this.menuItems.eq(e.index).attr("id");
            this.button.attr({
                "aria-labelledby": t,
                "aria-activedescendant": t
            }), this.menu.attr("aria-activedescendant", t)
        },
        _setOption: function (e, t) {
            "icons" === e && this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(t.button), this._super(e, t), "appendTo" === e && this.menuWrap.appendTo(this._appendTo()), "disabled" === e && (this.menuInstance.option("disabled", t), this.button.toggleClass("ui-state-disabled", t).attr("aria-disabled", t), this.element.prop("disabled", t), t ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0)), "width" === e && this._resizeButton()
        },
        _appendTo: function () {
            var t = this.options.appendTo;
            return t && (t = t.jquery || t.nodeType ? e(t) : this.document.find(t).eq(0)), t && t[0] || (t = this.element.closest(".ui-front")), t.length || (t = this.document[0].body), t
        },
        _toggleAttr: function () {
            this.button.toggleClass("ui-corner-top", this.isOpen).toggleClass("ui-corner-all", !this.isOpen).attr("aria-expanded", this.isOpen), this.menuWrap.toggleClass("ui-selectmenu-open", this.isOpen), this.menu.attr("aria-hidden", !this.isOpen)
        },
        _resizeButton: function () {
            var e = this.options.width;
            e || (e = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(e)
        },
        _resizeMenu: function () {
            this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1))
        },
        _getCreateOptions: function () {
            return {disabled: this.element.prop("disabled")}
        },
        _parseOptions: function (t) {
            var i = [];
            t.each(function (t, s) {
                var n = e(s), a = n.parent("optgroup");
                i.push({
                    element: n,
                    index: t,
                    value: n.val(),
                    label: n.text(),
                    optgroup: a.attr("label") || "",
                    disabled: a.prop("disabled") || n.prop("disabled")
                })
            }), this.items = i
        },
        _destroy: function () {
            this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.label.attr("for", this.ids.element)
        }
    }), e.widget("ui.slider", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create: function () {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all"), this._refresh(), this._setOption("disabled", this.options.disabled), this._animateOff = !1
        },
        _refresh: function () {
            this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
        },
        _createHandles: function () {
            var t, i, s = this.options,
                n = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                a = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>", o = [];
            for (i = s.values && s.values.length || 1, n.length > i && (n.slice(i).remove(), n = n.slice(0, i)), t = n.length; i > t; t++) o.push(a);
            this.handles = n.add(e(o.join("")).appendTo(this.element)), this.handle = this.handles.eq(0), this.handles.each(function (t) {
                e(this).data("ui-slider-handle-index", t)
            })
        },
        _createRange: function () {
            var t = this.options, i = "";
            t.range ? (t.range === !0 && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : e.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                left: "",
                bottom: ""
            }) : (this.range = e("<div></div>").appendTo(this.element), i = "ui-slider-range ui-widget-header ui-corner-all"), this.range.addClass(i + ("min" === t.range || "max" === t.range ? " ui-slider-range-" + t.range : ""))) : (this.range && this.range.remove(), this.range = null)
        },
        _setupEvents: function () {
            this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
        },
        _destroy: function () {
            this.handles.remove(), this.range && this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"), this._mouseDestroy()
        },
        _mouseCapture: function (t) {
            var i, s, n, a, o, r, h, l, u = this, d = this.options;
            return d.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), i = {
                x: t.pageX,
                y: t.pageY
            }, s = this._normValueFromMouse(i), n = this._valueMax() - this._valueMin() + 1, this.handles.each(function (t) {
                var i = Math.abs(s - u.values(t));
                (n > i || n === i && (t === u._lastChangedValue || u.values(t) === d.min)) && (n = i, a = e(this), o = t)
            }), r = this._start(t, o), r === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = o, a.addClass("ui-state-active").focus(), h = a.offset(), l = !e(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = l ? {
                left: 0,
                top: 0
            } : {
                left: t.pageX - h.left - a.width() / 2,
                top: t.pageY - h.top - a.height() / 2 - (parseInt(a.css("borderTopWidth"), 10) || 0) - (parseInt(a.css("borderBottomWidth"), 10) || 0) + (parseInt(a.css("marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, s), this._animateOff = !0, !0))
        },
        _mouseStart: function () {
            return !0
        },
        _mouseDrag: function (e) {
            var t = {x: e.pageX, y: e.pageY}, i = this._normValueFromMouse(t);
            return this._slide(e, this._handleIndex, i), !1
        },
        _mouseStop: function (e) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1
        },
        _detectOrientation: function () {
            this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
        },
        _normValueFromMouse: function (e) {
            var t, i, s, n, a;
            return "horizontal" === this.orientation ? (t = this.elementSize.width, i = e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, i = e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), s = i / t, s > 1 && (s = 1), 0 > s && (s = 0), "vertical" === this.orientation && (s = 1 - s), n = this._valueMax() - this._valueMin(), a = this._valueMin() + s * n, this._trimAlignValue(a)
        },
        _start: function (e, t) {
            var i = {handle: this.handles[t], value: this.value()};
            return this.options.values && this.options.values.length && (i.value = this.values(t), i.values = this.values()), this._trigger("start", e, i)
        },
        _slide: function (e, t, i) {
            var s, n, a;
            this.options.values && this.options.values.length ? (s = this.values(t ? 0 : 1), 2 === this.options.values.length && this.options.range === !0 && (0 === t && i > s || 1 === t && s > i) && (i = s), i !== this.values(t) && (n = this.values(), n[t] = i, a = this._trigger("slide", e, {
                handle: this.handles[t],
                value: i,
                values: n
            }), s = this.values(t ? 0 : 1), a !== !1 && this.values(t, i))) : i !== this.value() && (a = this._trigger("slide", e, {
                handle: this.handles[t],
                value: i
            }), a !== !1 && this.value(i))
        },
        _stop: function (e, t) {
            var i = {handle: this.handles[t], value: this.value()};
            this.options.values && this.options.values.length && (i.value = this.values(t), i.values = this.values()), this._trigger("stop", e, i)
        },
        _change: function (e, t) {
            if (!this._keySliding && !this._mouseSliding) {
                var i = {handle: this.handles[t], value: this.value()};
                this.options.values && this.options.values.length && (i.value = this.values(t), i.values = this.values()), this._lastChangedValue = t, this._trigger("change", e, i)
            }
        },
        value: function (e) {
            return arguments.length ? (this.options.value = this._trimAlignValue(e), this._refreshValue(), this._change(null, 0), void 0) : this._value()
        },
        values: function (t, i) {
            var s, n, a;
            if (arguments.length > 1) return this.options.values[t] = this._trimAlignValue(i), this._refreshValue(), this._change(null, t), void 0;
            if (!arguments.length) return this._values();
            if (!e.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(t) : this.value();
            for (s = this.options.values, n = arguments[0], a = 0; s.length > a; a += 1) s[a] = this._trimAlignValue(n[a]), this._change(null, a);
            this._refreshValue()
        },
        _setOption: function (t, i) {
            var s, n = 0;
            switch ("range" === t && this.options.range === !0 && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), e.isArray(this.options.values) && (n = this.options.values.length), "disabled" === t && this.element.toggleClass("ui-state-disabled", !!i), this._super(t, i), t) {
                case"orientation":
                    this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), this._refreshValue(), this.handles.css("horizontal" === i ? "bottom" : "left", "");
                    break;
                case"value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                    break;
                case"values":
                    for (this._animateOff = !0, this._refreshValue(), s = 0; n > s; s += 1) this._change(null, s);
                    this._animateOff = !1;
                    break;
                case"step":
                case"min":
                case"max":
                    this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
                    break;
                case"range":
                    this._animateOff = !0, this._refresh(), this._animateOff = !1
            }
        },
        _value: function () {
            var e = this.options.value;
            return e = this._trimAlignValue(e)
        },
        _values: function (e) {
            var t, i, s;
            if (arguments.length) return t = this.options.values[e], t = this._trimAlignValue(t);
            if (this.options.values && this.options.values.length) {
                for (i = this.options.values.slice(), s = 0; i.length > s; s += 1) i[s] = this._trimAlignValue(i[s]);
                return i
            }
            return []
        },
        _trimAlignValue: function (e) {
            if (this._valueMin() >= e) return this._valueMin();
            if (e >= this._valueMax()) return this._valueMax();
            var t = this.options.step > 0 ? this.options.step : 1, i = (e - this._valueMin()) % t, s = e - i;
            return 2 * Math.abs(i) >= t && (s += i > 0 ? t : -t), parseFloat(s.toFixed(5))
        },
        _calculateNewMax: function () {
            var e = this.options.max, t = this._valueMin(), i = this.options.step,
                s = Math.floor(+(e - t).toFixed(this._precision()) / i) * i;
            e = s + t, this.max = parseFloat(e.toFixed(this._precision()))
        },
        _precision: function () {
            var e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this.options.min))), e
        },
        _precisionOf: function (e) {
            var t = "" + e, i = t.indexOf(".");
            return -1 === i ? 0 : t.length - i - 1
        },
        _valueMin: function () {
            return this.options.min
        },
        _valueMax: function () {
            return this.max
        },
        _refreshValue: function () {
            var t, i, s, n, a, o = this.options.range, r = this.options, h = this,
                l = this._animateOff ? !1 : r.animate, u = {};
            this.options.values && this.options.values.length ? this.handles.each(function (s) {
                i = 100 * ((h.values(s) - h._valueMin()) / (h._valueMax() - h._valueMin())), u["horizontal" === h.orientation ? "left" : "bottom"] = i + "%", e(this).stop(1, 1)[l ? "animate" : "css"](u, r.animate), h.options.range === !0 && ("horizontal" === h.orientation ? (0 === s && h.range.stop(1, 1)[l ? "animate" : "css"]({left: i + "%"}, r.animate), 1 === s && h.range[l ? "animate" : "css"]({width: i - t + "%"}, {
                    queue: !1,
                    duration: r.animate
                })) : (0 === s && h.range.stop(1, 1)[l ? "animate" : "css"]({bottom: i + "%"}, r.animate), 1 === s && h.range[l ? "animate" : "css"]({height: i - t + "%"}, {
                    queue: !1,
                    duration: r.animate
                }))), t = i
            }) : (s = this.value(), n = this._valueMin(), a = this._valueMax(), i = a !== n ? 100 * ((s - n) / (a - n)) : 0, u["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[l ? "animate" : "css"](u, r.animate), "min" === o && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({width: i + "%"}, r.animate), "max" === o && "horizontal" === this.orientation && this.range[l ? "animate" : "css"]({width: 100 - i + "%"}, {
                queue: !1,
                duration: r.animate
            }), "min" === o && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({height: i + "%"}, r.animate), "max" === o && "vertical" === this.orientation && this.range[l ? "animate" : "css"]({height: 100 - i + "%"}, {
                queue: !1,
                duration: r.animate
            }))
        },
        _handleEvents: {
            keydown: function (t) {
                var i, s, n, a, o = e(t.target).data("ui-slider-handle-index");
                switch (t.keyCode) {
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_UP:
                    case e.ui.keyCode.PAGE_DOWN:
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, e(t.target).addClass("ui-state-active"), i = this._start(t, o), i === !1)) return
                }
                switch (a = this.options.step, s = n = this.options.values && this.options.values.length ? this.values(o) : this.value(), t.keyCode) {
                    case e.ui.keyCode.HOME:
                        n = this._valueMin();
                        break;
                    case e.ui.keyCode.END:
                        n = this._valueMax();
                        break;
                    case e.ui.keyCode.PAGE_UP:
                        n = this._trimAlignValue(s + (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.PAGE_DOWN:
                        n = this._trimAlignValue(s - (this._valueMax() - this._valueMin()) / this.numPages);
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                        if (s === this._valueMax()) return;
                        n = this._trimAlignValue(s + a);
                        break;
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (s === this._valueMin()) return;
                        n = this._trimAlignValue(s - a)
                }
                this._slide(t, o, n)
            }, keyup: function (t) {
                var i = e(t.target).data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(t, i), this._change(t, i), e(t.target).removeClass("ui-state-active"))
            }
        }
    }), e.widget("ui.sortable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function (e, t, i) {
            return e >= t && t + i > e
        },
        _isFloating: function (e) {
            return /left|right/.test(e.css("float")) || /inline|table-cell/.test(e.css("display"))
        },
        _create: function () {
            this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0
        },
        _setOption: function (e, t) {
            this._super(e, t), "handle" === e && this._setHandleClassName()
        },
        _setHandleClassName: function () {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"), e.each(this.items, function () {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle")
            })
        },
        _destroy: function () {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"), this._mouseDestroy();
            for (var e = this.items.length - 1; e >= 0; e--) this.items[e].item.removeData(this.widgetName + "-item");
            return this
        },
        _mouseCapture: function (t, i) {
            var s = null, n = !1, a = this;
            return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(t), e(t.target).parents().each(function () {
                return e.data(this, a.widgetName + "-item") === a ? (s = e(this), !1) : void 0
            }), e.data(t.target, a.widgetName + "-item") === a && (s = e(t.target)), s ? !this.options.handle || i || (e(this.options.handle, s).find("*").addBack().each(function () {
                this === t.target && (n = !0)
            }), n) ? (this.currentItem = s, this._removeCurrentsFromItems(), !0) : !1 : !1)
        },
        _mouseStart: function (t, i, s) {
            var n, a, o = this.options;
            if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                }, e.extend(this.offset, {
                    click: {left: t.pageX - this.offset.left, top: t.pageY - this.offset.top},
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {
                    prev: this.currentItem.prev()[0],
                    parent: this.currentItem.parent()[0]
                }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (a = this.document.find("body"), this.storedCursor = a.css("cursor"), a.css("cursor", o.cursor), this.storedStylesheet = e("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(a)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !s) for (n = this.containers.length - 1; n >= 0; n--) this.containers[n]._trigger("activate", t, this._uiHash(this));
            return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(t), !0
        },
        _mouseDrag: function (t) {
            var i, s, n, a, o = this.options, r = !1;
            for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + o.scrollSpeed : t.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - o.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + o.scrollSpeed : t.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (t.pageY - this.document.scrollTop() < o.scrollSensitivity ? r = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < o.scrollSensitivity && (r = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed)), t.pageX - this.document.scrollLeft() < o.scrollSensitivity ? r = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < o.scrollSensitivity && (r = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed))), r !== !1 && e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), i = this.items.length - 1; i >= 0; i--) if (s = this.items[i], n = s.item[0], a = this._intersectsWithPointer(s), a && s.instance === this.currentContainer && n !== this.currentItem[0] && this.placeholder[1 === a ? "next" : "prev"]()[0] !== n && !e.contains(this.placeholder[0], n) && ("semi-dynamic" === this.options.type ? !e.contains(this.element[0], n) : !0)) {
                if (this.direction = 1 === a ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(s)) break;
                this._rearrange(t, s), this._trigger("change", t, this._uiHash());
                break
            }
            return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
        },
        _mouseStop: function (t, i) {
            if (t) {
                if (e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(this, t), this.options.revert) {
                    var s = this, n = this.placeholder.offset(), a = this.options.axis, o = {};
                    a && "x" !== a || (o.left = n.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), a && "y" !== a || (o.top = n.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, e(this.helper).animate(o, parseInt(this.options.revert, 10) || 500, function () {
                        s._clear(t)
                    })
                } else this._clear(t, i);
                return !1
            }
        },
        cancel: function () {
            if (this.dragging) {
                this._mouseUp({target: null}), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var t = this.containers.length - 1; t >= 0; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0)
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), e.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? e(this.domPosition.prev).after(this.currentItem) : e(this.domPosition.parent).prepend(this.currentItem)), this
        },
        serialize: function (t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, e(i).each(function () {
                var i = (e(t.item || this).attr(t.attribute || "id") || "").match(t.expression || /(.+)[\-=_](.+)/);
                i && s.push((t.key || i[1] + "[]") + "=" + (t.key && t.expression ? i[1] : i[2]))
            }), !s.length && t.key && s.push(t.key + "="), s.join("&")
        },
        toArray: function (t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, i.each(function () {
                s.push(e(t.item || this).attr(t.attribute || "id") || "")
            }), s
        },
        _intersectsWith: function (e) {
            var t = this.positionAbs.left, i = t + this.helperProportions.width, s = this.positionAbs.top,
                n = s + this.helperProportions.height, a = e.left, o = a + e.width, r = e.top, h = r + e.height,
                l = this.offset.click.top, u = this.offset.click.left,
                d = "x" === this.options.axis || s + l > r && h > s + l,
                c = "y" === this.options.axis || t + u > a && o > t + u, p = d && c;
            return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > e[this.floating ? "width" : "height"] ? p : t + this.helperProportions.width / 2 > a && o > i - this.helperProportions.width / 2 && s + this.helperProportions.height / 2 > r && h > n - this.helperProportions.height / 2
        },
        _intersectsWithPointer: function (e) {
            var t = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top, e.height),
                i = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left, e.width),
                s = t && i, n = this._getDragVerticalDirection(), a = this._getDragHorizontalDirection();
            return s ? this.floating ? a && "right" === a || "down" === n ? 2 : 1 : n && ("down" === n ? 2 : 1) : !1
        },
        _intersectsWithSides: function (e) {
            var t = this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top + e.height / 2, e.height),
                i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left + e.width / 2, e.width),
                s = this._getDragVerticalDirection(), n = this._getDragHorizontalDirection();
            return this.floating && n ? "right" === n && i || "left" === n && !i : s && ("down" === s && t || "up" === s && !t)
        },
        _getDragVerticalDirection: function () {
            var e = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== e && (e > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection: function () {
            var e = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== e && (e > 0 ? "right" : "left")
        },
        refresh: function (e) {
            return this._refreshItems(e), this._setHandleClassName(), this.refreshPositions(), this
        },
        _connectWith: function () {
            var e = this.options;
            return e.connectWith.constructor === String ? [e.connectWith] : e.connectWith
        },
        _getItemsAsjQuery: function (t) {
            function i() {
                r.push(this)
            }

            var s, n, a, o, r = [], h = [], l = this._connectWith();
            if (l && t) for (s = l.length - 1; s >= 0; s--) for (a = e(l[s], this.document[0]), n = a.length - 1; n >= 0; n--) o = e.data(a[n], this.widgetFullName), o && o !== this && !o.options.disabled && h.push([e.isFunction(o.options.items) ? o.options.items.call(o.element) : e(o.options.items, o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), o]);
            for (h.push([e.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : e(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), s = h.length - 1; s >= 0; s--) h[s][0].each(i);
            return e(r)
        },
        _removeCurrentsFromItems: function () {
            var t = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = e.grep(this.items, function (e) {
                for (var i = 0; t.length > i; i++) if (t[i] === e.item[0]) return !1;
                return !0
            })
        },
        _refreshItems: function (t) {
            this.items = [], this.containers = [this];
            var i, s, n, a, o, r, h, l, u = this.items,
                d = [[e.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {item: this.currentItem}) : e(this.options.items, this.element), this]],
                c = this._connectWith();
            if (c && this.ready) for (i = c.length - 1; i >= 0; i--) for (n = e(c[i], this.document[0]), s = n.length - 1; s >= 0; s--) a = e.data(n[s], this.widgetFullName), a && a !== this && !a.options.disabled && (d.push([e.isFunction(a.options.items) ? a.options.items.call(a.element[0], t, {item: this.currentItem}) : e(a.options.items, a.element), a]), this.containers.push(a));
            for (i = d.length - 1; i >= 0; i--) for (o = d[i][1], r = d[i][0], s = 0, l = r.length; l > s; s++) h = e(r[s]), h.data(this.widgetName + "-item", o), u.push({
                item: h,
                instance: o,
                width: 0,
                height: 0,
                left: 0,
                top: 0
            })
        },
        refreshPositions: function (t) {
            this.floating = this.items.length ? "x" === this.options.axis || this._isFloating(this.items[0].item) : !1, this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            var i, s, n, a;
            for (i = this.items.length - 1; i >= 0; i--) s = this.items[i], s.instance !== this.currentContainer && this.currentContainer && s.item[0] !== this.currentItem[0] || (n = this.options.toleranceElement ? e(this.options.toleranceElement, s.item) : s.item, t || (s.width = n.outerWidth(), s.height = n.outerHeight()), a = n.offset(), s.left = a.left, s.top = a.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this); else for (i = this.containers.length - 1; i >= 0; i--) a = this.containers[i].element.offset(), this.containers[i].containerCache.left = a.left, this.containers[i].containerCache.top = a.top, this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this
        },
        _createPlaceholder: function (t) {
            t = t || this;
            var i, s = t.options;
            s.placeholder && s.placeholder.constructor !== String || (i = s.placeholder, s.placeholder = {
                element: function () {
                    var s = t.currentItem[0].nodeName.toLowerCase(),
                        n = e("<" + s + ">", t.document[0]).addClass(i || t.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                    return "tbody" === s ? t._createTrPlaceholder(t.currentItem.find("tr").eq(0), e("<tr>", t.document[0]).appendTo(n)) : "tr" === s ? t._createTrPlaceholder(t.currentItem, n) : "img" === s && n.attr("src", t.currentItem.attr("src")), i || n.css("visibility", "hidden"), n
                }, update: function (e, n) {
                    (!i || s.forcePlaceholderSize) && (n.height() || n.height(t.currentItem.innerHeight() - parseInt(t.currentItem.css("paddingTop") || 0, 10) - parseInt(t.currentItem.css("paddingBottom") || 0, 10)), n.width() || n.width(t.currentItem.innerWidth() - parseInt(t.currentItem.css("paddingLeft") || 0, 10) - parseInt(t.currentItem.css("paddingRight") || 0, 10)))
                }
            }), t.placeholder = e(s.placeholder.element.call(t.element, t.currentItem)), t.currentItem.after(t.placeholder), s.placeholder.update(t, t.placeholder)
        },
        _createTrPlaceholder: function (t, i) {
            var s = this;
            t.children().each(function () {
                e("<td>&#160;</td>", s.document[0]).attr("colspan", e(this).attr("colspan") || 1).appendTo(i)
            })
        },
        _contactContainers: function (t) {
            var i, s, n, a, o, r, h, l, u, d, c = null, p = null;
            for (i = this.containers.length - 1; i >= 0; i--) if (!e.contains(this.currentItem[0], this.containers[i].element[0])) if (this._intersectsWith(this.containers[i].containerCache)) {
                if (c && e.contains(this.containers[i].element[0], c.element[0])) continue;
                c = this.containers[i], p = i
            } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", t, this._uiHash(this)), this.containers[i].containerCache.over = 0);
            if (c) if (1 === this.containers.length) this.containers[p].containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash(this)), this.containers[p].containerCache.over = 1); else {
                for (n = 1e4, a = null, u = c.floating || this._isFloating(this.currentItem), o = u ? "left" : "top", r = u ? "width" : "height", d = u ? "clientX" : "clientY", s = this.items.length - 1; s >= 0; s--) e.contains(this.containers[p].element[0], this.items[s].item[0]) && this.items[s].item[0] !== this.currentItem[0] && (h = this.items[s].item.offset()[o], l = !1, t[d] - h > this.items[s][r] / 2 && (l = !0), n > Math.abs(t[d] - h) && (n = Math.abs(t[d] - h), a = this.items[s], this.direction = l ? "up" : "down"));
                if (!a && !this.options.dropOnEmpty) return;
                if (this.currentContainer === this.containers[p]) return this.currentContainer.containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash()), this.currentContainer.containerCache.over = 1), void 0;
                a ? this._rearrange(t, a, null, !0) : this._rearrange(t, null, this.containers[p].element, !0), this._trigger("change", t, this._uiHash()), this.containers[p]._trigger("change", t, this._uiHash(this)), this.currentContainer = this.containers[p], this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[p]._trigger("over", t, this._uiHash(this)), this.containers[p].containerCache.over = 1
            }
        },
        _createHelper: function (t) {
            var i = this.options,
                s = e.isFunction(i.helper) ? e(i.helper.apply(this.element[0], [t, this.currentItem])) : "clone" === i.helper ? this.currentItem.clone() : this.currentItem;
            return s.parents("body").length || e("parent" !== i.appendTo ? i.appendTo : this.currentItem[0].parentNode)[0].appendChild(s[0]), s[0] === this.currentItem[0] && (this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            }), (!s[0].style.width || i.forceHelperSize) && s.width(this.currentItem.width()), (!s[0].style.height || i.forceHelperSize) && s.height(this.currentItem.height()), s
        },
        _adjustOffsetFromHelper: function (t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
        },
        _getParentOffset: function () {
            this.offsetParent = this.helper.offsetParent();
            var t = this.offsetParent.offset();
            return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && e.ui.ie) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            }
        },
        _getRelativeOffset: function () {
            if ("relative" === this.cssPosition) {
                var e = this.currentItem.position();
                return {
                    top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                }
            }
            return {top: 0, left: 0}
        },
        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            }
        },
        _cacheHelperProportions: function () {
            this.helperProportions = {width: this.helper.outerWidth(), height: this.helper.outerHeight()}
        },
        _setContainment: function () {
            var t, i, s, n = this.options;
            "parent" === n.containment && (n.containment = this.helper[0].parentNode), ("document" === n.containment || "window" === n.containment) && (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === n.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === n.containment ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(n.containment) || (t = e(n.containment)[0], i = e(n.containment).offset(), s = "hidden" !== e(t).css("overflow"), this.containment = [i.left + (parseInt(e(t).css("borderLeftWidth"), 10) || 0) + (parseInt(e(t).css("paddingLeft"), 10) || 0) - this.margins.left, i.top + (parseInt(e(t).css("borderTopWidth"), 10) || 0) + (parseInt(e(t).css("paddingTop"), 10) || 0) - this.margins.top, i.left + (s ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(e(t).css("borderLeftWidth"), 10) || 0) - (parseInt(e(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, i.top + (s ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(e(t).css("borderTopWidth"), 10) || 0) - (parseInt(e(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
        },
        _convertPositionTo: function (t, i) {
            i || (i = this.position);
            var s = "absolute" === t ? 1 : -1,
                n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                a = /(html|body)/i.test(n[0].tagName);
            return {
                top: i.top + this.offset.relative.top * s + this.offset.parent.top * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : a ? 0 : n.scrollTop()) * s,
                left: i.left + this.offset.relative.left * s + this.offset.parent.left * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : a ? 0 : n.scrollLeft()) * s
            }
        },
        _generatePosition: function (t) {
            var i, s, n = this.options, a = t.pageX, o = t.pageY,
                r = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                h = /(html|body)/i.test(r[0].tagName);
            return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (a = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (o = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (a = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (o = this.containment[3] + this.offset.click.top)), n.grid && (i = this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1], o = this.containment ? i - this.offset.click.top >= this.containment[1] && i - this.offset.click.top <= this.containment[3] ? i : i - this.offset.click.top >= this.containment[1] ? i - n.grid[1] : i + n.grid[1] : i, s = this.originalPageX + Math.round((a - this.originalPageX) / n.grid[0]) * n.grid[0], a = this.containment ? s - this.offset.click.left >= this.containment[0] && s - this.offset.click.left <= this.containment[2] ? s : s - this.offset.click.left >= this.containment[0] ? s - n.grid[0] : s + n.grid[0] : s)), {
                top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : h ? 0 : r.scrollTop()),
                left: a - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : h ? 0 : r.scrollLeft())
            }
        },
        _rearrange: function (e, t, i, s) {
            i ? i[0].appendChild(this.placeholder[0]) : t.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? t.item[0] : t.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
            var n = this.counter;
            this._delay(function () {
                n === this.counter && this.refreshPositions(!s)
            })
        },
        _clear: function (e, t) {
            function i(e, t, i) {
                return function (s) {
                    i._trigger(e, s, t._uiHash(t))
                }
            }

            this.reverting = !1;
            var s, n = [];
            if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (s in this._storedCSS) ("auto" === this._storedCSS[s] || "static" === this._storedCSS[s]) && (this._storedCSS[s] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
            } else this.currentItem.show();
            for (this.fromOutside && !t && n.push(function (e) {
                this._trigger("receive", e, this._uiHash(this.fromOutside))
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || t || n.push(function (e) {
                this._trigger("update", e, this._uiHash())
            }), this !== this.currentContainer && (t || (n.push(function (e) {
                this._trigger("remove", e, this._uiHash())
            }), n.push(function (e) {
                return function (t) {
                    e._trigger("receive", t, this._uiHash(this))
                }
            }.call(this, this.currentContainer)), n.push(function (e) {
                return function (t) {
                    e._trigger("update", t, this._uiHash(this))
                }
            }.call(this, this.currentContainer)))), s = this.containers.length - 1; s >= 0; s--) t || n.push(i("deactivate", this, this.containers[s])), this.containers[s].containerCache.over && (n.push(i("out", this, this.containers[s])), this.containers[s].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, t || this._trigger("beforeStop", e, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !t) {
                for (s = 0; n.length > s; s++) n[s].call(this, e);
                this._trigger("stop", e, this._uiHash())
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval
        },
        _trigger: function () {
            e.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel()
        },
        _uiHash: function (t) {
            var i = t || this;
            return {
                helper: i.helper,
                placeholder: i.placeholder || e([]),
                position: i.position,
                originalPosition: i.originalPosition,
                offset: i.positionAbs,
                item: i.currentItem,
                sender: t ? t.element : null
            }
        }
    }), e.widget("ui.spinner", {
        version: "1.11.4",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {down: "ui-icon-triangle-1-s", up: "ui-icon-triangle-1-n"},
            incremental: !0,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function () {
            this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _getCreateOptions: function () {
            var t = {}, i = this.element;
            return e.each(["min", "max", "step"], function (e, s) {
                var n = i.attr(s);
                void 0 !== n && n.length && (t[s] = n)
            }), t
        },
        _events: {
            keydown: function (e) {
                this._start(e) && this._keydown(e) && e.preventDefault()
            }, keyup: "_stop", focus: function () {
                this.previous = this.element.val()
            }, blur: function (e) {
                return this.cancelBlur ? (delete this.cancelBlur, void 0) : (this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", e), void 0)
            }, mousewheel: function (e, t) {
                if (t) {
                    if (!this.spinning && !this._start(e)) return !1;
                    this._spin((t > 0 ? 1 : -1) * this.options.step, e), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
                        this.spinning && this._stop(e)
                    }, 100), e.preventDefault()
                }
            }, "mousedown .ui-spinner-button": function (t) {
                function i() {
                    var e = this.element[0] === this.document[0].activeElement;
                    e || (this.element.focus(), this.previous = s, this._delay(function () {
                        this.previous = s
                    }))
                }

                var s;
                s = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), t.preventDefault(), i.call(this), this.cancelBlur = !0, this._delay(function () {
                    delete this.cancelBlur, i.call(this)
                }), this._start(t) !== !1 && this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
            }, "mouseup .ui-spinner-button": "_stop", "mouseenter .ui-spinner-button": function (t) {
                return e(t.currentTarget).hasClass("ui-state-active") ? this._start(t) === !1 ? !1 : (this._repeat(null, e(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t), void 0) : void 0
            }, "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function () {
            var e = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            this.element.attr("role", "spinbutton"), this.buttons = e.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all"), this.buttons.height() > Math.ceil(.5 * e.height()) && e.height() > 0 && e.height(e.height()), this.options.disabled && this.disable()
        },
        _keydown: function (t) {
            var i = this.options, s = e.ui.keyCode;
            switch (t.keyCode) {
                case s.UP:
                    return this._repeat(null, 1, t), !0;
                case s.DOWN:
                    return this._repeat(null, -1, t), !0;
                case s.PAGE_UP:
                    return this._repeat(null, i.page, t), !0;
                case s.PAGE_DOWN:
                    return this._repeat(null, -i.page, t), !0
            }
            return !1
        },
        _uiSpinnerHtml: function () {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"
        },
        _buttonHtml: function () {
            return "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>"
        },
        _start: function (e) {
            return this.spinning || this._trigger("start", e) !== !1 ? (this.counter || (this.counter = 1), this.spinning = !0, !0) : !1
        },
        _repeat: function (e, t, i) {
            e = e || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
                this._repeat(40, t, i)
            }, e), this._spin(t * this.options.step, i)
        },
        _spin: function (e, t) {
            var i = this.value() || 0;
            this.counter || (this.counter = 1), i = this._adjustValue(i + e * this._increment(this.counter)), this.spinning && this._trigger("spin", t, {value: i}) === !1 || (this._value(i), this.counter++)
        },
        _increment: function (t) {
            var i = this.options.incremental;
            return i ? e.isFunction(i) ? i(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1
        },
        _precision: function () {
            var e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this.options.min))), e
        },
        _precisionOf: function (e) {
            var t = "" + e, i = t.indexOf(".");
            return -1 === i ? 0 : t.length - i - 1
        },
        _adjustValue: function (e) {
            var t, i, s = this.options;
            return t = null !== s.min ? s.min : 0, i = e - t, i = Math.round(i / s.step) * s.step, e = t + i, e = parseFloat(e.toFixed(this._precision())), null !== s.max && e > s.max ? s.max : null !== s.min && s.min > e ? s.min : e
        },
        _stop: function (e) {
            this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", e))
        },
        _setOption: function (e, t) {
            if ("culture" === e || "numberFormat" === e) {
                var i = this._parse(this.element.val());
                return this.options[e] = t, this.element.val(this._format(i)), void 0
            }
            ("max" === e || "min" === e || "step" === e) && "string" == typeof t && (t = this._parse(t)), "icons" === e && (this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(t.up), this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(t.down)), this._super(e, t), "disabled" === e && (this.widget().toggleClass("ui-state-disabled", !!t), this.element.prop("disabled", !!t), this.buttons.button(t ? "disable" : "enable"))
        },
        _setOptions: h(function (e) {
            this._super(e)
        }),
        _parse: function (e) {
            return "string" == typeof e && "" !== e && (e = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(e, 10, this.options.culture) : +e), "" === e || isNaN(e) ? null : e
        },
        _format: function (e) {
            return "" === e ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(e, this.options.numberFormat, this.options.culture) : e
        },
        _refresh: function () {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            })
        },
        isValid: function () {
            var e = this.value();
            return null === e ? !1 : e === this._adjustValue(e)
        },
        _value: function (e, t) {
            var i;
            "" !== e && (i = this._parse(e), null !== i && (t || (i = this._adjustValue(i)), e = this._format(i))), this.element.val(e), this._refresh()
        },
        _destroy: function () {
            this.element.removeClass("ui-spinner-input").prop("disabled", !1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.uiSpinner.replaceWith(this.element)
        },
        stepUp: h(function (e) {
            this._stepUp(e)
        }),
        _stepUp: function (e) {
            this._start() && (this._spin((e || 1) * this.options.step), this._stop())
        },
        stepDown: h(function (e) {
            this._stepDown(e)
        }),
        _stepDown: function (e) {
            this._start() && (this._spin((e || 1) * -this.options.step), this._stop())
        },
        pageUp: h(function (e) {
            this._stepUp((e || 1) * this.options.page)
        }),
        pageDown: h(function (e) {
            this._stepDown((e || 1) * this.options.page)
        }),
        value: function (e) {
            return arguments.length ? (h(this._value).call(this, e), void 0) : this._parse(this.element.val())
        },
        widget: function () {
            return this.uiSpinner
        }
    }), e.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function () {
            var e = /#.*$/;
            return function (t) {
                var i, s;
                t = t.cloneNode(!1), i = t.href.replace(e, ""), s = location.href.replace(e, "");
                try {
                    i = decodeURIComponent(i)
                } catch (n) {
                }
                try {
                    s = decodeURIComponent(s)
                } catch (n) {
                }
                return t.hash.length > 1 && i === s
            }
        }(),
        _create: function () {
            var t = this, i = this.options;
            this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", i.collapsible), this._processTabs(), i.active = this._initialActive(), e.isArray(i.disabled) && (i.disabled = e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"), function (e) {
                return t.tabs.index(e)
            }))).sort()), this.active = this.options.active !== !1 && this.anchors.length ? this._findActive(i.active) : e(), this._refresh(), this.active.length && this.load(i.active)
        },
        _initialActive: function () {
            var t = this.options.active, i = this.options.collapsible, s = location.hash.substring(1);
            return null === t && (s && this.tabs.each(function (i, n) {
                return e(n).attr("aria-controls") === s ? (t = i, !1) : void 0
            }), null === t && (t = this.tabs.index(this.tabs.filter(".ui-tabs-active"))), (null === t || -1 === t) && (t = this.tabs.length ? 0 : !1)), t !== !1 && (t = this.tabs.index(this.tabs.eq(t)), -1 === t && (t = i ? !1 : 0)), !i && t === !1 && this.anchors.length && (t = 0), t
        },
        _getCreateEventData: function () {
            return {tab: this.active, panel: this.active.length ? this._getPanelForTab(this.active) : e()}
        },
        _tabKeydown: function (t) {
            var i = e(this.document[0].activeElement).closest("li"), s = this.tabs.index(i), n = !0;
            if (!this._handlePageNav(t)) {
                switch (t.keyCode) {
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                        s++;
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.LEFT:
                        n = !1, s--;
                        break;
                    case e.ui.keyCode.END:
                        s = this.anchors.length - 1;
                        break;
                    case e.ui.keyCode.HOME:
                        s = 0;
                        break;
                    case e.ui.keyCode.SPACE:
                        return t.preventDefault(), clearTimeout(this.activating), this._activate(s), void 0;
                    case e.ui.keyCode.ENTER:
                        return t.preventDefault(), clearTimeout(this.activating), this._activate(s === this.options.active ? !1 : s), void 0;
                    default:
                        return
                }
                t.preventDefault(), clearTimeout(this.activating), s = this._focusNextTab(s, n), t.ctrlKey || t.metaKey || (i.attr("aria-selected", "false"), this.tabs.eq(s).attr("aria-selected", "true"), this.activating = this._delay(function () {
                    this.option("active", s)
                }, this.delay))
            }
        },
        _panelKeydown: function (t) {
            this._handlePageNav(t) || t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t.preventDefault(), this.active.focus())
        },
        _handlePageNav: function (t) {
            return t.altKey && t.keyCode === e.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : t.altKey && t.keyCode === e.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0
        },
        _findNextTab: function (t, i) {
            function s() {
                return t > n && (t = 0), 0 > t && (t = n), t
            }

            for (var n = this.tabs.length - 1; -1 !== e.inArray(s(), this.options.disabled);) t = i ? t + 1 : t - 1;
            return t
        },
        _focusNextTab: function (e, t) {
            return e = this._findNextTab(e, t), this.tabs.eq(e).focus(), e
        },
        _setOption: function (e, t) {
            return "active" === e ? (this._activate(t), void 0) : "disabled" === e ? (this._setupDisabled(t), void 0) : (this._super(e, t), "collapsible" === e && (this.element.toggleClass("ui-tabs-collapsible", t), t || this.options.active !== !1 || this._activate(0)), "event" === e && this._setupEvents(t), "heightStyle" === e && this._setupHeightStyle(t), void 0)
        },
        _sanitizeSelector: function (e) {
            return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
        },
        refresh: function () {
            var t = this.options, i = this.tablist.children(":has(a[href])");
            t.disabled = e.map(i.filter(".ui-state-disabled"), function (e) {
                return i.index(e)
            }), this._processTabs(), t.active !== !1 && this.anchors.length ? this.active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = e()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1, this.active = e()), this._refresh()
        },
        _refresh: function () {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden": "true"}), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }), this._getPanelForTab(this.active).show().attr({"aria-hidden": "false"})) : this.tabs.eq(0).attr("tabIndex", 0)
        },
        _processTabs: function () {
            var t = this, i = this.tabs, s = this.anchors, n = this.panels;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function (t) {
                e(this).is(".ui-state-disabled") && t.preventDefault()
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
                e(this).closest("li").is(".ui-state-disabled") && this.blur()
            }), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            }), this.anchors = this.tabs.map(function () {
                return e("a", this)[0]
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            }), this.panels = e(), this.anchors.each(function (i, s) {
                var n, a, o, r = e(s).uniqueId().attr("id"), h = e(s).closest("li"), l = h.attr("aria-controls");
                t._isLocal(s) ? (n = s.hash, o = n.substring(1), a = t.element.find(t._sanitizeSelector(n))) : (o = h.attr("aria-controls") || e({}).uniqueId()[0].id, n = "#" + o, a = t.element.find(n), a.length || (a = t._createPanel(o), a.insertAfter(t.panels[i - 1] || t.tablist)), a.attr("aria-live", "polite")), a.length && (t.panels = t.panels.add(a)), l && h.data("ui-tabs-aria-controls", l), h.attr({
                    "aria-controls": o,
                    "aria-labelledby": r
                }), a.attr("aria-labelledby", r)
            }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel"), i && (this._off(i.not(this.tabs)), this._off(s.not(this.anchors)), this._off(n.not(this.panels)))
        },
        _getList: function () {
            return this.tablist || this.element.find("ol,ul").eq(0)
        },
        _createPanel: function (t) {
            return e("<div>").attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0)
        },
        _setupDisabled: function (t) {
            e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1);
            for (var i, s = 0; i = this.tabs[s]; s++) t === !0 || -1 !== e.inArray(s, t) ? e(i).addClass("ui-state-disabled").attr("aria-disabled", "true") : e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            this.options.disabled = t
        },
        _setupEvents: function (t) {
            var i = {};
            t && e.each(t.split(" "), function (e, t) {
                i[t] = "_eventHandler"
            }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
                click: function (e) {
                    e.preventDefault()
                }
            }), this._on(this.anchors, i), this._on(this.tabs, {keydown: "_tabKeydown"}), this._on(this.panels, {keydown: "_panelKeydown"}), this._focusable(this.tabs), this._hoverable(this.tabs)
        },
        _setupHeightStyle: function (t) {
            var i, s = this.element.parent();
            "fill" === t ? (i = s.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function () {
                var t = e(this), s = t.css("position");
                "absolute" !== s && "fixed" !== s && (i -= t.outerHeight(!0))
            }), this.element.children().not(this.panels).each(function () {
                i -= e(this).outerHeight(!0)
            }), this.panels.each(function () {
                e(this).height(Math.max(0, i - e(this).innerHeight() + e(this).height()))
            }).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function () {
                i = Math.max(i, e(this).height("").height())
            }).height(i))
        },
        _eventHandler: function (t) {
            var i = this.options, s = this.active, n = e(t.currentTarget), a = n.closest("li"), o = a[0] === s[0],
                r = o && i.collapsible, h = r ? e() : this._getPanelForTab(a),
                l = s.length ? this._getPanelForTab(s) : e(),
                u = {oldTab: s, oldPanel: l, newTab: r ? e() : a, newPanel: h};
            t.preventDefault(), a.hasClass("ui-state-disabled") || a.hasClass("ui-tabs-loading") || this.running || o && !i.collapsible || this._trigger("beforeActivate", t, u) === !1 || (i.active = r ? !1 : this.tabs.index(a), this.active = o ? e() : a, this.xhr && this.xhr.abort(), l.length || h.length || e.error("jQuery UI Tabs: Mismatching fragment identifier."), h.length && this.load(this.tabs.index(a), t), this._toggle(t, u))
        },
        _toggle: function (t, i) {
            function s() {
                a.running = !1, a._trigger("activate", t, i)
            }

            function n() {
                i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), o.length && a.options.show ? a._show(o, a.options.show, s) : (o.show(), s())
            }

            var a = this, o = i.newPanel, r = i.oldPanel;
            this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, function () {
                i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), n()
            }) : (i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), r.hide(), n()), r.attr("aria-hidden", "true"), i.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), o.length && r.length ? i.oldTab.attr("tabIndex", -1) : o.length && this.tabs.filter(function () {
                return 0 === e(this).attr("tabIndex")
            }).attr("tabIndex", -1), o.attr("aria-hidden", "false"), i.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            })
        },
        _activate: function (t) {
            var i, s = this._findActive(t);
            s[0] !== this.active[0] && (s.length || (s = this.active), i = s.find(".ui-tabs-anchor")[0], this._eventHandler({
                target: i,
                currentTarget: i,
                preventDefault: e.noop
            }))
        },
        _findActive: function (t) {
            return t === !1 ? e() : this.tabs.eq(t)
        },
        _getIndex: function (e) {
            return "string" == typeof e && (e = this.anchors.index(this.anchors.filter("[href$='" + e + "']"))), e
        },
        _destroy: function () {
            this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(), this.tablist.unbind(this.eventNamespace), this.tabs.add(this.panels).each(function () {
                e.data(this, "ui-tabs-destroy") ? e(this).remove() : e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")
            }), this.tabs.each(function () {
                var t = e(this), i = t.data("ui-tabs-aria-controls");
                i ? t.attr("aria-controls", i).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls")
            }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "")
        },
        enable: function (t) {
            var i = this.options.disabled;
            i !== !1 && (void 0 === t ? i = !1 : (t = this._getIndex(t), i = e.isArray(i) ? e.map(i, function (e) {
                return e !== t ? e : null
            }) : e.map(this.tabs, function (e, i) {
                return i !== t ? i : null
            })), this._setupDisabled(i))
        },
        disable: function (t) {
            var i = this.options.disabled;
            if (i !== !0) {
                if (void 0 === t) i = !0; else {
                    if (t = this._getIndex(t), -1 !== e.inArray(t, i)) return;
                    i = e.isArray(i) ? e.merge([t], i).sort() : [t]
                }
                this._setupDisabled(i)
            }
        },
        load: function (t, i) {
            t = this._getIndex(t);
            var s = this, n = this.tabs.eq(t), a = n.find(".ui-tabs-anchor"), o = this._getPanelForTab(n),
                r = {tab: n, panel: o}, h = function (e, t) {
                    "abort" === t && s.panels.stop(!1, !0), n.removeClass("ui-tabs-loading"), o.removeAttr("aria-busy"), e === s.xhr && delete s.xhr
                };
            this._isLocal(a[0]) || (this.xhr = e.ajax(this._ajaxSettings(a, i, r)), this.xhr && "canceled" !== this.xhr.statusText && (n.addClass("ui-tabs-loading"), o.attr("aria-busy", "true"), this.xhr.done(function (e, t, n) {
                setTimeout(function () {
                    o.html(e), s._trigger("load", i, r), h(n, t)
                }, 1)
            }).fail(function (e, t) {
                setTimeout(function () {
                    h(e, t)
                }, 1)
            })))
        },
        _ajaxSettings: function (t, i, s) {
            var n = this;
            return {
                url: t.attr("href"), beforeSend: function (t, a) {
                    return n._trigger("beforeLoad", i, e.extend({jqXHR: t, ajaxSettings: a}, s))
                }
            }
        },
        _getPanelForTab: function (t) {
            var i = e(t).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + i))
        }
    }), e.widget("ui.tooltip", {
        version: "1.11.4", options: {
            content: function () {
                var t = e(this).attr("title") || "";
                return e("<a>").text(t).html()
            },
            hide: !0,
            items: "[title]:not([disabled])",
            position: {my: "left top+15", at: "left bottom", collision: "flipfit flip"},
            show: !0,
            tooltipClass: null,
            track: !1,
            close: null,
            open: null
        }, _addDescribedBy: function (t, i) {
            var s = (t.attr("aria-describedby") || "").split(/\s+/);
            s.push(i), t.data("ui-tooltip-id", i).attr("aria-describedby", e.trim(s.join(" ")))
        }, _removeDescribedBy: function (t) {
            var i = t.data("ui-tooltip-id"), s = (t.attr("aria-describedby") || "").split(/\s+/), n = e.inArray(i, s);
            -1 !== n && s.splice(n, 1), t.removeData("ui-tooltip-id"), s = e.trim(s.join(" ")), s ? t.attr("aria-describedby", s) : t.removeAttr("aria-describedby")
        }, _create: function () {
            this._on({
                mouseover: "open",
                focusin: "open"
            }), this.tooltips = {}, this.parents = {}, this.options.disabled && this._disable(), this.liveRegion = e("<div>").attr({
                role: "log",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body)
        }, _setOption: function (t, i) {
            var s = this;
            return "disabled" === t ? (this[i ? "_disable" : "_enable"](), this.options[t] = i, void 0) : (this._super(t, i), "content" === t && e.each(this.tooltips, function (e, t) {
                s._updateContent(t.element)
            }), void 0)
        }, _disable: function () {
            var t = this;
            e.each(this.tooltips, function (i, s) {
                var n = e.Event("blur");
                n.target = n.currentTarget = s.element[0], t.close(n, !0)
            }), this.element.find(this.options.items).addBack().each(function () {
                var t = e(this);
                t.is("[title]") && t.data("ui-tooltip-title", t.attr("title")).removeAttr("title")
            })
        }, _enable: function () {
            this.element.find(this.options.items).addBack().each(function () {
                var t = e(this);
                t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"))
            })
        }, open: function (t) {
            var i = this, s = e(t ? t.target : this.element).closest(this.options.items);
            s.length && !s.data("ui-tooltip-id") && (s.attr("title") && s.data("ui-tooltip-title", s.attr("title")), s.data("ui-tooltip-open", !0), t && "mouseover" === t.type && s.parents().each(function () {
                var t, s = e(this);
                s.data("ui-tooltip-open") && (t = e.Event("blur"), t.target = t.currentTarget = this, i.close(t, !0)), s.attr("title") && (s.uniqueId(), i.parents[this.id] = {
                    element: this,
                    title: s.attr("title")
                }, s.attr("title", ""))
            }), this._registerCloseHandlers(t, s), this._updateContent(s, t))
        }, _updateContent: function (e, t) {
            var i, s = this.options.content, n = this, a = t ? t.type : null;
            return "string" == typeof s ? this._open(t, e, s) : (i = s.call(e[0], function (i) {
                n._delay(function () {
                    e.data("ui-tooltip-open") && (t && (t.type = a), this._open(t, e, i))
                })
            }), i && this._open(t, e, i), void 0)
        }, _open: function (t, i, s) {
            function n(e) {
                l.of = e, o.is(":hidden") || o.position(l)
            }

            var a, o, r, h, l = e.extend({}, this.options.position);
            if (s) {
                if (a = this._find(i)) return a.tooltip.find(".ui-tooltip-content").html(s), void 0;
                i.is("[title]") && (t && "mouseover" === t.type ? i.attr("title", "") : i.removeAttr("title")), a = this._tooltip(i), o = a.tooltip, this._addDescribedBy(i, o.attr("id")), o.find(".ui-tooltip-content").html(s), this.liveRegion.children().hide(), s.clone ? (h = s.clone(), h.removeAttr("id").find("[id]").removeAttr("id")) : h = s, e("<div>").html(h).appendTo(this.liveRegion), this.options.track && t && /^mouse/.test(t.type) ? (this._on(this.document, {mousemove: n}), n(t)) : o.position(e.extend({of: i}, this.options.position)), o.hide(), this._show(o, this.options.show), this.options.show && this.options.show.delay && (r = this.delayedShow = setInterval(function () {
                    o.is(":visible") && (n(l.of), clearInterval(r))
                }, e.fx.interval)), this._trigger("open", t, {tooltip: o})
            }
        }, _registerCloseHandlers: function (t, i) {
            var s = {
                keyup: function (t) {
                    if (t.keyCode === e.ui.keyCode.ESCAPE) {
                        var s = e.Event(t);
                        s.currentTarget = i[0], this.close(s, !0)
                    }
                }
            };
            i[0] !== this.element[0] && (s.remove = function () {
                this._removeTooltip(this._find(i).tooltip)
            }), t && "mouseover" !== t.type || (s.mouseleave = "close"), t && "focusin" !== t.type || (s.focusout = "close"), this._on(!0, i, s)
        }, close: function (t) {
            var i, s = this, n = e(t ? t.currentTarget : this.element), a = this._find(n);
            return a ? (i = a.tooltip, a.closing || (clearInterval(this.delayedShow), n.data("ui-tooltip-title") && !n.attr("title") && n.attr("title", n.data("ui-tooltip-title")), this._removeDescribedBy(n), a.hiding = !0, i.stop(!0), this._hide(i, this.options.hide, function () {
                s._removeTooltip(e(this))
            }), n.removeData("ui-tooltip-open"), this._off(n, "mouseleave focusout keyup"), n[0] !== this.element[0] && this._off(n, "remove"), this._off(this.document, "mousemove"), t && "mouseleave" === t.type && e.each(this.parents, function (t, i) {
                e(i.element).attr("title", i.title), delete s.parents[t]
            }), a.closing = !0, this._trigger("close", t, {tooltip: i}), a.hiding || (a.closing = !1)), void 0) : (n.removeData("ui-tooltip-open"), void 0)
        }, _tooltip: function (t) {
            var i = e("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")),
                s = i.uniqueId().attr("id");
            return e("<div>").addClass("ui-tooltip-content").appendTo(i), i.appendTo(this.document[0].body), this.tooltips[s] = {
                element: t,
                tooltip: i
            }
        }, _find: function (e) {
            var t = e.data("ui-tooltip-id");
            return t ? this.tooltips[t] : null
        }, _removeTooltip: function (e) {
            e.remove(), delete this.tooltips[e.attr("id")]
        }, _destroy: function () {
            var t = this;
            e.each(this.tooltips, function (i, s) {
                var n = e.Event("blur"), a = s.element;
                n.target = n.currentTarget = a[0], t.close(n, !0), e("#" + i).remove(), a.data("ui-tooltip-title") && (a.attr("title") || a.attr("title", a.data("ui-tooltip-title")), a.removeData("ui-tooltip-title"))
            }), this.liveRegion.remove()
        }
    })
});
!function (t, e) {
    "function" == typeof define && define.amd ? define(e) : "object" == typeof exports ? module.exports = e(require, exports, module) : t.Tether = e()
}(this, function (t, e, o) {
    "use strict";

    function i(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function n(t) {
        var e = getComputedStyle(t), o = e.position;
        if ("fixed" === o) return t;
        for (var i = t; i = i.parentNode;) {
            var n = void 0;
            try {
                n = getComputedStyle(i)
            } catch (r) {
            }
            if ("undefined" == typeof n || null === n) return i;
            var s = n, a = s.overflow, f = s.overflowX, h = s.overflowY;
            if (/(auto|scroll)/.test(a + h + f) && ("absolute" !== o || ["relative", "absolute", "fixed"].indexOf(n.position) >= 0)) return i
        }
        return document.body
    }

    function r(t) {
        var e = void 0;
        t === document ? (e = document, t = document.documentElement) : e = t.ownerDocument;
        var o = e.documentElement, i = {}, n = t.getBoundingClientRect();
        for (var r in n) i[r] = n[r];
        var s = x(e);
        return i.top -= s.top, i.left -= s.left, "undefined" == typeof i.width && (i.width = document.body.scrollWidth - i.left - i.right), "undefined" == typeof i.height && (i.height = document.body.scrollHeight - i.top - i.bottom), i.top = i.top - o.clientTop, i.left = i.left - o.clientLeft, i.right = e.body.clientWidth - i.width - i.left, i.bottom = e.body.clientHeight - i.height - i.top, i
    }

    function s(t) {
        return t.offsetParent || document.documentElement
    }

    function a() {
        var t = document.createElement("div");
        t.style.width = "100%", t.style.height = "200px";
        var e = document.createElement("div");
        f(e.style, {
            position: "absolute",
            top: 0,
            left: 0,
            pointerEvents: "none",
            visibility: "hidden",
            width: "200px",
            height: "150px",
            overflow: "hidden"
        }), e.appendChild(t), document.body.appendChild(e);
        var o = t.offsetWidth;
        e.style.overflow = "scroll";
        var i = t.offsetWidth;
        o === i && (i = e.clientWidth), document.body.removeChild(e);
        var n = o - i;
        return {width: n, height: n}
    }

    function f() {
        var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], e = [];
        return Array.prototype.push.apply(e, arguments), e.slice(1).forEach(function (e) {
            if (e) for (var o in e) ({}).hasOwnProperty.call(e, o) && (t[o] = e[o])
        }), t
    }

    function h(t, e) {
        if ("undefined" != typeof t.classList) e.split(" ").forEach(function (e) {
            e.trim() && t.classList.remove(e)
        }); else {
            var o = new RegExp("(^| )" + e.split(" ").join("|") + "( |$)", "gi"), i = u(t).replace(o, " ");
            p(t, i)
        }
    }

    function l(t, e) {
        if ("undefined" != typeof t.classList) e.split(" ").forEach(function (e) {
            e.trim() && t.classList.add(e)
        }); else {
            h(t, e);
            var o = u(t) + (" " + e);
            p(t, o)
        }
    }

    function d(t, e) {
        if ("undefined" != typeof t.classList) return t.classList.contains(e);
        var o = u(t);
        return new RegExp("(^| )" + e + "( |$)", "gi").test(o)
    }

    function u(t) {
        return t.className instanceof SVGAnimatedString ? t.className.baseVal : t.className
    }

    function p(t, e) {
        t.setAttribute("class", e)
    }

    function c(t, e, o) {
        o.forEach(function (o) {
            -1 === e.indexOf(o) && d(t, o) && h(t, o)
        }), e.forEach(function (e) {
            d(t, e) || l(t, e)
        })
    }

    function i(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function g(t, e) {
        var o = arguments.length <= 2 || void 0 === arguments[2] ? 1 : arguments[2];
        return t + o >= e && e >= t - o
    }

    function m() {
        return "undefined" != typeof performance && "undefined" != typeof performance.now ? performance.now() : +new Date
    }

    function v() {
        for (var t = {top: 0, left: 0}, e = arguments.length, o = Array(e), i = 0; e > i; i++) o[i] = arguments[i];
        return o.forEach(function (e) {
            var o = e.top, i = e.left;
            "string" == typeof o && (o = parseFloat(o, 10)), "string" == typeof i && (i = parseFloat(i, 10)), t.top += o, t.left += i
        }), t
    }

    function y(t, e) {
        return "string" == typeof t.left && -1 !== t.left.indexOf("%") && (t.left = parseFloat(t.left, 10) / 100 * e.width), "string" == typeof t.top && -1 !== t.top.indexOf("%") && (t.top = parseFloat(t.top, 10) / 100 * e.height), t
    }

    function b(t, e) {
        return "scrollParent" === e ? e = t.scrollParent : "window" === e && (e = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset]), e === document && (e = e.documentElement), "undefined" != typeof e.nodeType && !function () {
            var t = r(e), o = t, i = getComputedStyle(e);
            e = [o.left, o.top, t.width + o.left, t.height + o.top], U.forEach(function (t, o) {
                t = t[0].toUpperCase() + t.substr(1), "Top" === t || "Left" === t ? e[o] += parseFloat(i["border" + t + "Width"]) : e[o] -= parseFloat(i["border" + t + "Width"])
            })
        }(), e
    }

    var w = function () {
        function t(t, e) {
            for (var o = 0; o < e.length; o++) {
                var i = e[o];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        return function (e, o, i) {
            return o && t(e.prototype, o), i && t(e, i), e
        }
    }(), C = void 0;
    "undefined" == typeof C && (C = {modules: []});
    var O = function () {
        var t = 0;
        return function () {
            return ++t
        }
    }(), E = {}, x = function (t) {
        var e = t._tetherZeroElement;
        "undefined" == typeof e && (e = t.createElement("div"), e.setAttribute("data-tether-id", O()), f(e.style, {
            top: 0,
            left: 0,
            position: "absolute"
        }), t.body.appendChild(e), t._tetherZeroElement = e);
        var o = e.getAttribute("data-tether-id");
        if ("undefined" == typeof E[o]) {
            E[o] = {};
            var i = e.getBoundingClientRect();
            for (var n in i) E[o][n] = i[n];
            T(function () {
                delete E[o]
            })
        }
        return E[o]
    }, A = [], T = function (t) {
        A.push(t)
    }, S = function () {
        for (var t = void 0; t = A.pop();) t()
    }, W = function () {
        function t() {
            i(this, t)
        }

        return w(t, [{
            key: "on", value: function (t, e, o) {
                var i = arguments.length <= 3 || void 0 === arguments[3] ? !1 : arguments[3];
                "undefined" == typeof this.bindings && (this.bindings = {}), "undefined" == typeof this.bindings[t] && (this.bindings[t] = []), this.bindings[t].push({
                    handler: e,
                    ctx: o,
                    once: i
                })
            }
        }, {
            key: "once", value: function (t, e, o) {
                this.on(t, e, o, !0)
            }
        }, {
            key: "off", value: function (t, e) {
                if ("undefined" == typeof this.bindings || "undefined" == typeof this.bindings[t]) if ("undefined" == typeof e) delete this.bindings[t]; else for (var o = 0; o < this.bindings[t].length;) this.bindings[t][o].handler === e ? this.bindings[t].splice(o, 1) : ++o
            }
        }, {
            key: "trigger", value: function (t) {
                if ("undefined" != typeof this.bindings && this.bindings[t]) {
                    for (var e = 0, o = arguments.length, i = Array(o > 1 ? o - 1 : 0), n = 1; o > n; n++) i[n - 1] = arguments[n];
                    for (; e < this.bindings[t].length;) {
                        var r = this.bindings[t][e], s = r.handler, a = r.ctx, f = r.once, h = a;
                        "undefined" == typeof h && (h = this), s.apply(h, i), f ? this.bindings[t].splice(e, 1) : ++e
                    }
                }
            }
        }]), t
    }();
    C.Utils = {
        getScrollParent: n,
        getBounds: r,
        getOffsetParent: s,
        extend: f,
        addClass: l,
        removeClass: h,
        hasClass: d,
        updateClasses: c,
        defer: T,
        flush: S,
        uniqueId: O,
        Evented: W,
        getScrollBarSize: a
    };
    var M = function () {
        function t(t, e) {
            var o = [], i = !0, n = !1, r = void 0;
            try {
                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0) ;
            } catch (f) {
                n = !0, r = f
            } finally {
                try {
                    !i && a["return"] && a["return"]()
                } finally {
                    if (n) throw r
                }
            }
            return o
        }

        return function (e, o) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return t(e, o);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }(), w = function () {
        function t(t, e) {
            for (var o = 0; o < e.length; o++) {
                var i = e[o];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        return function (e, o, i) {
            return o && t(e.prototype, o), i && t(e, i), e
        }
    }();
    if ("undefined" == typeof C) throw new Error("You must include the utils.js file before tether.js");
    var P = C.Utils, n = P.getScrollParent, r = P.getBounds, s = P.getOffsetParent, f = P.extend, l = P.addClass,
        h = P.removeClass, c = P.updateClasses, T = P.defer, S = P.flush, a = P.getScrollBarSize, k = function () {
            if ("undefined" == typeof document) return "";
            for (var t = document.createElement("div"), e = ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"], o = 0; o < e.length; ++o) {
                var i = e[o];
                if (void 0 !== t.style[i]) return i
            }
        }(), B = [], _ = function () {
            B.forEach(function (t) {
                t.position(!1)
            }), S()
        };
    !function () {
        var t = null, e = null, o = null, i = function n() {
            return "undefined" != typeof e && e > 16 ? (e = Math.min(e - 16, 250), void(o = setTimeout(n, 250))) : void("undefined" != typeof t && m() - t < 10 || ("undefined" != typeof o && (clearTimeout(o), o = null), t = m(), _(), e = m() - t))
        };
        "undefined" != typeof window && ["resize", "scroll", "touchmove"].forEach(function (t) {
            window.addEventListener(t, i)
        })
    }();
    var z = {center: "center", left: "right", right: "left"}, F = {middle: "middle", top: "bottom", bottom: "top"},
        L = {top: 0, left: 0, middle: "50%", center: "50%", bottom: "100%", right: "100%"}, Y = function (t, e) {
            var o = t.left, i = t.top;
            return "auto" === o && (o = z[e.left]), "auto" === i && (i = F[e.top]), {left: o, top: i}
        }, H = function (t) {
            var e = t.left, o = t.top;
            return "undefined" != typeof L[t.left] && (e = L[t.left]), "undefined" != typeof L[t.top] && (o = L[t.top]), {
                left: e,
                top: o
            }
        }, X = function (t) {
            var e = t.split(" "), o = M(e, 2), i = o[0], n = o[1];
            return {top: i, left: n}
        }, j = X, N = function () {
            function t(e) {
                var o = this;
                i(this, t), this.position = this.position.bind(this), B.push(this), this.history = [], this.setOptions(e, !1), C.modules.forEach(function (t) {
                    "undefined" != typeof t.initialize && t.initialize.call(o)
                }), this.position()
            }

            return w(t, [{
                key: "getClass", value: function () {
                    var t = arguments.length <= 0 || void 0 === arguments[0] ? "" : arguments[0], e = this.options.classes;
                    return "undefined" != typeof e && e[t] ? this.options.classes[t] : this.options.classPrefix ? this.options.classPrefix + "-" + t : t
                }
            }, {
                key: "setOptions", value: function (t) {
                    var e = this, o = arguments.length <= 1 || void 0 === arguments[1] ? !0 : arguments[1],
                        i = {offset: "0 0", targetOffset: "0 0", targetAttachment: "auto auto", classPrefix: "tether"};
                    this.options = f(i, t);
                    var r = this.options, s = r.element, a = r.target, h = r.targetModifier;
                    if (this.element = s, this.target = a, this.targetModifier = h, "viewport" === this.target ? (this.target = document.body, this.targetModifier = "visible") : "scroll-handle" === this.target && (this.target = document.body, this.targetModifier = "scroll-handle"), ["element", "target"].forEach(function (t) {
                            if ("undefined" == typeof e[t]) throw new Error("Tether Error: Both element and target must be defined");
                            "undefined" != typeof e[t].jquery ? e[t] = e[t][0] : "string" == typeof e[t] && (e[t] = document.querySelector(e[t]))
                        }), l(this.element, this.getClass("element")), this.options.addTargetClasses !== !1 && l(this.target, this.getClass("target")), !this.options.attachment) throw new Error("Tether Error: You must provide an attachment");
                    this.targetAttachment = j(this.options.targetAttachment), this.attachment = j(this.options.attachment), this.offset = X(this.options.offset), this.targetOffset = X(this.options.targetOffset), "undefined" != typeof this.scrollParent && this.disable(), "scroll-handle" === this.targetModifier ? this.scrollParent = this.target : this.scrollParent = n(this.target), this.options.enabled !== !1 && this.enable(o)
                }
            }, {
                key: "getTargetBounds", value: function () {
                    if ("undefined" == typeof this.targetModifier) return r(this.target);
                    if ("visible" === this.targetModifier) {
                        if (this.target === document.body) return {
                            top: pageYOffset,
                            left: pageXOffset,
                            height: innerHeight,
                            width: innerWidth
                        };
                        var t = r(this.target), e = {height: t.height, width: t.width, top: t.top, left: t.left};
                        return e.height = Math.min(e.height, t.height - (pageYOffset - t.top)), e.height = Math.min(e.height, t.height - (t.top + t.height - (pageYOffset + innerHeight))), e.height = Math.min(innerHeight, e.height), e.height -= 2, e.width = Math.min(e.width, t.width - (pageXOffset - t.left)), e.width = Math.min(e.width, t.width - (t.left + t.width - (pageXOffset + innerWidth))), e.width = Math.min(innerWidth, e.width), e.width -= 2, e.top < pageYOffset && (e.top = pageYOffset), e.left < pageXOffset && (e.left = pageXOffset), e
                    }
                    if ("scroll-handle" === this.targetModifier) {
                        var t = void 0, o = this.target;
                        o === document.body ? (o = document.documentElement, t = {
                            left: pageXOffset,
                            top: pageYOffset,
                            height: innerHeight,
                            width: innerWidth
                        }) : t = r(o);
                        var i = getComputedStyle(o),
                            n = o.scrollWidth > o.clientWidth || [i.overflow, i.overflowX].indexOf("scroll") >= 0 || this.target !== document.body,
                            s = 0;
                        n && (s = 15);
                        var a = t.height - parseFloat(i.borderTopWidth) - parseFloat(i.borderBottomWidth) - s, e = {
                            width: 15,
                            height: .975 * a * (a / o.scrollHeight),
                            left: t.left + t.width - parseFloat(i.borderLeftWidth) - 15
                        }, f = 0;
                        408 > a && this.target === document.body && (f = -11e-5 * Math.pow(a, 2) - .00727 * a + 22.58), this.target !== document.body && (e.height = Math.max(e.height, 24));
                        var h = this.target.scrollTop / (o.scrollHeight - a);
                        return e.top = h * (a - e.height - f) + t.top + parseFloat(i.borderTopWidth), this.target === document.body && (e.height = Math.max(e.height, 24)), e
                    }
                }
            }, {
                key: "clearCache", value: function () {
                    this._cache = {}
                }
            }, {
                key: "cache", value: function (t, e) {
                    return "undefined" == typeof this._cache && (this._cache = {}), "undefined" == typeof this._cache[t] && (this._cache[t] = e.call(this)), this._cache[t]
                }
            }, {
                key: "enable", value: function () {
                    var t = arguments.length <= 0 || void 0 === arguments[0] ? !0 : arguments[0];
                    this.options.addTargetClasses !== !1 && l(this.target, this.getClass("enabled")), l(this.element, this.getClass("enabled")), this.enabled = !0, this.scrollParent !== document && this.scrollParent.addEventListener("scroll", this.position), t && this.position()
                }
            }, {
                key: "disable", value: function () {
                    h(this.target, this.getClass("enabled")), h(this.element, this.getClass("enabled")), this.enabled = !1, "undefined" != typeof this.scrollParent && this.scrollParent.removeEventListener("scroll", this.position)
                }
            }, {
                key: "destroy", value: function () {
                    var t = this;
                    this.disable(), B.forEach(function (e, o) {
                        return e === t ? void B.splice(o, 1) : void 0
                    })
                }
            }, {
                key: "updateAttachClasses", value: function (t, e) {
                    var o = this;
                    t = t || this.attachment, e = e || this.targetAttachment;
                    var i = ["left", "top", "bottom", "right", "middle", "center"];
                    "undefined" != typeof this._addAttachClasses && this._addAttachClasses.length && this._addAttachClasses.splice(0, this._addAttachClasses.length), "undefined" == typeof this._addAttachClasses && (this._addAttachClasses = []);
                    var n = this._addAttachClasses;
                    t.top && n.push(this.getClass("element-attached") + "-" + t.top), t.left && n.push(this.getClass("element-attached") + "-" + t.left), e.top && n.push(this.getClass("target-attached") + "-" + e.top), e.left && n.push(this.getClass("target-attached") + "-" + e.left);
                    var r = [];
                    i.forEach(function (t) {
                        r.push(o.getClass("element-attached") + "-" + t), r.push(o.getClass("target-attached") + "-" + t)
                    }), T(function () {
                        "undefined" != typeof o._addAttachClasses && (c(o.element, o._addAttachClasses, r), o.options.addTargetClasses !== !1 && c(o.target, o._addAttachClasses, r), delete o._addAttachClasses)
                    })
                }
            }, {
                key: "position", value: function () {
                    var t = this, e = arguments.length <= 0 || void 0 === arguments[0] ? !0 : arguments[0];
                    if (this.enabled) {
                        this.clearCache();
                        var o = Y(this.targetAttachment, this.attachment);
                        this.updateAttachClasses(this.attachment, o);
                        var i = this.cache("element-bounds", function () {
                            return r(t.element)
                        }), n = i.width, f = i.height;
                        if (0 === n && 0 === f && "undefined" != typeof this.lastSize) {
                            var h = this.lastSize;
                            n = h.width, f = h.height
                        } else this.lastSize = {width: n, height: f};
                        var l = this.cache("target-bounds", function () {
                                return t.getTargetBounds()
                            }), d = l, u = y(H(this.attachment), {width: n, height: f}), p = y(H(o), d),
                            c = y(this.offset, {width: n, height: f}), g = y(this.targetOffset, d);
                        u = v(u, c), p = v(p, g);
                        for (var m = l.left + p.left - u.left, b = l.top + p.top - u.top, w = 0; w < C.modules.length; ++w) {
                            var O = C.modules[w], E = O.position.call(this, {
                                left: m,
                                top: b,
                                targetAttachment: o,
                                targetPos: l,
                                elementPos: i,
                                offset: u,
                                targetOffset: p,
                                manualOffset: c,
                                manualTargetOffset: g,
                                scrollbarSize: A,
                                attachment: this.attachment
                            });
                            if (E === !1) return !1;
                            "undefined" != typeof E && "object" == typeof E && (b = E.top, m = E.left)
                        }
                        var x = {
                            page: {top: b, left: m},
                            viewport: {
                                top: b - pageYOffset,
                                bottom: pageYOffset - b - f + innerHeight,
                                left: m - pageXOffset,
                                right: pageXOffset - m - n + innerWidth
                            }
                        }, A = void 0;
                        return document.body.scrollWidth > window.innerWidth && (A = this.cache("scrollbar-size", a), x.viewport.bottom -= A.height), document.body.scrollHeight > window.innerHeight && (A = this.cache("scrollbar-size", a), x.viewport.right -= A.width), (-1 === ["", "static"].indexOf(document.body.style.position) || -1 === ["", "static"].indexOf(document.body.parentElement.style.position)) && (x.page.bottom = document.body.scrollHeight - b - f, x.page.right = document.body.scrollWidth - m - n), "undefined" != typeof this.options.optimizations && this.options.optimizations.moveElement !== !1 && "undefined" == typeof this.targetModifier && !function () {
                            var e = t.cache("target-offsetparent", function () {
                                return s(t.target)
                            }), o = t.cache("target-offsetparent-bounds", function () {
                                return r(e)
                            }), i = getComputedStyle(e), n = o, a = {};
                            if (["Top", "Left", "Bottom", "Right"].forEach(function (t) {
                                    a[t.toLowerCase()] = parseFloat(i["border" + t + "Width"])
                                }), o.right = document.body.scrollWidth - o.left - n.width + a.right, o.bottom = document.body.scrollHeight - o.top - n.height + a.bottom, x.page.top >= o.top + a.top && x.page.bottom >= o.bottom && x.page.left >= o.left + a.left && x.page.right >= o.right) {
                                var f = e.scrollTop, h = e.scrollLeft;
                                x.offset = {top: x.page.top - o.top + f - a.top, left: x.page.left - o.left + h - a.left}
                            }
                        }(), this.move(x), this.history.unshift(x), this.history.length > 3 && this.history.pop(), e && S(), !0
                    }
                }
            }, {
                key: "move", value: function (t) {
                    var e = this;
                    if ("undefined" != typeof this.element.parentNode) {
                        var o = {};
                        for (var i in t) {
                            o[i] = {};
                            for (var n in t[i]) {
                                for (var r = !1, a = 0; a < this.history.length; ++a) {
                                    var h = this.history[a];
                                    if ("undefined" != typeof h[i] && !g(h[i][n], t[i][n])) {
                                        r = !0;
                                        break
                                    }
                                }
                                r || (o[i][n] = !0)
                            }
                        }
                        var l = {top: "", left: "", right: "", bottom: ""}, d = function (t, o) {
                            var i = "undefined" != typeof e.options.optimizations,
                                n = i ? e.options.optimizations.gpu : null;
                            if (n !== !1) {
                                var r = void 0, s = void 0;
                                t.top ? (l.top = 0, r = o.top) : (l.bottom = 0, r = -o.bottom), t.left ? (l.left = 0, s = o.left) : (l.right = 0, s = -o.right), l[k] = "translateX(" + Math.round(s) + "px) translateY(" + Math.round(r) + "px)", "msTransform" !== k && (l[k] += " translateZ(0)")
                            } else t.top ? l.top = o.top + "px" : l.bottom = o.bottom + "px", t.left ? l.left = o.left + "px" : l.right = o.right + "px"
                        }, u = !1;
                        if ((o.page.top || o.page.bottom) && (o.page.left || o.page.right) ? (l.position = "absolute", d(o.page, t.page)) : (o.viewport.top || o.viewport.bottom) && (o.viewport.left || o.viewport.right) ? (l.position = "fixed", d(o.viewport, t.viewport)) : "undefined" != typeof o.offset && o.offset.top && o.offset.left ? !function () {
                                l.position = "absolute";
                                var i = e.cache("target-offsetparent", function () {
                                    return s(e.target)
                                });
                                s(e.element) !== i && T(function () {
                                    e.element.parentNode.removeChild(e.element), i.appendChild(e.element)
                                }), d(o.offset, t.offset), u = !0
                            }() : (l.position = "absolute", d({top: !0, left: !0}, t.page)), !u) {
                            for (var p = !0, c = this.element.parentNode; c && "BODY" !== c.tagName;) {
                                if ("static" !== getComputedStyle(c).position) {
                                    p = !1;
                                    break
                                }
                                c = c.parentNode
                            }
                            p || (this.element.parentNode.removeChild(this.element), document.body.appendChild(this.element))
                        }
                        var m = {}, v = !1;
                        for (var n in l) {
                            var y = l[n], b = this.element.style[n];
                            "" !== b && "" !== y && ["top", "left", "bottom", "right"].indexOf(n) >= 0 && (b = parseFloat(b), y = parseFloat(y)), b !== y && (v = !0, m[n] = y)
                        }
                        v && T(function () {
                            f(e.element.style, m)
                        })
                    }
                }
            }]), t
        }();
    N.modules = [], C.position = _;
    var R = f(N, C), M = function () {
            function t(t, e) {
                var o = [], i = !0, n = !1, r = void 0;
                try {
                    for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0) ;
                } catch (f) {
                    n = !0, r = f
                } finally {
                    try {
                        !i && a["return"] && a["return"]()
                    } finally {
                        if (n) throw r
                    }
                }
                return o
            }

            return function (e, o) {
                if (Array.isArray(e)) return e;
                if (Symbol.iterator in Object(e)) return t(e, o);
                throw new TypeError("Invalid attempt to destructure non-iterable instance")
            }
        }(), P = C.Utils, r = P.getBounds, f = P.extend, c = P.updateClasses, T = P.defer,
        U = ["left", "top", "right", "bottom"];
    C.modules.push({
        position: function (t) {
            var e = this, o = t.top, i = t.left, n = t.targetAttachment;
            if (!this.options.constraints) return !0;
            var s = this.cache("element-bounds", function () {
                return r(e.element)
            }), a = s.height, h = s.width;
            if (0 === h && 0 === a && "undefined" != typeof this.lastSize) {
                var l = this.lastSize;
                h = l.width, a = l.height
            }
            var d = this.cache("target-bounds", function () {
                return e.getTargetBounds()
            }), u = d.height, p = d.width, g = [this.getClass("pinned"), this.getClass("out-of-bounds")];
            this.options.constraints.forEach(function (t) {
                var e = t.outOfBoundsClass, o = t.pinnedClass;
                e && g.push(e), o && g.push(o)
            }), g.forEach(function (t) {
                ["left", "top", "right", "bottom"].forEach(function (e) {
                    g.push(t + "-" + e)
                })
            });
            var m = [], v = f({}, n), y = f({}, this.attachment);
            return this.options.constraints.forEach(function (t) {
                var r = t.to, s = t.attachment, f = t.pin;
                "undefined" == typeof s && (s = "");
                var l = void 0, d = void 0;
                if (s.indexOf(" ") >= 0) {
                    var c = s.split(" "), g = M(c, 2);
                    d = g[0], l = g[1]
                } else l = d = s;
                var w = b(e, r);
                ("target" === d || "both" === d) && (o < w[1] && "top" === v.top && (o += u, v.top = "bottom"), o + a > w[3] && "bottom" === v.top && (o -= u, v.top = "top")), "together" === d && (o < w[1] && "top" === v.top && ("bottom" === y.top ? (o += u, v.top = "bottom", o += a, y.top = "top") : "top" === y.top && (o += u, v.top = "bottom", o -= a, y.top = "bottom")), o + a > w[3] && "bottom" === v.top && ("top" === y.top ? (o -= u, v.top = "top", o -= a, y.top = "bottom") : "bottom" === y.top && (o -= u, v.top = "top", o += a, y.top = "top")), "middle" === v.top && (o + a > w[3] && "top" === y.top ? (o -= a, y.top = "bottom") : o < w[1] && "bottom" === y.top && (o += a, y.top = "top"))), ("target" === l || "both" === l) && (i < w[0] && "left" === v.left && (i += p, v.left = "right"), i + h > w[2] && "right" === v.left && (i -= p, v.left = "left")), "together" === l && (i < w[0] && "left" === v.left ? "right" === y.left ? (i += p, v.left = "right", i += h, y.left = "left") : "left" === y.left && (i += p, v.left = "right", i -= h, y.left = "right") : i + h > w[2] && "right" === v.left ? "left" === y.left ? (i -= p, v.left = "left", i -= h, y.left = "right") : "right" === y.left && (i -= p, v.left = "left", i += h, y.left = "left") : "center" === v.left && (i + h > w[2] && "left" === y.left ? (i -= h, y.left = "right") : i < w[0] && "right" === y.left && (i += h, y.left = "left"))), ("element" === d || "both" === d) && (o < w[1] && "bottom" === y.top && (o += a, y.top = "top"), o + a > w[3] && "top" === y.top && (o -= a, y.top = "bottom")), ("element" === l || "both" === l) && (i < w[0] && "right" === y.left && (i += h, y.left = "left"), i + h > w[2] && "left" === y.left && (i -= h, y.left = "right")), "string" == typeof f ? f = f.split(",").map(function (t) {
                    return t.trim()
                }) : f === !0 && (f = ["top", "left", "right", "bottom"]), f = f || [];
                var C = [], O = [];
                o < w[1] && (f.indexOf("top") >= 0 ? (o = w[1], C.push("top")) : O.push("top")), o + a > w[3] && (f.indexOf("bottom") >= 0 ? (o = w[3] - a, C.push("bottom")) : O.push("bottom")), i < w[0] && (f.indexOf("left") >= 0 ? (i = w[0], C.push("left")) : O.push("left")), i + h > w[2] && (f.indexOf("right") >= 0 ? (i = w[2] - h, C.push("right")) : O.push("right")), C.length && !function () {
                    var t = void 0;
                    t = "undefined" != typeof e.options.pinnedClass ? e.options.pinnedClass : e.getClass("pinned"), m.push(t), C.forEach(function (e) {
                        m.push(t + "-" + e)
                    })
                }(), O.length && !function () {
                    var t = void 0;
                    t = "undefined" != typeof e.options.outOfBoundsClass ? e.options.outOfBoundsClass : e.getClass("out-of-bounds"), m.push(t), O.forEach(function (e) {
                        m.push(t + "-" + e)
                    })
                }(), (C.indexOf("left") >= 0 || C.indexOf("right") >= 0) && (y.left = v.left = !1), (C.indexOf("top") >= 0 || C.indexOf("bottom") >= 0) && (y.top = v.top = !1), (v.top !== n.top || v.left !== n.left || y.top !== e.attachment.top || y.left !== e.attachment.left) && e.updateAttachClasses(y, v)
            }), T(function () {
                e.options.addTargetClasses !== !1 && c(e.target, m, g), c(e.element, m, g)
            }), {top: o, left: i}
        }
    });
    var P = C.Utils, r = P.getBounds, c = P.updateClasses, T = P.defer;
    C.modules.push({
        position: function (t) {
            var e = this, o = t.top, i = t.left, n = this.cache("element-bounds", function () {
                return r(e.element)
            }), s = n.height, a = n.width, f = this.getTargetBounds(), h = o + s, l = i + a, d = [];
            o <= f.bottom && h >= f.top && ["left", "right"].forEach(function (t) {
                var e = f[t];
                (e === i || e === l) && d.push(t)
            }), i <= f.right && l >= f.left && ["top", "bottom"].forEach(function (t) {
                var e = f[t];
                (e === o || e === h) && d.push(t)
            });
            var u = [], p = [], g = ["left", "top", "right", "bottom"];
            return u.push(this.getClass("abutted")), g.forEach(function (t) {
                u.push(e.getClass("abutted") + "-" + t)
            }), d.length && p.push(this.getClass("abutted")), d.forEach(function (t) {
                p.push(e.getClass("abutted") + "-" + t)
            }), T(function () {
                e.options.addTargetClasses !== !1 && c(e.target, p, u), c(e.element, p, u)
            }), !0
        }
    });
    var M = function () {
        function t(t, e) {
            var o = [], i = !0, n = !1, r = void 0;
            try {
                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (o.push(s.value), !e || o.length !== e); i = !0) ;
            } catch (f) {
                n = !0, r = f
            } finally {
                try {
                    !i && a["return"] && a["return"]()
                } finally {
                    if (n) throw r
                }
            }
            return o
        }

        return function (e, o) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return t(e, o);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }();
    return C.modules.push({
        position: function (t) {
            var e = t.top, o = t.left;
            if (this.options.shift) {
                var i = this.options.shift;
                "function" == typeof this.options.shift && (i = this.options.shift.call(this, {top: e, left: o}));
                var n = void 0, r = void 0;
                if ("string" == typeof i) {
                    i = i.split(" "), i[1] = i[1] || i[0];
                    var s = i, a = M(s, 2);
                    n = a[0], r = a[1], n = parseFloat(n, 10), r = parseFloat(r, 10)
                } else n = i.top, r = i.left;
                return e += n, o += r, {top: e, left: o}
            }
        }
    }), R
});
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");
+function (a) {
    "use strict";
    var b = a.fn.jquery.split(" ")[0].split(".");
    if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
}(jQuery), +function (a) {
    "use strict";

    function b() {
        var a = document.createElement("bootstrap"), b = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var c in b) if (void 0 !== a.style[c]) return {end: b[c]};
        return !1
    }

    a.fn.emulateTransitionEnd = function (b) {
        var c = !1, d = this;
        a(this).one("bsTransitionEnd", function () {
            c = !0
        });
        var e = function () {
            c || a(d).trigger(a.support.transition.end)
        };
        return setTimeout(e, b), this
    }, a(function () {
        a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = {
            bindType: a.support.transition.end,
            delegateType: a.support.transition.end,
            handle: function (b) {
                if (a(b.target).is(this)) return b.handleObj.handler.apply(this, arguments)
            }
        })
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var c = a(this), e = c.data("bs.alert");
            e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c)
        })
    }

    var c = '[data-dismiss="alert"]', d = function (b) {
        a(b).on("click", c, this.close)
    };
    d.VERSION = "3.3.7", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {
        function c() {
            g.detach().trigger("closed.bs.alert").remove()
        }

        var e = a(this), f = e.attr("data-target");
        f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));
        var g = a("#" === f ? [] : f);
        b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c())
    };
    var e = a.fn.alert;
    a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {
        return a.fn.alert = e, this
    }, a(document).on("click.bs.alert.data-api", c, d.prototype.close)
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.button"), f = "object" == typeof b && b;
            e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b)
        })
    }

    var c = function (b, d) {
        this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1
    };
    c.VERSION = "3.3.7", c.DEFAULTS = {loadingText: "loading..."}, c.prototype.setState = function (b) {
        var c = "disabled", d = this.$element, e = d.is("input") ? "val" : "html", f = d.data();
        b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () {
            d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c).prop(c, !0)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c).prop(c, !1))
        }, this), 0)
    }, c.prototype.toggle = function () {
        var a = !0, b = this.$element.closest('[data-toggle="buttons"]');
        if (b.length) {
            var c = this.$element.find("input");
            "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var d = a.fn.button;
    a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {
        return a.fn.button = d, this
    }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (c) {
        var d = a(c.target).closest(".btn");
        b.call(d, "toggle"), a(c.target).is('input[type="radio"], input[type="checkbox"]') || (c.preventDefault(), d.is("input,button") ? d.trigger("focus") : d.find("input:visible,button:visible").first().trigger("focus"))
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (b) {
        a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.carousel"),
                f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b),
                g = "string" == typeof b ? b : f.slide;
            e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle()
        })
    }

    var c = function (b, c) {
        this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this))
    };
    c.VERSION = "3.3.7", c.TRANSITION_DURATION = 600, c.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, c.prototype.keydown = function (a) {
        if (!/input|textarea/i.test(a.target.tagName)) {
            switch (a.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            a.preventDefault()
        }
    }, c.prototype.cycle = function (b) {
        return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this
    }, c.prototype.getItemIndex = function (a) {
        return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active)
    }, c.prototype.getItemForDirection = function (a, b) {
        var c = this.getItemIndex(b), d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;
        if (d && !this.options.wrap) return b;
        var e = "prev" == a ? -1 : 1, f = (c + e) % this.$items.length;
        return this.$items.eq(f)
    }, c.prototype.to = function (a) {
        var b = this, c = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(a > this.$items.length - 1 || a < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function () {
            b.to(a)
        }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a))
    }, c.prototype.pause = function (b) {
        return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
    }, c.prototype.next = function () {
        if (!this.sliding) return this.slide("next")
    }, c.prototype.prev = function () {
        if (!this.sliding) return this.slide("prev")
    }, c.prototype.slide = function (b, d) {
        var e = this.$element.find(".item.active"), f = d || this.getItemForDirection(b, e), g = this.interval,
            h = "next" == b ? "left" : "right", i = this;
        if (f.hasClass("active")) return this.sliding = !1;
        var j = f[0], k = a.Event("slide.bs.carousel", {relatedTarget: j, direction: h});
        if (this.$element.trigger(k), !k.isDefaultPrevented()) {
            if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var l = a(this.$indicators.children()[this.getItemIndex(f)]);
                l && l.addClass("active")
            }
            var m = a.Event("slid.bs.carousel", {relatedTarget: j, direction: h});
            return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () {
                f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () {
                    i.$element.trigger(m)
                }, 0)
            }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this
        }
    };
    var d = a.fn.carousel;
    a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {
        return a.fn.carousel = d, this
    };
    var e = function (c) {
        var d, e = a(this), f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));
        if (f.hasClass("carousel")) {
            var g = a.extend({}, f.data(), e.data()), h = e.attr("data-slide-to");
            h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault()
        }
    };
    a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () {
        a('[data-ride="carousel"]').each(function () {
            var c = a(this);
            b.call(c, c.data())
        })
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");
        return a(d)
    }

    function c(b) {
        return this.each(function () {
            var c = a(this), e = c.data("bs.collapse"),
                f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b);
            !e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]()
        })
    }

    var d = function (b, c) {
        this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
    };
    d.VERSION = "3.3.7", d.TRANSITION_DURATION = 350, d.DEFAULTS = {toggle: !0}, d.prototype.dimension = function () {
        var a = this.$element.hasClass("width");
        return a ? "width" : "height"
    }, d.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
                var f = a.Event("show.bs.collapse");
                if (this.$element.trigger(f), !f.isDefaultPrevented()) {
                    e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));
                    var g = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var h = function () {
                        this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                    };
                    if (!a.support.transition) return h.call(this);
                    var i = a.camelCase(["scroll", g].join("-"));
                    this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])
                }
            }
        }
    }, d.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var b = a.Event("hide.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                var c = this.dimension();
                this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var e = function () {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this)
            }
        }
    }, d.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, d.prototype.getParent = function () {
        return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function (c, d) {
            var e = a(d);
            this.addAriaAndCollapsedClass(b(e), e)
        }, this)).end()
    }, d.prototype.addAriaAndCollapsedClass = function (a, b) {
        var c = a.hasClass("in");
        a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c)
    };
    var e = a.fn.collapse;
    a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {
        return a.fn.collapse = e, this
    }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (d) {
        var e = a(this);
        e.attr("data-target") || d.preventDefault();
        var f = b(e), g = f.data("bs.collapse"), h = g ? "toggle" : e.data();
        c.call(f, h)
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        var c = b.attr("data-target");
        c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
        var d = c && a(c);
        return d && d.length ? d : b.parent()
    }

    function c(c) {
        c && 3 === c.which || (a(e).remove(), a(f).each(function () {
            var d = a(this), e = b(d), f = {relatedTarget: this};
            e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))))
        }))
    }

    function d(b) {
        return this.each(function () {
            var c = a(this), d = c.data("bs.dropdown");
            d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c)
        })
    }

    var e = ".dropdown-backdrop", f = '[data-toggle="dropdown"]', g = function (b) {
        a(b).on("click.bs.dropdown", this.toggle)
    };
    g.VERSION = "3.3.7", g.prototype.toggle = function (d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
            var f = b(e), g = f.hasClass("open");
            if (c(), !g) {
                "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
                var h = {relatedTarget: this};
                if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h))
            }
            return !1
        }
    }, g.prototype.keydown = function (c) {
        if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
            var d = a(this);
            if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
                var e = b(d), g = e.hasClass("open");
                if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");
                var h = " li:not(.disabled):visible a", i = e.find(".dropdown-menu" + h);
                if (i.length) {
                    var j = i.index(c.target);
                    38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus")
                }
            }
        }
    };
    var h = a.fn.dropdown;
    a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {
        return a.fn.dropdown = h, this
    }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) {
        a.stopPropagation()
    }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
}(jQuery), +function (a) {
    "use strict";

    function b(b, d) {
        return this.each(function () {
            var e = a(this), f = e.data("bs.modal"), g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
            f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d)
        })
    }

    var c = function (b, c) {
        this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    c.VERSION = "3.3.7", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, c.prototype.toggle = function (a) {
        return this.isShown ? this.hide() : this.show(a)
    }, c.prototype.show = function (b) {
        var d = this, e = a.Event("show.bs.modal", {relatedTarget: b});
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
            d.$element.one("mouseup.dismiss.bs.modal", function (b) {
                a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function () {
            var e = a.support.transition && d.$element.hasClass("fade");
            d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();
            var f = a.Event("shown.bs.modal", {relatedTarget: b});
            e ? d.$dialog.one("bsTransitionEnd", function () {
                d.$element.trigger("focus").trigger(f)
            }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
        }))
    }, c.prototype.hide = function (b) {
        b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
    }, c.prototype.enforceFocus = function () {
        a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) {
            document === a.target || this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
        }, this))
    }, c.prototype.escape = function () {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) {
            27 == a.which && this.hide()
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, c.prototype.resize = function () {
        this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
    }, c.prototype.hideModal = function () {
        var a = this;
        this.$element.hide(), this.backdrop(function () {
            a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal")
        })
    }, c.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, c.prototype.backdrop = function (b) {
        var d = this, e = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var f = a.support.transition && e;
            if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) {
                    return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
            f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var g = function () {
                d.removeBackdrop(), b && b()
            };
            a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
        } else b && b()
    }, c.prototype.handleUpdate = function () {
        this.adjustDialog()
    }, c.prototype.adjustDialog = function () {
        var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : ""
        })
    }, c.prototype.resetAdjustments = function () {
        this.$element.css({paddingLeft: "", paddingRight: ""})
    }, c.prototype.checkScrollbar = function () {
        var a = window.innerWidth;
        if (!a) {
            var b = document.documentElement.getBoundingClientRect();
            a = b.right - Math.abs(b.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar()
    }, c.prototype.setScrollbar = function () {
        var a = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
    }, c.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }, c.prototype.measureScrollbar = function () {
        var a = document.createElement("div");
        a.className = "modal-scrollbar-measure", this.$body.append(a);
        var b = a.offsetWidth - a.clientWidth;
        return this.$body[0].removeChild(a), b
    };
    var d = a.fn.modal;
    a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {
        return a.fn.modal = d, this
    }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (c) {
        var d = a(this), e = d.attr("href"), f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
            g = f.data("bs.modal") ? "toggle" : a.extend({remote: !/#/.test(e) && e}, f.data(), d.data());
        d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) {
            a.isDefaultPrevented() || f.one("hidden.bs.modal", function () {
                d.is(":visible") && d.trigger("focus")
            })
        }), b.call(f, g, this)
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.tooltip"), f = "object" == typeof b && b;
            !e && /destroy|hide/.test(b) || (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }

    var c = function (a, b) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b)
    };
    c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {selector: "body", padding: 0}
    }, c.prototype.init = function (b, c, d) {
        if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
                click: !1,
                hover: !1,
                focus: !1
            }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
            var g = e[f];
            if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this)); else if ("manual" != g) {
                var h = "hover" == g ? "mouseenter" : "focusin", i = "hover" == g ? "mouseleave" : "focusout";
                this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = a.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }, c.prototype.getDefaults = function () {
        return c.DEFAULTS
    }, c.prototype.getOptions = function (b) {
        return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = {
            show: b.delay,
            hide: b.delay
        }), b
    }, c.prototype.getDelegateOptions = function () {
        var b = {}, c = this.getDefaults();
        return this._options && a.each(this._options, function (a, d) {
            c[a] != d && (b[a] = d)
        }), b
    }, c.prototype.enter = function (b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
        return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void(c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void(c.timeout = setTimeout(function () {
            "in" == c.hoverState && c.show()
        }, c.options.delay.show)) : c.show())
    }, c.prototype.isInStateTrue = function () {
        for (var a in this.inState) if (this.inState[a]) return !0;
        return !1
    }, c.prototype.leave = function (b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
        if (c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), !c.isInStateTrue()) return clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void(c.timeout = setTimeout(function () {
            "out" == c.hoverState && c.hide()
        }, c.options.delay.hide)) : c.hide()
    }, c.prototype.show = function () {
        var b = a.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(b);
            var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (b.isDefaultPrevented() || !d) return;
            var e = this, f = this.tip(), g = this.getUID(this.type);
            this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");
            var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
                i = /\s?auto?\s?/i, j = i.test(h);
            j && (h = h.replace(i, "") || "top"), f.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var k = this.getPosition(), l = f[0].offsetWidth, m = f[0].offsetHeight;
            if (j) {
                var n = h, o = this.getPosition(this.$viewport);
                h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h)
            }
            var p = this.getCalculatedOffset(h, k, l, m);
            this.applyPlacement(p, h);
            var q = function () {
                var a = e.hoverState;
                e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e)
            };
            a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q()
        }
    }, c.prototype.applyPlacement = function (b, c) {
        var d = this.tip(), e = d[0].offsetWidth, f = d[0].offsetHeight, g = parseInt(d.css("margin-top"), 10),
            h = parseInt(d.css("margin-left"), 10);
        isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({
            using: function (a) {
                d.css({top: Math.round(a.top), left: Math.round(a.left)})
            }
        }, b), 0), d.addClass("in");
        var i = d[0].offsetWidth, j = d[0].offsetHeight;
        "top" == c && j != f && (b.top = b.top + f - j);
        var k = this.getViewportAdjustedDelta(c, b, i, j);
        k.left ? b.left += k.left : b.top += k.top;
        var l = /top|bottom/.test(c), m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
            n = l ? "offsetWidth" : "offsetHeight";
        d.offset(b), this.replaceArrow(m, d[0][n], l)
    }, c.prototype.replaceArrow = function (a, b, c) {
        this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "")
    }, c.prototype.setContent = function () {
        var a = this.tip(), b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right")
    }, c.prototype.hide = function (b) {
        function d() {
            "in" != e.hoverState && f.detach(), e.$element && e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b()
        }

        var e = this, f = a(this.$tip), g = a.Event("hide.bs." + this.type);
        if (this.$element.trigger(g), !g.isDefaultPrevented()) return f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this
    }, c.prototype.fixTitle = function () {
        var a = this.$element;
        (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "")
    }, c.prototype.hasContent = function () {
        return this.getTitle()
    }, c.prototype.getPosition = function (b) {
        b = b || this.$element;
        var c = b[0], d = "BODY" == c.tagName, e = c.getBoundingClientRect();
        null == e.width && (e = a.extend({}, e, {width: e.right - e.left, height: e.bottom - e.top}));
        var f = window.SVGElement && c instanceof window.SVGElement, g = d ? {top: 0, left: 0} : f ? null : b.offset(),
            h = {scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop()},
            i = d ? {width: a(window).width(), height: a(window).height()} : null;
        return a.extend({}, e, h, i, g)
    }, c.prototype.getCalculatedOffset = function (a, b, c, d) {
        return "bottom" == a ? {
            top: b.top + b.height,
            left: b.left + b.width / 2 - c / 2
        } : "top" == a ? {
            top: b.top - d,
            left: b.left + b.width / 2 - c / 2
        } : "left" == a ? {top: b.top + b.height / 2 - d / 2, left: b.left - c} : {
            top: b.top + b.height / 2 - d / 2,
            left: b.left + b.width
        }
    }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {
        var e = {top: 0, left: 0};
        if (!this.$viewport) return e;
        var f = this.options.viewport && this.options.viewport.padding || 0, g = this.getPosition(this.$viewport);
        if (/right|left/.test(a)) {
            var h = b.top - f - g.scroll, i = b.top + f - g.scroll + d;
            h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i)
        } else {
            var j = b.left - f, k = b.left + f + c;
            j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k)
        }
        return e
    }, c.prototype.getTitle = function () {
        var a, b = this.$element, c = this.options;
        return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title)
    }, c.prototype.getUID = function (a) {
        do a += ~~(1e6 * Math.random()); while (document.getElementById(a));
        return a
    }, c.prototype.tip = function () {
        if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }, c.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }, c.prototype.enable = function () {
        this.enabled = !0
    }, c.prototype.disable = function () {
        this.enabled = !1
    }, c.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }, c.prototype.toggle = function (b) {
        var c = this;
        b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c)
    }, c.prototype.destroy = function () {
        var a = this;
        clearTimeout(this.timeout), this.hide(function () {
            a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null, a.$element = null
        })
    };
    var d = a.fn.tooltip;
    a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {
        return a.fn.tooltip = d, this
    }
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.popover"), f = "object" == typeof b && b;
            !e && /destroy|hide/.test(b) || (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]())
        })
    }

    var c = function (a, b) {
        this.init("popover", a, b)
    };
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    c.VERSION = "3.3.7", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {
        return c.DEFAULTS
    }, c.prototype.setContent = function () {
        var a = this.tip(), b = this.getTitle(), c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide()
    }, c.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }, c.prototype.getContent = function () {
        var a = this.$element, b = this.options;
        return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content)
    }, c.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var d = a.fn.popover;
    a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {
        return a.fn.popover = d, this
    }
}(jQuery), +function (a) {
    "use strict";

    function b(c, d) {
        this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process()
    }

    function c(c) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.scrollspy"), f = "object" == typeof c && c;
            e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]()
        })
    }

    b.VERSION = "3.3.7", b.DEFAULTS = {offset: 10}, b.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }, b.prototype.refresh = function () {
        var b = this, c = "offset", d = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
            var b = a(this), e = b.data("target") || b.attr("href"), f = /^#./.test(e) && a(e);
            return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null
        }).sort(function (a, b) {
            return a[0] - b[0]
        }).each(function () {
            b.offsets.push(this[0]), b.targets.push(this[1])
        })
    }, b.prototype.process = function () {
        var a, b = this.$scrollElement.scrollTop() + this.options.offset, c = this.getScrollHeight(),
            d = this.options.offset + c - this.$scrollElement.height(), e = this.offsets, f = this.targets,
            g = this.activeTarget;
        if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);
        if (g && b < e[0]) return this.activeTarget = null, this.clear();
        for (a = e.length; a--;) g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a])
    }, b.prototype.activate = function (b) {
        this.activeTarget = b, this.clear();
        var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
            d = a(c).parents("li").addClass("active");
        d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy")
    }, b.prototype.clear = function () {
        a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var d = a.fn.scrollspy;
    a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {
        return a.fn.scrollspy = d, this
    }, a(window).on("load.bs.scrollspy.data-api", function () {
        a('[data-spy="scroll"]').each(function () {
            var b = a(this);
            c.call(b, b.data())
        })
    })
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.tab");
            e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]()
        })
    }

    var c = function (b) {
        this.element = a(b)
    };
    c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.prototype.show = function () {
        var b = this.element, c = b.closest("ul:not(.dropdown-menu)"), d = b.data("target");
        if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
            var e = c.find(".active:last a"), f = a.Event("hide.bs.tab", {relatedTarget: b[0]}),
                g = a.Event("show.bs.tab", {relatedTarget: e[0]});
            if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                var h = a(d);
                this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {
                    e.trigger({type: "hidden.bs.tab", relatedTarget: b[0]}), b.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: e[0]
                    })
                })
            }
        }
    }, c.prototype.activate = function (b, d, e) {
        function f() {
            g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e()
        }

        var g = d.find("> .active"),
            h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
        g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in")
    };
    var d = a.fn.tab;
    a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {
        return a.fn.tab = d, this
    };
    var e = function (c) {
        c.preventDefault(), b.call(a(this), "show")
    };
    a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
}(jQuery), +function (a) {
    "use strict";

    function b(b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.affix"), f = "object" == typeof b && b;
            e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]()
        })
    }

    var c = function (b, d) {
        this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
    };
    c.VERSION = "3.3.7", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = {
        offset: 0,
        target: window
    }, c.prototype.getState = function (a, b, c, d) {
        var e = this.$target.scrollTop(), f = this.$element.offset(), g = this.$target.height();
        if (null != c && "top" == this.affixed) return e < c && "top";
        if ("bottom" == this.affixed) return null != c ? !(e + this.unpin <= f.top) && "bottom" : !(e + g <= a - d) && "bottom";
        var h = null == this.affixed, i = h ? e : f.top, j = h ? g : b;
        return null != c && e <= c ? "top" : null != d && i + j >= a - d && "bottom"
    }, c.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(c.RESET).addClass("affix");
        var a = this.$target.scrollTop(), b = this.$element.offset();
        return this.pinnedOffset = b.top - a
    }, c.prototype.checkPositionWithEventLoop = function () {
        setTimeout(a.proxy(this.checkPosition, this), 1)
    }, c.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
            var b = this.$element.height(), d = this.options.offset, e = d.top, f = d.bottom,
                g = Math.max(a(document).height(), a(document.body).height());
            "object" != typeof d && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));
            var h = this.getState(g, b, e, f);
            if (this.affixed != h) {
                null != this.unpin && this.$element.css("top", "");
                var i = "affix" + (h ? "-" + h : ""), j = a.Event(i + ".bs.affix");
                if (this.$element.trigger(j), j.isDefaultPrevented()) return;
                this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == h && this.$element.offset({top: g - b - f})
        }
    };
    var d = a.fn.affix;
    a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {
        return a.fn.affix = d, this
    }, a(window).on("load", function () {
        a('[data-spy="affix"]').each(function () {
            var c = a(this), d = c.data();
            d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d)
        })
    })
}(jQuery);
/*!
 DataTables 1.10.15
 2008-2017 SpryMedia Ltd - datatables.net/license
*/
(function (h) {
    "function" === typeof define && define.amd ? define(["jquery"], function (E) {
        return h(E, window, document)
    }) : "object" === typeof exports ? module.exports = function (E, H) {
        E || (E = window);
        H || (H = "undefined" !== typeof window ? require("jquery") : require("jquery")(E));
        return h(H, E, E.document)
    } : h(jQuery, window, document)
})(function (h, E, H, k) {
    function Y(a) {
        var b, c, d = {};
        h.each(a, function (e) {
            if ((b = e.match(/^([^A-Z]+?)([A-Z])/)) && -1 !== "a aa ai ao as b fn i m o s ".indexOf(b[1] + " ")) c = e.replace(b[0], b[2].toLowerCase()),
                d[c] = e, "o" === b[1] && Y(a[e])
        });
        a._hungarianMap = d
    }

    function J(a, b, c) {
        a._hungarianMap || Y(a);
        var d;
        h.each(b, function (e) {
            d = a._hungarianMap[e];
            if (d !== k && (c || b[d] === k)) "o" === d.charAt(0) ? (b[d] || (b[d] = {}), h.extend(!0, b[d], b[e]), J(a[d], b[d], c)) : b[d] = b[e]
        })
    }

    function Fa(a) {
        var b = m.defaults.oLanguage, c = a.sZeroRecords;
        !a.sEmptyTable && (c && "No data available in table" === b.sEmptyTable) && F(a, a, "sZeroRecords", "sEmptyTable");
        !a.sLoadingRecords && (c && "Loading..." === b.sLoadingRecords) && F(a, a, "sZeroRecords", "sLoadingRecords");
        a.sInfoThousands && (a.sThousands = a.sInfoThousands);
        (a = a.sDecimal) && fb(a)
    }

    function gb(a) {
        A(a, "ordering", "bSort");
        A(a, "orderMulti", "bSortMulti");
        A(a, "orderClasses", "bSortClasses");
        A(a, "orderCellsTop", "bSortCellsTop");
        A(a, "order", "aaSorting");
        A(a, "orderFixed", "aaSortingFixed");
        A(a, "paging", "bPaginate");
        A(a, "pagingType", "sPaginationType");
        A(a, "pageLength", "iDisplayLength");
        A(a, "searching", "bFilter");
        "boolean" === typeof a.sScrollX && (a.sScrollX = a.sScrollX ? "100%" : "");
        "boolean" === typeof a.scrollX && (a.scrollX =
            a.scrollX ? "100%" : "");
        if (a = a.aoSearchCols) for (var b = 0, c = a.length; b < c; b++) a[b] && J(m.models.oSearch, a[b])
    }

    function hb(a) {
        A(a, "orderable", "bSortable");
        A(a, "orderData", "aDataSort");
        A(a, "orderSequence", "asSorting");
        A(a, "orderDataType", "sortDataType");
        var b = a.aDataSort;
        "number" === typeof b && !h.isArray(b) && (a.aDataSort = [b])
    }

    function ib(a) {
        if (!m.__browser) {
            var b = {};
            m.__browser = b;
            var c = h("<div/>").css({
                    position: "fixed",
                    top: 0,
                    left: -1 * h(E).scrollLeft(),
                    height: 1,
                    width: 1,
                    overflow: "hidden"
                }).append(h("<div/>").css({
                    position: "absolute",
                    top: 1, left: 1, width: 100, overflow: "scroll"
                }).append(h("<div/>").css({width: "100%", height: 10}))).appendTo("body"), d = c.children(),
                e = d.children();
            b.barWidth = d[0].offsetWidth - d[0].clientWidth;
            b.bScrollOversize = 100 === e[0].offsetWidth && 100 !== d[0].clientWidth;
            b.bScrollbarLeft = 1 !== Math.round(e.offset().left);
            b.bBounding = c[0].getBoundingClientRect().width ? !0 : !1;
            c.remove()
        }
        h.extend(a.oBrowser, m.__browser);
        a.oScroll.iBarWidth = m.__browser.barWidth
    }

    function jb(a, b, c, d, e, f) {
        var g, j = !1;
        c !== k && (g = c, j = !0);
        for (; d !==
               e;) a.hasOwnProperty(d) && (g = j ? b(g, a[d], d, a) : a[d], j = !0, d += f);
        return g
    }

    function Ga(a, b) {
        var c = m.defaults.column, d = a.aoColumns.length, c = h.extend({}, m.models.oColumn, c, {
            nTh: b ? b : H.createElement("th"),
            sTitle: c.sTitle ? c.sTitle : b ? b.innerHTML : "",
            aDataSort: c.aDataSort ? c.aDataSort : [d],
            mData: c.mData ? c.mData : d,
            idx: d
        });
        a.aoColumns.push(c);
        c = a.aoPreSearchCols;
        c[d] = h.extend({}, m.models.oSearch, c[d]);
        la(a, d, h(b).data())
    }

    function la(a, b, c) {
        var b = a.aoColumns[b], d = a.oClasses, e = h(b.nTh);
        if (!b.sWidthOrig) {
            b.sWidthOrig =
                e.attr("width") || null;
            var f = (e.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
            f && (b.sWidthOrig = f[1])
        }
        c !== k && null !== c && (hb(c), J(m.defaults.column, c), c.mDataProp !== k && !c.mData && (c.mData = c.mDataProp), c.sType && (b._sManualType = c.sType), c.className && !c.sClass && (c.sClass = c.className), h.extend(b, c), F(b, c, "sWidth", "sWidthOrig"), c.iDataSort !== k && (b.aDataSort = [c.iDataSort]), F(b, c, "aDataSort"));
        var g = b.mData, j = R(g), i = b.mRender ? R(b.mRender) : null, c = function (a) {
            return "string" === typeof a && -1 !== a.indexOf("@")
        };
        b._bAttrSrc = h.isPlainObject(g) && (c(g.sort) || c(g.type) || c(g.filter));
        b._setter = null;
        b.fnGetData = function (a, b, c) {
            var d = j(a, b, k, c);
            return i && b ? i(d, b, a, c) : d
        };
        b.fnSetData = function (a, b, c) {
            return S(g)(a, b, c)
        };
        "number" !== typeof g && (a._rowReadObject = !0);
        a.oFeatures.bSort || (b.bSortable = !1, e.addClass(d.sSortableNone));
        a = -1 !== h.inArray("asc", b.asSorting);
        c = -1 !== h.inArray("desc", b.asSorting);
        !b.bSortable || !a && !c ? (b.sSortingClass = d.sSortableNone, b.sSortingClassJUI = "") : a && !c ? (b.sSortingClass = d.sSortableAsc, b.sSortingClassJUI =
            d.sSortJUIAscAllowed) : !a && c ? (b.sSortingClass = d.sSortableDesc, b.sSortingClassJUI = d.sSortJUIDescAllowed) : (b.sSortingClass = d.sSortable, b.sSortingClassJUI = d.sSortJUI)
    }

    function Z(a) {
        if (!1 !== a.oFeatures.bAutoWidth) {
            var b = a.aoColumns;
            Ha(a);
            for (var c = 0, d = b.length; c < d; c++) b[c].nTh.style.width = b[c].sWidth
        }
        b = a.oScroll;
        ("" !== b.sY || "" !== b.sX) && ma(a);
        s(a, null, "column-sizing", [a])
    }

    function $(a, b) {
        var c = na(a, "bVisible");
        return "number" === typeof c[b] ? c[b] : null
    }

    function aa(a, b) {
        var c = na(a, "bVisible"), c = h.inArray(b,
            c);
        return -1 !== c ? c : null
    }

    function ba(a) {
        var b = 0;
        h.each(a.aoColumns, function (a, d) {
            d.bVisible && "none" !== h(d.nTh).css("display") && b++
        });
        return b
    }

    function na(a, b) {
        var c = [];
        h.map(a.aoColumns, function (a, e) {
            a[b] && c.push(e)
        });
        return c
    }

    function Ia(a) {
        var b = a.aoColumns, c = a.aoData, d = m.ext.type.detect, e, f, g, j, i, h, l, q, r;
        e = 0;
        for (f = b.length; e < f; e++) if (l = b[e], r = [], !l.sType && l._sManualType) l.sType = l._sManualType; else if (!l.sType) {
            g = 0;
            for (j = d.length; g < j; g++) {
                i = 0;
                for (h = c.length; i < h; i++) {
                    r[i] === k && (r[i] = B(a, i, e, "type"));
                    q = d[g](r[i], a);
                    if (!q && g !== d.length - 1) break;
                    if ("html" === q) break
                }
                if (q) {
                    l.sType = q;
                    break
                }
            }
            l.sType || (l.sType = "string")
        }
    }

    function kb(a, b, c, d) {
        var e, f, g, j, i, n, l = a.aoColumns;
        if (b) for (e = b.length - 1; 0 <= e; e--) {
            n = b[e];
            var q = n.targets !== k ? n.targets : n.aTargets;
            h.isArray(q) || (q = [q]);
            f = 0;
            for (g = q.length; f < g; f++) if ("number" === typeof q[f] && 0 <= q[f]) {
                for (; l.length <= q[f];) Ga(a);
                d(q[f], n)
            } else if ("number" === typeof q[f] && 0 > q[f]) d(l.length + q[f], n); else if ("string" === typeof q[f]) {
                j = 0;
                for (i = l.length; j < i; j++) ("_all" == q[f] || h(l[j].nTh).hasClass(q[f])) &&
                d(j, n)
            }
        }
        if (c) {
            e = 0;
            for (a = c.length; e < a; e++) d(e, c[e])
        }
    }

    function N(a, b, c, d) {
        var e = a.aoData.length, f = h.extend(!0, {}, m.models.oRow, {src: c ? "dom" : "data", idx: e});
        f._aData = b;
        a.aoData.push(f);
        for (var g = a.aoColumns, j = 0, i = g.length; j < i; j++) g[j].sType = null;
        a.aiDisplayMaster.push(e);
        b = a.rowIdFn(b);
        b !== k && (a.aIds[b] = f);
        (c || !a.oFeatures.bDeferRender) && Ja(a, e, c, d);
        return e
    }

    function oa(a, b) {
        var c;
        b instanceof h || (b = h(b));
        return b.map(function (b, e) {
            c = Ka(a, e);
            return N(a, c.data, e, c.cells)
        })
    }

    function B(a, b, c, d) {
        var e = a.iDraw,
            f = a.aoColumns[c], g = a.aoData[b]._aData, j = f.sDefaultContent,
            i = f.fnGetData(g, d, {settings: a, row: b, col: c});
        if (i === k) return a.iDrawError != e && null === j && (K(a, 0, "Requested unknown parameter " + ("function" == typeof f.mData ? "{function}" : "'" + f.mData + "'") + " for row " + b + ", column " + c, 4), a.iDrawError = e), j;
        if ((i === g || null === i) && null !== j && d !== k) i = j; else if ("function" === typeof i) return i.call(g);
        return null === i && "display" == d ? "" : i
    }

    function lb(a, b, c, d) {
        a.aoColumns[c].fnSetData(a.aoData[b]._aData, d, {settings: a, row: b, col: c})
    }

    function La(a) {
        return h.map(a.match(/(\\.|[^\.])+/g) || [""], function (a) {
            return a.replace(/\\\./g, ".")
        })
    }

    function R(a) {
        if (h.isPlainObject(a)) {
            var b = {};
            h.each(a, function (a, c) {
                c && (b[a] = R(c))
            });
            return function (a, c, f, g) {
                var j = b[c] || b._;
                return j !== k ? j(a, c, f, g) : a
            }
        }
        if (null === a) return function (a) {
            return a
        };
        if ("function" === typeof a) return function (b, c, f, g) {
            return a(b, c, f, g)
        };
        if ("string" === typeof a && (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))) {
            var c = function (a, b, f) {
                var g, j;
                if ("" !== f) {
                    j = La(f);
                    for (var i = 0, n = j.length; i < n; i++) {
                        f = j[i].match(ca);
                        g = j[i].match(V);
                        if (f) {
                            j[i] = j[i].replace(ca, "");
                            "" !== j[i] && (a = a[j[i]]);
                            g = [];
                            j.splice(0, i + 1);
                            j = j.join(".");
                            if (h.isArray(a)) {
                                i = 0;
                                for (n = a.length; i < n; i++) g.push(c(a[i], b, j))
                            }
                            a = f[0].substring(1, f[0].length - 1);
                            a = "" === a ? g : g.join(a);
                            break
                        } else if (g) {
                            j[i] = j[i].replace(V, "");
                            a = a[j[i]]();
                            continue
                        }
                        if (null === a || a[j[i]] === k) return k;
                        a = a[j[i]]
                    }
                }
                return a
            };
            return function (b, e) {
                return c(b, e, a)
            }
        }
        return function (b) {
            return b[a]
        }
    }

    function S(a) {
        if (h.isPlainObject(a)) return S(a._);
        if (null === a) return function () {
        };
        if ("function" === typeof a) return function (b, d, e) {
            a(b, "set", d, e)
        };
        if ("string" === typeof a && (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))) {
            var b = function (a, d, e) {
                var e = La(e), f;
                f = e[e.length - 1];
                for (var g, j, i = 0, n = e.length - 1; i < n; i++) {
                    g = e[i].match(ca);
                    j = e[i].match(V);
                    if (g) {
                        e[i] = e[i].replace(ca, "");
                        a[e[i]] = [];
                        f = e.slice();
                        f.splice(0, i + 1);
                        g = f.join(".");
                        if (h.isArray(d)) {
                            j = 0;
                            for (n = d.length; j < n; j++) f = {}, b(f, d[j], g), a[e[i]].push(f)
                        } else a[e[i]] = d;
                        return
                    }
                    j && (e[i] = e[i].replace(V,
                        ""), a = a[e[i]](d));
                    if (null === a[e[i]] || a[e[i]] === k) a[e[i]] = {};
                    a = a[e[i]]
                }
                if (f.match(V)) a[f.replace(V, "")](d); else a[f.replace(ca, "")] = d
            };
            return function (c, d) {
                return b(c, d, a)
            }
        }
        return function (b, d) {
            b[a] = d
        }
    }

    function Ma(a) {
        return D(a.aoData, "_aData")
    }

    function pa(a) {
        a.aoData.length = 0;
        a.aiDisplayMaster.length = 0;
        a.aiDisplay.length = 0;
        a.aIds = {}
    }

    function qa(a, b, c) {
        for (var d = -1, e = 0, f = a.length; e < f; e++) a[e] == b ? d = e : a[e] > b && a[e]--;
        -1 != d && c === k && a.splice(d, 1)
    }

    function da(a, b, c, d) {
        var e = a.aoData[b], f, g = function (c, d) {
            for (; c.childNodes.length;) c.removeChild(c.firstChild);
            c.innerHTML = B(a, b, d, "display")
        };
        if ("dom" === c || (!c || "auto" === c) && "dom" === e.src) e._aData = Ka(a, e, d, d === k ? k : e._aData).data; else {
            var j = e.anCells;
            if (j) if (d !== k) g(j[d], d); else {
                c = 0;
                for (f = j.length; c < f; c++) g(j[c], c)
            }
        }
        e._aSortData = null;
        e._aFilterData = null;
        g = a.aoColumns;
        if (d !== k) g[d].sType = null; else {
            c = 0;
            for (f = g.length; c < f; c++) g[c].sType = null;
            Na(a, e)
        }
    }

    function Ka(a, b, c, d) {
        var e = [], f = b.firstChild, g, j, i = 0, n, l = a.aoColumns, q = a._rowReadObject,
            d = d !== k ? d : q ? {} : [], r = function (a, b) {
                if ("string" === typeof a) {
                    var c = a.indexOf("@");
                    -1 !== c && (c = a.substring(c + 1), S(a)(d, b.getAttribute(c)))
                }
            }, m = function (a) {
                if (c === k || c === i) j = l[i], n = h.trim(a.innerHTML), j && j._bAttrSrc ? (S(j.mData._)(d, n), r(j.mData.sort, a), r(j.mData.type, a), r(j.mData.filter, a)) : q ? (j._setter || (j._setter = S(j.mData)), j._setter(d, n)) : d[i] = n;
                i++
            };
        if (f) for (; f;) {
            g = f.nodeName.toUpperCase();
            if ("TD" == g || "TH" == g) m(f), e.push(f);
            f = f.nextSibling
        } else {
            e = b.anCells;
            f = 0;
            for (g = e.length; f < g; f++) m(e[f])
        }
        if (b = b.firstChild ? b : b.nTr) (b = b.getAttribute("id")) && S(a.rowId)(d, b);
        return {data: d, cells: e}
    }

    function Ja(a, b, c, d) {
        var e = a.aoData[b], f = e._aData, g = [], j, i, n, l, q;
        if (null === e.nTr) {
            j = c || H.createElement("tr");
            e.nTr = j;
            e.anCells = g;
            j._DT_RowIndex = b;
            Na(a, e);
            l = 0;
            for (q = a.aoColumns.length; l < q; l++) {
                n = a.aoColumns[l];
                i = c ? d[l] : H.createElement(n.sCellType);
                i._DT_CellIndex = {row: b, column: l};
                g.push(i);
                if ((!c || n.mRender || n.mData !== l) && (!h.isPlainObject(n.mData) || n.mData._ !== l + ".display")) i.innerHTML = B(a, b, l, "display");
                n.sClass && (i.className += " " + n.sClass);
                n.bVisible && !c ? j.appendChild(i) : !n.bVisible && c && i.parentNode.removeChild(i);
                n.fnCreatedCell && n.fnCreatedCell.call(a.oInstance, i, B(a, b, l), f, b, l)
            }
            s(a, "aoRowCreatedCallback", null, [j, f, b])
        }
        e.nTr.setAttribute("role", "row")
    }

    function Na(a, b) {
        var c = b.nTr, d = b._aData;
        if (c) {
            var e = a.rowIdFn(d);
            e && (c.id = e);
            d.DT_RowClass && (e = d.DT_RowClass.split(" "), b.__rowc = b.__rowc ? sa(b.__rowc.concat(e)) : e, h(c).removeClass(b.__rowc.join(" ")).addClass(d.DT_RowClass));
            d.DT_RowAttr && h(c).attr(d.DT_RowAttr);
            d.DT_RowData && h(c).data(d.DT_RowData)
        }
    }

    function mb(a) {
        var b, c, d, e, f, g = a.nTHead, j = a.nTFoot, i = 0 ===
            h("th, td", g).length, n = a.oClasses, l = a.aoColumns;
        i && (e = h("<tr/>").appendTo(g));
        b = 0;
        for (c = l.length; b < c; b++) f = l[b], d = h(f.nTh).addClass(f.sClass), i && d.appendTo(e), a.oFeatures.bSort && (d.addClass(f.sSortingClass), !1 !== f.bSortable && (d.attr("tabindex", a.iTabIndex).attr("aria-controls", a.sTableId), Oa(a, f.nTh, b))), f.sTitle != d[0].innerHTML && d.html(f.sTitle), Pa(a, "header")(a, d, f, n);
        i && ea(a.aoHeader, g);
        h(g).find(">tr").attr("role", "row");
        h(g).find(">tr>th, >tr>td").addClass(n.sHeaderTH);
        h(j).find(">tr>th, >tr>td").addClass(n.sFooterTH);
        if (null !== j) {
            a = a.aoFooter[0];
            b = 0;
            for (c = a.length; b < c; b++) f = l[b], f.nTf = a[b].cell, f.sClass && h(f.nTf).addClass(f.sClass)
        }
    }

    function fa(a, b, c) {
        var d, e, f, g = [], j = [], i = a.aoColumns.length, n;
        if (b) {
            c === k && (c = !1);
            d = 0;
            for (e = b.length; d < e; d++) {
                g[d] = b[d].slice();
                g[d].nTr = b[d].nTr;
                for (f = i - 1; 0 <= f; f--) !a.aoColumns[f].bVisible && !c && g[d].splice(f, 1);
                j.push([])
            }
            d = 0;
            for (e = g.length; d < e; d++) {
                if (a = g[d].nTr) for (; f = a.firstChild;) a.removeChild(f);
                f = 0;
                for (b = g[d].length; f < b; f++) if (n = i = 1, j[d][f] === k) {
                    a.appendChild(g[d][f].cell);
                    for (j[d][f] = 1; g[d + i] !== k && g[d][f].cell == g[d + i][f].cell;) j[d + i][f] = 1, i++;
                    for (; g[d][f + n] !== k && g[d][f].cell == g[d][f + n].cell;) {
                        for (c = 0; c < i; c++) j[d + c][f + n] = 1;
                        n++
                    }
                    h(g[d][f].cell).attr("rowspan", i).attr("colspan", n)
                }
            }
        }
    }

    function O(a) {
        var b = s(a, "aoPreDrawCallback", "preDraw", [a]);
        if (-1 !== h.inArray(!1, b)) C(a, !1); else {
            var b = [], c = 0, d = a.asStripeClasses, e = d.length, f = a.oLanguage, g = a.iInitDisplayStart,
                j = "ssp" == y(a), i = a.aiDisplay;
            a.bDrawing = !0;
            g !== k && -1 !== g && (a._iDisplayStart = j ? g : g >= a.fnRecordsDisplay() ? 0 : g, a.iInitDisplayStart =
                -1);
            var g = a._iDisplayStart, n = a.fnDisplayEnd();
            if (a.bDeferLoading) a.bDeferLoading = !1, a.iDraw++, C(a, !1); else if (j) {
                if (!a.bDestroying && !nb(a)) return
            } else a.iDraw++;
            if (0 !== i.length) {
                f = j ? a.aoData.length : n;
                for (j = j ? 0 : g; j < f; j++) {
                    var l = i[j], q = a.aoData[l];
                    null === q.nTr && Ja(a, l);
                    l = q.nTr;
                    if (0 !== e) {
                        var r = d[c % e];
                        q._sRowStripe != r && (h(l).removeClass(q._sRowStripe).addClass(r), q._sRowStripe = r)
                    }
                    s(a, "aoRowCallback", null, [l, q._aData, c, j]);
                    b.push(l);
                    c++
                }
            } else c = f.sZeroRecords, 1 == a.iDraw && "ajax" == y(a) ? c = f.sLoadingRecords :
                f.sEmptyTable && 0 === a.fnRecordsTotal() && (c = f.sEmptyTable), b[0] = h("<tr/>", {"class": e ? d[0] : ""}).append(h("<td />", {
                valign: "top",
                colSpan: ba(a),
                "class": a.oClasses.sRowEmpty
            }).html(c))[0];
            s(a, "aoHeaderCallback", "header", [h(a.nTHead).children("tr")[0], Ma(a), g, n, i]);
            s(a, "aoFooterCallback", "footer", [h(a.nTFoot).children("tr")[0], Ma(a), g, n, i]);
            d = h(a.nTBody);
            d.children().detach();
            d.append(h(b));
            s(a, "aoDrawCallback", "draw", [a]);
            a.bSorted = !1;
            a.bFiltered = !1;
            a.bDrawing = !1
        }
    }

    function T(a, b) {
        var c = a.oFeatures, d = c.bFilter;
        c.bSort && ob(a);
        d ? ga(a, a.oPreviousSearch) : a.aiDisplay = a.aiDisplayMaster.slice();
        !0 !== b && (a._iDisplayStart = 0);
        a._drawHold = b;
        O(a);
        a._drawHold = !1
    }

    function pb(a) {
        var b = a.oClasses, c = h(a.nTable), c = h("<div/>").insertBefore(c), d = a.oFeatures,
            e = h("<div/>", {id: a.sTableId + "_wrapper", "class": b.sWrapper + (a.nTFoot ? "" : " " + b.sNoFooter)});
        a.nHolding = c[0];
        a.nTableWrapper = e[0];
        a.nTableReinsertBefore = a.nTable.nextSibling;
        for (var f = a.sDom.split(""), g, j, i, n, l, q, k = 0; k < f.length; k++) {
            g = null;
            j = f[k];
            if ("<" == j) {
                i = h("<div/>")[0];
                n = f[k + 1];
                if ("'" == n || '"' == n) {
                    l = "";
                    for (q = 2; f[k + q] != n;) l += f[k + q], q++;
                    "H" == l ? l = b.sJUIHeader : "F" == l && (l = b.sJUIFooter);
                    -1 != l.indexOf(".") ? (n = l.split("."), i.id = n[0].substr(1, n[0].length - 1), i.className = n[1]) : "#" == l.charAt(0) ? i.id = l.substr(1, l.length - 1) : i.className = l;
                    k += q
                }
                e.append(i);
                e = h(i)
            } else if (">" == j) e = e.parent(); else if ("l" == j && d.bPaginate && d.bLengthChange) g = qb(a); else if ("f" == j && d.bFilter) g = rb(a); else if ("r" == j && d.bProcessing) g = sb(a); else if ("t" == j) g = tb(a); else if ("i" == j && d.bInfo) g = ub(a); else if ("p" ==
                j && d.bPaginate) g = vb(a); else if (0 !== m.ext.feature.length) {
                i = m.ext.feature;
                q = 0;
                for (n = i.length; q < n; q++) if (j == i[q].cFeature) {
                    g = i[q].fnInit(a);
                    break
                }
            }
            g && (i = a.aanFeatures, i[j] || (i[j] = []), i[j].push(g), e.append(g))
        }
        c.replaceWith(e);
        a.nHolding = null
    }

    function ea(a, b) {
        var c = h(b).children("tr"), d, e, f, g, j, i, n, l, q, k;
        a.splice(0, a.length);
        f = 0;
        for (i = c.length; f < i; f++) a.push([]);
        f = 0;
        for (i = c.length; f < i; f++) {
            d = c[f];
            for (e = d.firstChild; e;) {
                if ("TD" == e.nodeName.toUpperCase() || "TH" == e.nodeName.toUpperCase()) {
                    l = 1 * e.getAttribute("colspan");
                    q = 1 * e.getAttribute("rowspan");
                    l = !l || 0 === l || 1 === l ? 1 : l;
                    q = !q || 0 === q || 1 === q ? 1 : q;
                    g = 0;
                    for (j = a[f]; j[g];) g++;
                    n = g;
                    k = 1 === l ? !0 : !1;
                    for (j = 0; j < l; j++) for (g = 0; g < q; g++) a[f + g][n + j] = {
                        cell: e,
                        unique: k
                    }, a[f + g].nTr = d
                }
                e = e.nextSibling
            }
        }
    }

    function ta(a, b, c) {
        var d = [];
        c || (c = a.aoHeader, b && (c = [], ea(c, b)));
        for (var b = 0, e = c.length; b < e; b++) for (var f = 0, g = c[b].length; f < g; f++) if (c[b][f].unique && (!d[f] || !a.bSortCellsTop)) d[f] = c[b][f].cell;
        return d
    }

    function ua(a, b, c) {
        s(a, "aoServerParams", "serverParams", [b]);
        if (b && h.isArray(b)) {
            var d = {},
                e = /(.*?)\[\]$/;
            h.each(b, function (a, b) {
                var c = b.name.match(e);
                c ? (c = c[0], d[c] || (d[c] = []), d[c].push(b.value)) : d[b.name] = b.value
            });
            b = d
        }
        var f, g = a.ajax, j = a.oInstance, i = function (b) {
            s(a, null, "xhr", [a, b, a.jqXHR]);
            c(b)
        };
        if (h.isPlainObject(g) && g.data) {
            f = g.data;
            var n = h.isFunction(f) ? f(b, a) : f, b = h.isFunction(f) && n ? n : h.extend(!0, b, n);
            delete g.data
        }
        n = {
            data: b, success: function (b) {
                var c = b.error || b.sError;
                c && K(a, 0, c);
                a.json = b;
                i(b)
            }, dataType: "json", cache: !1, type: a.sServerMethod, error: function (b, c) {
                var d = s(a, null, "xhr",
                    [a, null, a.jqXHR]);
                -1 === h.inArray(!0, d) && ("parsererror" == c ? K(a, 0, "Invalid JSON response", 1) : 4 === b.readyState && K(a, 0, "Ajax error", 7));
                C(a, !1)
            }
        };
        a.oAjaxData = b;
        s(a, null, "preXhr", [a, b]);
        a.fnServerData ? a.fnServerData.call(j, a.sAjaxSource, h.map(b, function (a, b) {
            return {name: b, value: a}
        }), i, a) : a.sAjaxSource || "string" === typeof g ? a.jqXHR = h.ajax(h.extend(n, {url: g || a.sAjaxSource})) : h.isFunction(g) ? a.jqXHR = g.call(j, b, i, a) : (a.jqXHR = h.ajax(h.extend(n, g)), g.data = f)
    }

    function nb(a) {
        return a.bAjaxDataGet ? (a.iDraw++, C(a,
            !0), ua(a, wb(a), function (b) {
            xb(a, b)
        }), !1) : !0
    }

    function wb(a) {
        var b = a.aoColumns, c = b.length, d = a.oFeatures, e = a.oPreviousSearch, f = a.aoPreSearchCols, g, j = [], i,
            n, l, k = W(a);
        g = a._iDisplayStart;
        i = !1 !== d.bPaginate ? a._iDisplayLength : -1;
        var r = function (a, b) {
            j.push({name: a, value: b})
        };
        r("sEcho", a.iDraw);
        r("iColumns", c);
        r("sColumns", D(b, "sName").join(","));
        r("iDisplayStart", g);
        r("iDisplayLength", i);
        var ra = {
            draw: a.iDraw,
            columns: [],
            order: [],
            start: g,
            length: i,
            search: {value: e.sSearch, regex: e.bRegex}
        };
        for (g = 0; g < c; g++) n = b[g],
            l = f[g], i = "function" == typeof n.mData ? "function" : n.mData, ra.columns.push({
            data: i,
            name: n.sName,
            searchable: n.bSearchable,
            orderable: n.bSortable,
            search: {value: l.sSearch, regex: l.bRegex}
        }), r("mDataProp_" + g, i), d.bFilter && (r("sSearch_" + g, l.sSearch), r("bRegex_" + g, l.bRegex), r("bSearchable_" + g, n.bSearchable)), d.bSort && r("bSortable_" + g, n.bSortable);
        d.bFilter && (r("sSearch", e.sSearch), r("bRegex", e.bRegex));
        d.bSort && (h.each(k, function (a, b) {
            ra.order.push({column: b.col, dir: b.dir});
            r("iSortCol_" + a, b.col);
            r("sSortDir_" +
                a, b.dir)
        }), r("iSortingCols", k.length));
        b = m.ext.legacy.ajax;
        return null === b ? a.sAjaxSource ? j : ra : b ? j : ra
    }

    function xb(a, b) {
        var c = va(a, b), d = b.sEcho !== k ? b.sEcho : b.draw,
            e = b.iTotalRecords !== k ? b.iTotalRecords : b.recordsTotal,
            f = b.iTotalDisplayRecords !== k ? b.iTotalDisplayRecords : b.recordsFiltered;
        if (d) {
            if (1 * d < a.iDraw) return;
            a.iDraw = 1 * d
        }
        pa(a);
        a._iRecordsTotal = parseInt(e, 10);
        a._iRecordsDisplay = parseInt(f, 10);
        d = 0;
        for (e = c.length; d < e; d++) N(a, c[d]);
        a.aiDisplay = a.aiDisplayMaster.slice();
        a.bAjaxDataGet = !1;
        O(a);
        a._bInitComplete ||
        wa(a, b);
        a.bAjaxDataGet = !0;
        C(a, !1)
    }

    function va(a, b) {
        var c = h.isPlainObject(a.ajax) && a.ajax.dataSrc !== k ? a.ajax.dataSrc : a.sAjaxDataProp;
        return "data" === c ? b.aaData || b[c] : "" !== c ? R(c)(b) : b
    }

    function rb(a) {
        var b = a.oClasses, c = a.sTableId, d = a.oLanguage, e = a.oPreviousSearch, f = a.aanFeatures,
            g = '<input type="search" class="' + b.sFilterInput + '"/>', j = d.sSearch,
            j = j.match(/_INPUT_/) ? j.replace("_INPUT_", g) : j + g,
            b = h("<div/>", {id: !f.f ? c + "_filter" : null, "class": b.sFilter}).append(h("<label/>").append(j)),
            f = function () {
                var b = !this.value ?
                    "" : this.value;
                b != e.sSearch && (ga(a, {
                    sSearch: b,
                    bRegex: e.bRegex,
                    bSmart: e.bSmart,
                    bCaseInsensitive: e.bCaseInsensitive
                }), a._iDisplayStart = 0, O(a))
            }, g = null !== a.searchDelay ? a.searchDelay : "ssp" === y(a) ? 400 : 0,
            i = h("input", b).val(e.sSearch).attr("placeholder", d.sSearchPlaceholder).on("keyup.DT search.DT input.DT paste.DT cut.DT", g ? Qa(f, g) : f).on("keypress.DT", function (a) {
                if (13 == a.keyCode) return !1
            }).attr("aria-controls", c);
        h(a.nTable).on("search.dt.DT", function (b, c) {
            if (a === c) try {
                i[0] !== H.activeElement && i.val(e.sSearch)
            } catch (d) {
            }
        });
        return b[0]
    }

    function ga(a, b, c) {
        var d = a.oPreviousSearch, e = a.aoPreSearchCols, f = function (a) {
            d.sSearch = a.sSearch;
            d.bRegex = a.bRegex;
            d.bSmart = a.bSmart;
            d.bCaseInsensitive = a.bCaseInsensitive
        };
        Ia(a);
        if ("ssp" != y(a)) {
            yb(a, b.sSearch, c, b.bEscapeRegex !== k ? !b.bEscapeRegex : b.bRegex, b.bSmart, b.bCaseInsensitive);
            f(b);
            for (b = 0; b < e.length; b++) zb(a, e[b].sSearch, b, e[b].bEscapeRegex !== k ? !e[b].bEscapeRegex : e[b].bRegex, e[b].bSmart, e[b].bCaseInsensitive);
            Ab(a)
        } else f(b);
        a.bFiltered = !0;
        s(a, null, "search", [a])
    }

    function Ab(a) {
        for (var b =
            m.ext.search, c = a.aiDisplay, d, e, f = 0, g = b.length; f < g; f++) {
            for (var j = [], i = 0, n = c.length; i < n; i++) e = c[i], d = a.aoData[e], b[f](a, d._aFilterData, e, d._aData, i) && j.push(e);
            c.length = 0;
            h.merge(c, j)
        }
    }

    function zb(a, b, c, d, e, f) {
        if ("" !== b) {
            for (var g = [], j = a.aiDisplay, d = Ra(b, d, e, f), e = 0; e < j.length; e++) b = a.aoData[j[e]]._aFilterData[c], d.test(b) && g.push(j[e]);
            a.aiDisplay = g
        }
    }

    function yb(a, b, c, d, e, f) {
        var d = Ra(b, d, e, f), f = a.oPreviousSearch.sSearch, g = a.aiDisplayMaster, j, e = [];
        0 !== m.ext.search.length && (c = !0);
        j = Bb(a);
        if (0 >= b.length) a.aiDisplay =
            g.slice(); else {
            if (j || c || f.length > b.length || 0 !== b.indexOf(f) || a.bSorted) a.aiDisplay = g.slice();
            b = a.aiDisplay;
            for (c = 0; c < b.length; c++) d.test(a.aoData[b[c]]._sFilterRow) && e.push(b[c]);
            a.aiDisplay = e
        }
    }

    function Ra(a, b, c, d) {
        a = b ? a : Sa(a);
        c && (a = "^(?=.*?" + h.map(a.match(/"[^"]+"|[^ ]+/g) || [""], function (a) {
            if ('"' === a.charAt(0)) var b = a.match(/^"(.*)"$/), a = b ? b[1] : a;
            return a.replace('"', "")
        }).join(")(?=.*?") + ").*$");
        return RegExp(a, d ? "i" : "")
    }

    function Bb(a) {
        var b = a.aoColumns, c, d, e, f, g, j, i, h, l = m.ext.type.search;
        c = !1;
        d = 0;
        for (f = a.aoData.length; d < f; d++) if (h = a.aoData[d], !h._aFilterData) {
            j = [];
            e = 0;
            for (g = b.length; e < g; e++) c = b[e], c.bSearchable ? (i = B(a, d, e, "filter"), l[c.sType] && (i = l[c.sType](i)), null === i && (i = ""), "string" !== typeof i && i.toString && (i = i.toString())) : i = "", i.indexOf && -1 !== i.indexOf("&") && (xa.innerHTML = i, i = $b ? xa.textContent : xa.innerText), i.replace && (i = i.replace(/[\r\n]/g, "")), j.push(i);
            h._aFilterData = j;
            h._sFilterRow = j.join("  ");
            c = !0
        }
        return c
    }

    function Cb(a) {
        return {
            search: a.sSearch, smart: a.bSmart, regex: a.bRegex,
            caseInsensitive: a.bCaseInsensitive
        }
    }

    function Db(a) {
        return {sSearch: a.search, bSmart: a.smart, bRegex: a.regex, bCaseInsensitive: a.caseInsensitive}
    }

    function ub(a) {
        var b = a.sTableId, c = a.aanFeatures.i,
            d = h("<div/>", {"class": a.oClasses.sInfo, id: !c ? b + "_info" : null});
        c || (a.aoDrawCallback.push({
            fn: Eb,
            sName: "information"
        }), d.attr("role", "status").attr("aria-live", "polite"), h(a.nTable).attr("aria-describedby", b + "_info"));
        return d[0]
    }

    function Eb(a) {
        var b = a.aanFeatures.i;
        if (0 !== b.length) {
            var c = a.oLanguage, d = a._iDisplayStart +
                1, e = a.fnDisplayEnd(), f = a.fnRecordsTotal(), g = a.fnRecordsDisplay(),
                j = g ? c.sInfo : c.sInfoEmpty;
            g !== f && (j += " " + c.sInfoFiltered);
            j += c.sInfoPostFix;
            j = Fb(a, j);
            c = c.fnInfoCallback;
            null !== c && (j = c.call(a.oInstance, a, d, e, f, g, j));
            h(b).html(j)
        }
    }

    function Fb(a, b) {
        var c = a.fnFormatNumber, d = a._iDisplayStart + 1, e = a._iDisplayLength, f = a.fnRecordsDisplay(),
            g = -1 === e;
        return b.replace(/_START_/g, c.call(a, d)).replace(/_END_/g, c.call(a, a.fnDisplayEnd())).replace(/_MAX_/g, c.call(a, a.fnRecordsTotal())).replace(/_TOTAL_/g, c.call(a,
            f)).replace(/_PAGE_/g, c.call(a, g ? 1 : Math.ceil(d / e))).replace(/_PAGES_/g, c.call(a, g ? 1 : Math.ceil(f / e)))
    }

    function ha(a) {
        var b, c, d = a.iInitDisplayStart, e = a.aoColumns, f;
        c = a.oFeatures;
        var g = a.bDeferLoading;
        if (a.bInitialised) {
            pb(a);
            mb(a);
            fa(a, a.aoHeader);
            fa(a, a.aoFooter);
            C(a, !0);
            c.bAutoWidth && Ha(a);
            b = 0;
            for (c = e.length; b < c; b++) f = e[b], f.sWidth && (f.nTh.style.width = v(f.sWidth));
            s(a, null, "preInit", [a]);
            T(a);
            e = y(a);
            if ("ssp" != e || g) "ajax" == e ? ua(a, [], function (c) {
                var f = va(a, c);
                for (b = 0; b < f.length; b++) N(a, f[b]);
                a.iInitDisplayStart =
                    d;
                T(a);
                C(a, !1);
                wa(a, c)
            }, a) : (C(a, !1), wa(a))
        } else setTimeout(function () {
            ha(a)
        }, 200)
    }

    function wa(a, b) {
        a._bInitComplete = !0;
        (b || a.oInit.aaData) && Z(a);
        s(a, null, "plugin-init", [a, b]);
        s(a, "aoInitComplete", "init", [a, b])
    }

    function Ta(a, b) {
        var c = parseInt(b, 10);
        a._iDisplayLength = c;
        Ua(a);
        s(a, null, "length", [a, c])
    }

    function qb(a) {
        for (var b = a.oClasses, c = a.sTableId, d = a.aLengthMenu, e = h.isArray(d[0]), f = e ? d[0] : d, d = e ? d[1] : d, e = h("<select/>", {
            name: c + "_length",
            "aria-controls": c,
            "class": b.sLengthSelect
        }), g = 0, j = f.length; g < j; g++) e[0][g] =
            new Option(d[g], f[g]);
        var i = h("<div><label/></div>").addClass(b.sLength);
        a.aanFeatures.l || (i[0].id = c + "_length");
        i.children().append(a.oLanguage.sLengthMenu.replace("_MENU_", e[0].outerHTML));
        h("select", i).val(a._iDisplayLength).on("change.DT", function () {
            Ta(a, h(this).val());
            O(a)
        });
        h(a.nTable).on("length.dt.DT", function (b, c, d) {
            a === c && h("select", i).val(d)
        });
        return i[0]
    }

    function vb(a) {
        var b = a.sPaginationType, c = m.ext.pager[b], d = "function" === typeof c, e = function (a) {
            O(a)
        }, b = h("<div/>").addClass(a.oClasses.sPaging +
            b)[0], f = a.aanFeatures;
        d || c.fnInit(a, b, e);
        f.p || (b.id = a.sTableId + "_paginate", a.aoDrawCallback.push({
            fn: function (a) {
                if (d) {
                    var b = a._iDisplayStart, i = a._iDisplayLength, h = a.fnRecordsDisplay(), l = -1 === i,
                        b = l ? 0 : Math.ceil(b / i), i = l ? 1 : Math.ceil(h / i), h = c(b, i), k, l = 0;
                    for (k = f.p.length; l < k; l++) Pa(a, "pageButton")(a, f.p[l], l, h, b, i)
                } else c.fnUpdate(a, e)
            }, sName: "pagination"
        }));
        return b
    }

    function Va(a, b, c) {
        var d = a._iDisplayStart, e = a._iDisplayLength, f = a.fnRecordsDisplay();
        0 === f || -1 === e ? d = 0 : "number" === typeof b ? (d = b * e, d > f &&
        (d = 0)) : "first" == b ? d = 0 : "previous" == b ? (d = 0 <= e ? d - e : 0, 0 > d && (d = 0)) : "next" == b ? d + e < f && (d += e) : "last" == b ? d = Math.floor((f - 1) / e) * e : K(a, 0, "Unknown paging action: " + b, 5);
        b = a._iDisplayStart !== d;
        a._iDisplayStart = d;
        b && (s(a, null, "page", [a]), c && O(a));
        return b
    }

    function sb(a) {
        return h("<div/>", {
            id: !a.aanFeatures.r ? a.sTableId + "_processing" : null,
            "class": a.oClasses.sProcessing
        }).html(a.oLanguage.sProcessing).insertBefore(a.nTable)[0]
    }

    function C(a, b) {
        a.oFeatures.bProcessing && h(a.aanFeatures.r).css("display", b ? "block" : "none");
        s(a, null, "processing", [a, b])
    }

    function tb(a) {
        var b = h(a.nTable);
        b.attr("role", "grid");
        var c = a.oScroll;
        if ("" === c.sX && "" === c.sY) return a.nTable;
        var d = c.sX, e = c.sY, f = a.oClasses, g = b.children("caption"), j = g.length ? g[0]._captionSide : null,
            i = h(b[0].cloneNode(!1)), n = h(b[0].cloneNode(!1)), l = b.children("tfoot");
        l.length || (l = null);
        i = h("<div/>", {"class": f.sScrollWrapper}).append(h("<div/>", {"class": f.sScrollHead}).css({
            overflow: "hidden",
            position: "relative",
            border: 0,
            width: d ? !d ? null : v(d) : "100%"
        }).append(h("<div/>",
            {"class": f.sScrollHeadInner}).css({
            "box-sizing": "content-box",
            width: c.sXInner || "100%"
        }).append(i.removeAttr("id").css("margin-left", 0).append("top" === j ? g : null).append(b.children("thead"))))).append(h("<div/>", {"class": f.sScrollBody}).css({
            position: "relative",
            overflow: "auto",
            width: !d ? null : v(d)
        }).append(b));
        l && i.append(h("<div/>", {"class": f.sScrollFoot}).css({
            overflow: "hidden",
            border: 0,
            width: d ? !d ? null : v(d) : "100%"
        }).append(h("<div/>", {"class": f.sScrollFootInner}).append(n.removeAttr("id").css("margin-left",
            0).append("bottom" === j ? g : null).append(b.children("tfoot")))));
        var b = i.children(), k = b[0], f = b[1], r = l ? b[2] : null;
        if (d) h(f).on("scroll.DT", function () {
            var a = this.scrollLeft;
            k.scrollLeft = a;
            l && (r.scrollLeft = a)
        });
        h(f).css(e && c.bCollapse ? "max-height" : "height", e);
        a.nScrollHead = k;
        a.nScrollBody = f;
        a.nScrollFoot = r;
        a.aoDrawCallback.push({fn: ma, sName: "scrolling"});
        return i[0]
    }

    function ma(a) {
        var b = a.oScroll, c = b.sX, d = b.sXInner, e = b.sY, b = b.iBarWidth, f = h(a.nScrollHead), g = f[0].style,
            j = f.children("div"), i = j[0].style, n = j.children("table"),
            j = a.nScrollBody, l = h(j), q = j.style, r = h(a.nScrollFoot).children("div"), m = r.children("table"),
            p = h(a.nTHead), o = h(a.nTable), t = o[0], s = t.style, u = a.nTFoot ? h(a.nTFoot) : null, x = a.oBrowser,
            U = x.bScrollOversize, ac = D(a.aoColumns, "nTh"), P, L, Q, w, Wa = [], y = [], z = [], A = [], B,
            C = function (a) {
                a = a.style;
                a.paddingTop = "0";
                a.paddingBottom = "0";
                a.borderTopWidth = "0";
                a.borderBottomWidth = "0";
                a.height = 0
            };
        L = j.scrollHeight > j.clientHeight;
        if (a.scrollBarVis !== L && a.scrollBarVis !== k) a.scrollBarVis = L, Z(a); else {
            a.scrollBarVis = L;
            o.children("thead, tfoot").remove();
            u && (Q = u.clone().prependTo(o), P = u.find("tr"), Q = Q.find("tr"));
            w = p.clone().prependTo(o);
            p = p.find("tr");
            L = w.find("tr");
            w.find("th, td").removeAttr("tabindex");
            c || (q.width = "100%", f[0].style.width = "100%");
            h.each(ta(a, w), function (b, c) {
                B = $(a, b);
                c.style.width = a.aoColumns[B].sWidth
            });
            u && I(function (a) {
                a.style.width = ""
            }, Q);
            f = o.outerWidth();
            if ("" === c) {
                s.width = "100%";
                if (U && (o.find("tbody").height() > j.offsetHeight || "scroll" == l.css("overflow-y"))) s.width = v(o.outerWidth() - b);
                f = o.outerWidth()
            } else "" !== d && (s.width =
                v(d), f = o.outerWidth());
            I(C, L);
            I(function (a) {
                z.push(a.innerHTML);
                Wa.push(v(h(a).css("width")))
            }, L);
            I(function (a, b) {
                if (h.inArray(a, ac) !== -1) a.style.width = Wa[b]
            }, p);
            h(L).height(0);
            u && (I(C, Q), I(function (a) {
                A.push(a.innerHTML);
                y.push(v(h(a).css("width")))
            }, Q), I(function (a, b) {
                a.style.width = y[b]
            }, P), h(Q).height(0));
            I(function (a, b) {
                a.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + z[b] + "</div>";
                a.style.width = Wa[b]
            }, L);
            u && I(function (a, b) {
                a.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' +
                    A[b] + "</div>";
                a.style.width = y[b]
            }, Q);
            if (o.outerWidth() < f) {
                P = j.scrollHeight > j.offsetHeight || "scroll" == l.css("overflow-y") ? f + b : f;
                if (U && (j.scrollHeight > j.offsetHeight || "scroll" == l.css("overflow-y"))) s.width = v(P - b);
                ("" === c || "" !== d) && K(a, 1, "Possible column misalignment", 6)
            } else P = "100%";
            q.width = v(P);
            g.width = v(P);
            u && (a.nScrollFoot.style.width = v(P));
            !e && U && (q.height = v(t.offsetHeight + b));
            c = o.outerWidth();
            n[0].style.width = v(c);
            i.width = v(c);
            d = o.height() > j.clientHeight || "scroll" == l.css("overflow-y");
            e = "padding" +
                (x.bScrollbarLeft ? "Left" : "Right");
            i[e] = d ? b + "px" : "0px";
            u && (m[0].style.width = v(c), r[0].style.width = v(c), r[0].style[e] = d ? b + "px" : "0px");
            o.children("colgroup").insertBefore(o.children("thead"));
            l.scroll();
            if ((a.bSorted || a.bFiltered) && !a._drawHold) j.scrollTop = 0
        }
    }

    function I(a, b, c) {
        for (var d = 0, e = 0, f = b.length, g, j; e < f;) {
            g = b[e].firstChild;
            for (j = c ? c[e].firstChild : null; g;) 1 === g.nodeType && (c ? a(g, j, d) : a(g, d), d++), g = g.nextSibling, j = c ? j.nextSibling : null;
            e++
        }
    }

    function Ha(a) {
        var b = a.nTable, c = a.aoColumns, d = a.oScroll,
            e = d.sY, f = d.sX, g = d.sXInner, j = c.length, i = na(a, "bVisible"), n = h("th", a.nTHead),
            l = b.getAttribute("width"), k = b.parentNode, r = !1, m, p, o = a.oBrowser, d = o.bScrollOversize;
        (m = b.style.width) && -1 !== m.indexOf("%") && (l = m);
        for (m = 0; m < i.length; m++) p = c[i[m]], null !== p.sWidth && (p.sWidth = Gb(p.sWidthOrig, k), r = !0);
        if (d || !r && !f && !e && j == ba(a) && j == n.length) for (m = 0; m < j; m++) i = $(a, m), null !== i && (c[i].sWidth = v(n.eq(m).width())); else {
            j = h(b).clone().css("visibility", "hidden").removeAttr("id");
            j.find("tbody tr").remove();
            var t = h("<tr/>").appendTo(j.find("tbody"));
            j.find("thead, tfoot").remove();
            j.append(h(a.nTHead).clone()).append(h(a.nTFoot).clone());
            j.find("tfoot th, tfoot td").css("width", "");
            n = ta(a, j.find("thead")[0]);
            for (m = 0; m < i.length; m++) p = c[i[m]], n[m].style.width = null !== p.sWidthOrig && "" !== p.sWidthOrig ? v(p.sWidthOrig) : "", p.sWidthOrig && f && h(n[m]).append(h("<div/>").css({
                width: p.sWidthOrig,
                margin: 0,
                padding: 0,
                border: 0,
                height: 1
            }));
            if (a.aoData.length) for (m = 0; m < i.length; m++) r = i[m], p = c[r], h(Hb(a, r)).clone(!1).append(p.sContentPadding).appendTo(t);
            h("[name]",
                j).removeAttr("name");
            p = h("<div/>").css(f || e ? {
                position: "absolute",
                top: 0,
                left: 0,
                height: 1,
                right: 0,
                overflow: "hidden"
            } : {}).append(j).appendTo(k);
            f && g ? j.width(g) : f ? (j.css("width", "auto"), j.removeAttr("width"), j.width() < k.clientWidth && l && j.width(k.clientWidth)) : e ? j.width(k.clientWidth) : l && j.width(l);
            for (m = e = 0; m < i.length; m++) k = h(n[m]), g = k.outerWidth() - k.width(), k = o.bBounding ? Math.ceil(n[m].getBoundingClientRect().width) : k.outerWidth(), e += k, c[i[m]].sWidth = v(k - g);
            b.style.width = v(e);
            p.remove()
        }
        l && (b.style.width =
            v(l));
        if ((l || f) && !a._reszEvt) b = function () {
            h(E).on("resize.DT-" + a.sInstance, Qa(function () {
                Z(a)
            }))
        }, d ? setTimeout(b, 1E3) : b(), a._reszEvt = !0
    }

    function Gb(a, b) {
        if (!a) return 0;
        var c = h("<div/>").css("width", v(a)).appendTo(b || H.body), d = c[0].offsetWidth;
        c.remove();
        return d
    }

    function Hb(a, b) {
        var c = Ib(a, b);
        if (0 > c) return null;
        var d = a.aoData[c];
        return !d.nTr ? h("<td/>").html(B(a, c, b, "display"))[0] : d.anCells[b]
    }

    function Ib(a, b) {
        for (var c, d = -1, e = -1, f = 0, g = a.aoData.length; f < g; f++) c = B(a, f, b, "display") + "", c = c.replace(bc,
            ""), c = c.replace(/&nbsp;/g, " "), c.length > d && (d = c.length, e = f);
        return e
    }

    function v(a) {
        return null === a ? "0px" : "number" == typeof a ? 0 > a ? "0px" : a + "px" : a.match(/\d$/) ? a + "px" : a
    }

    function W(a) {
        var b, c, d = [], e = a.aoColumns, f, g, j, i;
        b = a.aaSortingFixed;
        c = h.isPlainObject(b);
        var n = [];
        f = function (a) {
            a.length && !h.isArray(a[0]) ? n.push(a) : h.merge(n, a)
        };
        h.isArray(b) && f(b);
        c && b.pre && f(b.pre);
        f(a.aaSorting);
        c && b.post && f(b.post);
        for (a = 0; a < n.length; a++) {
            i = n[a][0];
            f = e[i].aDataSort;
            b = 0;
            for (c = f.length; b < c; b++) g = f[b], j = e[g].sType ||
                "string", n[a]._idx === k && (n[a]._idx = h.inArray(n[a][1], e[g].asSorting)), d.push({
                src: i,
                col: g,
                dir: n[a][1],
                index: n[a]._idx,
                type: j,
                formatter: m.ext.type.order[j + "-pre"]
            })
        }
        return d
    }

    function ob(a) {
        var b, c, d = [], e = m.ext.type.order, f = a.aoData, g = 0, j, i = a.aiDisplayMaster, h;
        Ia(a);
        h = W(a);
        b = 0;
        for (c = h.length; b < c; b++) j = h[b], j.formatter && g++, Jb(a, j.col);
        if ("ssp" != y(a) && 0 !== h.length) {
            b = 0;
            for (c = i.length; b < c; b++) d[i[b]] = b;
            g === h.length ? i.sort(function (a, b) {
                var c, e, g, j, i = h.length, k = f[a]._aSortData, m = f[b]._aSortData;
                for (g =
                         0; g < i; g++) if (j = h[g], c = k[j.col], e = m[j.col], c = c < e ? -1 : c > e ? 1 : 0, 0 !== c) return "asc" === j.dir ? c : -c;
                c = d[a];
                e = d[b];
                return c < e ? -1 : c > e ? 1 : 0
            }) : i.sort(function (a, b) {
                var c, g, j, i, k = h.length, m = f[a]._aSortData, p = f[b]._aSortData;
                for (j = 0; j < k; j++) if (i = h[j], c = m[i.col], g = p[i.col], i = e[i.type + "-" + i.dir] || e["string-" + i.dir], c = i(c, g), 0 !== c) return c;
                c = d[a];
                g = d[b];
                return c < g ? -1 : c > g ? 1 : 0
            })
        }
        a.bSorted = !0
    }

    function Kb(a) {
        for (var b, c, d = a.aoColumns, e = W(a), a = a.oLanguage.oAria, f = 0, g = d.length; f < g; f++) {
            c = d[f];
            var j = c.asSorting;
            b = c.sTitle.replace(/<.*?>/g,
                "");
            var i = c.nTh;
            i.removeAttribute("aria-sort");
            c.bSortable && (0 < e.length && e[0].col == f ? (i.setAttribute("aria-sort", "asc" == e[0].dir ? "ascending" : "descending"), c = j[e[0].index + 1] || j[0]) : c = j[0], b += "asc" === c ? a.sSortAscending : a.sSortDescending);
            i.setAttribute("aria-label", b)
        }
    }

    function Xa(a, b, c, d) {
        var e = a.aaSorting, f = a.aoColumns[b].asSorting, g = function (a, b) {
            var c = a._idx;
            c === k && (c = h.inArray(a[1], f));
            return c + 1 < f.length ? c + 1 : b ? null : 0
        };
        "number" === typeof e[0] && (e = a.aaSorting = [e]);
        c && a.oFeatures.bSortMulti ? (c = h.inArray(b,
            D(e, "0")), -1 !== c ? (b = g(e[c], !0), null === b && 1 === e.length && (b = 0), null === b ? e.splice(c, 1) : (e[c][1] = f[b], e[c]._idx = b)) : (e.push([b, f[0], 0]), e[e.length - 1]._idx = 0)) : e.length && e[0][0] == b ? (b = g(e[0]), e.length = 1, e[0][1] = f[b], e[0]._idx = b) : (e.length = 0, e.push([b, f[0]]), e[0]._idx = 0);
        T(a);
        "function" == typeof d && d(a)
    }

    function Oa(a, b, c, d) {
        var e = a.aoColumns[c];
        Ya(b, {}, function (b) {
            !1 !== e.bSortable && (a.oFeatures.bProcessing ? (C(a, !0), setTimeout(function () {
                Xa(a, c, b.shiftKey, d);
                "ssp" !== y(a) && C(a, !1)
            }, 0)) : Xa(a, c, b.shiftKey, d))
        })
    }

    function ya(a) {
        var b = a.aLastSort, c = a.oClasses.sSortColumn, d = W(a), e = a.oFeatures, f, g;
        if (e.bSort && e.bSortClasses) {
            e = 0;
            for (f = b.length; e < f; e++) g = b[e].src, h(D(a.aoData, "anCells", g)).removeClass(c + (2 > e ? e + 1 : 3));
            e = 0;
            for (f = d.length; e < f; e++) g = d[e].src, h(D(a.aoData, "anCells", g)).addClass(c + (2 > e ? e + 1 : 3))
        }
        a.aLastSort = d
    }

    function Jb(a, b) {
        var c = a.aoColumns[b], d = m.ext.order[c.sSortDataType], e;
        d && (e = d.call(a.oInstance, a, b, aa(a, b)));
        for (var f, g = m.ext.type.order[c.sType + "-pre"], j = 0, i = a.aoData.length; j < i; j++) if (c = a.aoData[j],
            c._aSortData || (c._aSortData = []), !c._aSortData[b] || d) f = d ? e[j] : B(a, j, b, "sort"), c._aSortData[b] = g ? g(f) : f
    }

    function za(a) {
        if (a.oFeatures.bStateSave && !a.bDestroying) {
            var b = {
                time: +new Date,
                start: a._iDisplayStart,
                length: a._iDisplayLength,
                order: h.extend(!0, [], a.aaSorting),
                search: Cb(a.oPreviousSearch),
                columns: h.map(a.aoColumns, function (b, d) {
                    return {visible: b.bVisible, search: Cb(a.aoPreSearchCols[d])}
                })
            };
            s(a, "aoStateSaveParams", "stateSaveParams", [a, b]);
            a.oSavedState = b;
            a.fnStateSaveCallback.call(a.oInstance, a,
                b)
        }
    }

    function Lb(a, b, c) {
        var d, e, f = a.aoColumns, b = function (b) {
            if (b && b.time) {
                var g = s(a, "aoStateLoadParams", "stateLoadParams", [a, b]);
                if (-1 === h.inArray(!1, g) && (g = a.iStateDuration, !(0 < g && b.time < +new Date - 1E3 * g) && !(b.columns && f.length !== b.columns.length))) {
                    a.oLoadedState = h.extend(!0, {}, b);
                    b.start !== k && (a._iDisplayStart = b.start, a.iInitDisplayStart = b.start);
                    b.length !== k && (a._iDisplayLength = b.length);
                    b.order !== k && (a.aaSorting = [], h.each(b.order, function (b, c) {
                        a.aaSorting.push(c[0] >= f.length ? [0, c[1]] : c)
                    }));
                    b.search !==
                    k && h.extend(a.oPreviousSearch, Db(b.search));
                    if (b.columns) {
                        d = 0;
                        for (e = b.columns.length; d < e; d++) g = b.columns[d], g.visible !== k && (f[d].bVisible = g.visible), g.search !== k && h.extend(a.aoPreSearchCols[d], Db(g.search))
                    }
                    s(a, "aoStateLoaded", "stateLoaded", [a, b])
                }
            }
            c()
        };
        if (a.oFeatures.bStateSave) {
            var g = a.fnStateLoadCallback.call(a.oInstance, a, b);
            g !== k && b(g)
        } else c()
    }

    function Aa(a) {
        var b = m.settings, a = h.inArray(a, D(b, "nTable"));
        return -1 !== a ? b[a] : null
    }

    function K(a, b, c, d) {
        c = "DataTables warning: " + (a ? "table id=" + a.sTableId +
            " - " : "") + c;
        d && (c += ". For more information about this error, please see http://datatables.net/tn/" + d);
        if (b) E.console && console.log && console.log(c); else if (b = m.ext, b = b.sErrMode || b.errMode, a && s(a, null, "error", [a, d, c]), "alert" == b) alert(c); else {
            if ("throw" == b) throw Error(c);
            "function" == typeof b && b(a, d, c)
        }
    }

    function F(a, b, c, d) {
        h.isArray(c) ? h.each(c, function (c, d) {
            h.isArray(d) ? F(a, b, d[0], d[1]) : F(a, b, d)
        }) : (d === k && (d = c), b[c] !== k && (a[d] = b[c]))
    }

    function Mb(a, b, c) {
        var d, e;
        for (e in b) b.hasOwnProperty(e) && (d = b[e],
            h.isPlainObject(d) ? (h.isPlainObject(a[e]) || (a[e] = {}), h.extend(!0, a[e], d)) : a[e] = c && "data" !== e && "aaData" !== e && h.isArray(d) ? d.slice() : d);
        return a
    }

    function Ya(a, b, c) {
        h(a).on("click.DT", b, function (b) {
            a.blur();
            c(b)
        }).on("keypress.DT", b, function (a) {
            13 === a.which && (a.preventDefault(), c(a))
        }).on("selectstart.DT", function () {
            return !1
        })
    }

    function z(a, b, c, d) {
        c && a[b].push({fn: c, sName: d})
    }

    function s(a, b, c, d) {
        var e = [];
        b && (e = h.map(a[b].slice().reverse(), function (b) {
            return b.fn.apply(a.oInstance, d)
        }));
        null !== c && (b = h.Event(c +
            ".dt"), h(a.nTable).trigger(b, d), e.push(b.result));
        return e
    }

    function Ua(a) {
        var b = a._iDisplayStart, c = a.fnDisplayEnd(), d = a._iDisplayLength;
        b >= c && (b = c - d);
        b -= b % d;
        if (-1 === d || 0 > b) b = 0;
        a._iDisplayStart = b
    }

    function Pa(a, b) {
        var c = a.renderer, d = m.ext.renderer[b];
        return h.isPlainObject(c) && c[b] ? d[c[b]] || d._ : "string" === typeof c ? d[c] || d._ : d._
    }

    function y(a) {
        return a.oFeatures.bServerSide ? "ssp" : a.ajax || a.sAjaxSource ? "ajax" : "dom"
    }

    function ia(a, b) {
        var c = [], c = Nb.numbers_length, d = Math.floor(c / 2);
        b <= c ? c = X(0, b) : a <= d ? (c = X(0,
            c - 2), c.push("ellipsis"), c.push(b - 1)) : (a >= b - 1 - d ? c = X(b - (c - 2), b) : (c = X(a - d + 2, a + d - 1), c.push("ellipsis"), c.push(b - 1)), c.splice(0, 0, "ellipsis"), c.splice(0, 0, 0));
        c.DT_el = "span";
        return c
    }

    function fb(a) {
        h.each({
            num: function (b) {
                return Ba(b, a)
            }, "num-fmt": function (b) {
                return Ba(b, a, Za)
            }, "html-num": function (b) {
                return Ba(b, a, Ca)
            }, "html-num-fmt": function (b) {
                return Ba(b, a, Ca, Za)
            }
        }, function (b, c) {
            x.type.order[b + a + "-pre"] = c;
            b.match(/^html\-/) && (x.type.search[b + a] = x.type.search.html)
        })
    }

    function Ob(a) {
        return function () {
            var b =
                [Aa(this[m.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
            return m.ext.internal[a].apply(this, b)
        }
    }

    var m = function (a) {
            this.$ = function (a, b) {
                return this.api(!0).$(a, b)
            };
            this._ = function (a, b) {
                return this.api(!0).rows(a, b).data()
            };
            this.api = function (a) {
                return a ? new t(Aa(this[x.iApiIndex])) : new t(this)
            };
            this.fnAddData = function (a, b) {
                var c = this.api(!0),
                    d = h.isArray(a) && (h.isArray(a[0]) || h.isPlainObject(a[0])) ? c.rows.add(a) : c.row.add(a);
                (b === k || b) && c.draw();
                return d.flatten().toArray()
            };
            this.fnAdjustColumnSizing =
                function (a) {
                    var b = this.api(!0).columns.adjust(), c = b.settings()[0], d = c.oScroll;
                    a === k || a ? b.draw(!1) : ("" !== d.sX || "" !== d.sY) && ma(c)
                };
            this.fnClearTable = function (a) {
                var b = this.api(!0).clear();
                (a === k || a) && b.draw()
            };
            this.fnClose = function (a) {
                this.api(!0).row(a).child.hide()
            };
            this.fnDeleteRow = function (a, b, c) {
                var d = this.api(!0), a = d.rows(a), e = a.settings()[0], h = e.aoData[a[0][0]];
                a.remove();
                b && b.call(this, e, h);
                (c === k || c) && d.draw();
                return h
            };
            this.fnDestroy = function (a) {
                this.api(!0).destroy(a)
            };
            this.fnDraw = function (a) {
                this.api(!0).draw(a)
            };
            this.fnFilter = function (a, b, c, d, e, h) {
                e = this.api(!0);
                null === b || b === k ? e.search(a, c, d, h) : e.column(b).search(a, c, d, h);
                e.draw()
            };
            this.fnGetData = function (a, b) {
                var c = this.api(!0);
                if (a !== k) {
                    var d = a.nodeName ? a.nodeName.toLowerCase() : "";
                    return b !== k || "td" == d || "th" == d ? c.cell(a, b).data() : c.row(a).data() || null
                }
                return c.data().toArray()
            };
            this.fnGetNodes = function (a) {
                var b = this.api(!0);
                return a !== k ? b.row(a).node() : b.rows().nodes().flatten().toArray()
            };
            this.fnGetPosition = function (a) {
                var b = this.api(!0), c = a.nodeName.toUpperCase();
                return "TR" == c ? b.row(a).index() : "TD" == c || "TH" == c ? (a = b.cell(a).index(), [a.row, a.columnVisible, a.column]) : null
            };
            this.fnIsOpen = function (a) {
                return this.api(!0).row(a).child.isShown()
            };
            this.fnOpen = function (a, b, c) {
                return this.api(!0).row(a).child(b, c).show().child()[0]
            };
            this.fnPageChange = function (a, b) {
                var c = this.api(!0).page(a);
                (b === k || b) && c.draw(!1)
            };
            this.fnSetColumnVis = function (a, b, c) {
                a = this.api(!0).column(a).visible(b);
                (c === k || c) && a.columns.adjust().draw()
            };
            this.fnSettings = function () {
                return Aa(this[x.iApiIndex])
            };
            this.fnSort = function (a) {
                this.api(!0).order(a).draw()
            };
            this.fnSortListener = function (a, b, c) {
                this.api(!0).order.listener(a, b, c)
            };
            this.fnUpdate = function (a, b, c, d, e) {
                var h = this.api(!0);
                c === k || null === c ? h.row(b).data(a) : h.cell(b, c).data(a);
                (e === k || e) && h.columns.adjust();
                (d === k || d) && h.draw();
                return 0
            };
            this.fnVersionCheck = x.fnVersionCheck;
            var b = this, c = a === k, d = this.length;
            c && (a = {});
            this.oApi = this.internal = x.internal;
            for (var e in m.ext.internal) e && (this[e] = Ob(e));
            this.each(function () {
                var e = {}, g = 1 < d ? Mb(e, a, !0) :
                    a, j = 0, i, e = this.getAttribute("id"), n = !1, l = m.defaults, q = h(this);
                if ("table" != this.nodeName.toLowerCase()) K(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2); else {
                    gb(l);
                    hb(l.column);
                    J(l, l, !0);
                    J(l.column, l.column, !0);
                    J(l, h.extend(g, q.data()));
                    var r = m.settings, j = 0;
                    for (i = r.length; j < i; j++) {
                        var p = r[j];
                        if (p.nTable == this || p.nTHead.parentNode == this || p.nTFoot && p.nTFoot.parentNode == this) {
                            var t = g.bRetrieve !== k ? g.bRetrieve : l.bRetrieve;
                            if (c || t) return p.oInstance;
                            if (g.bDestroy !== k ? g.bDestroy : l.bDestroy) {
                                p.oInstance.fnDestroy();
                                break
                            } else {
                                K(p, 0, "Cannot reinitialise DataTable", 3);
                                return
                            }
                        }
                        if (p.sTableId == this.id) {
                            r.splice(j, 1);
                            break
                        }
                    }
                    if (null === e || "" === e) this.id = e = "DataTables_Table_" + m.ext._unique++;
                    var o = h.extend(!0, {}, m.models.oSettings, {
                        sDestroyWidth: q[0].style.width,
                        sInstance: e,
                        sTableId: e
                    });
                    o.nTable = this;
                    o.oApi = b.internal;
                    o.oInit = g;
                    r.push(o);
                    o.oInstance = 1 === b.length ? b : q.dataTable();
                    gb(g);
                    g.oLanguage && Fa(g.oLanguage);
                    g.aLengthMenu && !g.iDisplayLength && (g.iDisplayLength = h.isArray(g.aLengthMenu[0]) ? g.aLengthMenu[0][0] : g.aLengthMenu[0]);
                    g = Mb(h.extend(!0, {}, l), g);
                    F(o.oFeatures, g, "bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender".split(" "));
                    F(o, g, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"],
                        ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"], ["bJQueryUI", "bJUI"]]);
                    F(o.oScroll, g, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);
                    F(o.oLanguage, g, "fnInfoCallback");
                    z(o, "aoDrawCallback", g.fnDrawCallback, "user");
                    z(o, "aoServerParams", g.fnServerParams, "user");
                    z(o, "aoStateSaveParams", g.fnStateSaveParams, "user");
                    z(o, "aoStateLoadParams", g.fnStateLoadParams, "user");
                    z(o, "aoStateLoaded", g.fnStateLoaded,
                        "user");
                    z(o, "aoRowCallback", g.fnRowCallback, "user");
                    z(o, "aoRowCreatedCallback", g.fnCreatedRow, "user");
                    z(o, "aoHeaderCallback", g.fnHeaderCallback, "user");
                    z(o, "aoFooterCallback", g.fnFooterCallback, "user");
                    z(o, "aoInitComplete", g.fnInitComplete, "user");
                    z(o, "aoPreDrawCallback", g.fnPreDrawCallback, "user");
                    o.rowIdFn = R(g.rowId);
                    ib(o);
                    var u = o.oClasses;
                    g.bJQueryUI ? (h.extend(u, m.ext.oJUIClasses, g.oClasses), g.sDom === l.sDom && "lfrtip" === l.sDom && (o.sDom = '<"H"lfr>t<"F"ip>'), o.renderer) ? h.isPlainObject(o.renderer) &&
                        !o.renderer.header && (o.renderer.header = "jqueryui") : o.renderer = "jqueryui" : h.extend(u, m.ext.classes, g.oClasses);
                    q.addClass(u.sTable);
                    o.iInitDisplayStart === k && (o.iInitDisplayStart = g.iDisplayStart, o._iDisplayStart = g.iDisplayStart);
                    null !== g.iDeferLoading && (o.bDeferLoading = !0, e = h.isArray(g.iDeferLoading), o._iRecordsDisplay = e ? g.iDeferLoading[0] : g.iDeferLoading, o._iRecordsTotal = e ? g.iDeferLoading[1] : g.iDeferLoading);
                    var v = o.oLanguage;
                    h.extend(!0, v, g.oLanguage);
                    v.sUrl && (h.ajax({
                        dataType: "json", url: v.sUrl, success: function (a) {
                            Fa(a);
                            J(l.oLanguage, a);
                            h.extend(true, v, a);
                            ha(o)
                        }, error: function () {
                            ha(o)
                        }
                    }), n = !0);
                    null === g.asStripeClasses && (o.asStripeClasses = [u.sStripeOdd, u.sStripeEven]);
                    var e = o.asStripeClasses, x = q.children("tbody").find("tr").eq(0);
                    -1 !== h.inArray(!0, h.map(e, function (a) {
                        return x.hasClass(a)
                    })) && (h("tbody tr", this).removeClass(e.join(" ")), o.asDestroyStripes = e.slice());
                    e = [];
                    r = this.getElementsByTagName("thead");
                    0 !== r.length && (ea(o.aoHeader, r[0]), e = ta(o));
                    if (null === g.aoColumns) {
                        r = [];
                        j = 0;
                        for (i = e.length; j < i; j++) r.push(null)
                    } else r =
                        g.aoColumns;
                    j = 0;
                    for (i = r.length; j < i; j++) Ga(o, e ? e[j] : null);
                    kb(o, g.aoColumnDefs, r, function (a, b) {
                        la(o, a, b)
                    });
                    if (x.length) {
                        var w = function (a, b) {
                            return a.getAttribute("data-" + b) !== null ? b : null
                        };
                        h(x[0]).children("th, td").each(function (a, b) {
                            var c = o.aoColumns[a];
                            if (c.mData === a) {
                                var d = w(b, "sort") || w(b, "order"), e = w(b, "filter") || w(b, "search");
                                if (d !== null || e !== null) {
                                    c.mData = {
                                        _: a + ".display",
                                        sort: d !== null ? a + ".@data-" + d : k,
                                        type: d !== null ? a + ".@data-" + d : k,
                                        filter: e !== null ? a + ".@data-" + e : k
                                    };
                                    la(o, a)
                                }
                            }
                        })
                    }
                    var U = o.oFeatures,
                        e = function () {
                            if (g.aaSorting === k) {
                                var a = o.aaSorting;
                                j = 0;
                                for (i = a.length; j < i; j++) a[j][1] = o.aoColumns[j].asSorting[0]
                            }
                            ya(o);
                            U.bSort && z(o, "aoDrawCallback", function () {
                                if (o.bSorted) {
                                    var a = W(o), b = {};
                                    h.each(a, function (a, c) {
                                        b[c.src] = c.dir
                                    });
                                    s(o, null, "order", [o, a, b]);
                                    Kb(o)
                                }
                            });
                            z(o, "aoDrawCallback", function () {
                                (o.bSorted || y(o) === "ssp" || U.bDeferRender) && ya(o)
                            }, "sc");
                            var a = q.children("caption").each(function () {
                                this._captionSide = h(this).css("caption-side")
                            }), b = q.children("thead");
                            b.length === 0 && (b = h("<thead/>").appendTo(q));
                            o.nTHead = b[0];
                            b = q.children("tbody");
                            b.length === 0 && (b = h("<tbody/>").appendTo(q));
                            o.nTBody = b[0];
                            b = q.children("tfoot");
                            if (b.length === 0 && a.length > 0 && (o.oScroll.sX !== "" || o.oScroll.sY !== "")) b = h("<tfoot/>").appendTo(q);
                            if (b.length === 0 || b.children().length === 0) q.addClass(u.sNoFooter); else if (b.length > 0) {
                                o.nTFoot = b[0];
                                ea(o.aoFooter, o.nTFoot)
                            }
                            if (g.aaData) for (j = 0; j < g.aaData.length; j++) N(o, g.aaData[j]); else (o.bDeferLoading || y(o) == "dom") && oa(o, h(o.nTBody).children("tr"));
                            o.aiDisplay = o.aiDisplayMaster.slice();
                            o.bInitialised = true;
                            n === false && ha(o)
                        };
                    g.bStateSave ? (U.bStateSave = !0, z(o, "aoDrawCallback", za, "state_save"), Lb(o, g, e)) : e()
                }
            });
            b = null;
            return this
        }, x, t, p, u, $a = {}, Pb = /[\r\n]/g, Ca = /<.*?>/g,
        cc = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/,
        dc = RegExp("(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\|\\$|\\^|\\-)", "g"),
        Za = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi, M = function (a) {
            return !a || !0 === a || "-" === a ? !0 : !1
        }, Qb = function (a) {
            var b = parseInt(a, 10);
            return !isNaN(b) &&
            isFinite(a) ? b : null
        }, Rb = function (a, b) {
            $a[b] || ($a[b] = RegExp(Sa(b), "g"));
            return "string" === typeof a && "." !== b ? a.replace(/\./g, "").replace($a[b], ".") : a
        }, ab = function (a, b, c) {
            var d = "string" === typeof a;
            if (M(a)) return !0;
            b && d && (a = Rb(a, b));
            c && d && (a = a.replace(Za, ""));
            return !isNaN(parseFloat(a)) && isFinite(a)
        }, Sb = function (a, b, c) {
            return M(a) ? !0 : !(M(a) || "string" === typeof a) ? null : ab(a.replace(Ca, ""), b, c) ? !0 : null
        }, D = function (a, b, c) {
            var d = [], e = 0, f = a.length;
            if (c !== k) for (; e < f; e++) a[e] && a[e][b] && d.push(a[e][b][c]); else for (; e <
                                                                                               f; e++) a[e] && d.push(a[e][b]);
            return d
        }, ja = function (a, b, c, d) {
            var e = [], f = 0, g = b.length;
            if (d !== k) for (; f < g; f++) a[b[f]][c] && e.push(a[b[f]][c][d]); else for (; f < g; f++) e.push(a[b[f]][c]);
            return e
        }, X = function (a, b) {
            var c = [], d;
            b === k ? (b = 0, d = a) : (d = b, b = a);
            for (var e = b; e < d; e++) c.push(e);
            return c
        }, Tb = function (a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) a[c] && b.push(a[c]);
            return b
        }, sa = function (a) {
            var b;
            a:{
                if (!(2 > a.length)) {
                    b = a.slice().sort();
                    for (var c = b[0], d = 1, e = b.length; d < e; d++) {
                        if (b[d] === c) {
                            b = !1;
                            break a
                        }
                        c = b[d]
                    }
                }
                b = !0
            }
            if (b) return a.slice();
            b = [];
            var e = a.length, f, g = 0, d = 0;
            a:for (; d < e; d++) {
                c = a[d];
                for (f = 0; f < g; f++) if (b[f] === c) continue a;
                b.push(c);
                g++
            }
            return b
        };
    m.util = {
        throttle: function (a, b) {
            var c = b !== k ? b : 200, d, e;
            return function () {
                var b = this, g = +new Date, h = arguments;
                d && g < d + c ? (clearTimeout(e), e = setTimeout(function () {
                    d = k;
                    a.apply(b, h)
                }, c)) : (d = g, a.apply(b, h))
            }
        }, escapeRegex: function (a) {
            return a.replace(dc, "\\$1")
        }
    };
    var A = function (a, b, c) {
        a[b] !== k && (a[c] = a[b])
    }, ca = /\[.*?\]$/, V = /\(\)$/, Sa = m.util.escapeRegex, xa = h("<div>")[0], $b = xa.textContent !== k, bc =
        /<.*?>/g, Qa = m.util.throttle, Ub = [], w = Array.prototype, ec = function (a) {
        var b, c, d = m.settings, e = h.map(d, function (a) {
            return a.nTable
        });
        if (a) {
            if (a.nTable && a.oApi) return [a];
            if (a.nodeName && "table" === a.nodeName.toLowerCase()) return b = h.inArray(a, e), -1 !== b ? [d[b]] : null;
            if (a && "function" === typeof a.settings) return a.settings().toArray();
            "string" === typeof a ? c = h(a) : a instanceof h && (c = a)
        } else return [];
        if (c) return c.map(function () {
            b = h.inArray(this, e);
            return -1 !== b ? d[b] : null
        }).toArray()
    };
    t = function (a, b) {
        if (!(this instanceof
                t)) return new t(a, b);
        var c = [], d = function (a) {
            (a = ec(a)) && (c = c.concat(a))
        };
        if (h.isArray(a)) for (var e = 0, f = a.length; e < f; e++) d(a[e]); else d(a);
        this.context = sa(c);
        b && h.merge(this, b);
        this.selector = {rows: null, cols: null, opts: null};
        t.extend(this, this, Ub)
    };
    m.Api = t;
    h.extend(t.prototype, {
        any: function () {
            return 0 !== this.count()
        }, concat: w.concat, context: [], count: function () {
            return this.flatten().length
        }, each: function (a) {
            for (var b = 0, c = this.length; b < c; b++) a.call(this, this[b], b, this);
            return this
        }, eq: function (a) {
            var b =
                this.context;
            return b.length > a ? new t(b[a], this[a]) : null
        }, filter: function (a) {
            var b = [];
            if (w.filter) b = w.filter.call(this, a, this); else for (var c = 0, d = this.length; c < d; c++) a.call(this, this[c], c, this) && b.push(this[c]);
            return new t(this.context, b)
        }, flatten: function () {
            var a = [];
            return new t(this.context, a.concat.apply(a, this.toArray()))
        }, join: w.join, indexOf: w.indexOf || function (a, b) {
            for (var c = b || 0, d = this.length; c < d; c++) if (this[c] === a) return c;
            return -1
        }, iterator: function (a, b, c, d) {
            var e = [], f, g, h, i, n, l = this.context,
                m, p, u = this.selector;
            "string" === typeof a && (d = c, c = b, b = a, a = !1);
            g = 0;
            for (h = l.length; g < h; g++) {
                var s = new t(l[g]);
                if ("table" === b) f = c.call(s, l[g], g), f !== k && e.push(f); else if ("columns" === b || "rows" === b) f = c.call(s, l[g], this[g], g), f !== k && e.push(f); else if ("column" === b || "column-rows" === b || "row" === b || "cell" === b) {
                    p = this[g];
                    "column-rows" === b && (m = Da(l[g], u.opts));
                    i = 0;
                    for (n = p.length; i < n; i++) f = p[i], f = "cell" === b ? c.call(s, l[g], f.row, f.column, g, i) : c.call(s, l[g], f, g, i, m), f !== k && e.push(f)
                }
            }
            return e.length || d ? (a = new t(l, a ?
                e.concat.apply([], e) : e), b = a.selector, b.rows = u.rows, b.cols = u.cols, b.opts = u.opts, a) : this
        }, lastIndexOf: w.lastIndexOf || function (a, b) {
            return this.indexOf.apply(this.toArray.reverse(), arguments)
        }, length: 0, map: function (a) {
            var b = [];
            if (w.map) b = w.map.call(this, a, this); else for (var c = 0, d = this.length; c < d; c++) b.push(a.call(this, this[c], c));
            return new t(this.context, b)
        }, pluck: function (a) {
            return this.map(function (b) {
                return b[a]
            })
        }, pop: w.pop, push: w.push, reduce: w.reduce || function (a, b) {
            return jb(this, a, b, 0, this.length,
                1)
        }, reduceRight: w.reduceRight || function (a, b) {
            return jb(this, a, b, this.length - 1, -1, -1)
        }, reverse: w.reverse, selector: null, shift: w.shift, slice: function () {
            return new t(this.context, this)
        }, sort: w.sort, splice: w.splice, toArray: function () {
            return w.slice.call(this)
        }, to$: function () {
            return h(this)
        }, toJQuery: function () {
            return h(this)
        }, unique: function () {
            return new t(this.context, sa(this))
        }, unshift: w.unshift
    });
    t.extend = function (a, b, c) {
        if (c.length && b && (b instanceof t || b.__dt_wrapper)) {
            var d, e, f, g = function (a, b, c) {
                return function () {
                    var d =
                        b.apply(a, arguments);
                    t.extend(d, d, c.methodExt);
                    return d
                }
            };
            d = 0;
            for (e = c.length; d < e; d++) f = c[d], b[f.name] = "function" === typeof f.val ? g(a, f.val, f) : h.isPlainObject(f.val) ? {} : f.val, b[f.name].__dt_wrapper = !0, t.extend(a, b[f.name], f.propExt)
        }
    };
    t.register = p = function (a, b) {
        if (h.isArray(a)) for (var c = 0, d = a.length; c < d; c++) t.register(a[c], b); else for (var e = a.split("."), f = Ub, g, j, c = 0, d = e.length; c < d; c++) {
            g = (j = -1 !== e[c].indexOf("()")) ? e[c].replace("()", "") : e[c];
            var i;
            a:{
                i = 0;
                for (var n = f.length; i < n; i++) if (f[i].name === g) {
                    i =
                        f[i];
                    break a
                }
                i = null
            }
            i || (i = {name: g, val: {}, methodExt: [], propExt: []}, f.push(i));
            c === d - 1 ? i.val = b : f = j ? i.methodExt : i.propExt
        }
    };
    t.registerPlural = u = function (a, b, c) {
        t.register(a, c);
        t.register(b, function () {
            var a = c.apply(this, arguments);
            return a === this ? this : a instanceof t ? a.length ? h.isArray(a[0]) ? new t(a.context, a[0]) : a[0] : k : a
        })
    };
    p("tables()", function (a) {
        var b;
        if (a) {
            b = t;
            var c = this.context;
            if ("number" === typeof a) a = [c[a]]; else var d = h.map(c, function (a) {
                return a.nTable
            }), a = h(d).filter(a).map(function () {
                var a = h.inArray(this,
                    d);
                return c[a]
            }).toArray();
            b = new b(a)
        } else b = this;
        return b
    });
    p("table()", function (a) {
        var a = this.tables(a), b = a.context;
        return b.length ? new t(b[0]) : a
    });
    u("tables().nodes()", "table().node()", function () {
        return this.iterator("table", function (a) {
            return a.nTable
        }, 1)
    });
    u("tables().body()", "table().body()", function () {
        return this.iterator("table", function (a) {
            return a.nTBody
        }, 1)
    });
    u("tables().header()", "table().header()", function () {
        return this.iterator("table", function (a) {
            return a.nTHead
        }, 1)
    });
    u("tables().footer()",
        "table().footer()", function () {
            return this.iterator("table", function (a) {
                return a.nTFoot
            }, 1)
        });
    u("tables().containers()", "table().container()", function () {
        return this.iterator("table", function (a) {
            return a.nTableWrapper
        }, 1)
    });
    p("draw()", function (a) {
        return this.iterator("table", function (b) {
            "page" === a ? O(b) : ("string" === typeof a && (a = "full-hold" === a ? !1 : !0), T(b, !1 === a))
        })
    });
    p("page()", function (a) {
        return a === k ? this.page.info().page : this.iterator("table", function (b) {
            Va(b, a)
        })
    });
    p("page.info()", function () {
        if (0 ===
            this.context.length) return k;
        var a = this.context[0], b = a._iDisplayStart, c = a.oFeatures.bPaginate ? a._iDisplayLength : -1,
            d = a.fnRecordsDisplay(), e = -1 === c;
        return {
            page: e ? 0 : Math.floor(b / c),
            pages: e ? 1 : Math.ceil(d / c),
            start: b,
            end: a.fnDisplayEnd(),
            length: c,
            recordsTotal: a.fnRecordsTotal(),
            recordsDisplay: d,
            serverSide: "ssp" === y(a)
        }
    });
    p("page.len()", function (a) {
        return a === k ? 0 !== this.context.length ? this.context[0]._iDisplayLength : k : this.iterator("table", function (b) {
            Ta(b, a)
        })
    });
    var Vb = function (a, b, c) {
        if (c) {
            var d = new t(a);
            d.one("draw", function () {
                c(d.ajax.json())
            })
        }
        if ("ssp" == y(a)) T(a, b); else {
            C(a, !0);
            var e = a.jqXHR;
            e && 4 !== e.readyState && e.abort();
            ua(a, [], function (c) {
                pa(a);
                for (var c = va(a, c), d = 0, e = c.length; d < e; d++) N(a, c[d]);
                T(a, b);
                C(a, !1)
            })
        }
    };
    p("ajax.json()", function () {
        var a = this.context;
        if (0 < a.length) return a[0].json
    });
    p("ajax.params()", function () {
        var a = this.context;
        if (0 < a.length) return a[0].oAjaxData
    });
    p("ajax.reload()", function (a, b) {
        return this.iterator("table", function (c) {
            Vb(c, !1 === b, a)
        })
    });
    p("ajax.url()", function (a) {
        var b =
            this.context;
        if (a === k) {
            if (0 === b.length) return k;
            b = b[0];
            return b.ajax ? h.isPlainObject(b.ajax) ? b.ajax.url : b.ajax : b.sAjaxSource
        }
        return this.iterator("table", function (b) {
            h.isPlainObject(b.ajax) ? b.ajax.url = a : b.ajax = a
        })
    });
    p("ajax.url().load()", function (a, b) {
        return this.iterator("table", function (c) {
            Vb(c, !1 === b, a)
        })
    });
    var bb = function (a, b, c, d, e) {
        var f = [], g, j, i, n, l, m;
        i = typeof b;
        if (!b || "string" === i || "function" === i || b.length === k) b = [b];
        i = 0;
        for (n = b.length; i < n; i++) {
            j = b[i] && b[i].split && !b[i].match(/[\[\(:]/) ? b[i].split(",") :
                [b[i]];
            l = 0;
            for (m = j.length; l < m; l++) (g = c("string" === typeof j[l] ? h.trim(j[l]) : j[l])) && g.length && (f = f.concat(g))
        }
        a = x.selector[a];
        if (a.length) {
            i = 0;
            for (n = a.length; i < n; i++) f = a[i](d, e, f)
        }
        return sa(f)
    }, cb = function (a) {
        a || (a = {});
        a.filter && a.search === k && (a.search = a.filter);
        return h.extend({search: "none", order: "current", page: "all"}, a)
    }, db = function (a) {
        for (var b = 0, c = a.length; b < c; b++) if (0 < a[b].length) return a[0] = a[b], a[0].length = 1, a.length = 1, a.context = [a.context[b]], a;
        a.length = 0;
        return a
    }, Da = function (a, b) {
        var c,
            d, e, f = [], g = a.aiDisplay;
        c = a.aiDisplayMaster;
        var j = b.search;
        d = b.order;
        e = b.page;
        if ("ssp" == y(a)) return "removed" === j ? [] : X(0, c.length);
        if ("current" == e) {
            c = a._iDisplayStart;
            for (d = a.fnDisplayEnd(); c < d; c++) f.push(g[c])
        } else if ("current" == d || "applied" == d) f = "none" == j ? c.slice() : "applied" == j ? g.slice() : h.map(c, function (a) {
            return -1 === h.inArray(a, g) ? a : null
        }); else if ("index" == d || "original" == d) {
            c = 0;
            for (d = a.aoData.length; c < d; c++) "none" == j ? f.push(c) : (e = h.inArray(c, g), (-1 === e && "removed" == j || 0 <= e && "applied" == j) && f.push(c))
        }
        return f
    };
    p("rows()", function (a, b) {
        a === k ? a = "" : h.isPlainObject(a) && (b = a, a = "");
        var b = cb(b), c = this.iterator("table", function (c) {
            var e = b, f;
            return bb("row", a, function (a) {
                var b = Qb(a);
                if (b !== null && !e) return [b];
                f || (f = Da(c, e));
                if (b !== null && h.inArray(b, f) !== -1) return [b];
                if (a === null || a === k || a === "") return f;
                if (typeof a === "function") return h.map(f, function (b) {
                    var e = c.aoData[b];
                    return a(b, e._aData, e.nTr) ? b : null
                });
                b = Tb(ja(c.aoData, f, "nTr"));
                if (a.nodeName) {
                    if (a._DT_RowIndex !== k) return [a._DT_RowIndex];
                    if (a._DT_CellIndex) return [a._DT_CellIndex.row];
                    b = h(a).closest("*[data-dt-row]");
                    return b.length ? [b.data("dt-row")] : []
                }
                if (typeof a === "string" && a.charAt(0) === "#") {
                    var i = c.aIds[a.replace(/^#/, "")];
                    if (i !== k) return [i.idx]
                }
                return h(b).filter(a).map(function () {
                    return this._DT_RowIndex
                }).toArray()
            }, c, e)
        }, 1);
        c.selector.rows = a;
        c.selector.opts = b;
        return c
    });
    p("rows().nodes()", function () {
        return this.iterator("row", function (a, b) {
            return a.aoData[b].nTr || k
        }, 1)
    });
    p("rows().data()", function () {
        return this.iterator(!0, "rows", function (a, b) {
                return ja(a.aoData, b, "_aData")
            },
            1)
    });
    u("rows().cache()", "row().cache()", function (a) {
        return this.iterator("row", function (b, c) {
            var d = b.aoData[c];
            return "search" === a ? d._aFilterData : d._aSortData
        }, 1)
    });
    u("rows().invalidate()", "row().invalidate()", function (a) {
        return this.iterator("row", function (b, c) {
            da(b, c, a)
        })
    });
    u("rows().indexes()", "row().index()", function () {
        return this.iterator("row", function (a, b) {
            return b
        }, 1)
    });
    u("rows().ids()", "row().id()", function (a) {
        for (var b = [], c = this.context, d = 0, e = c.length; d < e; d++) for (var f = 0, g = this[d].length; f <
        g; f++) {
            var h = c[d].rowIdFn(c[d].aoData[this[d][f]]._aData);
            b.push((!0 === a ? "#" : "") + h)
        }
        return new t(c, b)
    });
    u("rows().remove()", "row().remove()", function () {
        var a = this;
        this.iterator("row", function (b, c, d) {
            var e = b.aoData, f = e[c], g, h, i, n, l;
            e.splice(c, 1);
            g = 0;
            for (h = e.length; g < h; g++) if (i = e[g], l = i.anCells, null !== i.nTr && (i.nTr._DT_RowIndex = g), null !== l) {
                i = 0;
                for (n = l.length; i < n; i++) l[i]._DT_CellIndex.row = g
            }
            qa(b.aiDisplayMaster, c);
            qa(b.aiDisplay, c);
            qa(a[d], c, !1);
            Ua(b);
            c = b.rowIdFn(f._aData);
            c !== k && delete b.aIds[c]
        });
        this.iterator("table", function (a) {
            for (var c = 0, d = a.aoData.length; c < d; c++) a.aoData[c].idx = c
        });
        return this
    });
    p("rows.add()", function (a) {
        var b = this.iterator("table", function (b) {
            var c, f, g, h = [];
            f = 0;
            for (g = a.length; f < g; f++) c = a[f], c.nodeName && "TR" === c.nodeName.toUpperCase() ? h.push(oa(b, c)[0]) : h.push(N(b, c));
            return h
        }, 1), c = this.rows(-1);
        c.pop();
        h.merge(c, b);
        return c
    });
    p("row()", function (a, b) {
        return db(this.rows(a, b))
    });
    p("row().data()", function (a) {
        var b = this.context;
        if (a === k) return b.length && this.length ? b[0].aoData[this[0]]._aData :
            k;
        b[0].aoData[this[0]]._aData = a;
        da(b[0], this[0], "data");
        return this
    });
    p("row().node()", function () {
        var a = this.context;
        return a.length && this.length ? a[0].aoData[this[0]].nTr || null : null
    });
    p("row.add()", function (a) {
        a instanceof h && a.length && (a = a[0]);
        var b = this.iterator("table", function (b) {
            return a.nodeName && "TR" === a.nodeName.toUpperCase() ? oa(b, a)[0] : N(b, a)
        });
        return this.row(b[0])
    });
    var eb = function (a, b) {
        var c = a.context;
        if (c.length && (c = c[0].aoData[b !== k ? b : a[0]]) && c._details) c._details.remove(), c._detailsShow =
            k, c._details = k
    }, Wb = function (a, b) {
        var c = a.context;
        if (c.length && a.length) {
            var d = c[0].aoData[a[0]];
            if (d._details) {
                (d._detailsShow = b) ? d._details.insertAfter(d.nTr) : d._details.detach();
                var e = c[0], f = new t(e), g = e.aoData;
                f.off("draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details");
                0 < D(g, "_details").length && (f.on("draw.dt.DT_details", function (a, b) {
                    e === b && f.rows({page: "current"}).eq(0).each(function (a) {
                        a = g[a];
                        a._detailsShow && a._details.insertAfter(a.nTr)
                    })
                }), f.on("column-visibility.dt.DT_details",
                    function (a, b) {
                        if (e === b) for (var c, d = ba(b), f = 0, h = g.length; f < h; f++) c = g[f], c._details && c._details.children("td[colspan]").attr("colspan", d)
                    }), f.on("destroy.dt.DT_details", function (a, b) {
                    if (e === b) for (var c = 0, d = g.length; c < d; c++) g[c]._details && eb(f, c)
                }))
            }
        }
    };
    p("row().child()", function (a, b) {
        var c = this.context;
        if (a === k) return c.length && this.length ? c[0].aoData[this[0]]._details : k;
        if (!0 === a) this.child.show(); else if (!1 === a) eb(this); else if (c.length && this.length) {
            var d = c[0], c = c[0].aoData[this[0]], e = [], f = function (a,
                                                                          b) {
                if (h.isArray(a) || a instanceof h) for (var c = 0, k = a.length; c < k; c++) f(a[c], b); else a.nodeName && "tr" === a.nodeName.toLowerCase() ? e.push(a) : (c = h("<tr><td/></tr>").addClass(b), h("td", c).addClass(b).html(a)[0].colSpan = ba(d), e.push(c[0]))
            };
            f(a, b);
            c._details && c._details.detach();
            c._details = h(e);
            c._detailsShow && c._details.insertAfter(c.nTr)
        }
        return this
    });
    p(["row().child.show()", "row().child().show()"], function () {
        Wb(this, !0);
        return this
    });
    p(["row().child.hide()", "row().child().hide()"], function () {
        Wb(this, !1);
        return this
    });
    p(["row().child.remove()", "row().child().remove()"], function () {
        eb(this);
        return this
    });
    p("row().child.isShown()", function () {
        var a = this.context;
        return a.length && this.length ? a[0].aoData[this[0]]._detailsShow || !1 : !1
    });
    var fc = /^([^:]+):(name|visIdx|visible)$/, Xb = function (a, b, c, d, e) {
        for (var c = [], d = 0, f = e.length; d < f; d++) c.push(B(a, e[d], b));
        return c
    };
    p("columns()", function (a, b) {
        a === k ? a = "" : h.isPlainObject(a) && (b = a, a = "");
        var b = cb(b), c = this.iterator("table", function (c) {
            var e = a, f = b, g = c.aoColumns,
                j = D(g, "sName"), i = D(g, "nTh");
            return bb("column", e, function (a) {
                var b = Qb(a);
                if (a === "") return X(g.length);
                if (b !== null) return [b >= 0 ? b : g.length + b];
                if (typeof a === "function") {
                    var e = Da(c, f);
                    return h.map(g, function (b, f) {
                        return a(f, Xb(c, f, 0, 0, e), i[f]) ? f : null
                    })
                }
                var k = typeof a === "string" ? a.match(fc) : "";
                if (k) switch (k[2]) {
                    case "visIdx":
                    case "visible":
                        b = parseInt(k[1], 10);
                        if (b < 0) {
                            var m = h.map(g, function (a, b) {
                                return a.bVisible ? b : null
                            });
                            return [m[m.length + b]]
                        }
                        return [$(c, b)];
                    case "name":
                        return h.map(j, function (a, b) {
                            return a ===
                            k[1] ? b : null
                        });
                    default:
                        return []
                }
                if (a.nodeName && a._DT_CellIndex) return [a._DT_CellIndex.column];
                b = h(i).filter(a).map(function () {
                    return h.inArray(this, i)
                }).toArray();
                if (b.length || !a.nodeName) return b;
                b = h(a).closest("*[data-dt-column]");
                return b.length ? [b.data("dt-column")] : []
            }, c, f)
        }, 1);
        c.selector.cols = a;
        c.selector.opts = b;
        return c
    });
    u("columns().header()", "column().header()", function () {
        return this.iterator("column", function (a, b) {
            return a.aoColumns[b].nTh
        }, 1)
    });
    u("columns().footer()", "column().footer()",
        function () {
            return this.iterator("column", function (a, b) {
                return a.aoColumns[b].nTf
            }, 1)
        });
    u("columns().data()", "column().data()", function () {
        return this.iterator("column-rows", Xb, 1)
    });
    u("columns().dataSrc()", "column().dataSrc()", function () {
        return this.iterator("column", function (a, b) {
            return a.aoColumns[b].mData
        }, 1)
    });
    u("columns().cache()", "column().cache()", function (a) {
        return this.iterator("column-rows", function (b, c, d, e, f) {
            return ja(b.aoData, f, "search" === a ? "_aFilterData" : "_aSortData", c)
        }, 1)
    });
    u("columns().nodes()",
        "column().nodes()", function () {
            return this.iterator("column-rows", function (a, b, c, d, e) {
                return ja(a.aoData, e, "anCells", b)
            }, 1)
        });
    u("columns().visible()", "column().visible()", function (a, b) {
        var c = this.iterator("column", function (b, c) {
            if (a === k) return b.aoColumns[c].bVisible;
            var f = b.aoColumns, g = f[c], j = b.aoData, i, n, l;
            if (a !== k && g.bVisible !== a) {
                if (a) {
                    var m = h.inArray(!0, D(f, "bVisible"), c + 1);
                    i = 0;
                    for (n = j.length; i < n; i++) l = j[i].nTr, f = j[i].anCells, l && l.insertBefore(f[c], f[m] || null)
                } else h(D(b.aoData, "anCells", c)).detach();
                g.bVisible = a;
                fa(b, b.aoHeader);
                fa(b, b.aoFooter);
                za(b)
            }
        });
        a !== k && (this.iterator("column", function (c, e) {
            s(c, null, "column-visibility", [c, e, a, b])
        }), (b === k || b) && this.columns.adjust());
        return c
    });
    u("columns().indexes()", "column().index()", function (a) {
        return this.iterator("column", function (b, c) {
            return "visible" === a ? aa(b, c) : c
        }, 1)
    });
    p("columns.adjust()", function () {
        return this.iterator("table", function (a) {
            Z(a)
        }, 1)
    });
    p("column.index()", function (a, b) {
        if (0 !== this.context.length) {
            var c = this.context[0];
            if ("fromVisible" ===
                a || "toData" === a) return $(c, b);
            if ("fromData" === a || "toVisible" === a) return aa(c, b)
        }
    });
    p("column()", function (a, b) {
        return db(this.columns(a, b))
    });
    p("cells()", function (a, b, c) {
        h.isPlainObject(a) && (a.row === k ? (c = a, a = null) : (c = b, b = null));
        h.isPlainObject(b) && (c = b, b = null);
        if (null === b || b === k) return this.iterator("table", function (b) {
            var d = a, e = cb(c), f = b.aoData, g = Da(b, e), j = Tb(ja(f, g, "anCells")),
                i = h([].concat.apply([], j)), l, n = b.aoColumns.length, m, p, u, t, s, v;
            return bb("cell", d, function (a) {
                var c = typeof a === "function";
                if (a === null || a === k || c) {
                    m = [];
                    p = 0;
                    for (u = g.length; p < u; p++) {
                        l = g[p];
                        for (t = 0; t < n; t++) {
                            s = {row: l, column: t};
                            if (c) {
                                v = f[l];
                                a(s, B(b, l, t), v.anCells ? v.anCells[t] : null) && m.push(s)
                            } else m.push(s)
                        }
                    }
                    return m
                }
                if (h.isPlainObject(a)) return [a];
                c = i.filter(a).map(function (a, b) {
                    return {row: b._DT_CellIndex.row, column: b._DT_CellIndex.column}
                }).toArray();
                if (c.length || !a.nodeName) return c;
                v = h(a).closest("*[data-dt-row]");
                return v.length ? [{row: v.data("dt-row"), column: v.data("dt-column")}] : []
            }, b, e)
        });
        var d = this.columns(b, c), e = this.rows(a,
            c), f, g, j, i, n, l = this.iterator("table", function (a, b) {
            f = [];
            g = 0;
            for (j = e[b].length; g < j; g++) {
                i = 0;
                for (n = d[b].length; i < n; i++) f.push({row: e[b][g], column: d[b][i]})
            }
            return f
        }, 1);
        h.extend(l.selector, {cols: b, rows: a, opts: c});
        return l
    });
    u("cells().nodes()", "cell().node()", function () {
        return this.iterator("cell", function (a, b, c) {
            return (a = a.aoData[b]) && a.anCells ? a.anCells[c] : k
        }, 1)
    });
    p("cells().data()", function () {
        return this.iterator("cell", function (a, b, c) {
            return B(a, b, c)
        }, 1)
    });
    u("cells().cache()", "cell().cache()", function (a) {
        a =
            "search" === a ? "_aFilterData" : "_aSortData";
        return this.iterator("cell", function (b, c, d) {
            return b.aoData[c][a][d]
        }, 1)
    });
    u("cells().render()", "cell().render()", function (a) {
        return this.iterator("cell", function (b, c, d) {
            return B(b, c, d, a)
        }, 1)
    });
    u("cells().indexes()", "cell().index()", function () {
        return this.iterator("cell", function (a, b, c) {
            return {row: b, column: c, columnVisible: aa(a, c)}
        }, 1)
    });
    u("cells().invalidate()", "cell().invalidate()", function (a) {
        return this.iterator("cell", function (b, c, d) {
            da(b, c, a, d)
        })
    });
    p("cell()",
        function (a, b, c) {
            return db(this.cells(a, b, c))
        });
    p("cell().data()", function (a) {
        var b = this.context, c = this[0];
        if (a === k) return b.length && c.length ? B(b[0], c[0].row, c[0].column) : k;
        lb(b[0], c[0].row, c[0].column, a);
        da(b[0], c[0].row, "data", c[0].column);
        return this
    });
    p("order()", function (a, b) {
        var c = this.context;
        if (a === k) return 0 !== c.length ? c[0].aaSorting : k;
        "number" === typeof a ? a = [[a, b]] : a.length && !h.isArray(a[0]) && (a = Array.prototype.slice.call(arguments));
        return this.iterator("table", function (b) {
            b.aaSorting = a.slice()
        })
    });
    p("order.listener()", function (a, b, c) {
        return this.iterator("table", function (d) {
            Oa(d, a, b, c)
        })
    });
    p("order.fixed()", function (a) {
        if (!a) {
            var b = this.context, b = b.length ? b[0].aaSortingFixed : k;
            return h.isArray(b) ? {pre: b} : b
        }
        return this.iterator("table", function (b) {
            b.aaSortingFixed = h.extend(!0, {}, a)
        })
    });
    p(["columns().order()", "column().order()"], function (a) {
        var b = this;
        return this.iterator("table", function (c, d) {
            var e = [];
            h.each(b[d], function (b, c) {
                e.push([c, a])
            });
            c.aaSorting = e
        })
    });
    p("search()", function (a, b, c, d) {
        var e =
            this.context;
        return a === k ? 0 !== e.length ? e[0].oPreviousSearch.sSearch : k : this.iterator("table", function (e) {
            e.oFeatures.bFilter && ga(e, h.extend({}, e.oPreviousSearch, {
                sSearch: a + "",
                bRegex: null === b ? !1 : b,
                bSmart: null === c ? !0 : c,
                bCaseInsensitive: null === d ? !0 : d
            }), 1)
        })
    });
    u("columns().search()", "column().search()", function (a, b, c, d) {
        return this.iterator("column", function (e, f) {
            var g = e.aoPreSearchCols;
            if (a === k) return g[f].sSearch;
            e.oFeatures.bFilter && (h.extend(g[f], {
                sSearch: a + "", bRegex: null === b ? !1 : b, bSmart: null === c ?
                    !0 : c, bCaseInsensitive: null === d ? !0 : d
            }), ga(e, e.oPreviousSearch, 1))
        })
    });
    p("state()", function () {
        return this.context.length ? this.context[0].oSavedState : null
    });
    p("state.clear()", function () {
        return this.iterator("table", function (a) {
            a.fnStateSaveCallback.call(a.oInstance, a, {})
        })
    });
    p("state.loaded()", function () {
        return this.context.length ? this.context[0].oLoadedState : null
    });
    p("state.save()", function () {
        return this.iterator("table", function (a) {
            za(a)
        })
    });
    m.versionCheck = m.fnVersionCheck = function (a) {
        for (var b = m.version.split("."),
                 a = a.split("."), c, d, e = 0, f = a.length; e < f; e++) if (c = parseInt(b[e], 10) || 0, d = parseInt(a[e], 10) || 0, c !== d) return c > d;
        return !0
    };
    m.isDataTable = m.fnIsDataTable = function (a) {
        var b = h(a).get(0), c = !1;
        if (a instanceof m.Api) return !0;
        h.each(m.settings, function (a, e) {
            var f = e.nScrollHead ? h("table", e.nScrollHead)[0] : null,
                g = e.nScrollFoot ? h("table", e.nScrollFoot)[0] : null;
            if (e.nTable === b || f === b || g === b) c = !0
        });
        return c
    };
    m.tables = m.fnTables = function (a) {
        var b = !1;
        h.isPlainObject(a) && (b = a.api, a = a.visible);
        var c = h.map(m.settings,
            function (b) {
                if (!a || a && h(b.nTable).is(":visible")) return b.nTable
            });
        return b ? new t(c) : c
    };
    m.camelToHungarian = J;
    p("$()", function (a, b) {
        var c = this.rows(b).nodes(), c = h(c);
        return h([].concat(c.filter(a).toArray(), c.find(a).toArray()))
    });
    h.each(["on", "one", "off"], function (a, b) {
        p(b + "()", function () {
            var a = Array.prototype.slice.call(arguments);
            a[0] = h.map(a[0].split(/\s/), function (a) {
                return !a.match(/\.dt\b/) ? a + ".dt" : a
            }).join(" ");
            var d = h(this.tables().nodes());
            d[b].apply(d, a);
            return this
        })
    });
    p("clear()", function () {
        return this.iterator("table",
            function (a) {
                pa(a)
            })
    });
    p("settings()", function () {
        return new t(this.context, this.context)
    });
    p("init()", function () {
        var a = this.context;
        return a.length ? a[0].oInit : null
    });
    p("data()", function () {
        return this.iterator("table", function (a) {
            return D(a.aoData, "_aData")
        }).flatten()
    });
    p("destroy()", function (a) {
        a = a || !1;
        return this.iterator("table", function (b) {
            var c = b.nTableWrapper.parentNode, d = b.oClasses, e = b.nTable, f = b.nTBody, g = b.nTHead, j = b.nTFoot,
                i = h(e), f = h(f), k = h(b.nTableWrapper), l = h.map(b.aoData, function (a) {
                    return a.nTr
                }),
                p;
            b.bDestroying = !0;
            s(b, "aoDestroyCallback", "destroy", [b]);
            a || (new t(b)).columns().visible(!0);
            k.off(".DT").find(":not(tbody *)").off(".DT");
            h(E).off(".DT-" + b.sInstance);
            e != g.parentNode && (i.children("thead").detach(), i.append(g));
            j && e != j.parentNode && (i.children("tfoot").detach(), i.append(j));
            b.aaSorting = [];
            b.aaSortingFixed = [];
            ya(b);
            h(l).removeClass(b.asStripeClasses.join(" "));
            h("th, td", g).removeClass(d.sSortable + " " + d.sSortableAsc + " " + d.sSortableDesc + " " + d.sSortableNone);
            b.bJUI && (h("th span." + d.sSortIcon +
                ", td span." + d.sSortIcon, g).detach(), h("th, td", g).each(function () {
                var a = h("div." + d.sSortJUIWrapper, this);
                h(this).append(a.contents());
                a.detach()
            }));
            f.children().detach();
            f.append(l);
            g = a ? "remove" : "detach";
            i[g]();
            k[g]();
            !a && c && (c.insertBefore(e, b.nTableReinsertBefore), i.css("width", b.sDestroyWidth).removeClass(d.sTable), (p = b.asDestroyStripes.length) && f.children().each(function (a) {
                h(this).addClass(b.asDestroyStripes[a % p])
            }));
            c = h.inArray(b, m.settings);
            -1 !== c && m.settings.splice(c, 1)
        })
    });
    h.each(["column",
        "row", "cell"], function (a, b) {
        p(b + "s().every()", function (a) {
            var d = this.selector.opts, e = this;
            return this.iterator(b, function (f, g, h, i, m) {
                a.call(e[b](g, "cell" === b ? h : d, "cell" === b ? d : k), g, h, i, m)
            })
        })
    });
    p("i18n()", function (a, b, c) {
        var d = this.context[0], a = R(a)(d.oLanguage);
        a === k && (a = b);
        c !== k && h.isPlainObject(a) && (a = a[c] !== k ? a[c] : a._);
        return a.replace("%d", c)
    });
    m.version = "1.10.15";
    m.settings = [];
    m.models = {};
    m.models.oSearch = {bCaseInsensitive: !0, sSearch: "", bRegex: !1, bSmart: !0};
    m.models.oRow = {
        nTr: null, anCells: null,
        _aData: [], _aSortData: null, _aFilterData: null, _sFilterRow: null, _sRowStripe: "", src: null, idx: -1
    };
    m.models.oColumn = {
        idx: null,
        aDataSort: null,
        asSorting: null,
        bSearchable: null,
        bSortable: null,
        bVisible: null,
        _sManualType: null,
        _bAttrSrc: !1,
        fnCreatedCell: null,
        fnGetData: null,
        fnSetData: null,
        mData: null,
        mRender: null,
        nTh: null,
        nTf: null,
        sClass: null,
        sContentPadding: null,
        sDefaultContent: null,
        sName: null,
        sSortDataType: "std",
        sSortingClass: null,
        sSortingClassJUI: null,
        sTitle: null,
        sType: null,
        sWidth: null,
        sWidthOrig: null
    };
    m.defaults =
        {
            aaData: null,
            aaSorting: [[0, "asc"]],
            aaSortingFixed: [],
            ajax: null,
            aLengthMenu: [10, 25, 50, 100],
            aoColumns: null,
            aoColumnDefs: null,
            aoSearchCols: [],
            asStripeClasses: null,
            bAutoWidth: !0,
            bDeferRender: !1,
            bDestroy: !1,
            bFilter: !0,
            bInfo: !0,
            bJQueryUI: !1,
            bLengthChange: !0,
            bPaginate: !0,
            bProcessing: !1,
            bRetrieve: !1,
            bScrollCollapse: !1,
            bServerSide: !1,
            bSort: !0,
            bSortMulti: !0,
            bSortCellsTop: !1,
            bSortClasses: !0,
            bStateSave: !1,
            fnCreatedRow: null,
            fnDrawCallback: null,
            fnFooterCallback: null,
            fnFormatNumber: function (a) {
                return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g,
                    this.oLanguage.sThousands)
            },
            fnHeaderCallback: null,
            fnInfoCallback: null,
            fnInitComplete: null,
            fnPreDrawCallback: null,
            fnRowCallback: null,
            fnServerData: null,
            fnServerParams: null,
            fnStateLoadCallback: function (a) {
                try {
                    return JSON.parse((-1 === a.iStateDuration ? sessionStorage : localStorage).getItem("DataTables_" + a.sInstance + "_" + location.pathname))
                } catch (b) {
                }
            },
            fnStateLoadParams: null,
            fnStateLoaded: null,
            fnStateSaveCallback: function (a, b) {
                try {
                    (-1 === a.iStateDuration ? sessionStorage : localStorage).setItem("DataTables_" + a.sInstance +
                        "_" + location.pathname, JSON.stringify(b))
                } catch (c) {
                }
            },
            fnStateSaveParams: null,
            iStateDuration: 7200,
            iDeferLoading: null,
            iDisplayLength: 10,
            iDisplayStart: 0,
            iTabIndex: 0,
            oClasses: {},
            oLanguage: {
                oAria: {
                    sSortAscending: ": activate to sort column ascending",
                    sSortDescending: ": activate to sort column descending"
                },
                oPaginate: {sFirst: "First", sLast: "Last", sNext: "Next", sPrevious: "Previous"},
                sEmptyTable: "No data available in table",
                sInfo: "Showing _START_ to _END_ of _TOTAL_ entries",
                sInfoEmpty: "Showing 0 to 0 of 0 entries",
                sInfoFiltered: "(filtered from _MAX_ total entries)",
                sInfoPostFix: "",
                sDecimal: "",
                sThousands: ",",
                sLengthMenu: "Show _MENU_ entries",
                sLoadingRecords: "Loading...",
                sProcessing: "Processing...",
                sSearch: "Search:",
                sSearchPlaceholder: "",
                sUrl: "",
                sZeroRecords: "No matching records found"
            },
            oSearch: h.extend({}, m.models.oSearch),
            sAjaxDataProp: "data",
            sAjaxSource: null,
            sDom: "lfrtip",
            searchDelay: null,
            sPaginationType: "simple_numbers",
            sScrollX: "",
            sScrollXInner: "",
            sScrollY: "",
            sServerMethod: "GET",
            renderer: null,
            rowId: "DT_RowId"
        };
    Y(m.defaults);
    m.defaults.column = {
        aDataSort: null,
        iDataSort: -1,
        asSorting: ["asc", "desc"],
        bSearchable: !0,
        bSortable: !0,
        bVisible: !0,
        fnCreatedCell: null,
        mData: null,
        mRender: null,
        sCellType: "td",
        sClass: "",
        sContentPadding: "",
        sDefaultContent: null,
        sName: "",
        sSortDataType: "std",
        sTitle: null,
        sType: null,
        sWidth: null
    };
    Y(m.defaults.column);
    m.models.oSettings = {
        oFeatures: {
            bAutoWidth: null,
            bDeferRender: null,
            bFilter: null,
            bInfo: null,
            bLengthChange: null,
            bPaginate: null,
            bProcessing: null,
            bServerSide: null,
            bSort: null,
            bSortMulti: null,
            bSortClasses: null,
            bStateSave: null
        },
        oScroll: {bCollapse: null, iBarWidth: 0, sX: null, sXInner: null, sY: null},
        oLanguage: {fnInfoCallback: null},
        oBrowser: {bScrollOversize: !1, bScrollbarLeft: !1, bBounding: !1, barWidth: 0},
        ajax: null,
        aanFeatures: [],
        aoData: [],
        aiDisplay: [],
        aiDisplayMaster: [],
        aIds: {},
        aoColumns: [],
        aoHeader: [],
        aoFooter: [],
        oPreviousSearch: {},
        aoPreSearchCols: [],
        aaSorting: null,
        aaSortingFixed: [],
        asStripeClasses: null,
        asDestroyStripes: [],
        sDestroyWidth: 0,
        aoRowCallback: [],
        aoHeaderCallback: [],
        aoFooterCallback: [],
        aoDrawCallback: [],
        aoRowCreatedCallback: [],
        aoPreDrawCallback: [],
        aoInitComplete: [],
        aoStateSaveParams: [],
        aoStateLoadParams: [],
        aoStateLoaded: [],
        sTableId: "",
        nTable: null,
        nTHead: null,
        nTFoot: null,
        nTBody: null,
        nTableWrapper: null,
        bDeferLoading: !1,
        bInitialised: !1,
        aoOpenRows: [],
        sDom: null,
        searchDelay: null,
        sPaginationType: "two_button",
        iStateDuration: 0,
        aoStateSave: [],
        aoStateLoad: [],
        oSavedState: null,
        oLoadedState: null,
        sAjaxSource: null,
        sAjaxDataProp: null,
        bAjaxDataGet: !0,
        jqXHR: null,
        json: k,
        oAjaxData: k,
        fnServerData: null,
        aoServerParams: [],
        sServerMethod: null,
        fnFormatNumber: null,
        aLengthMenu: null,
        iDraw: 0,
        bDrawing: !1,
        iDrawError: -1,
        _iDisplayLength: 10,
        _iDisplayStart: 0,
        _iRecordsTotal: 0,
        _iRecordsDisplay: 0,
        bJUI: null,
        oClasses: {},
        bFiltered: !1,
        bSorted: !1,
        bSortCellsTop: null,
        oInit: null,
        aoDestroyCallback: [],
        fnRecordsTotal: function () {
            return "ssp" == y(this) ? 1 * this._iRecordsTotal : this.aiDisplayMaster.length
        },
        fnRecordsDisplay: function () {
            return "ssp" == y(this) ? 1 * this._iRecordsDisplay : this.aiDisplay.length
        },
        fnDisplayEnd: function () {
            var a =
                    this._iDisplayLength, b = this._iDisplayStart, c = b + a, d = this.aiDisplay.length, e = this.oFeatures,
                f = e.bPaginate;
            return e.bServerSide ? !1 === f || -1 === a ? b + d : Math.min(b + a, this._iRecordsDisplay) : !f || c > d || -1 === a ? d : c
        },
        oInstance: null,
        sInstance: null,
        iTabIndex: 0,
        nScrollHead: null,
        nScrollFoot: null,
        aLastSort: [],
        oPlugins: {},
        rowIdFn: null,
        rowId: null
    };
    m.ext = x = {
        buttons: {},
        classes: {},
        builder: "-source-",
        errMode: "alert",
        feature: [],
        search: [],
        selector: {cell: [], column: [], row: []},
        internal: {},
        legacy: {ajax: null},
        pager: {},
        renderer: {
            pageButton: {},
            header: {}
        },
        order: {},
        type: {detect: [], search: {}, order: {}},
        _unique: 0,
        fnVersionCheck: m.fnVersionCheck,
        iApiIndex: 0,
        oJUIClasses: {},
        sVersion: m.version
    };
    h.extend(x, {
        afnFiltering: x.search,
        aTypes: x.type.detect,
        ofnSearch: x.type.search,
        oSort: x.type.order,
        afnSortData: x.order,
        aoFeatures: x.feature,
        oApi: x.internal,
        oStdClasses: x.classes,
        oPagination: x.pager
    });
    h.extend(m.ext.classes, {
        sTable: "dataTable",
        sNoFooter: "no-footer",
        sPageButton: "paginate_button",
        sPageButtonActive: "current",
        sPageButtonDisabled: "disabled",
        sStripeOdd: "odd",
        sStripeEven: "even",
        sRowEmpty: "dataTables_empty",
        sWrapper: "dataTables_wrapper",
        sFilter: "dataTables_filter",
        sInfo: "dataTables_info",
        sPaging: "dataTables_paginate paging_",
        sLength: "dataTables_length",
        sProcessing: "dataTables_processing",
        sSortAsc: "sorting_asc",
        sSortDesc: "sorting_desc",
        sSortable: "sorting",
        sSortableAsc: "sorting_asc_disabled",
        sSortableDesc: "sorting_desc_disabled",
        sSortableNone: "sorting_disabled",
        sSortColumn: "sorting_",
        sFilterInput: "",
        sLengthSelect: "",
        sScrollWrapper: "dataTables_scroll",
        sScrollHead: "dataTables_scrollHead",
        sScrollHeadInner: "dataTables_scrollHeadInner",
        sScrollBody: "dataTables_scrollBody",
        sScrollFoot: "dataTables_scrollFoot",
        sScrollFootInner: "dataTables_scrollFootInner",
        sHeaderTH: "",
        sFooterTH: "",
        sSortJUIAsc: "",
        sSortJUIDesc: "",
        sSortJUI: "",
        sSortJUIAscAllowed: "",
        sSortJUIDescAllowed: "",
        sSortJUIWrapper: "",
        sSortIcon: "",
        sJUIHeader: "",
        sJUIFooter: ""
    });
    var Ea = "", Ea = "", G = Ea + "ui-state-default", ka = Ea + "css_right ui-icon ui-icon-",
        Yb = Ea + "fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix";
    h.extend(m.ext.oJUIClasses,
        m.ext.classes, {
            sPageButton: "fg-button ui-button " + G,
            sPageButtonActive: "ui-state-disabled",
            sPageButtonDisabled: "ui-state-disabled",
            sPaging: "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi paging_",
            sSortAsc: G + " sorting_asc",
            sSortDesc: G + " sorting_desc",
            sSortable: G + " sorting",
            sSortableAsc: G + " sorting_asc_disabled",
            sSortableDesc: G + " sorting_desc_disabled",
            sSortableNone: G + " sorting_disabled",
            sSortJUIAsc: ka + "triangle-1-n",
            sSortJUIDesc: ka + "triangle-1-s",
            sSortJUI: ka + "carat-2-n-s",
            sSortJUIAscAllowed: ka + "carat-1-n",
            sSortJUIDescAllowed: ka + "carat-1-s",
            sSortJUIWrapper: "DataTables_sort_wrapper",
            sSortIcon: "DataTables_sort_icon",
            sScrollHead: "dataTables_scrollHead " + G,
            sScrollFoot: "dataTables_scrollFoot " + G,
            sHeaderTH: G,
            sFooterTH: G,
            sJUIHeader: Yb + " ui-corner-tl ui-corner-tr",
            sJUIFooter: Yb + " ui-corner-bl ui-corner-br"
        });
    var Nb = m.ext.pager;
    h.extend(Nb, {
        simple: function () {
            return ["previous", "next"]
        }, full: function () {
            return ["first", "previous", "next", "last"]
        }, numbers: function (a, b) {
            return [ia(a,
                b)]
        }, simple_numbers: function (a, b) {
            return ["previous", ia(a, b), "next"]
        }, full_numbers: function (a, b) {
            return ["first", "previous", ia(a, b), "next", "last"]
        }, first_last_numbers: function (a, b) {
            return ["first", ia(a, b), "last"]
        }, _numbers: ia, numbers_length: 7
    });
    h.extend(!0, m.ext.renderer, {
        pageButton: {
            _: function (a, b, c, d, e, f) {
                var g = a.oClasses, j = a.oLanguage.oPaginate, i = a.oLanguage.oAria.paginate || {}, m, l, p = 0,
                    r = function (b, d) {
                        var k, t, u, s, v = function (b) {
                            Va(a, b.data.action, true)
                        };
                        k = 0;
                        for (t = d.length; k < t; k++) {
                            s = d[k];
                            if (h.isArray(s)) {
                                u =
                                    h("<" + (s.DT_el || "div") + "/>").appendTo(b);
                                r(u, s)
                            } else {
                                m = null;
                                l = "";
                                switch (s) {
                                    case "ellipsis":
                                        b.append('<span class="ellipsis">&#x2026;</span>');
                                        break;
                                    case "first":
                                        m = j.sFirst;
                                        l = s + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                                        break;
                                    case "previous":
                                        m = j.sPrevious;
                                        l = s + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                                        break;
                                    case "next":
                                        m = j.sNext;
                                        l = s + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                                        break;
                                    case "last":
                                        m = j.sLast;
                                        l = s + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                                        break;
                                    default:
                                        m = s + 1;
                                        l = e === s ? g.sPageButtonActive : ""
                                }
                                if (m !== null) {
                                    u = h("<a>", {
                                        "class": g.sPageButton +
                                        " " + l,
                                        "aria-controls": a.sTableId,
                                        "aria-label": i[s],
                                        "data-dt-idx": p,
                                        tabindex: a.iTabIndex,
                                        id: c === 0 && typeof s === "string" ? a.sTableId + "_" + s : null
                                    }).html(m).appendTo(b);
                                    Ya(u, {action: s}, v);
                                    p++
                                }
                            }
                        }
                    }, t;
                try {
                    t = h(b).find(H.activeElement).data("dt-idx")
                } catch (u) {
                }
                r(h(b).empty(), d);
                t !== k && h(b).find("[data-dt-idx=" + t + "]").focus()
            }
        }
    });
    h.extend(m.ext.type.detect, [function (a, b) {
        var c = b.oLanguage.sDecimal;
        return ab(a, c) ? "num" + c : null
    }, function (a) {
        if (a && !(a instanceof Date) && !cc.test(a)) return null;
        var b = Date.parse(a);
        return null !== b && !isNaN(b) || M(a) ? "date" : null
    }, function (a, b) {
        var c = b.oLanguage.sDecimal;
        return ab(a, c, !0) ? "num-fmt" + c : null
    }, function (a, b) {
        var c = b.oLanguage.sDecimal;
        return Sb(a, c) ? "html-num" + c : null
    }, function (a, b) {
        var c = b.oLanguage.sDecimal;
        return Sb(a, c, !0) ? "html-num-fmt" + c : null
    }, function (a) {
        return M(a) || "string" === typeof a && -1 !== a.indexOf("<") ? "html" : null
    }]);
    h.extend(m.ext.type.search, {
        html: function (a) {
            return M(a) ? a : "string" === typeof a ? a.replace(Pb, " ").replace(Ca, "") : ""
        }, string: function (a) {
            return M(a) ?
                a : "string" === typeof a ? a.replace(Pb, " ") : a
        }
    });
    var Ba = function (a, b, c, d) {
        if (0 !== a && (!a || "-" === a)) return -Infinity;
        b && (a = Rb(a, b));
        a.replace && (c && (a = a.replace(c, "")), d && (a = a.replace(d, "")));
        return 1 * a
    };
    h.extend(x.type.order, {
        "date-pre": function (a) {
            return Date.parse(a) || -Infinity
        }, "html-pre": function (a) {
            return M(a) ? "" : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + ""
        }, "string-pre": function (a) {
            return M(a) ? "" : "string" === typeof a ? a.toLowerCase() : !a.toString ? "" : a.toString()
        }, "string-asc": function (a, b) {
            return a <
            b ? -1 : a > b ? 1 : 0
        }, "string-desc": function (a, b) {
            return a < b ? 1 : a > b ? -1 : 0
        }
    });
    fb("");
    h.extend(!0, m.ext.renderer, {
        header: {
            _: function (a, b, c, d) {
                h(a.nTable).on("order.dt.DT", function (e, f, g, h) {
                    if (a === f) {
                        e = c.idx;
                        b.removeClass(c.sSortingClass + " " + d.sSortAsc + " " + d.sSortDesc).addClass(h[e] == "asc" ? d.sSortAsc : h[e] == "desc" ? d.sSortDesc : c.sSortingClass)
                    }
                })
            }, jqueryui: function (a, b, c, d) {
                h("<div/>").addClass(d.sSortJUIWrapper).append(b.contents()).append(h("<span/>").addClass(d.sSortIcon + " " + c.sSortingClassJUI)).appendTo(b);
                h(a.nTable).on("order.dt.DT", function (e, f, g, h) {
                    if (a === f) {
                        e = c.idx;
                        b.removeClass(d.sSortAsc + " " + d.sSortDesc).addClass(h[e] == "asc" ? d.sSortAsc : h[e] == "desc" ? d.sSortDesc : c.sSortingClass);
                        b.find("span." + d.sSortIcon).removeClass(d.sSortJUIAsc + " " + d.sSortJUIDesc + " " + d.sSortJUI + " " + d.sSortJUIAscAllowed + " " + d.sSortJUIDescAllowed).addClass(h[e] == "asc" ? d.sSortJUIAsc : h[e] == "desc" ? d.sSortJUIDesc : c.sSortingClassJUI)
                    }
                })
            }
        }
    });
    var Zb = function (a) {
        return "string" === typeof a ? a.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g,
            "&quot;") : a
    };
    m.render = {
        number: function (a, b, c, d, e) {
            return {
                display: function (f) {
                    if ("number" !== typeof f && "string" !== typeof f) return f;
                    var g = 0 > f ? "-" : "", h = parseFloat(f);
                    if (isNaN(h)) return Zb(f);
                    h = h.toFixed(c);
                    f = Math.abs(h);
                    h = parseInt(f, 10);
                    f = c ? b + (f - h).toFixed(c).substring(2) : "";
                    return g + (d || "") + h.toString().replace(/\B(?=(\d{3})+(?!\d))/g, a) + f + (e || "")
                }
            }
        }, text: function () {
            return {display: Zb}
        }
    };
    h.extend(m.ext.internal, {
        _fnExternApiFunc: Ob,
        _fnBuildAjax: ua,
        _fnAjaxUpdate: nb,
        _fnAjaxParameters: wb,
        _fnAjaxUpdateDraw: xb,
        _fnAjaxDataSrc: va,
        _fnAddColumn: Ga,
        _fnColumnOptions: la,
        _fnAdjustColumnSizing: Z,
        _fnVisibleToColumnIndex: $,
        _fnColumnIndexToVisible: aa,
        _fnVisbleColumns: ba,
        _fnGetColumns: na,
        _fnColumnTypes: Ia,
        _fnApplyColumnDefs: kb,
        _fnHungarianMap: Y,
        _fnCamelToHungarian: J,
        _fnLanguageCompat: Fa,
        _fnBrowserDetect: ib,
        _fnAddData: N,
        _fnAddTr: oa,
        _fnNodeToDataIndex: function (a, b) {
            return b._DT_RowIndex !== k ? b._DT_RowIndex : null
        },
        _fnNodeToColumnIndex: function (a, b, c) {
            return h.inArray(c, a.aoData[b].anCells)
        },
        _fnGetCellData: B,
        _fnSetCellData: lb,
        _fnSplitObjNotation: La,
        _fnGetObjectDataFn: R,
        _fnSetObjectDataFn: S,
        _fnGetDataMaster: Ma,
        _fnClearTable: pa,
        _fnDeleteIndex: qa,
        _fnInvalidate: da,
        _fnGetRowElements: Ka,
        _fnCreateTr: Ja,
        _fnBuildHead: mb,
        _fnDrawHead: fa,
        _fnDraw: O,
        _fnReDraw: T,
        _fnAddOptionsHtml: pb,
        _fnDetectHeader: ea,
        _fnGetUniqueThs: ta,
        _fnFeatureHtmlFilter: rb,
        _fnFilterComplete: ga,
        _fnFilterCustom: Ab,
        _fnFilterColumn: zb,
        _fnFilter: yb,
        _fnFilterCreateSearch: Ra,
        _fnEscapeRegex: Sa,
        _fnFilterData: Bb,
        _fnFeatureHtmlInfo: ub,
        _fnUpdateInfo: Eb,
        _fnInfoMacros: Fb,
        _fnInitialise: ha,
        _fnInitComplete: wa,
        _fnLengthChange: Ta,
        _fnFeatureHtmlLength: qb,
        _fnFeatureHtmlPaginate: vb,
        _fnPageChange: Va,
        _fnFeatureHtmlProcessing: sb,
        _fnProcessingDisplay: C,
        _fnFeatureHtmlTable: tb,
        _fnScrollDraw: ma,
        _fnApplyToChildren: I,
        _fnCalculateColumnWidths: Ha,
        _fnThrottle: Qa,
        _fnConvertToWidth: Gb,
        _fnGetWidestNode: Hb,
        _fnGetMaxLenString: Ib,
        _fnStringToCss: v,
        _fnSortFlatten: W,
        _fnSort: ob,
        _fnSortAria: Kb,
        _fnSortListener: Xa,
        _fnSortAttachListener: Oa,
        _fnSortingClasses: ya,
        _fnSortData: Jb,
        _fnSaveState: za,
        _fnLoadState: Lb,
        _fnSettingsFromNode: Aa,
        _fnLog: K,
        _fnMap: F,
        _fnBindAction: Ya,
        _fnCallbackReg: z,
        _fnCallbackFire: s,
        _fnLengthOverflow: Ua,
        _fnRenderer: Pa,
        _fnDataSource: y,
        _fnRowAttributes: Na,
        _fnCalculateEnd: function () {
        }
    });
    h.fn.dataTable = m;
    m.$ = h;
    h.fn.dataTableSettings = m.settings;
    h.fn.dataTableExt = m.ext;
    h.fn.DataTable = function (a) {
        return h(this).dataTable(a).api()
    };
    h.each(m, function (a, b) {
        h.fn.DataTable[a] = b
    });
    return h.fn.dataTable
});

/*! DataTables Bootstrap 3 integration
 * 2011-2015 SpryMedia Ltd - datatables.net/license
 */

/**
 * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
 * DataTables 1.10 or newer.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
 * for further information.
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                root = window;
            }

            if (!$ || !$.fn.dataTable) {
                // Require DataTables, which attaches to jQuery, including
                // jQuery if needed and have a $ property so we can access the
                // jQuery object that is used
                $ = require('datatables.net')(root, $).$;
            }

            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document, undefined) {
    'use strict';
    var DataTable = $.fn.dataTable;


    /* Set the defaults for DataTables initialisation */
    $.extend(true, DataTable.defaults, {
        dom:
        "<'row'<'col-sm-6'l><'col-sm-6'f>>" +
        "<'row'<'col-sm-12'tr>>" +
        "<'row'<'col-sm-5'i><'col-sm-7'p>>",
        renderer: 'bootstrap'
    });


    /* Default class modification */
    $.extend(DataTable.ext.classes, {
        sWrapper: "dataTables_wrapper form-inline dt-bootstrap",
        sFilterInput: "form-control input-sm",
        sLengthSelect: "form-control input-sm",
        sProcessing: "dataTables_processing panel panel-default"
    });


    /* Bootstrap paging button renderer */
    DataTable.ext.renderer.pageButton.bootstrap = function (settings, host, idx, buttons, page, pages) {
        var api = new DataTable.Api(settings);
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay, btnClass, counter = 0;

        var attach = function (container, buttons) {
            var i, ien, node, button;
            var clickHandler = function (e) {
                e.preventDefault();
                if (!$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action) {
                    api.page(e.data.action).draw('page');
                }
            };

            for (i = 0, ien = buttons.length; i < ien; i++) {
                button = buttons[i];

                if ($.isArray(button)) {
                    attach(container, button);
                }
                else {
                    btnDisplay = '';
                    btnClass = '';

                    switch (button) {
                        case 'ellipsis':
                            btnDisplay = '&#x2026;';
                            btnClass = 'disabled';
                            break;

                        case 'first':
                            btnDisplay = lang.sFirst;
                            btnClass = button + (page > 0 ?
                                '' : ' disabled');
                            break;

                        case 'previous':
                            btnDisplay = lang.sPrevious;
                            btnClass = button + (page > 0 ?
                                '' : ' disabled');
                            break;

                        case 'next':
                            btnDisplay = lang.sNext;
                            btnClass = button + (page < pages - 1 ?
                                '' : ' disabled');
                            break;

                        case 'last':
                            btnDisplay = lang.sLast;
                            btnClass = button + (page < pages - 1 ?
                                '' : ' disabled');
                            break;

                        default:
                            btnDisplay = button + 1;
                            btnClass = page === button ?
                                'active' : '';
                            break;
                    }

                    if (btnDisplay) {
                        node = $('<li>', {
                            'class': classes.sPageButton + ' ' + btnClass,
                            'id': idx === 0 && typeof button === 'string' ?
                                settings.sTableId + '_' + button :
                                null
                        })
                            .append($('<a>', {
                                    'href': '#',
                                    'aria-controls': settings.sTableId,
                                    'aria-label': aria[button],
                                    'data-dt-idx': counter,
                                    'tabindex': settings.iTabIndex
                                })
                                    .html(btnDisplay)
                            )
                            .appendTo(container);

                        settings.oApi._fnBindAction(
                            node, {action: button}, clickHandler
                        );

                        counter++;
                    }
                }
            }
        };

        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame.
        var activeEl;

        try {
            // Because this approach is destroying and recreating the paging
            // elements, focus is lost on the select button which is bad for
            // accessibility. So we want to restore focus once the draw has
            // completed
            activeEl = $(host).find(document.activeElement).data('dt-idx');
        }
        catch (e) {
        }

        attach(
            $(host).empty().html('<ul class="pagination"/>').children('ul'),
            buttons
        );

        if (activeEl !== undefined) {
            $(host).find('[data-dt-idx=' + activeEl + ']').focus();
        }
    };


    return DataTable;
}));

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () {
    function n(n) {
        function t(t, r, e, u, i, o) {
            for (; i >= 0 && o > i; i += n) {
                var a = u ? u[i] : i;
                e = r(e, t[a], a, t)
            }
            return e
        }

        return function (r, e, u, i) {
            e = b(e, i, 4);
            var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1;
            return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a)
        }
    }

    function t(n) {
        return function (t, r, e) {
            r = x(r, e);
            for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i;
            return -1
        }
    }

    function r(n, t, r) {
        return function (e, u, i) {
            var o = 0, a = O(e);
            if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), e[i] === u ? i : -1;
            if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1;
            for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i;
            return -1
        }
    }

    function e(n, t) {
        var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor";
        for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--;) i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i)
    }

    var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice,
        s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create,
        d = function () {
        }, m = function (n) {
            return n instanceof m ? n : this instanceof m ? void(this._wrapped = n) : new m(n)
        };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), exports._ = m) : u._ = m, m.VERSION = "1.8.3";
    var b = function (n, t, r) {
        if (t === void 0) return n;
        switch (null == r ? 3 : r) {
            case 1:
                return function (r) {
                    return n.call(t, r)
                };
            case 2:
                return function (r, e) {
                    return n.call(t, r, e)
                };
            case 3:
                return function (r, e, u) {
                    return n.call(t, r, e, u)
                };
            case 4:
                return function (r, e, u, i) {
                    return n.call(t, r, e, u, i)
                }
        }
        return function () {
            return n.apply(t, arguments)
        }
    }, x = function (n, t, r) {
        return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n)
    };
    m.iteratee = function (n, t) {
        return x(n, t, 1 / 0)
    };
    var _ = function (n, t) {
        return function (r) {
            var e = arguments.length;
            if (2 > e || null == r) return r;
            for (var u = 1; e > u; u++) for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {
                var f = o[c];
                t && r[f] !== void 0 || (r[f] = i[f])
            }
            return r
        }
    }, j = function (n) {
        if (!m.isObject(n)) return {};
        if (y) return y(n);
        d.prototype = n;
        var t = new d;
        return d.prototype = null, t
    }, w = function (n) {
        return function (t) {
            return null == t ? void 0 : t[n]
        }
    }, A = Math.pow(2, 53) - 1, O = w("length"), k = function (n) {
        var t = O(n);
        return "number" == typeof t && t >= 0 && A >= t
    };
    m.each = m.forEach = function (n, t, r) {
        t = b(t, r);
        var e, u;
        if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n); else {
            var i = m.keys(n);
            for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n)
        }
        return n
    }, m.map = m.collect = function (n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {
            var a = e ? e[o] : o;
            i[o] = t(n[a], a, n)
        }
        return i
    }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function (n, t, r) {
        var e;
        return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0
    }, m.filter = m.select = function (n, t, r) {
        var e = [];
        return t = x(t, r), m.each(n, function (n, r, u) {
            t(n, r, u) && e.push(n)
        }), e
    }, m.reject = function (n, t, r) {
        return m.filter(n, m.negate(x(t)), r)
    }, m.every = m.all = function (n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (!t(n[o], o, n)) return !1
        }
        return !0
    }, m.some = m.any = function (n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (t(n[o], o, n)) return !0
        }
        return !1
    }, m.contains = m.includes = m.include = function (n, t, r, e) {
        return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0
    }, m.invoke = function (n, t) {
        var r = l.call(arguments, 2), e = m.isFunction(t);
        return m.map(n, function (n) {
            var u = e ? t : n[t];
            return null == u ? u : u.apply(n, r)
        })
    }, m.pluck = function (n, t) {
        return m.map(n, m.property(t))
    }, m.where = function (n, t) {
        return m.filter(n, m.matcher(t))
    }, m.findWhere = function (n, t) {
        return m.find(n, m.matcher(t))
    }, m.max = function (n, t, r) {
        var e, u, i = -1 / 0, o = -1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], e > i && (i = e)
        } else t = x(t, r), m.each(n, function (n, r, e) {
            u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u)
        });
        return i
    }, m.min = function (n, t, r) {
        var e, u, i = 1 / 0, o = 1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], i > e && (i = e)
        } else t = x(t, r), m.each(n, function (n, r, e) {
            u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u)
        });
        return i
    }, m.shuffle = function (n) {
        for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) t = m.random(0, i), t !== i && (u[i] = u[t]), u[t] = r[i];
        return u
    }, m.sample = function (n, t, r) {
        return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t))
    }, m.sortBy = function (n, t, r) {
        return t = x(t, r), m.pluck(m.map(n, function (n, r, e) {
            return {value: n, index: r, criteria: t(n, r, e)}
        }).sort(function (n, t) {
            var r = n.criteria, e = t.criteria;
            if (r !== e) {
                if (r > e || r === void 0) return 1;
                if (e > r || e === void 0) return -1
            }
            return n.index - t.index
        }), "value")
    };
    var F = function (n) {
        return function (t, r, e) {
            var u = {};
            return r = x(r, e), m.each(t, function (e, i) {
                var o = r(e, i, t);
                n(u, e, o)
            }), u
        }
    };
    m.groupBy = F(function (n, t, r) {
        m.has(n, r) ? n[r].push(t) : n[r] = [t]
    }), m.indexBy = F(function (n, t, r) {
        n[r] = t
    }), m.countBy = F(function (n, t, r) {
        m.has(n, r) ? n[r]++ : n[r] = 1
    }), m.toArray = function (n) {
        return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : []
    }, m.size = function (n) {
        return null == n ? 0 : k(n) ? n.length : m.keys(n).length
    }, m.partition = function (n, t, r) {
        t = x(t, r);
        var e = [], u = [];
        return m.each(n, function (n, r, i) {
            (t(n, r, i) ? e : u).push(n)
        }), [e, u]
    }, m.first = m.head = m.take = function (n, t, r) {
        return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t)
    }, m.initial = function (n, t, r) {
        return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)))
    }, m.last = function (n, t, r) {
        return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t))
    }, m.rest = m.tail = m.drop = function (n, t, r) {
        return l.call(n, null == t || r ? 1 : t)
    }, m.compact = function (n) {
        return m.filter(n, m.identity)
    };
    var S = function (n, t, r, e) {
        for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {
            var c = n[o];
            if (k(c) && (m.isArray(c) || m.isArguments(c))) {
                t || (c = S(c, t, r));
                var f = 0, l = c.length;
                for (u.length += l; l > f;) u[i++] = c[f++]
            } else r || (u[i++] = c)
        }
        return u
    };
    m.flatten = function (n, t) {
        return S(n, t, !1)
    }, m.without = function (n) {
        return m.difference(n, l.call(arguments, 1))
    }, m.uniq = m.unique = function (n, t, r, e) {
        m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e));
        for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {
            var c = n[o], f = r ? r(c, o, n) : c;
            t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c)
        }
        return u
    }, m.union = function () {
        return m.uniq(S(arguments, !0, !0))
    }, m.intersection = function (n) {
        for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {
            var i = n[e];
            if (!m.contains(t, i)) {
                for (var o = 1; r > o && m.contains(arguments[o], i); o++) ;
                o === r && t.push(i)
            }
        }
        return t
    }, m.difference = function (n) {
        var t = S(arguments, !0, !0, 1);
        return m.filter(n, function (n) {
            return !m.contains(t, n)
        })
    }, m.zip = function () {
        return m.unzip(arguments)
    }, m.unzip = function (n) {
        for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e);
        return r
    }, m.object = function (n, t) {
        for (var r = {}, e = 0, u = O(n); u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
        return r
    }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function (n, t, r, e) {
        r = x(r, e, 1);
        for (var u = r(t), i = 0, o = O(n); o > i;) {
            var a = Math.floor((i + o) / 2);
            r(n[a]) < u ? i = a + 1 : o = a
        }
        return i
    }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), m.range = function (n, t, r) {
        null == t && (t = n || 0, n = 0), r = r || 1;
        for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n;
        return u
    };
    var E = function (n, t, r, e, u) {
        if (!(e instanceof t)) return n.apply(r, u);
        var i = j(n.prototype), o = n.apply(i, u);
        return m.isObject(o) ? o : i
    };
    m.bind = function (n, t) {
        if (g && n.bind === g) return g.apply(n, l.call(arguments, 1));
        if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function");
        var r = l.call(arguments, 2), e = function () {
            return E(n, e, t, this, r.concat(l.call(arguments)))
        };
        return e
    }, m.partial = function (n) {
        var t = l.call(arguments, 1), r = function () {
            for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o];
            for (; e < arguments.length;) i.push(arguments[e++]);
            return E(n, r, this, this, i)
        };
        return r
    }, m.bindAll = function (n) {
        var t, r, e = arguments.length;
        if (1 >= e) throw new Error("bindAll must be passed function names");
        for (t = 1; e > t; t++) r = arguments[t], n[r] = m.bind(n[r], n);
        return n
    }, m.memoize = function (n, t) {
        var r = function (e) {
            var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e);
            return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i]
        };
        return r.cache = {}, r
    }, m.delay = function (n, t) {
        var r = l.call(arguments, 2);
        return setTimeout(function () {
            return n.apply(null, r)
        }, t)
    }, m.defer = m.partial(m.delay, m, 1), m.throttle = function (n, t, r) {
        var e, u, i, o = null, a = 0;
        r || (r = {});
        var c = function () {
            a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null)
        };
        return function () {
            var f = m.now();
            a || r.leading !== !1 || (a = f);
            var l = t - (f - a);
            return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i
        }
    }, m.debounce = function (n, t, r) {
        var e, u, i, o, a, c = function () {
            var f = m.now() - o;
            t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), e || (i = u = null)))
        };
        return function () {
            i = this, u = arguments, o = m.now();
            var f = r && !e;
            return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a
        }
    }, m.wrap = function (n, t) {
        return m.partial(t, n)
    }, m.negate = function (n) {
        return function () {
            return !n.apply(this, arguments)
        }
    }, m.compose = function () {
        var n = arguments, t = n.length - 1;
        return function () {
            for (var r = t, e = n[t].apply(this, arguments); r--;) e = n[r].call(this, e);
            return e
        }
    }, m.after = function (n, t) {
        return function () {
            return --n < 1 ? t.apply(this, arguments) : void 0
        }
    }, m.before = function (n, t) {
        var r;
        return function () {
            return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r
        }
    }, m.once = m.partial(m.before, 2);
    var M = !{toString: null}.propertyIsEnumerable("toString"),
        I = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
    m.keys = function (n) {
        if (!m.isObject(n)) return [];
        if (v) return v(n);
        var t = [];
        for (var r in n) m.has(n, r) && t.push(r);
        return M && e(n, t), t
    }, m.allKeys = function (n) {
        if (!m.isObject(n)) return [];
        var t = [];
        for (var r in n) t.push(r);
        return M && e(n, t), t
    }, m.values = function (n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]];
        return e
    }, m.mapObject = function (n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) e = u[a], o[e] = t(n[e], e, n);
        return o
    }, m.pairs = function (n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]];
        return e
    }, m.invert = function (n) {
        for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e];
        return t
    }, m.functions = m.methods = function (n) {
        var t = [];
        for (var r in n) m.isFunction(n[r]) && t.push(r);
        return t.sort()
    }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function (n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (e = u[i], t(n[e], e, n)) return e
    }, m.pick = function (n, t, r) {
        var e, u, i = {}, o = n;
        if (null == o) return i;
        m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), e = function (n, t, r) {
            return t in r
        }, o = Object(o));
        for (var a = 0, c = u.length; c > a; a++) {
            var f = u[a], l = o[f];
            e(l, f, o) && (i[f] = l)
        }
        return i
    }, m.omit = function (n, t, r) {
        if (m.isFunction(t)) t = m.negate(t); else {
            var e = m.map(S(arguments, !1, !1, 1), String);
            t = function (n, t) {
                return !m.contains(e, t)
            }
        }
        return m.pick(n, t, r)
    }, m.defaults = _(m.allKeys, !0), m.create = function (n, t) {
        var r = j(n);
        return t && m.extendOwn(r, t), r
    }, m.clone = function (n) {
        return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n
    }, m.tap = function (n, t) {
        return t(n), n
    }, m.isMatch = function (n, t) {
        var r = m.keys(t), e = r.length;
        if (null == n) return !e;
        for (var u = Object(n), i = 0; e > i; i++) {
            var o = r[i];
            if (t[o] !== u[o] || !(o in u)) return !1
        }
        return !0
    };
    var N = function (n, t, r, e) {
        if (n === t) return 0 !== n || 1 / n === 1 / t;
        if (null == n || null == t) return n === t;
        n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped);
        var u = s.call(n);
        if (u !== s.call(t)) return !1;
        switch (u) {
            case"[object RegExp]":
            case"[object String]":
                return "" + n == "" + t;
            case"[object Number]":
                return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t;
            case"[object Date]":
            case"[object Boolean]":
                return +n === +t
        }
        var i = "[object Array]" === u;
        if (!i) {
            if ("object" != typeof n || "object" != typeof t) return !1;
            var o = n.constructor, a = t.constructor;
            if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1
        }
        r = r || [], e = e || [];
        for (var c = r.length; c--;) if (r[c] === n) return e[c] === t;
        if (r.push(n), e.push(t), i) {
            if (c = n.length, c !== t.length) return !1;
            for (; c--;) if (!N(n[c], t[c], r, e)) return !1
        } else {
            var f, l = m.keys(n);
            if (c = l.length, m.keys(t).length !== c) return !1;
            for (; c--;) if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1
        }
        return r.pop(), e.pop(), !0
    };
    m.isEqual = function (n, t) {
        return N(n, t)
    }, m.isEmpty = function (n) {
        return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length
    }, m.isElement = function (n) {
        return !(!n || 1 !== n.nodeType)
    }, m.isArray = h || function (n) {
        return "[object Array]" === s.call(n)
    }, m.isObject = function (n) {
        var t = typeof n;
        return "function" === t || "object" === t && !!n
    }, m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (n) {
        m["is" + n] = function (t) {
            return s.call(t) === "[object " + n + "]"
        }
    }), m.isArguments(arguments) || (m.isArguments = function (n) {
        return m.has(n, "callee")
    }), "function" != typeof/./ && "object" != typeof Int8Array && (m.isFunction = function (n) {
        return "function" == typeof n || !1
    }), m.isFinite = function (n) {
        return isFinite(n) && !isNaN(parseFloat(n))
    }, m.isNaN = function (n) {
        return m.isNumber(n) && n !== +n
    }, m.isBoolean = function (n) {
        return n === !0 || n === !1 || "[object Boolean]" === s.call(n)
    }, m.isNull = function (n) {
        return null === n
    }, m.isUndefined = function (n) {
        return n === void 0
    }, m.has = function (n, t) {
        return null != n && p.call(n, t)
    }, m.noConflict = function () {
        return u._ = i, this
    }, m.identity = function (n) {
        return n
    }, m.constant = function (n) {
        return function () {
            return n
        }
    }, m.noop = function () {
    }, m.property = w, m.propertyOf = function (n) {
        return null == n ? function () {
        } : function (t) {
            return n[t]
        }
    }, m.matcher = m.matches = function (n) {
        return n = m.extendOwn({}, n), function (t) {
            return m.isMatch(t, n)
        }
    }, m.times = function (n, t, r) {
        var e = Array(Math.max(0, n));
        t = b(t, r, 1);
        for (var u = 0; n > u; u++) e[u] = t(u);
        return e
    }, m.random = function (n, t) {
        return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1))
    }, m.now = Date.now || function () {
        return (new Date).getTime()
    };
    var B = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;"}, T = m.invert(B),
        R = function (n) {
            var t = function (t) {
                return n[t]
            }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g");
            return function (n) {
                return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n
            }
        };
    m.escape = R(B), m.unescape = R(T), m.result = function (n, t, r) {
        var e = null == n ? void 0 : n[t];
        return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e
    };
    var q = 0;
    m.uniqueId = function (n) {
        var t = ++q + "";
        return n ? n + t : t
    }, m.templateSettings = {evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g};
    var K = /(.)^/, z = {"'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029"},
        D = /\\|'|\r|\n|\u2028|\u2029/g, L = function (n) {
            return "\\" + z[n]
        };
    m.template = function (n, t, r) {
        !t && r && (t = r), t = m.defaults({}, t, m.templateSettings);
        var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join("|") + "|$", "g"),
            u = 0, i = "__p+='";
        n.replace(e, function (t, r, e, o, a) {
            return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), t
        }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n";
        try {
            var o = new Function(t.variable || "obj", "_", i)
        } catch (a) {
            throw a.source = i, a
        }
        var c = function (n) {
            return o.call(this, n, m)
        }, f = t.variable || "obj";
        return c.source = "function(" + f + "){\n" + i + "}", c
    }, m.chain = function (n) {
        var t = m(n);
        return t._chain = !0, t
    };
    var P = function (n, t) {
        return n._chain ? m(t).chain() : t
    };
    m.mixin = function (n) {
        m.each(m.functions(n), function (t) {
            var r = m[t] = n[t];
            m.prototype[t] = function () {
                var n = [this._wrapped];
                return f.apply(n, arguments), P(this, r.apply(m, n))
            }
        })
    }, m.mixin(m), m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (n) {
        var t = o[n];
        m.prototype[n] = function () {
            var r = this._wrapped;
            return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], P(this, r)
        }
    }), m.each(["concat", "join", "slice"], function (n) {
        var t = o[n];
        m.prototype[n] = function () {
            return P(this, t.apply(this._wrapped, arguments))
        }
    }), m.prototype.value = function () {
        return this._wrapped
    }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function () {
        return "" + this._wrapped
    }, "function" == typeof define && define.amd && define("underscore", [], function () {
        return m
    })
}).call(this);
//# sourceMappingURL=underscore-min.map
/*! Select2 4.0.3 | https://github.com/select2/select2/blob/master/LICENSE.md */
!function (a) {
    "function" == typeof define && define.amd ? define(["jquery"], a) : a("object" == typeof exports ? require("jquery") : jQuery)
}(function (a) {
    var b = function () {
        if (a && a.fn && a.fn.select2 && a.fn.select2.amd) var b = a.fn.select2.amd;
        var b;
        return function () {
            if (!b || !b.requirejs) {
                b ? c = b : b = {};
                var a, c, d;
                !function (b) {
                    function e(a, b) {
                        return u.call(a, b)
                    }

                    function f(a, b) {
                        var c, d, e, f, g, h, i, j, k, l, m, n = b && b.split("/"), o = s.map, p = o && o["*"] || {};
                        if (a && "." === a.charAt(0)) if (b) {
                            for (a = a.split("/"), g = a.length - 1, s.nodeIdCompat && w.test(a[g]) && (a[g] = a[g].replace(w, "")), a = n.slice(0, n.length - 1).concat(a), k = 0; k < a.length; k += 1) if (m = a[k], "." === m) a.splice(k, 1), k -= 1; else if (".." === m) {
                                if (1 === k && (".." === a[2] || ".." === a[0])) break;
                                k > 0 && (a.splice(k - 1, 2), k -= 2)
                            }
                            a = a.join("/")
                        } else 0 === a.indexOf("./") && (a = a.substring(2));
                        if ((n || p) && o) {
                            for (c = a.split("/"), k = c.length; k > 0; k -= 1) {
                                if (d = c.slice(0, k).join("/"), n) for (l = n.length; l > 0; l -= 1) if (e = o[n.slice(0, l).join("/")], e && (e = e[d])) {
                                    f = e, h = k;
                                    break
                                }
                                if (f) break;
                                !i && p && p[d] && (i = p[d], j = k)
                            }
                            !f && i && (f = i, h = j), f && (c.splice(0, h, f), a = c.join("/"))
                        }
                        return a
                    }

                    function g(a, c) {
                        return function () {
                            var d = v.call(arguments, 0);
                            return "string" != typeof d[0] && 1 === d.length && d.push(null), n.apply(b, d.concat([a, c]))
                        }
                    }

                    function h(a) {
                        return function (b) {
                            return f(b, a)
                        }
                    }

                    function i(a) {
                        return function (b) {
                            q[a] = b
                        }
                    }

                    function j(a) {
                        if (e(r, a)) {
                            var c = r[a];
                            delete r[a], t[a] = !0, m.apply(b, c)
                        }
                        if (!e(q, a) && !e(t, a)) throw new Error("No " + a);
                        return q[a]
                    }

                    function k(a) {
                        var b, c = a ? a.indexOf("!") : -1;
                        return c > -1 && (b = a.substring(0, c), a = a.substring(c + 1, a.length)), [b, a]
                    }

                    function l(a) {
                        return function () {
                            return s && s.config && s.config[a] || {}
                        }
                    }

                    var m, n, o, p, q = {}, r = {}, s = {}, t = {}, u = Object.prototype.hasOwnProperty, v = [].slice,
                        w = /\.js$/;
                    o = function (a, b) {
                        var c, d = k(a), e = d[0];
                        return a = d[1], e && (e = f(e, b), c = j(e)), e ? a = c && c.normalize ? c.normalize(a, h(b)) : f(a, b) : (a = f(a, b), d = k(a), e = d[0], a = d[1], e && (c = j(e))), {
                            f: e ? e + "!" + a : a,
                            n: a,
                            pr: e,
                            p: c
                        }
                    }, p = {
                        require: function (a) {
                            return g(a)
                        }, exports: function (a) {
                            var b = q[a];
                            return "undefined" != typeof b ? b : q[a] = {}
                        }, module: function (a) {
                            return {id: a, uri: "", exports: q[a], config: l(a)}
                        }
                    }, m = function (a, c, d, f) {
                        var h, k, l, m, n, s, u = [], v = typeof d;
                        if (f = f || a, "undefined" === v || "function" === v) {
                            for (c = !c.length && d.length ? ["require", "exports", "module"] : c, n = 0; n < c.length; n += 1) if (m = o(c[n], f), k = m.f, "require" === k) u[n] = p.require(a); else if ("exports" === k) u[n] = p.exports(a), s = !0; else if ("module" === k) h = u[n] = p.module(a); else if (e(q, k) || e(r, k) || e(t, k)) u[n] = j(k); else {
                                if (!m.p) throw new Error(a + " missing " + k);
                                m.p.load(m.n, g(f, !0), i(k), {}), u[n] = q[k]
                            }
                            l = d ? d.apply(q[a], u) : void 0, a && (h && h.exports !== b && h.exports !== q[a] ? q[a] = h.exports : l === b && s || (q[a] = l))
                        } else a && (q[a] = d)
                    }, a = c = n = function (a, c, d, e, f) {
                        if ("string" == typeof a) return p[a] ? p[a](c) : j(o(a, c).f);
                        if (!a.splice) {
                            if (s = a, s.deps && n(s.deps, s.callback), !c) return;
                            c.splice ? (a = c, c = d, d = null) : a = b
                        }
                        return c = c || function () {
                        }, "function" == typeof d && (d = e, e = f), e ? m(b, a, c, d) : setTimeout(function () {
                            m(b, a, c, d)
                        }, 4), n
                    }, n.config = function (a) {
                        return n(a)
                    }, a._defined = q, d = function (a, b, c) {
                        if ("string" != typeof a) throw new Error("See almond README: incorrect module build, no module name");
                        b.splice || (c = b, b = []), e(q, a) || e(r, a) || (r[a] = [a, b, c])
                    }, d.amd = {jQuery: !0}
                }(), b.requirejs = a, b.require = c, b.define = d
            }
        }(), b.define("almond", function () {
        }), b.define("jquery", [], function () {
            var b = a || $;
            return null == b && console && console.error && console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."), b
        }), b.define("select2/utils", ["jquery"], function (a) {
            function b(a) {
                var b = a.prototype, c = [];
                for (var d in b) {
                    var e = b[d];
                    "function" == typeof e && "constructor" !== d && c.push(d)
                }
                return c
            }

            var c = {};
            c.Extend = function (a, b) {
                function c() {
                    this.constructor = a
                }

                var d = {}.hasOwnProperty;
                for (var e in b) d.call(b, e) && (a[e] = b[e]);
                return c.prototype = b.prototype, a.prototype = new c, a.__super__ = b.prototype, a
            }, c.Decorate = function (a, c) {
                function d() {
                    var b = Array.prototype.unshift, d = c.prototype.constructor.length, e = a.prototype.constructor;
                    d > 0 && (b.call(arguments, a.prototype.constructor), e = c.prototype.constructor), e.apply(this, arguments)
                }

                function e() {
                    this.constructor = d
                }

                var f = b(c), g = b(a);
                c.displayName = a.displayName, d.prototype = new e;
                for (var h = 0; h < g.length; h++) {
                    var i = g[h];
                    d.prototype[i] = a.prototype[i]
                }
                for (var j = (function (a) {
                    var b = function () {
                    };
                    a in d.prototype && (b = d.prototype[a]);
                    var e = c.prototype[a];
                    return function () {
                        var a = Array.prototype.unshift;
                        return a.call(arguments, b), e.apply(this, arguments)
                    }
                }), k = 0; k < f.length; k++) {
                    var l = f[k];
                    d.prototype[l] = j(l)
                }
                return d
            };
            var d = function () {
                this.listeners = {}
            };
            return d.prototype.on = function (a, b) {
                this.listeners = this.listeners || {}, a in this.listeners ? this.listeners[a].push(b) : this.listeners[a] = [b]
            }, d.prototype.trigger = function (a) {
                var b = Array.prototype.slice, c = b.call(arguments, 1);
                this.listeners = this.listeners || {}, null == c && (c = []), 0 === c.length && c.push({}), c[0]._type = a, a in this.listeners && this.invoke(this.listeners[a], b.call(arguments, 1)), "*" in this.listeners && this.invoke(this.listeners["*"], arguments)
            }, d.prototype.invoke = function (a, b) {
                for (var c = 0, d = a.length; d > c; c++) a[c].apply(this, b)
            }, c.Observable = d, c.generateChars = function (a) {
                for (var b = "", c = 0; a > c; c++) {
                    var d = Math.floor(36 * Math.random());
                    b += d.toString(36)
                }
                return b
            }, c.bind = function (a, b) {
                return function () {
                    a.apply(b, arguments)
                }
            }, c._convertData = function (a) {
                for (var b in a) {
                    var c = b.split("-"), d = a;
                    if (1 !== c.length) {
                        for (var e = 0; e < c.length; e++) {
                            var f = c[e];
                            f = f.substring(0, 1).toLowerCase() + f.substring(1), f in d || (d[f] = {}), e == c.length - 1 && (d[f] = a[b]), d = d[f]
                        }
                        delete a[b]
                    }
                }
                return a
            }, c.hasScroll = function (b, c) {
                var d = a(c), e = c.style.overflowX, f = c.style.overflowY;
                return e !== f || "hidden" !== f && "visible" !== f ? "scroll" === e || "scroll" === f ? !0 : d.innerHeight() < c.scrollHeight || d.innerWidth() < c.scrollWidth : !1
            }, c.escapeMarkup = function (a) {
                var b = {
                    "\\": "&#92;",
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "/": "&#47;"
                };
                return "string" != typeof a ? a : String(a).replace(/[&<>"'\/\\]/g, function (a) {
                    return b[a]
                })
            }, c.appendMany = function (b, c) {
                if ("1.7" === a.fn.jquery.substr(0, 3)) {
                    var d = a();
                    a.map(c, function (a) {
                        d = d.add(a)
                    }), c = d
                }
                b.append(c)
            }, c
        }), b.define("select2/results", ["jquery", "./utils"], function (a, b) {
            function c(a, b, d) {
                this.$element = a, this.data = d, this.options = b, c.__super__.constructor.call(this)
            }

            return b.Extend(c, b.Observable), c.prototype.render = function () {
                var b = a('<ul class="select2-results__options" role="tree"></ul>');
                return this.options.get("multiple") && b.attr("aria-multiselectable", "true"), this.$results = b, b
            }, c.prototype.clear = function () {
                this.$results.empty()
            }, c.prototype.displayMessage = function (b) {
                var c = this.options.get("escapeMarkup");
                this.clear(), this.hideLoading();
                var d = a('<li role="treeitem" aria-live="assertive" class="select2-results__option"></li>'),
                    e = this.options.get("translations").get(b.message);
                d.append(c(e(b.args))), d[0].className += " select2-results__message", this.$results.append(d)
            }, c.prototype.hideMessages = function () {
                this.$results.find(".select2-results__message").remove()
            }, c.prototype.append = function (a) {
                this.hideLoading();
                var b = [];
                if (null == a.results || 0 === a.results.length) return void(0 === this.$results.children().length && this.trigger("results:message", {message: "noResults"}));
                a.results = this.sort(a.results);
                for (var c = 0; c < a.results.length; c++) {
                    var d = a.results[c], e = this.option(d);
                    b.push(e)
                }
                this.$results.append(b)
            }, c.prototype.position = function (a, b) {
                var c = b.find(".select2-results");
                c.append(a)
            }, c.prototype.sort = function (a) {
                var b = this.options.get("sorter");
                return b(a)
            }, c.prototype.highlightFirstItem = function () {
                var a = this.$results.find(".select2-results__option[aria-selected]"),
                    b = a.filter("[aria-selected=true]");
                b.length > 0 ? b.first().trigger("mouseenter") : a.first().trigger("mouseenter"), this.ensureHighlightVisible()
            }, c.prototype.setClasses = function () {
                var b = this;
                this.data.current(function (c) {
                    var d = a.map(c, function (a) {
                        return a.id.toString()
                    }), e = b.$results.find(".select2-results__option[aria-selected]");
                    e.each(function () {
                        var b = a(this), c = a.data(this, "data"), e = "" + c.id;
                        null != c.element && c.element.selected || null == c.element && a.inArray(e, d) > -1 ? b.attr("aria-selected", "true") : b.attr("aria-selected", "false")
                    })
                })
            }, c.prototype.showLoading = function (a) {
                this.hideLoading();
                var b = this.options.get("translations").get("searching"), c = {disabled: !0, loading: !0, text: b(a)},
                    d = this.option(c);
                d.className += " loading-results", this.$results.prepend(d)
            }, c.prototype.hideLoading = function () {
                this.$results.find(".loading-results").remove()
            }, c.prototype.option = function (b) {
                var c = document.createElement("li");
                c.className = "select2-results__option";
                var d = {role: "treeitem", "aria-selected": "false"};
                b.disabled && (delete d["aria-selected"], d["aria-disabled"] = "true"), null == b.id && delete d["aria-selected"], null != b._resultId && (c.id = b._resultId), b.title && (c.title = b.title), b.children && (d.role = "group", d["aria-label"] = b.text, delete d["aria-selected"]);
                for (var e in d) {
                    var f = d[e];
                    c.setAttribute(e, f)
                }
                if (b.children) {
                    var g = a(c), h = document.createElement("strong");
                    h.className = "select2-results__group";
                    a(h);
                    this.template(b, h);
                    for (var i = [], j = 0; j < b.children.length; j++) {
                        var k = b.children[j], l = this.option(k);
                        i.push(l)
                    }
                    var m = a("<ul></ul>", {"class": "select2-results__options select2-results__options--nested"});
                    m.append(i), g.append(h), g.append(m)
                } else this.template(b, c);
                return a.data(c, "data", b), c
            }, c.prototype.bind = function (b, c) {
                var d = this, e = b.id + "-results";
                this.$results.attr("id", e), b.on("results:all", function (a) {
                    d.clear(), d.append(a.data), b.isOpen() && (d.setClasses(), d.highlightFirstItem())
                }), b.on("results:append", function (a) {
                    d.append(a.data), b.isOpen() && d.setClasses()
                }), b.on("query", function (a) {
                    d.hideMessages(), d.showLoading(a)
                }), b.on("select", function () {
                    b.isOpen() && (d.setClasses(), d.highlightFirstItem())
                }), b.on("unselect", function () {
                    b.isOpen() && (d.setClasses(), d.highlightFirstItem())
                }), b.on("open", function () {
                    d.$results.attr("aria-expanded", "true"), d.$results.attr("aria-hidden", "false"), d.setClasses(), d.ensureHighlightVisible()
                }), b.on("close", function () {
                    d.$results.attr("aria-expanded", "false"), d.$results.attr("aria-hidden", "true"), d.$results.removeAttr("aria-activedescendant")
                }), b.on("results:toggle", function () {
                    var a = d.getHighlightedResults();
                    0 !== a.length && a.trigger("mouseup")
                }), b.on("results:select", function () {
                    var a = d.getHighlightedResults();
                    if (0 !== a.length) {
                        var b = a.data("data");
                        "true" == a.attr("aria-selected") ? d.trigger("close", {}) : d.trigger("select", {data: b})
                    }
                }), b.on("results:previous", function () {
                    var a = d.getHighlightedResults(), b = d.$results.find("[aria-selected]"), c = b.index(a);
                    if (0 !== c) {
                        var e = c - 1;
                        0 === a.length && (e = 0);
                        var f = b.eq(e);
                        f.trigger("mouseenter");
                        var g = d.$results.offset().top, h = f.offset().top, i = d.$results.scrollTop() + (h - g);
                        0 === e ? d.$results.scrollTop(0) : 0 > h - g && d.$results.scrollTop(i)
                    }
                }), b.on("results:next", function () {
                    var a = d.getHighlightedResults(), b = d.$results.find("[aria-selected]"), c = b.index(a),
                        e = c + 1;
                    if (!(e >= b.length)) {
                        var f = b.eq(e);
                        f.trigger("mouseenter");
                        var g = d.$results.offset().top + d.$results.outerHeight(!1),
                            h = f.offset().top + f.outerHeight(!1), i = d.$results.scrollTop() + h - g;
                        0 === e ? d.$results.scrollTop(0) : h > g && d.$results.scrollTop(i)
                    }
                }), b.on("results:focus", function (a) {
                    a.element.addClass("select2-results__option--highlighted")
                }), b.on("results:message", function (a) {
                    d.displayMessage(a)
                }), a.fn.mousewheel && this.$results.on("mousewheel", function (a) {
                    var b = d.$results.scrollTop(), c = d.$results.get(0).scrollHeight - b + a.deltaY,
                        e = a.deltaY > 0 && b - a.deltaY <= 0, f = a.deltaY < 0 && c <= d.$results.height();
                    e ? (d.$results.scrollTop(0), a.preventDefault(), a.stopPropagation()) : f && (d.$results.scrollTop(d.$results.get(0).scrollHeight - d.$results.height()), a.preventDefault(), a.stopPropagation())
                }), this.$results.on("mouseup", ".select2-results__option[aria-selected]", function (b) {
                    var c = a(this), e = c.data("data");
                    return "true" === c.attr("aria-selected") ? void(d.options.get("multiple") ? d.trigger("unselect", {
                        originalEvent: b,
                        data: e
                    }) : d.trigger("close", {})) : void d.trigger("select", {originalEvent: b, data: e})
                }), this.$results.on("mouseenter", ".select2-results__option[aria-selected]", function (b) {
                    var c = a(this).data("data");
                    d.getHighlightedResults().removeClass("select2-results__option--highlighted"), d.trigger("results:focus", {
                        data: c,
                        element: a(this)
                    })
                })
            }, c.prototype.getHighlightedResults = function () {
                var a = this.$results.find(".select2-results__option--highlighted");
                return a
            }, c.prototype.destroy = function () {
                this.$results.remove()
            }, c.prototype.ensureHighlightVisible = function () {
                var a = this.getHighlightedResults();
                if (0 !== a.length) {
                    var b = this.$results.find("[aria-selected]"), c = b.index(a), d = this.$results.offset().top,
                        e = a.offset().top, f = this.$results.scrollTop() + (e - d), g = e - d;
                    f -= 2 * a.outerHeight(!1), 2 >= c ? this.$results.scrollTop(0) : (g > this.$results.outerHeight() || 0 > g) && this.$results.scrollTop(f)
                }
            }, c.prototype.template = function (b, c) {
                var d = this.options.get("templateResult"), e = this.options.get("escapeMarkup"), f = d(b, c);
                null == f ? c.style.display = "none" : "string" == typeof f ? c.innerHTML = e(f) : a(c).append(f)
            }, c
        }), b.define("select2/keys", [], function () {
            var a = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
            };
            return a
        }), b.define("select2/selection/base", ["jquery", "../utils", "../keys"], function (a, b, c) {
            function d(a, b) {
                this.$element = a, this.options = b, d.__super__.constructor.call(this)
            }

            return b.Extend(d, b.Observable), d.prototype.render = function () {
                var b = a('<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>');
                return this._tabindex = 0, null != this.$element.data("old-tabindex") ? this._tabindex = this.$element.data("old-tabindex") : null != this.$element.attr("tabindex") && (this._tabindex = this.$element.attr("tabindex")), b.attr("title", this.$element.attr("title")), b.attr("tabindex", this._tabindex), this.$selection = b, b
            }, d.prototype.bind = function (a, b) {
                var d = this, e = (a.id + "-container", a.id + "-results");
                this.container = a, this.$selection.on("focus", function (a) {
                    d.trigger("focus", a)
                }), this.$selection.on("blur", function (a) {
                    d._handleBlur(a)
                }), this.$selection.on("keydown", function (a) {
                    d.trigger("keypress", a), a.which === c.SPACE && a.preventDefault()
                }), a.on("results:focus", function (a) {
                    d.$selection.attr("aria-activedescendant", a.data._resultId)
                }), a.on("selection:update", function (a) {
                    d.update(a.data)
                }), a.on("open", function () {
                    d.$selection.attr("aria-expanded", "true"), d.$selection.attr("aria-owns", e), d._attachCloseHandler(a)
                }), a.on("close", function () {
                    d.$selection.attr("aria-expanded", "false"), d.$selection.removeAttr("aria-activedescendant"), d.$selection.removeAttr("aria-owns"), d.$selection.focus(), d._detachCloseHandler(a)
                }), a.on("enable", function () {
                    d.$selection.attr("tabindex", d._tabindex)
                }), a.on("disable", function () {
                    d.$selection.attr("tabindex", "-1")
                })
            }, d.prototype._handleBlur = function (b) {
                var c = this;
                window.setTimeout(function () {
                    document.activeElement == c.$selection[0] || a.contains(c.$selection[0], document.activeElement) || c.trigger("blur", b)
                }, 1)
            }, d.prototype._attachCloseHandler = function (b) {
                a(document.body).on("mousedown.select2." + b.id, function (b) {
                    var c = a(b.target), d = c.closest(".select2"), e = a(".select2.select2-container--open");
                    e.each(function () {
                        var b = a(this);
                        if (this != d[0]) {
                            var c = b.data("element");
                            c.select2("close")
                        }
                    })
                })
            }, d.prototype._detachCloseHandler = function (b) {
                a(document.body).off("mousedown.select2." + b.id)
            }, d.prototype.position = function (a, b) {
                var c = b.find(".selection");
                c.append(a)
            }, d.prototype.destroy = function () {
                this._detachCloseHandler(this.container)
            }, d.prototype.update = function (a) {
                throw new Error("The `update` method must be defined in child classes.")
            }, d
        }), b.define("select2/selection/single", ["jquery", "./base", "../utils", "../keys"], function (a, b, c, d) {
            function e() {
                e.__super__.constructor.apply(this, arguments)
            }

            return c.Extend(e, b), e.prototype.render = function () {
                var a = e.__super__.render.call(this);
                return a.addClass("select2-selection--single"), a.html('<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'), a
            }, e.prototype.bind = function (a, b) {
                var c = this;
                e.__super__.bind.apply(this, arguments);
                var d = a.id + "-container";
                this.$selection.find(".select2-selection__rendered").attr("id", d), this.$selection.attr("aria-labelledby", d), this.$selection.on("mousedown", function (a) {
                    1 === a.which && c.trigger("toggle", {originalEvent: a})
                }), this.$selection.on("focus", function (a) {
                }), this.$selection.on("blur", function (a) {
                }), a.on("focus", function (b) {
                    a.isOpen() || c.$selection.focus()
                }), a.on("selection:update", function (a) {
                    c.update(a.data)
                })
            }, e.prototype.clear = function () {
                this.$selection.find(".select2-selection__rendered").empty()
            }, e.prototype.display = function (a, b) {
                var c = this.options.get("templateSelection"), d = this.options.get("escapeMarkup");
                return d(c(a, b))
            }, e.prototype.selectionContainer = function () {
                return a("<span></span>")
            }, e.prototype.update = function (a) {
                if (0 === a.length) return void this.clear();
                var b = a[0], c = this.$selection.find(".select2-selection__rendered"), d = this.display(b, c);
                c.empty().append(d), c.prop("title", b.title || b.text)
            }, e
        }), b.define("select2/selection/multiple", ["jquery", "./base", "../utils"], function (a, b, c) {
            function d(a, b) {
                d.__super__.constructor.apply(this, arguments)
            }

            return c.Extend(d, b), d.prototype.render = function () {
                var a = d.__super__.render.call(this);
                return a.addClass("select2-selection--multiple"), a.html('<ul class="select2-selection__rendered"></ul>'), a
            }, d.prototype.bind = function (b, c) {
                var e = this;
                d.__super__.bind.apply(this, arguments), this.$selection.on("click", function (a) {
                    e.trigger("toggle", {originalEvent: a})
                }), this.$selection.on("click", ".select2-selection__choice__remove", function (b) {
                    if (!e.options.get("disabled")) {
                        var c = a(this), d = c.parent(), f = d.data("data");
                        e.trigger("unselect", {originalEvent: b, data: f})
                    }
                })
            }, d.prototype.clear = function () {
                this.$selection.find(".select2-selection__rendered").empty()
            }, d.prototype.display = function (a, b) {
                var c = this.options.get("templateSelection"), d = this.options.get("escapeMarkup");
                return d(c(a, b))
            }, d.prototype.selectionContainer = function () {
                var b = a('<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>');
                return b
            }, d.prototype.update = function (a) {
                if (this.clear(), 0 !== a.length) {
                    for (var b = [], d = 0; d < a.length; d++) {
                        var e = a[d], f = this.selectionContainer(), g = this.display(e, f);
                        f.append(g), f.prop("title", e.title || e.text), f.data("data", e), b.push(f)
                    }
                    var h = this.$selection.find(".select2-selection__rendered");
                    c.appendMany(h, b)
                }
            }, d
        }), b.define("select2/selection/placeholder", ["../utils"], function (a) {
            function b(a, b, c) {
                this.placeholder = this.normalizePlaceholder(c.get("placeholder")), a.call(this, b, c)
            }

            return b.prototype.normalizePlaceholder = function (a, b) {
                return "string" == typeof b && (b = {id: "", text: b}), b
            }, b.prototype.createPlaceholder = function (a, b) {
                var c = this.selectionContainer();
                return c.html(this.display(b)), c.addClass("select2-selection__placeholder").removeClass("select2-selection__choice"), c
            }, b.prototype.update = function (a, b) {
                var c = 1 == b.length && b[0].id != this.placeholder.id, d = b.length > 1;
                if (d || c) return a.call(this, b);
                this.clear();
                var e = this.createPlaceholder(this.placeholder);
                this.$selection.find(".select2-selection__rendered").append(e)
            }, b
        }), b.define("select2/selection/allowClear", ["jquery", "../keys"], function (a, b) {
            function c() {
            }

            return c.prototype.bind = function (a, b, c) {
                var d = this;
                a.call(this, b, c), null == this.placeholder && this.options.get("debug") && window.console && console.error && console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."), this.$selection.on("mousedown", ".select2-selection__clear", function (a) {
                    d._handleClear(a)
                }), b.on("keypress", function (a) {
                    d._handleKeyboardClear(a, b)
                })
            }, c.prototype._handleClear = function (a, b) {
                if (!this.options.get("disabled")) {
                    var c = this.$selection.find(".select2-selection__clear");
                    if (0 !== c.length) {
                        b.stopPropagation();
                        for (var d = c.data("data"), e = 0; e < d.length; e++) {
                            var f = {data: d[e]};
                            if (this.trigger("unselect", f), f.prevented) return
                        }
                        this.$element.val(this.placeholder.id).trigger("change"), this.trigger("toggle", {})
                    }
                }
            }, c.prototype._handleKeyboardClear = function (a, c, d) {
                d.isOpen() || (c.which == b.DELETE || c.which == b.BACKSPACE) && this._handleClear(c)
            }, c.prototype.update = function (b, c) {
                if (b.call(this, c), !(this.$selection.find(".select2-selection__placeholder").length > 0 || 0 === c.length)) {
                    var d = a('<span class="select2-selection__clear">&times;</span>');
                    d.data("data", c), this.$selection.find(".select2-selection__rendered").prepend(d)
                }
            }, c
        }), b.define("select2/selection/search", ["jquery", "../utils", "../keys"], function (a, b, c) {
            function d(a, b, c) {
                a.call(this, b, c)
            }

            return d.prototype.render = function (b) {
                var c = a('<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" aria-autocomplete="list" /></li>');
                this.$searchContainer = c, this.$search = c.find("input");
                var d = b.call(this);
                return this._transferTabIndex(), d
            }, d.prototype.bind = function (a, b, d) {
                var e = this;
                a.call(this, b, d), b.on("open", function () {
                    e.$search.trigger("focus")
                }), b.on("close", function () {
                    e.$search.val(""), e.$search.removeAttr("aria-activedescendant"), e.$search.trigger("focus")
                }), b.on("enable", function () {
                    e.$search.prop("disabled", !1), e._transferTabIndex()
                }), b.on("disable", function () {
                    e.$search.prop("disabled", !0)
                }), b.on("focus", function (a) {
                    e.$search.trigger("focus")
                }), b.on("results:focus", function (a) {
                    e.$search.attr("aria-activedescendant", a.id)
                }), this.$selection.on("focusin", ".select2-search--inline", function (a) {
                    e.trigger("focus", a)
                }), this.$selection.on("focusout", ".select2-search--inline", function (a) {
                    e._handleBlur(a)
                }), this.$selection.on("keydown", ".select2-search--inline", function (a) {
                    a.stopPropagation(), e.trigger("keypress", a), e._keyUpPrevented = a.isDefaultPrevented();
                    var b = a.which;
                    if (b === c.BACKSPACE && "" === e.$search.val()) {
                        var d = e.$searchContainer.prev(".select2-selection__choice");
                        if (d.length > 0) {
                            var f = d.data("data");
                            e.searchRemoveChoice(f), a.preventDefault()
                        }
                    }
                });
                var f = document.documentMode, g = f && 11 >= f;
                this.$selection.on("input.searchcheck", ".select2-search--inline", function (a) {
                    return g ? void e.$selection.off("input.search input.searchcheck") : void e.$selection.off("keyup.search")
                }), this.$selection.on("keyup.search input.search", ".select2-search--inline", function (a) {
                    if (g && "input" === a.type) return void e.$selection.off("input.search input.searchcheck");
                    var b = a.which;
                    b != c.SHIFT && b != c.CTRL && b != c.ALT && b != c.TAB && e.handleSearch(a)
                })
            }, d.prototype._transferTabIndex = function (a) {
                this.$search.attr("tabindex", this.$selection.attr("tabindex")), this.$selection.attr("tabindex", "-1")
            }, d.prototype.createPlaceholder = function (a, b) {
                this.$search.attr("placeholder", b.text)
            }, d.prototype.update = function (a, b) {
                var c = this.$search[0] == document.activeElement;
                this.$search.attr("placeholder", ""), a.call(this, b), this.$selection.find(".select2-selection__rendered").append(this.$searchContainer), this.resizeSearch(), c && this.$search.focus()
            }, d.prototype.handleSearch = function () {
                if (this.resizeSearch(), !this._keyUpPrevented) {
                    var a = this.$search.val();
                    this.trigger("query", {term: a})
                }
                this._keyUpPrevented = !1
            }, d.prototype.searchRemoveChoice = function (a, b) {
                this.trigger("unselect", {data: b}), this.$search.val(b.text), this.handleSearch()
            }, d.prototype.resizeSearch = function () {
                this.$search.css("width", "25px");
                var a = "";
                if ("" !== this.$search.attr("placeholder")) a = this.$selection.find(".select2-selection__rendered").innerWidth(); else {
                    var b = this.$search.val().length + 1;
                    a = .75 * b + "em"
                }
                this.$search.css("width", a)
            }, d
        }), b.define("select2/selection/eventRelay", ["jquery"], function (a) {
            function b() {
            }

            return b.prototype.bind = function (b, c, d) {
                var e = this,
                    f = ["open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting"],
                    g = ["opening", "closing", "selecting", "unselecting"];
                b.call(this, c, d), c.on("*", function (b, c) {
                    if (-1 !== a.inArray(b, f)) {
                        c = c || {};
                        var d = a.Event("select2:" + b, {params: c});
                        e.$element.trigger(d), -1 !== a.inArray(b, g) && (c.prevented = d.isDefaultPrevented())
                    }
                })
            }, b
        }), b.define("select2/translation", ["jquery", "require"], function (a, b) {
            function c(a) {
                this.dict = a || {}
            }

            return c.prototype.all = function () {
                return this.dict
            }, c.prototype.get = function (a) {
                return this.dict[a]
            }, c.prototype.extend = function (b) {
                this.dict = a.extend({}, b.all(), this.dict)
            }, c._cache = {}, c.loadPath = function (a) {
                if (!(a in c._cache)) {
                    var d = b(a);
                    c._cache[a] = d
                }
                return new c(c._cache[a])
            }, c
        }), b.define("select2/diacritics", [], function () {
            var a = {
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "AA",
                "": "AE",
                "": "AE",
                "": "AE",
                "": "AO",
                "": "AU",
                "": "AV",
                "": "AV",
                "": "AY",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "DZ",
                "": "DZ",
                "": "Dz",
                "": "Dz",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "LJ",
                "": "Lj",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "NJ",
                "": "Nj",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "OI",
                "": "OO",
                "": "OU",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "TZ",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "VY",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "aa",
                "": "ae",
                "": "ae",
                "": "ae",
                "": "ao",
                "": "au",
                "": "av",
                "": "av",
                "": "ay",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "dz",
                "": "dz",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "hv",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "lj",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "nj",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "oi",
                "": "ou",
                "": "oo",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "tz",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "vy",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": ""
            };
            return a
        }), b.define("select2/data/base", ["../utils"], function (a) {
            function b(a, c) {
                b.__super__.constructor.call(this)
            }

            return a.Extend(b, a.Observable), b.prototype.current = function (a) {
                throw new Error("The `current` method must be defined in child classes.")
            }, b.prototype.query = function (a, b) {
                throw new Error("The `query` method must be defined in child classes.")
            }, b.prototype.bind = function (a, b) {
            }, b.prototype.destroy = function () {
            }, b.prototype.generateResultId = function (b, c) {
                var d = b.id + "-result-";
                return d += a.generateChars(4), d += null != c.id ? "-" + c.id.toString() : "-" + a.generateChars(4)
            }, b
        }), b.define("select2/data/select", ["./base", "../utils", "jquery"], function (a, b, c) {
            function d(a, b) {
                this.$element = a, this.options = b, d.__super__.constructor.call(this)
            }

            return b.Extend(d, a), d.prototype.current = function (a) {
                var b = [], d = this;
                this.$element.find(":selected").each(function () {
                    var a = c(this), e = d.item(a);
                    b.push(e)
                }), a(b)
            }, d.prototype.select = function (a) {
                var b = this;
                if (a.selected = !0, c(a.element).is("option")) return a.element.selected = !0, void this.$element.trigger("change");
                if (this.$element.prop("multiple")) this.current(function (d) {
                    var e = [];
                    a = [a], a.push.apply(a, d);
                    for (var f = 0; f < a.length; f++) {
                        var g = a[f].id;
                        -1 === c.inArray(g, e) && e.push(g)
                    }
                    b.$element.val(e), b.$element.trigger("change")
                }); else {
                    var d = a.id;
                    this.$element.val(d), this.$element.trigger("change")
                }
            }, d.prototype.unselect = function (a) {
                var b = this;
                if (this.$element.prop("multiple")) return a.selected = !1, c(a.element).is("option") ? (a.element.selected = !1, void this.$element.trigger("change")) : void this.current(function (d) {
                    for (var e = [], f = 0; f < d.length; f++) {
                        var g = d[f].id;
                        g !== a.id && -1 === c.inArray(g, e) && e.push(g)
                    }
                    b.$element.val(e), b.$element.trigger("change")
                })
            }, d.prototype.bind = function (a, b) {
                var c = this;
                this.container = a, a.on("select", function (a) {
                    c.select(a.data)
                }), a.on("unselect", function (a) {
                    c.unselect(a.data)
                })
            }, d.prototype.destroy = function () {
                this.$element.find("*").each(function () {
                    c.removeData(this, "data")
                })
            }, d.prototype.query = function (a, b) {
                var d = [], e = this, f = this.$element.children();
                f.each(function () {
                    var b = c(this);
                    if (b.is("option") || b.is("optgroup")) {
                        var f = e.item(b), g = e.matches(a, f);
                        null !== g && d.push(g)
                    }
                }), b({results: d})
            }, d.prototype.addOptions = function (a) {
                b.appendMany(this.$element, a)
            }, d.prototype.option = function (a) {
                var b;
                a.children ? (b = document.createElement("optgroup"), b.label = a.text) : (b = document.createElement("option"), void 0 !== b.textContent ? b.textContent = a.text : b.innerText = a.text), a.id && (b.value = a.id), a.disabled && (b.disabled = !0), a.selected && (b.selected = !0), a.title && (b.title = a.title);
                var d = c(b), e = this._normalizeItem(a);
                return e.element = b, c.data(b, "data", e), d
            }, d.prototype.item = function (a) {
                var b = {};
                if (b = c.data(a[0], "data"), null != b) return b;
                if (a.is("option")) b = {
                    id: a.val(),
                    text: a.text(),
                    disabled: a.prop("disabled"),
                    selected: a.prop("selected"),
                    title: a.prop("title")
                }; else if (a.is("optgroup")) {
                    b = {text: a.prop("label"), children: [], title: a.prop("title")};
                    for (var d = a.children("option"), e = [], f = 0; f < d.length; f++) {
                        var g = c(d[f]), h = this.item(g);
                        e.push(h)
                    }
                    b.children = e
                }
                return b = this._normalizeItem(b), b.element = a[0], c.data(a[0], "data", b), b
            }, d.prototype._normalizeItem = function (a) {
                c.isPlainObject(a) || (a = {id: a, text: a}), a = c.extend({}, {text: ""}, a);
                var b = {selected: !1, disabled: !1};
                return null != a.id && (a.id = a.id.toString()), null != a.text && (a.text = a.text.toString()), null == a._resultId && a.id && null != this.container && (a._resultId = this.generateResultId(this.container, a)), c.extend({}, b, a)
            }, d.prototype.matches = function (a, b) {
                var c = this.options.get("matcher");
                return c(a, b)
            }, d
        }), b.define("select2/data/array", ["./select", "../utils", "jquery"], function (a, b, c) {
            function d(a, b) {
                var c = b.get("data") || [];
                d.__super__.constructor.call(this, a, b), this.addOptions(this.convertToOptions(c))
            }

            return b.Extend(d, a), d.prototype.select = function (a) {
                var b = this.$element.find("option").filter(function (b, c) {
                    return c.value == a.id.toString()
                });
                0 === b.length && (b = this.option(a), this.addOptions(b)), d.__super__.select.call(this, a)
            }, d.prototype.convertToOptions = function (a) {
                function d(a) {
                    return function () {
                        return c(this).val() == a.id
                    }
                }

                for (var e = this, f = this.$element.find("option"), g = f.map(function () {
                    return e.item(c(this)).id
                }).get(), h = [], i = 0; i < a.length; i++) {
                    var j = this._normalizeItem(a[i]);
                    if (c.inArray(j.id, g) >= 0) {
                        var k = f.filter(d(j)), l = this.item(k), m = c.extend(!0, {}, j, l), n = this.option(m);
                        k.replaceWith(n)
                    } else {
                        var o = this.option(j);
                        if (j.children) {
                            var p = this.convertToOptions(j.children);
                            b.appendMany(o, p)
                        }
                        h.push(o)
                    }
                }
                return h
            }, d
        }), b.define("select2/data/ajax", ["./array", "../utils", "jquery"], function (a, b, c) {
            function d(a, b) {
                this.ajaxOptions = this._applyDefaults(b.get("ajax")), null != this.ajaxOptions.processResults && (this.processResults = this.ajaxOptions.processResults), d.__super__.constructor.call(this, a, b)
            }

            return b.Extend(d, a), d.prototype._applyDefaults = function (a) {
                var b = {
                    data: function (a) {
                        return c.extend({}, a, {q: a.term})
                    }, transport: function (a, b, d) {
                        var e = c.ajax(a);
                        return e.then(b), e.fail(d), e
                    }
                };
                return c.extend({}, b, a, !0)
            }, d.prototype.processResults = function (a) {
                return a
            }, d.prototype.query = function (a, b) {
                function d() {
                    var d = f.transport(f, function (d) {
                        var f = e.processResults(d, a);
                        e.options.get("debug") && window.console && console.error && (f && f.results && c.isArray(f.results) || console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")), b(f)
                    }, function () {
                        d.status && "0" === d.status || e.trigger("results:message", {message: "errorLoading"})
                    });
                    e._request = d
                }

                var e = this;
                null != this._request && (c.isFunction(this._request.abort) && this._request.abort(), this._request = null);
                var f = c.extend({type: "GET"}, this.ajaxOptions);
                "function" == typeof f.url && (f.url = f.url.call(this.$element, a)), "function" == typeof f.data && (f.data = f.data.call(this.$element, a)), this.ajaxOptions.delay && null != a.term ? (this._queryTimeout && window.clearTimeout(this._queryTimeout), this._queryTimeout = window.setTimeout(d, this.ajaxOptions.delay)) : d()
            }, d
        }), b.define("select2/data/tags", ["jquery"], function (a) {
            function b(b, c, d) {
                var e = d.get("tags"), f = d.get("createTag");
                void 0 !== f && (this.createTag = f);
                var g = d.get("insertTag");
                if (void 0 !== g && (this.insertTag = g), b.call(this, c, d), a.isArray(e)) for (var h = 0; h < e.length; h++) {
                    var i = e[h], j = this._normalizeItem(i), k = this.option(j);
                    this.$element.append(k)
                }
            }

            return b.prototype.query = function (a, b, c) {
                function d(a, f) {
                    for (var g = a.results, h = 0; h < g.length; h++) {
                        var i = g[h], j = null != i.children && !d({results: i.children}, !0), k = i.text === b.term;
                        if (k || j) return f ? !1 : (a.data = g, void c(a))
                    }
                    if (f) return !0;
                    var l = e.createTag(b);
                    if (null != l) {
                        var m = e.option(l);
                        m.attr("data-select2-tag", !0), e.addOptions([m]), e.insertTag(g, l)
                    }
                    a.results = g, c(a)
                }

                var e = this;
                return this._removeOldTags(), null == b.term || null != b.page ? void a.call(this, b, c) : void a.call(this, b, d)
            }, b.prototype.createTag = function (b, c) {
                var d = a.trim(c.term);
                return "" === d ? null : {id: d, text: d}
            }, b.prototype.insertTag = function (a, b, c) {
                b.unshift(c)
            }, b.prototype._removeOldTags = function (b) {
                var c = (this._lastTag, this.$element.find("option[data-select2-tag]"));
                c.each(function () {
                    this.selected || a(this).remove()
                })
            }, b
        }), b.define("select2/data/tokenizer", ["jquery"], function (a) {
            function b(a, b, c) {
                var d = c.get("tokenizer");
                void 0 !== d && (this.tokenizer = d), a.call(this, b, c)
            }

            return b.prototype.bind = function (a, b, c) {
                a.call(this, b, c), this.$search = b.dropdown.$search || b.selection.$search || c.find(".select2-search__field")
            }, b.prototype.query = function (b, c, d) {
                function e(b) {
                    var c = g._normalizeItem(b), d = g.$element.find("option").filter(function () {
                        return a(this).val() === c.id
                    });
                    if (!d.length) {
                        var e = g.option(c);
                        e.attr("data-select2-tag", !0), g._removeOldTags(), g.addOptions([e])
                    }
                    f(c)
                }

                function f(a) {
                    g.trigger("select", {data: a})
                }

                var g = this;
                c.term = c.term || "";
                var h = this.tokenizer(c, this.options, e);
                h.term !== c.term && (this.$search.length && (this.$search.val(h.term), this.$search.focus()), c.term = h.term), b.call(this, c, d)
            }, b.prototype.tokenizer = function (b, c, d, e) {
                for (var f = d.get("tokenSeparators") || [], g = c.term, h = 0, i = this.createTag || function (a) {
                    return {id: a.term, text: a.term}
                }; h < g.length;) {
                    var j = g[h];
                    if (-1 !== a.inArray(j, f)) {
                        var k = g.substr(0, h), l = a.extend({}, c, {term: k}), m = i(l);
                        null != m ? (e(m), g = g.substr(h + 1) || "", h = 0) : h++
                    } else h++
                }
                return {term: g}
            }, b
        }), b.define("select2/data/minimumInputLength", [], function () {
            function a(a, b, c) {
                this.minimumInputLength = c.get("minimumInputLength"), a.call(this, b, c)
            }

            return a.prototype.query = function (a, b, c) {
                return b.term = b.term || "", b.term.length < this.minimumInputLength ? void this.trigger("results:message", {
                    message: "inputTooShort",
                    args: {minimum: this.minimumInputLength, input: b.term, params: b}
                }) : void a.call(this, b, c)
            }, a
        }), b.define("select2/data/maximumInputLength", [], function () {
            function a(a, b, c) {
                this.maximumInputLength = c.get("maximumInputLength"), a.call(this, b, c)
            }

            return a.prototype.query = function (a, b, c) {
                return b.term = b.term || "", this.maximumInputLength > 0 && b.term.length > this.maximumInputLength ? void this.trigger("results:message", {
                    message: "inputTooLong",
                    args: {maximum: this.maximumInputLength, input: b.term, params: b}
                }) : void a.call(this, b, c)
            }, a
        }), b.define("select2/data/maximumSelectionLength", [], function () {
            function a(a, b, c) {
                this.maximumSelectionLength = c.get("maximumSelectionLength"), a.call(this, b, c)
            }

            return a.prototype.query = function (a, b, c) {
                var d = this;
                this.current(function (e) {
                    var f = null != e ? e.length : 0;
                    return d.maximumSelectionLength > 0 && f >= d.maximumSelectionLength ? void d.trigger("results:message", {
                        message: "maximumSelected",
                        args: {maximum: d.maximumSelectionLength}
                    }) : void a.call(d, b, c)
                })
            }, a
        }), b.define("select2/dropdown", ["jquery", "./utils"], function (a, b) {
            function c(a, b) {
                this.$element = a, this.options = b, c.__super__.constructor.call(this)
            }

            return b.Extend(c, b.Observable), c.prototype.render = function () {
                var b = a('<span class="select2-dropdown"><span class="select2-results"></span></span>');
                return b.attr("dir", this.options.get("dir")), this.$dropdown = b, b
            }, c.prototype.bind = function () {
            }, c.prototype.position = function (a, b) {
            }, c.prototype.destroy = function () {
                this.$dropdown.remove()
            }, c
        }), b.define("select2/dropdown/search", ["jquery", "../utils"], function (a, b) {
            function c() {
            }

            return c.prototype.render = function (b) {
                var c = b.call(this),
                    d = a('<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></span>');
                return this.$searchContainer = d, this.$search = d.find("input"), c.prepend(d), c
            }, c.prototype.bind = function (b, c, d) {
                var e = this;
                b.call(this, c, d), this.$search.on("keydown", function (a) {
                    e.trigger("keypress", a), e._keyUpPrevented = a.isDefaultPrevented()
                }), this.$search.on("input", function (b) {
                    a(this).off("keyup")
                }), this.$search.on("keyup input", function (a) {
                    e.handleSearch(a)
                }), c.on("open", function () {
                    e.$search.attr("tabindex", 0), e.$search.focus(), window.setTimeout(function () {
                        e.$search.focus()
                    }, 0)
                }), c.on("close", function () {
                    e.$search.attr("tabindex", -1), e.$search.val("")
                }), c.on("focus", function () {
                    c.isOpen() && e.$search.focus()
                }), c.on("results:all", function (a) {
                    if (null == a.query.term || "" === a.query.term) {
                        var b = e.showSearch(a);
                        b ? e.$searchContainer.removeClass("select2-search--hide") : e.$searchContainer.addClass("select2-search--hide")
                    }
                })
            }, c.prototype.handleSearch = function (a) {
                if (!this._keyUpPrevented) {
                    var b = this.$search.val();
                    this.trigger("query", {term: b})
                }
                this._keyUpPrevented = !1
            }, c.prototype.showSearch = function (a, b) {
                return !0
            }, c
        }), b.define("select2/dropdown/hidePlaceholder", [], function () {
            function a(a, b, c, d) {
                this.placeholder = this.normalizePlaceholder(c.get("placeholder")), a.call(this, b, c, d)
            }

            return a.prototype.append = function (a, b) {
                b.results = this.removePlaceholder(b.results), a.call(this, b)
            }, a.prototype.normalizePlaceholder = function (a, b) {
                return "string" == typeof b && (b = {id: "", text: b}), b
            }, a.prototype.removePlaceholder = function (a, b) {
                for (var c = b.slice(0), d = b.length - 1; d >= 0; d--) {
                    var e = b[d];
                    this.placeholder.id === e.id && c.splice(d, 1)
                }
                return c
            }, a
        }), b.define("select2/dropdown/infiniteScroll", ["jquery"], function (a) {
            function b(a, b, c, d) {
                this.lastParams = {}, a.call(this, b, c, d), this.$loadingMore = this.createLoadingMore(), this.loading = !1
            }

            return b.prototype.append = function (a, b) {
                this.$loadingMore.remove(), this.loading = !1, a.call(this, b), this.showLoadingMore(b) && this.$results.append(this.$loadingMore)
            }, b.prototype.bind = function (b, c, d) {
                var e = this;
                b.call(this, c, d), c.on("query", function (a) {
                    e.lastParams = a, e.loading = !0
                }), c.on("query:append", function (a) {
                    e.lastParams = a, e.loading = !0
                }), this.$results.on("scroll", function () {
                    var b = a.contains(document.documentElement, e.$loadingMore[0]);
                    if (!e.loading && b) {
                        var c = e.$results.offset().top + e.$results.outerHeight(!1),
                            d = e.$loadingMore.offset().top + e.$loadingMore.outerHeight(!1);
                        c + 50 >= d && e.loadMore()
                    }
                })
            }, b.prototype.loadMore = function () {
                this.loading = !0;
                var b = a.extend({}, {page: 1}, this.lastParams);
                b.page++, this.trigger("query:append", b)
            }, b.prototype.showLoadingMore = function (a, b) {
                return b.pagination && b.pagination.more
            }, b.prototype.createLoadingMore = function () {
                var b = a('<li class="select2-results__option select2-results__option--load-more"role="treeitem" aria-disabled="true"></li>'),
                    c = this.options.get("translations").get("loadingMore");
                return b.html(c(this.lastParams)), b
            }, b
        }), b.define("select2/dropdown/attachBody", ["jquery", "../utils"], function (a, b) {
            function c(b, c, d) {
                this.$dropdownParent = d.get("dropdownParent") || a(document.body), b.call(this, c, d)
            }

            return c.prototype.bind = function (a, b, c) {
                var d = this, e = !1;
                a.call(this, b, c), b.on("open", function () {
                    d._showDropdown(), d._attachPositioningHandler(b), e || (e = !0, b.on("results:all", function () {
                        d._positionDropdown(), d._resizeDropdown()
                    }), b.on("results:append", function () {
                        d._positionDropdown(), d._resizeDropdown()
                    }))
                }), b.on("close", function () {
                    d._hideDropdown(), d._detachPositioningHandler(b)
                }), this.$dropdownContainer.on("mousedown", function (a) {
                    a.stopPropagation()
                })
            }, c.prototype.destroy = function (a) {
                a.call(this), this.$dropdownContainer.remove()
            }, c.prototype.position = function (a, b, c) {
                b.attr("class", c.attr("class")), b.removeClass("select2"), b.addClass("select2-container--open"), b.css({
                    position: "absolute",
                    top: -999999
                }), this.$container = c
            }, c.prototype.render = function (b) {
                var c = a("<span></span>"), d = b.call(this);
                return c.append(d), this.$dropdownContainer = c, c
            }, c.prototype._hideDropdown = function (a) {
                this.$dropdownContainer.detach()
            }, c.prototype._attachPositioningHandler = function (c, d) {
                var e = this, f = "scroll.select2." + d.id, g = "resize.select2." + d.id,
                    h = "orientationchange.select2." + d.id, i = this.$container.parents().filter(b.hasScroll);
                i.each(function () {
                    a(this).data("select2-scroll-position", {x: a(this).scrollLeft(), y: a(this).scrollTop()})
                }), i.on(f, function (b) {
                    var c = a(this).data("select2-scroll-position");
                    a(this).scrollTop(c.y)
                }), a(window).on(f + " " + g + " " + h, function (a) {
                    e._positionDropdown(), e._resizeDropdown()
                })
            }, c.prototype._detachPositioningHandler = function (c, d) {
                var e = "scroll.select2." + d.id, f = "resize.select2." + d.id, g = "orientationchange.select2." + d.id,
                    h = this.$container.parents().filter(b.hasScroll);
                h.off(e), a(window).off(e + " " + f + " " + g)
            }, c.prototype._positionDropdown = function () {
                var b = a(window), c = this.$dropdown.hasClass("select2-dropdown--above"),
                    d = this.$dropdown.hasClass("select2-dropdown--below"), e = null, f = this.$container.offset();
                f.bottom = f.top + this.$container.outerHeight(!1);
                var g = {height: this.$container.outerHeight(!1)};
                g.top = f.top, g.bottom = f.top + g.height;
                var h = {height: this.$dropdown.outerHeight(!1)},
                    i = {top: b.scrollTop(), bottom: b.scrollTop() + b.height()}, j = i.top < f.top - h.height,
                    k = i.bottom > f.bottom + h.height, l = {left: f.left, top: g.bottom}, m = this.$dropdownParent;
                "static" === m.css("position") && (m = m.offsetParent());
                var n = m.offset();
                l.top -= n.top, l.left -= n.left, c || d || (e = "below"), k || !j || c ? !j && k && c && (e = "below") : e = "above", ("above" == e || c && "below" !== e) && (l.top = g.top - n.top - h.height), null != e && (this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + e), this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + e)), this.$dropdownContainer.css(l)
            }, c.prototype._resizeDropdown = function () {
                var a = {width: this.$container.outerWidth(!1) + "px"};
                this.options.get("dropdownAutoWidth") && (a.minWidth = a.width, a.position = "relative", a.width = "auto"), this.$dropdown.css(a)
            }, c.prototype._showDropdown = function (a) {
                this.$dropdownContainer.appendTo(this.$dropdownParent), this._positionDropdown(), this._resizeDropdown()
            }, c
        }), b.define("select2/dropdown/minimumResultsForSearch", [], function () {
            function a(b) {
                for (var c = 0, d = 0; d < b.length; d++) {
                    var e = b[d];
                    e.children ? c += a(e.children) : c++
                }
                return c
            }

            function b(a, b, c, d) {
                this.minimumResultsForSearch = c.get("minimumResultsForSearch"), this.minimumResultsForSearch < 0 && (this.minimumResultsForSearch = 1 / 0), a.call(this, b, c, d)
            }

            return b.prototype.showSearch = function (b, c) {
                return a(c.data.results) < this.minimumResultsForSearch ? !1 : b.call(this, c)
            }, b
        }), b.define("select2/dropdown/selectOnClose", [], function () {
            function a() {
            }

            return a.prototype.bind = function (a, b, c) {
                var d = this;
                a.call(this, b, c), b.on("close", function (a) {
                    d._handleSelectOnClose(a)
                })
            }, a.prototype._handleSelectOnClose = function (a, b) {
                if (b && null != b.originalSelect2Event) {
                    var c = b.originalSelect2Event;
                    if ("select" === c._type || "unselect" === c._type) return
                }
                var d = this.getHighlightedResults();
                if (!(d.length < 1)) {
                    var e = d.data("data");
                    null != e.element && e.element.selected || null == e.element && e.selected || this.trigger("select", {data: e})
                }
            }, a
        }), b.define("select2/dropdown/closeOnSelect", [], function () {
            function a() {
            }

            return a.prototype.bind = function (a, b, c) {
                var d = this;
                a.call(this, b, c), b.on("select", function (a) {
                    d._selectTriggered(a)
                }), b.on("unselect", function (a) {
                    d._selectTriggered(a)
                })
            }, a.prototype._selectTriggered = function (a, b) {
                var c = b.originalEvent;
                c && c.ctrlKey || this.trigger("close", {originalEvent: c, originalSelect2Event: b})
            }, a
        }), b.define("select2/i18n/en", [], function () {
            return {
                errorLoading: function () {
                    return "The results could not be loaded."
                }, inputTooLong: function (a) {
                    var b = a.input.length - a.maximum, c = "Please delete " + b + " character";
                    return 1 != b && (c += "s"), c
                }, inputTooShort: function (a) {
                    var b = a.minimum - a.input.length, c = "Please enter " + b + " or more characters";
                    return c
                }, loadingMore: function () {
                    return "Loading more results"
                }, maximumSelected: function (a) {
                    var b = "You can only select " + a.maximum + " item";
                    return 1 != a.maximum && (b += "s"), b
                }, noResults: function () {
                    return "No results found"
                }, searching: function () {
                    return "Searching"
                }
            }
        }), b.define("select2/defaults", ["jquery", "require", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./i18n/en"], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C) {
            function D() {
                this.reset()
            }

            D.prototype.apply = function (l) {
                if (l = a.extend(!0, {}, this.defaults, l), null == l.dataAdapter) {
                    if (null != l.ajax ? l.dataAdapter = o : null != l.data ? l.dataAdapter = n : l.dataAdapter = m, l.minimumInputLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, r)), l.maximumInputLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, s)), l.maximumSelectionLength > 0 && (l.dataAdapter = j.Decorate(l.dataAdapter, t)), l.tags && (l.dataAdapter = j.Decorate(l.dataAdapter, p)), (null != l.tokenSeparators || null != l.tokenizer) && (l.dataAdapter = j.Decorate(l.dataAdapter, q)), null != l.query) {
                        var C = b(l.amdBase + "compat/query");
                        l.dataAdapter = j.Decorate(l.dataAdapter, C)
                    }
                    if (null != l.initSelection) {
                        var D = b(l.amdBase + "compat/initSelection");
                        l.dataAdapter = j.Decorate(l.dataAdapter, D)
                    }
                }
                if (null == l.resultsAdapter && (l.resultsAdapter = c, null != l.ajax && (l.resultsAdapter = j.Decorate(l.resultsAdapter, x)), null != l.placeholder && (l.resultsAdapter = j.Decorate(l.resultsAdapter, w)), l.selectOnClose && (l.resultsAdapter = j.Decorate(l.resultsAdapter, A))), null == l.dropdownAdapter) {
                    if (l.multiple) l.dropdownAdapter = u; else {
                        var E = j.Decorate(u, v);
                        l.dropdownAdapter = E
                    }
                    if (0 !== l.minimumResultsForSearch && (l.dropdownAdapter = j.Decorate(l.dropdownAdapter, z)), l.closeOnSelect && (l.dropdownAdapter = j.Decorate(l.dropdownAdapter, B)), null != l.dropdownCssClass || null != l.dropdownCss || null != l.adaptDropdownCssClass) {
                        var F = b(l.amdBase + "compat/dropdownCss");
                        l.dropdownAdapter = j.Decorate(l.dropdownAdapter, F)
                    }
                    l.dropdownAdapter = j.Decorate(l.dropdownAdapter, y)
                }
                if (null == l.selectionAdapter) {
                    if (l.multiple ? l.selectionAdapter = e : l.selectionAdapter = d, null != l.placeholder && (l.selectionAdapter = j.Decorate(l.selectionAdapter, f)), l.allowClear && (l.selectionAdapter = j.Decorate(l.selectionAdapter, g)), l.multiple && (l.selectionAdapter = j.Decorate(l.selectionAdapter, h)), null != l.containerCssClass || null != l.containerCss || null != l.adaptContainerCssClass) {
                        var G = b(l.amdBase + "compat/containerCss");
                        l.selectionAdapter = j.Decorate(l.selectionAdapter, G)
                    }
                    l.selectionAdapter = j.Decorate(l.selectionAdapter, i)
                }
                if ("string" == typeof l.language) if (l.language.indexOf("-") > 0) {
                    var H = l.language.split("-"), I = H[0];
                    l.language = [l.language, I]
                } else l.language = [l.language];
                if (a.isArray(l.language)) {
                    var J = new k;
                    l.language.push("en");
                    for (var K = l.language, L = 0; L < K.length; L++) {
                        var M = K[L], N = {};
                        try {
                            N = k.loadPath(M)
                        } catch (O) {
                            try {
                                M = this.defaults.amdLanguageBase + M, N = k.loadPath(M)
                            } catch (P) {
                                l.debug && window.console && console.warn && console.warn('Select2: The language file for "' + M + '" could not be automatically loaded. A fallback will be used instead.');
                                continue
                            }
                        }
                        J.extend(N)
                    }
                    l.translations = J
                } else {
                    var Q = k.loadPath(this.defaults.amdLanguageBase + "en"), R = new k(l.language);
                    R.extend(Q), l.translations = R
                }
                return l
            }, D.prototype.reset = function () {
                function b(a) {
                    function b(a) {
                        return l[a] || a
                    }

                    return a.replace(/[^\u0000-\u007E]/g, b)
                }

                function c(d, e) {
                    if ("" === a.trim(d.term)) return e;
                    if (e.children && e.children.length > 0) {
                        for (var f = a.extend(!0, {}, e), g = e.children.length - 1; g >= 0; g--) {
                            var h = e.children[g], i = c(d, h);
                            null == i && f.children.splice(g, 1)
                        }
                        return f.children.length > 0 ? f : c(d, f)
                    }
                    var j = b(e.text).toUpperCase(), k = b(d.term).toUpperCase();
                    return j.indexOf(k) > -1 ? e : null
                }

                this.defaults = {
                    amdBase: "./",
                    amdLanguageBase: "./i18n/",
                    closeOnSelect: !0,
                    debug: !1,
                    dropdownAutoWidth: !1,
                    escapeMarkup: j.escapeMarkup,
                    language: C,
                    matcher: c,
                    minimumInputLength: 0,
                    maximumInputLength: 0,
                    maximumSelectionLength: 0,
                    minimumResultsForSearch: 0,
                    selectOnClose: !1,
                    sorter: function (a) {
                        return a
                    },
                    templateResult: function (a) {
                        return a.text
                    },
                    templateSelection: function (a) {
                        return a.text
                    },
                    theme: "default",
                    width: "resolve"
                }
            }, D.prototype.set = function (b, c) {
                var d = a.camelCase(b), e = {};
                e[d] = c;
                var f = j._convertData(e);
                a.extend(this.defaults, f)
            };
            var E = new D;
            return E
        }), b.define("select2/options", ["require", "jquery", "./defaults", "./utils"], function (a, b, c, d) {
            function e(b, e) {
                if (this.options = b, null != e && this.fromElement(e), this.options = c.apply(this.options), e && e.is("input")) {
                    var f = a(this.get("amdBase") + "compat/inputData");
                    this.options.dataAdapter = d.Decorate(this.options.dataAdapter, f)
                }
            }

            return e.prototype.fromElement = function (a) {
                var c = ["select2"];
                null == this.options.multiple && (this.options.multiple = a.prop("multiple")), null == this.options.disabled && (this.options.disabled = a.prop("disabled")), null == this.options.language && (a.prop("lang") ? this.options.language = a.prop("lang").toLowerCase() : a.closest("[lang]").prop("lang") && (this.options.language = a.closest("[lang]").prop("lang"))), null == this.options.dir && (a.prop("dir") ? this.options.dir = a.prop("dir") : a.closest("[dir]").prop("dir") ? this.options.dir = a.closest("[dir]").prop("dir") : this.options.dir = "ltr"), a.prop("disabled", this.options.disabled), a.prop("multiple", this.options.multiple), a.data("select2Tags") && (this.options.debug && window.console && console.warn && console.warn('Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'), a.data("data", a.data("select2Tags")), a.data("tags", !0)), a.data("ajaxUrl") && (this.options.debug && window.console && console.warn && console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."), a.attr("ajax--url", a.data("ajaxUrl")), a.data("ajax--url", a.data("ajaxUrl")));
                var e = {};
                e = b.fn.jquery && "1." == b.fn.jquery.substr(0, 2) && a[0].dataset ? b.extend(!0, {}, a[0].dataset, a.data()) : a.data();
                var f = b.extend(!0, {}, e);
                f = d._convertData(f);
                for (var g in f) b.inArray(g, c) > -1 || (b.isPlainObject(this.options[g]) ? b.extend(this.options[g], f[g]) : this.options[g] = f[g]);
                return this
            }, e.prototype.get = function (a) {
                return this.options[a]
            }, e.prototype.set = function (a, b) {
                this.options[a] = b
            }, e
        }), b.define("select2/core", ["jquery", "./options", "./utils", "./keys"], function (a, b, c, d) {
            var e = function (a, c) {
                null != a.data("select2") && a.data("select2").destroy(), this.$element = a, this.id = this._generateId(a), c = c || {}, this.options = new b(c, a), e.__super__.constructor.call(this);
                var d = a.attr("tabindex") || 0;
                a.data("old-tabindex", d), a.attr("tabindex", "-1");
                var f = this.options.get("dataAdapter");
                this.dataAdapter = new f(a, this.options);
                var g = this.render();
                this._placeContainer(g);
                var h = this.options.get("selectionAdapter");
                this.selection = new h(a, this.options), this.$selection = this.selection.render(), this.selection.position(this.$selection, g);
                var i = this.options.get("dropdownAdapter");
                this.dropdown = new i(a, this.options), this.$dropdown = this.dropdown.render(), this.dropdown.position(this.$dropdown, g);
                var j = this.options.get("resultsAdapter");
                this.results = new j(a, this.options, this.dataAdapter), this.$results = this.results.render(), this.results.position(this.$results, this.$dropdown);
                var k = this;
                this._bindAdapters(), this._registerDomEvents(), this._registerDataEvents(), this._registerSelectionEvents(), this._registerDropdownEvents(), this._registerResultsEvents(), this._registerEvents(), this.dataAdapter.current(function (a) {
                    k.trigger("selection:update", {data: a})
                }), a.addClass("select2-hidden-accessible"), a.attr("aria-hidden", "true"), this._syncAttributes(), a.data("select2", this)
            };
            return c.Extend(e, c.Observable), e.prototype._generateId = function (a) {
                var b = "";
                return b = null != a.attr("id") ? a.attr("id") : null != a.attr("name") ? a.attr("name") + "-" + c.generateChars(2) : c.generateChars(4), b = b.replace(/(:|\.|\[|\]|,)/g, ""), b = "select2-" + b
            }, e.prototype._placeContainer = function (a) {
                a.insertAfter(this.$element);
                var b = this._resolveWidth(this.$element, this.options.get("width"));
                null != b && a.css("width", b)
            }, e.prototype._resolveWidth = function (a, b) {
                var c = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
                if ("resolve" == b) {
                    var d = this._resolveWidth(a, "style");
                    return null != d ? d : this._resolveWidth(a, "element")
                }
                if ("element" == b) {
                    var e = a.outerWidth(!1);
                    return 0 >= e ? "auto" : e + "px"
                }
                if ("style" == b) {
                    var f = a.attr("style");
                    if ("string" != typeof f) return null;
                    for (var g = f.split(";"), h = 0, i = g.length; i > h; h += 1) {
                        var j = g[h].replace(/\s/g, ""), k = j.match(c);
                        if (null !== k && k.length >= 1) return k[1]
                    }
                    return null
                }
                return b
            }, e.prototype._bindAdapters = function () {
                this.dataAdapter.bind(this, this.$container), this.selection.bind(this, this.$container), this.dropdown.bind(this, this.$container), this.results.bind(this, this.$container)
            }, e.prototype._registerDomEvents = function () {
                var b = this;
                this.$element.on("change.select2", function () {
                    b.dataAdapter.current(function (a) {
                        b.trigger("selection:update", {data: a})
                    })
                }), this.$element.on("focus.select2", function (a) {
                    b.trigger("focus", a)
                }), this._syncA = c.bind(this._syncAttributes, this), this._syncS = c.bind(this._syncSubtree, this), this.$element[0].attachEvent && this.$element[0].attachEvent("onpropertychange", this._syncA);
                var d = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
                null != d ? (this._observer = new d(function (c) {
                    a.each(c, b._syncA), a.each(c, b._syncS)
                }), this._observer.observe(this.$element[0], {
                    attributes: !0,
                    childList: !0,
                    subtree: !1
                })) : this.$element[0].addEventListener && (this.$element[0].addEventListener("DOMAttrModified", b._syncA, !1), this.$element[0].addEventListener("DOMNodeInserted", b._syncS, !1), this.$element[0].addEventListener("DOMNodeRemoved", b._syncS, !1))
            }, e.prototype._registerDataEvents = function () {
                var a = this;
                this.dataAdapter.on("*", function (b, c) {
                    a.trigger(b, c)
                })
            }, e.prototype._registerSelectionEvents = function () {
                var b = this, c = ["toggle", "focus"];
                this.selection.on("toggle", function () {
                    b.toggleDropdown()
                }), this.selection.on("focus", function (a) {
                    b.focus(a)
                }), this.selection.on("*", function (d, e) {
                    -1 === a.inArray(d, c) && b.trigger(d, e)
                })
            }, e.prototype._registerDropdownEvents = function () {
                var a = this;
                this.dropdown.on("*", function (b, c) {
                    a.trigger(b, c)
                })
            }, e.prototype._registerResultsEvents = function () {
                var a = this;
                this.results.on("*", function (b, c) {
                    a.trigger(b, c)
                })
            }, e.prototype._registerEvents = function () {
                var a = this;
                this.on("open", function () {
                    a.$container.addClass("select2-container--open")
                }), this.on("close", function () {
                    a.$container.removeClass("select2-container--open")
                }), this.on("enable", function () {
                    a.$container.removeClass("select2-container--disabled")
                }), this.on("disable", function () {
                    a.$container.addClass("select2-container--disabled")
                }), this.on("blur", function () {
                    a.$container.removeClass("select2-container--focus")
                }), this.on("query", function (b) {
                    a.isOpen() || a.trigger("open", {}), this.dataAdapter.query(b, function (c) {
                        a.trigger("results:all", {data: c, query: b})
                    })
                }), this.on("query:append", function (b) {
                    this.dataAdapter.query(b, function (c) {
                        a.trigger("results:append", {data: c, query: b})
                    })
                }), this.on("keypress", function (b) {
                    var c = b.which;
                    a.isOpen() ? c === d.ESC || c === d.TAB || c === d.UP && b.altKey ? (a.close(), b.preventDefault()) : c === d.ENTER ? (a.trigger("results:select", {}), b.preventDefault()) : c === d.SPACE && b.ctrlKey ? (a.trigger("results:toggle", {}), b.preventDefault()) : c === d.UP ? (a.trigger("results:previous", {}), b.preventDefault()) : c === d.DOWN && (a.trigger("results:next", {}), b.preventDefault()) : (c === d.ENTER || c === d.SPACE || c === d.DOWN && b.altKey) && (a.open(), b.preventDefault())
                })
            }, e.prototype._syncAttributes = function () {
                this.options.set("disabled", this.$element.prop("disabled")), this.options.get("disabled") ? (this.isOpen() && this.close(), this.trigger("disable", {})) : this.trigger("enable", {})
            }, e.prototype._syncSubtree = function (a, b) {
                var c = !1, d = this;
                if (!a || !a.target || "OPTION" === a.target.nodeName || "OPTGROUP" === a.target.nodeName) {
                    if (b) if (b.addedNodes && b.addedNodes.length > 0) for (var e = 0; e < b.addedNodes.length; e++) {
                        var f = b.addedNodes[e];
                        f.selected && (c = !0)
                    } else b.removedNodes && b.removedNodes.length > 0 && (c = !0); else c = !0;
                    c && this.dataAdapter.current(function (a) {
                        d.trigger("selection:update", {data: a})
                    })
                }
            }, e.prototype.trigger = function (a, b) {
                var c = e.__super__.trigger,
                    d = {open: "opening", close: "closing", select: "selecting", unselect: "unselecting"};
                if (void 0 === b && (b = {}), a in d) {
                    var f = d[a], g = {prevented: !1, name: a, args: b};
                    if (c.call(this, f, g), g.prevented) return void(b.prevented = !0)
                }
                c.call(this, a, b)
            }, e.prototype.toggleDropdown = function () {
                this.options.get("disabled") || (this.isOpen() ? this.close() : this.open())
            }, e.prototype.open = function () {
                this.isOpen() || this.trigger("query", {})
            }, e.prototype.close = function () {
                this.isOpen() && this.trigger("close", {})
            }, e.prototype.isOpen = function () {
                return this.$container.hasClass("select2-container--open")
            }, e.prototype.hasFocus = function () {
                return this.$container.hasClass("select2-container--focus")
            }, e.prototype.focus = function (a) {
                this.hasFocus() || (this.$container.addClass("select2-container--focus"), this.trigger("focus", {}))
            }, e.prototype.enable = function (a) {
                this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'), (null == a || 0 === a.length) && (a = [!0]);
                var b = !a[0];
                this.$element.prop("disabled", b)
            }, e.prototype.data = function () {
                this.options.get("debug") && arguments.length > 0 && window.console && console.warn && console.warn('Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.');
                var a = [];
                return this.dataAdapter.current(function (b) {
                    a = b
                }), a
            }, e.prototype.val = function (b) {
                if (this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'), null == b || 0 === b.length) return this.$element.val();
                var c = b[0];
                a.isArray(c) && (c = a.map(c, function (a) {
                    return a.toString()
                })), this.$element.val(c).trigger("change")
            }, e.prototype.destroy = function () {
                this.$container.remove(), this.$element[0].detachEvent && this.$element[0].detachEvent("onpropertychange", this._syncA), null != this._observer ? (this._observer.disconnect(), this._observer = null) : this.$element[0].removeEventListener && (this.$element[0].removeEventListener("DOMAttrModified", this._syncA, !1), this.$element[0].removeEventListener("DOMNodeInserted", this._syncS, !1), this.$element[0].removeEventListener("DOMNodeRemoved", this._syncS, !1)), this._syncA = null, this._syncS = null, this.$element.off(".select2"), this.$element.attr("tabindex", this.$element.data("old-tabindex")), this.$element.removeClass("select2-hidden-accessible"), this.$element.attr("aria-hidden", "false"), this.$element.removeData("select2"), this.dataAdapter.destroy(), this.selection.destroy(), this.dropdown.destroy(), this.results.destroy(), this.dataAdapter = null, this.selection = null, this.dropdown = null, this.results = null;
            }, e.prototype.render = function () {
                var b = a('<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>');
                return b.attr("dir", this.options.get("dir")), this.$container = b, this.$container.addClass("select2-container--" + this.options.get("theme")), b.data("element", this.$element), b
            }, e
        }), b.define("jquery-mousewheel", ["jquery"], function (a) {
            return a
        }), b.define("jquery.select2", ["jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults"], function (a, b, c, d) {
            if (null == a.fn.select2) {
                var e = ["open", "close", "destroy"];
                a.fn.select2 = function (b) {
                    if (b = b || {}, "object" == typeof b) return this.each(function () {
                        var d = a.extend(!0, {}, b);
                        new c(a(this), d)
                    }), this;
                    if ("string" == typeof b) {
                        var d, f = Array.prototype.slice.call(arguments, 1);
                        return this.each(function () {
                            var c = a(this).data("select2");
                            null == c && window.console && console.error && console.error("The select2('" + b + "') method was called on an element that is not using Select2."), d = c[b].apply(c, f)
                        }), a.inArray(b, e) > -1 ? this : d
                    }
                    throw new Error("Invalid arguments for Select2: " + b)
                }
            }
            return null == a.fn.select2.defaults && (a.fn.select2.defaults = d), c
        }), {define: b.define, require: b.require}
    }(), c = b.require("jquery.select2");
    return a.fn.select2.amd = b, c
});
//! moment.js
//! version : 2.15.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            global.moment = factory()
}(this, function () {
    'use strict';

    var hookCallback;

    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            // even if its not own property I'd still call it non-empty
            return false;
        }
        return true;
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
            (typeof console !== 'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };

    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };

    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get(mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set(mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1 = /\d/;            //       0 - 9
    var match2 = /\d\d/;          //      00 - 99
    var match3 = /\d{3}/;         //     000 - 999
    var match4 = /\d{4}/;         //    0000 - 9999
    var match6 = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2 = /\d\d?/;         //       0 - 99
    var match3to4 = /\d\d\d\d?/;     //     999 - 9999
    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3 = /\d{1,3}/;       //       0 - 999
    var match1to4 = /\d{1,4}/;       //       0 - 9999
    var match1to6 = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned = /\d+/;           //       0 - inf
    var matchSigned = /[+-]?\d+/;      //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
        if (!m) {
            return this._months;
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
        if (!m) {
            return this._monthsShort;
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
        if (!m) {
            return this._weekdays;
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = create_utc__createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                        'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            // MERGE
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                    a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                        a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                            a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                    a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {
    };

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {
    };

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);

            if (tZone === 0) {
                this.utcOffset(0, true);
            } else {
                this.utcOffset(offsetFromString(matchOffset, this._i));
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

    function create__createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                    'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val;
                val = period;
                period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                        diff < 2 ? 'nextDay' :
                            diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function moment_calendar__calendar(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                    units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                        units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
                local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
                local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    function startOf(units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
            /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
            /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
            /* falls through */
            case 'hour':
                this.minutes(0);
            /* falls through */
            case 'minute':
                this.seconds(0);
            /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf() {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid() {
        return valid__isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = stringGet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isSameOrAfter = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore = isSameOrBefore;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = stringSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = toJSON;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.creationData = creationData;

    // Year
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix(input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var prototype__proto = Locale.prototype;

    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto.ordinal = ordinal;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;

    // Month
    prototype__proto.months = localeMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.monthsRegex = monthsRegex;
    prototype__proto.monthsShortRegex = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;

    prototype__proto.weekdaysRegex = weekdaysRegex;
    prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex = weekdaysMinRegex;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function lists__listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function lists__listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function lists__listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function lists__listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function lists__listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   :
                    return days / 7 + milliseconds / 6048e5;
                case 'day'    :
                    return days + milliseconds / 864e5;
                case 'hour'   :
                    return days * 24 + milliseconds / 36e5;
                case 'minute' :
                    return days * 1440 + milliseconds / 6e4;
                case 'second' :
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf() {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');

    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds] ||
            minutes <= 1 && ['m'] ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours <= 1 && ['h'] ||
            hours < thresholds.h && ['hh', hours] ||
            days <= 1 && ['d'] ||
            days < thresholds.d && ['dd', days] ||
            months <= 1 && ['M'] ||
            months < thresholds.M && ['MM', months] ||
            years <= 1 && ['y'] || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.15.2';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.now = now;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.updateLocale = updateLocale;
    utils_hooks__hooks.locales = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat = getCalendarFormat;
    utils_hooks__hooks.prototype = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
!function (a) {
    "use strict";
    if ("function" == typeof define && define.amd) define(["jquery", "moment"], a); else if ("object" == typeof exports) module.exports = a(require("jquery"), require("moment")); else {
        if ("undefined" == typeof jQuery) throw"bootstrap-datetimepicker requires jQuery to be loaded first";
        if ("undefined" == typeof moment) throw"bootstrap-datetimepicker requires Moment.js to be loaded first";
        a(jQuery, moment)
    }
}(function (a, b) {
    "use strict";
    if (!b) throw new Error("bootstrap-datetimepicker requires Moment.js to be loaded first");
    var c = function (c, d) {
        var e, f, g, h, i, j, k, l = {}, m = !0, n = !1, o = !1, p = 0,
            q = [{clsName: "days", navFnc: "M", navStep: 1}, {
                clsName: "months",
                navFnc: "y",
                navStep: 1
            }, {clsName: "years", navFnc: "y", navStep: 10}, {clsName: "decades", navFnc: "y", navStep: 100}],
            r = ["days", "months", "years", "decades"], s = ["top", "bottom", "auto"], t = ["left", "right", "auto"],
            u = ["default", "top", "bottom"], v = {
                up: 38,
                38: "up",
                down: 40,
                40: "down",
                left: 37,
                37: "left",
                right: 39,
                39: "right",
                tab: 9,
                9: "tab",
                escape: 27,
                27: "escape",
                enter: 13,
                13: "enter",
                pageUp: 33,
                33: "pageUp",
                pageDown: 34,
                34: "pageDown",
                shift: 16,
                16: "shift",
                control: 17,
                17: "control",
                space: 32,
                32: "space",
                t: 84,
                84: "t",
                delete: 46,
                46: "delete"
            }, w = {}, x = function () {
                return void 0 !== b.tz && void 0 !== d.timeZone && null !== d.timeZone && "" !== d.timeZone
            }, y = function (a) {
                var c;
                return c = void 0 === a || null === a ? b() : b.isDate(a) || b.isMoment(a) ? b(a) : x() ? b.tz(a, j, d.useStrict, d.timeZone) : b(a, j, d.useStrict), x() && c.tz(d.timeZone), c
            }, z = function (a) {
                if ("string" != typeof a || a.length > 1) throw new TypeError("isEnabled expects a single character string parameter");
                switch (a) {
                    case"y":
                        return i.indexOf("Y") !== -1;
                    case"M":
                        return i.indexOf("M") !== -1;
                    case"d":
                        return i.toLowerCase().indexOf("d") !== -1;
                    case"h":
                    case"H":
                        return i.toLowerCase().indexOf("h") !== -1;
                    case"m":
                        return i.indexOf("m") !== -1;
                    case"s":
                        return i.indexOf("s") !== -1;
                    default:
                        return !1
                }
            }, A = function () {
                return z("h") || z("m") || z("s")
            }, B = function () {
                return z("y") || z("M") || z("d")
            }, C = function () {
                var b = a("<thead>").append(a("<tr>").append(a("<th>").addClass("prev").attr("data-action", "previous").append(a("<span>").addClass(d.icons.previous))).append(a("<th>").addClass("picker-switch").attr("data-action", "pickerSwitch").attr("colspan", d.calendarWeeks ? "6" : "5")).append(a("<th>").addClass("next").attr("data-action", "next").append(a("<span>").addClass(d.icons.next)))),
                    c = a("<tbody>").append(a("<tr>").append(a("<td>").attr("colspan", d.calendarWeeks ? "8" : "7")));
                return [a("<div>").addClass("datepicker-days").append(a("<table>").addClass("table-condensed").append(b).append(a("<tbody>"))), a("<div>").addClass("datepicker-months").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone())), a("<div>").addClass("datepicker-years").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone())), a("<div>").addClass("datepicker-decades").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone()))]
            }, D = function () {
                var b = a("<tr>"), c = a("<tr>"), e = a("<tr>");
                return z("h") && (b.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.incrementHour
                }).addClass("btn").attr("data-action", "incrementHours").append(a("<span>").addClass(d.icons.up)))), c.append(a("<td>").append(a("<span>").addClass("timepicker-hour").attr({
                    "data-time-component": "hours",
                    title: d.tooltips.pickHour
                }).attr("data-action", "showHours"))), e.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.decrementHour
                }).addClass("btn").attr("data-action", "decrementHours").append(a("<span>").addClass(d.icons.down))))), z("m") && (z("h") && (b.append(a("<td>").addClass("separator")), c.append(a("<td>").addClass("separator").html(":")), e.append(a("<td>").addClass("separator"))), b.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.incrementMinute
                }).addClass("btn").attr("data-action", "incrementMinutes").append(a("<span>").addClass(d.icons.up)))), c.append(a("<td>").append(a("<span>").addClass("timepicker-minute").attr({
                    "data-time-component": "minutes",
                    title: d.tooltips.pickMinute
                }).attr("data-action", "showMinutes"))), e.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.decrementMinute
                }).addClass("btn").attr("data-action", "decrementMinutes").append(a("<span>").addClass(d.icons.down))))), z("s") && (z("m") && (b.append(a("<td>").addClass("separator")), c.append(a("<td>").addClass("separator").html(":")), e.append(a("<td>").addClass("separator"))), b.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.incrementSecond
                }).addClass("btn").attr("data-action", "incrementSeconds").append(a("<span>").addClass(d.icons.up)))), c.append(a("<td>").append(a("<span>").addClass("timepicker-second").attr({
                    "data-time-component": "seconds",
                    title: d.tooltips.pickSecond
                }).attr("data-action", "showSeconds"))), e.append(a("<td>").append(a("<a>").attr({
                    href: "#",
                    tabindex: "-1",
                    title: d.tooltips.decrementSecond
                }).addClass("btn").attr("data-action", "decrementSeconds").append(a("<span>").addClass(d.icons.down))))), h || (b.append(a("<td>").addClass("separator")), c.append(a("<td>").append(a("<button>").addClass("btn btn-primary").attr({
                    "data-action": "togglePeriod",
                    tabindex: "-1",
                    title: d.tooltips.togglePeriod
                }))), e.append(a("<td>").addClass("separator"))), a("<div>").addClass("timepicker-picker").append(a("<table>").addClass("table-condensed").append([b, c, e]))
            }, E = function () {
                var b = a("<div>").addClass("timepicker-hours").append(a("<table>").addClass("table-condensed")),
                    c = a("<div>").addClass("timepicker-minutes").append(a("<table>").addClass("table-condensed")),
                    d = a("<div>").addClass("timepicker-seconds").append(a("<table>").addClass("table-condensed")),
                    e = [D()];
                return z("h") && e.push(b), z("m") && e.push(c), z("s") && e.push(d), e
            }, F = function () {
                var b = [];
                return d.showTodayButton && b.push(a("<td>").append(a("<a>").attr({
                    "data-action": "today",
                    title: d.tooltips.today
                }).append(a("<span>").addClass(d.icons.today)))), !d.sideBySide && B() && A() && b.push(a("<td>").append(a("<a>").attr({
                    "data-action": "togglePicker",
                    title: d.tooltips.selectTime
                }).append(a("<span>").addClass(d.icons.time)))), d.showClear && b.push(a("<td>").append(a("<a>").attr({
                    "data-action": "clear",
                    title: d.tooltips.clear
                }).append(a("<span>").addClass(d.icons.clear)))), d.showClose && b.push(a("<td>").append(a("<a>").attr({
                    "data-action": "close",
                    title: d.tooltips.close
                }).append(a("<span>").addClass(d.icons.close)))), a("<table>").addClass("table-condensed").append(a("<tbody>").append(a("<tr>").append(b)))
            }, G = function () {
                var b = a("<div>").addClass("bootstrap-datetimepicker-widget dropdown-menu"),
                    c = a("<div>").addClass("datepicker").append(C()), e = a("<div>").addClass("timepicker").append(E()),
                    f = a("<ul>").addClass("list-unstyled"),
                    g = a("<li>").addClass("picker-switch" + (d.collapse ? " accordion-toggle" : "")).append(F());
                return d.inline && b.removeClass("dropdown-menu"), h && b.addClass("usetwentyfour"), z("s") && !h && b.addClass("wider"), d.sideBySide && B() && A() ? (b.addClass("timepicker-sbs"), "top" === d.toolbarPlacement && b.append(g), b.append(a("<div>").addClass("row").append(c.addClass("col-md-6")).append(e.addClass("col-md-6"))), "bottom" === d.toolbarPlacement && b.append(g), b) : ("top" === d.toolbarPlacement && f.append(g), B() && f.append(a("<li>").addClass(d.collapse && A() ? "collapse in" : "").append(c)), "default" === d.toolbarPlacement && f.append(g), A() && f.append(a("<li>").addClass(d.collapse && B() ? "collapse" : "").append(e)), "bottom" === d.toolbarPlacement && f.append(g), b.append(f))
            }, H = function () {
                var b, e = {};
                return b = c.is("input") || d.inline ? c.data() : c.find("input").data(), b.dateOptions && b.dateOptions instanceof Object && (e = a.extend(!0, e, b.dateOptions)), a.each(d, function (a) {
                    var c = "date" + a.charAt(0).toUpperCase() + a.slice(1);
                    void 0 !== b[c] && (e[a] = b[c])
                }), e
            }, I = function () {
                var b, e = (n || c).position(), f = (n || c).offset(), g = d.widgetPositioning.vertical,
                    h = d.widgetPositioning.horizontal;
                if (d.widgetParent) b = d.widgetParent.append(o); else if (c.is("input")) b = c.after(o).parent(); else {
                    if (d.inline) return void(b = c.append(o));
                    b = c, c.children().first().after(o)
                }
                if ("auto" === g && (g = f.top + 1.5 * o.height() >= a(window).height() + a(window).scrollTop() && o.height() + c.outerHeight() < f.top ? "top" : "bottom"), "auto" === h && (h = b.width() < f.left + o.outerWidth() / 2 && f.left + o.outerWidth() > a(window).width() ? "right" : "left"), "top" === g ? o.addClass("top").removeClass("bottom") : o.addClass("bottom").removeClass("top"), "right" === h ? o.addClass("pull-right") : o.removeClass("pull-right"), "static" === b.css("position") && (b = b.parents().filter(function () {
                        return "static" !== a(this).css("position")
                    }).first()), 0 === b.length) throw new Error("datetimepicker component should be placed within a non-static positioned container");
                o.css({
                    top: "top" === g ? "auto" : e.top + c.outerHeight(),
                    bottom: "top" === g ? b.outerHeight() - (b === c ? 0 : e.top) : "auto",
                    left: "left" === h ? b === c ? 0 : e.left : "auto",
                    right: "left" === h ? "auto" : b.outerWidth() - c.outerWidth() - (b === c ? 0 : e.left)
                })
            }, J = function (a) {
                "dp.change" === a.type && (a.date && a.date.isSame(a.oldDate) || !a.date && !a.oldDate) || c.trigger(a)
            }, K = function (a) {
                "y" === a && (a = "YYYY"), J({type: "dp.update", change: a, viewDate: f.clone()})
            }, L = function (a) {
                o && (a && (k = Math.max(p, Math.min(3, k + a))), o.find(".datepicker > div").hide().filter(".datepicker-" + q[k].clsName).show())
            }, M = function () {
                var b = a("<tr>"), c = f.clone().startOf("w").startOf("d");
                for (d.calendarWeeks === !0 && b.append(a("<th>").addClass("cw").text("#")); c.isBefore(f.clone().endOf("w"));) b.append(a("<th>").addClass("dow").text(c.format("dd"))), c.add(1, "d");
                o.find(".datepicker-days thead").append(b)
            }, N = function (a) {
                return d.disabledDates[a.format("YYYY-MM-DD")] === !0
            }, O = function (a) {
                return d.enabledDates[a.format("YYYY-MM-DD")] === !0
            }, P = function (a) {
                return d.disabledHours[a.format("H")] === !0
            }, Q = function (a) {
                return d.enabledHours[a.format("H")] === !0
            }, R = function (b, c) {
                if (!b.isValid()) return !1;
                if (d.disabledDates && "d" === c && N(b)) return !1;
                if (d.enabledDates && "d" === c && !O(b)) return !1;
                if (d.minDate && b.isBefore(d.minDate, c)) return !1;
                if (d.maxDate && b.isAfter(d.maxDate, c)) return !1;
                if (d.daysOfWeekDisabled && "d" === c && d.daysOfWeekDisabled.indexOf(b.day()) !== -1) return !1;
                if (d.disabledHours && ("h" === c || "m" === c || "s" === c) && P(b)) return !1;
                if (d.enabledHours && ("h" === c || "m" === c || "s" === c) && !Q(b)) return !1;
                if (d.disabledTimeIntervals && ("h" === c || "m" === c || "s" === c)) {
                    var e = !1;
                    if (a.each(d.disabledTimeIntervals, function () {
                            if (b.isBetween(this[0], this[1])) return e = !0, !1
                        }), e) return !1
                }
                return !0
            }, S = function () {
                for (var b = [], c = f.clone().startOf("y").startOf("d"); c.isSame(f, "y");) b.push(a("<span>").attr("data-action", "selectMonth").addClass("month").text(c.format("MMM"))), c.add(1, "M");
                o.find(".datepicker-months td").empty().append(b)
            }, T = function () {
                var b = o.find(".datepicker-months"), c = b.find("th"), g = b.find("tbody").find("span");
                c.eq(0).find("span").attr("title", d.tooltips.prevYear), c.eq(1).attr("title", d.tooltips.selectYear), c.eq(2).find("span").attr("title", d.tooltips.nextYear), b.find(".disabled").removeClass("disabled"), R(f.clone().subtract(1, "y"), "y") || c.eq(0).addClass("disabled"), c.eq(1).text(f.year()), R(f.clone().add(1, "y"), "y") || c.eq(2).addClass("disabled"), g.removeClass("active"), e.isSame(f, "y") && !m && g.eq(e.month()).addClass("active"), g.each(function (b) {
                    R(f.clone().month(b), "M") || a(this).addClass("disabled")
                })
            }, U = function () {
                var a = o.find(".datepicker-years"), b = a.find("th"), c = f.clone().subtract(5, "y"),
                    g = f.clone().add(6, "y"), h = "";
                for (b.eq(0).find("span").attr("title", d.tooltips.prevDecade), b.eq(1).attr("title", d.tooltips.selectDecade), b.eq(2).find("span").attr("title", d.tooltips.nextDecade), a.find(".disabled").removeClass("disabled"), d.minDate && d.minDate.isAfter(c, "y") && b.eq(0).addClass("disabled"), b.eq(1).text(c.year() + "-" + g.year()), d.maxDate && d.maxDate.isBefore(g, "y") && b.eq(2).addClass("disabled"); !c.isAfter(g, "y");) h += '<span data-action="selectYear" class="year' + (c.isSame(e, "y") && !m ? " active" : "") + (R(c, "y") ? "" : " disabled") + '">' + c.year() + "</span>", c.add(1, "y");
                a.find("td").html(h)
            }, V = function () {
                var a, c = o.find(".datepicker-decades"), g = c.find("th"), h = b({y: f.year() - f.year() % 100 - 1}),
                    i = h.clone().add(100, "y"), j = h.clone(), k = !1, l = !1, m = "";
                for (g.eq(0).find("span").attr("title", d.tooltips.prevCentury), g.eq(2).find("span").attr("title", d.tooltips.nextCentury), c.find(".disabled").removeClass("disabled"), (h.isSame(b({y: 1900})) || d.minDate && d.minDate.isAfter(h, "y")) && g.eq(0).addClass("disabled"), g.eq(1).text(h.year() + "-" + i.year()), (h.isSame(b({y: 2e3})) || d.maxDate && d.maxDate.isBefore(i, "y")) && g.eq(2).addClass("disabled"); !h.isAfter(i, "y");) a = h.year() + 12, k = d.minDate && d.minDate.isAfter(h, "y") && d.minDate.year() <= a, l = d.maxDate && d.maxDate.isAfter(h, "y") && d.maxDate.year() <= a, m += '<span data-action="selectDecade" class="decade' + (e.isAfter(h) && e.year() <= a ? " active" : "") + (R(h, "y") || k || l ? "" : " disabled") + '" data-selection="' + (h.year() + 6) + '">' + (h.year() + 1) + " - " + (h.year() + 12) + "</span>", h.add(12, "y");
                m += "<span></span><span></span><span></span>", c.find("td").html(m), g.eq(1).text(j.year() + 1 + "-" + h.year())
            }, W = function () {
                var b, c, g, h = o.find(".datepicker-days"), i = h.find("th"), j = [], k = [];
                if (B()) {
                    for (i.eq(0).find("span").attr("title", d.tooltips.prevMonth), i.eq(1).attr("title", d.tooltips.selectMonth), i.eq(2).find("span").attr("title", d.tooltips.nextMonth), h.find(".disabled").removeClass("disabled"), i.eq(1).text(f.format(d.dayViewHeaderFormat)), R(f.clone().subtract(1, "M"), "M") || i.eq(0).addClass("disabled"), R(f.clone().add(1, "M"), "M") || i.eq(2).addClass("disabled"), b = f.clone().startOf("M").startOf("w").startOf("d"), g = 0; g < 42; g++) 0 === b.weekday() && (c = a("<tr>"), d.calendarWeeks && c.append('<td class="cw">' + b.week() + "</td>"), j.push(c)), k = ["day"], b.isBefore(f, "M") && k.push("old"), b.isAfter(f, "M") && k.push("new"), b.isSame(e, "d") && !m && k.push("active"), R(b, "d") || k.push("disabled"), b.isSame(y(), "d") && k.push("today"), 0 !== b.day() && 6 !== b.day() || k.push("weekend"), J({
                        type: "dp.classify",
                        date: b,
                        classNames: k
                    }), c.append('<td data-action="selectDay" data-day="' + b.format("L") + '" class="' + k.join(" ") + '">' + b.date() + "</td>"), b.add(1, "d");
                    h.find("tbody").empty().append(j), T(), U(), V()
                }
            }, X = function () {
                var b = o.find(".timepicker-hours table"), c = f.clone().startOf("d"), d = [], e = a("<tr>");
                for (f.hour() > 11 && !h && c.hour(12); c.isSame(f, "d") && (h || f.hour() < 12 && c.hour() < 12 || f.hour() > 11);) c.hour() % 4 === 0 && (e = a("<tr>"), d.push(e)), e.append('<td data-action="selectHour" class="hour' + (R(c, "h") ? "" : " disabled") + '">' + c.format(h ? "HH" : "hh") + "</td>"), c.add(1, "h");
                b.empty().append(d)
            }, Y = function () {
                for (var b = o.find(".timepicker-minutes table"), c = f.clone().startOf("h"), e = [], g = a("<tr>"), h = 1 === d.stepping ? 5 : d.stepping; f.isSame(c, "h");) c.minute() % (4 * h) === 0 && (g = a("<tr>"), e.push(g)), g.append('<td data-action="selectMinute" class="minute' + (R(c, "m") ? "" : " disabled") + '">' + c.format("mm") + "</td>"), c.add(h, "m");
                b.empty().append(e)
            }, Z = function () {
                for (var b = o.find(".timepicker-seconds table"), c = f.clone().startOf("m"), d = [], e = a("<tr>"); f.isSame(c, "m");) c.second() % 20 === 0 && (e = a("<tr>"), d.push(e)), e.append('<td data-action="selectSecond" class="second' + (R(c, "s") ? "" : " disabled") + '">' + c.format("ss") + "</td>"), c.add(5, "s");
                b.empty().append(d)
            }, $ = function () {
                var a, b, c = o.find(".timepicker span[data-time-component]");
                h || (a = o.find(".timepicker [data-action=togglePeriod]"), b = e.clone().add(e.hours() >= 12 ? -12 : 12, "h"), a.text(e.format("A")), R(b, "h") ? a.removeClass("disabled") : a.addClass("disabled")), c.filter("[data-time-component=hours]").text(e.format(h ? "HH" : "hh")), c.filter("[data-time-component=minutes]").text(e.format("mm")), c.filter("[data-time-component=seconds]").text(e.format("ss")), X(), Y(), Z()
            }, _ = function () {
                o && (W(), $())
            }, aa = function (a) {
                var b = m ? null : e;
                if (!a) return m = !0, g.val(""), c.data("date", ""), J({
                    type: "dp.change",
                    date: !1,
                    oldDate: b
                }), void _();
                if (a = a.clone().locale(d.locale), x() && a.tz(d.timeZone), 1 !== d.stepping) for (a.minutes(Math.round(a.minutes() / d.stepping) * d.stepping).seconds(0); d.minDate && a.isBefore(d.minDate);) a.add(d.stepping, "minutes");
                R(a) ? (e = a, f = e.clone(), g.val(e.format(i)), c.data("date", e.format(i)), m = !1, _(), J({
                    type: "dp.change",
                    date: e.clone(),
                    oldDate: b
                })) : (d.keepInvalid ? J({
                    type: "dp.change",
                    date: a,
                    oldDate: b
                }) : g.val(m ? "" : e.format(i)), J({type: "dp.error", date: a, oldDate: b}))
            }, ba = function () {
                var b = !1;
                return o ? (o.find(".collapse").each(function () {
                    var c = a(this).data("collapse");
                    return !c || !c.transitioning || (b = !0, !1)
                }), b ? l : (n && n.hasClass("btn") && n.toggleClass("active"), o.hide(), a(window).off("resize", I), o.off("click", "[data-action]"), o.off("mousedown", !1), o.remove(), o = !1, J({
                    type: "dp.hide",
                    date: e.clone()
                }), g.blur(), f = e.clone(), l)) : l
            }, ca = function () {
                aa(null)
            }, da = function (a) {
                return void 0 === d.parseInputDate ? (!b.isMoment(a) || a instanceof Date) && (a = y(a)) : a = d.parseInputDate(a), a
            }, ea = {
                next: function () {
                    var a = q[k].navFnc;
                    f.add(q[k].navStep, a), W(), K(a)
                }, previous: function () {
                    var a = q[k].navFnc;
                    f.subtract(q[k].navStep, a), W(), K(a)
                }, pickerSwitch: function () {
                    L(1)
                }, selectMonth: function (b) {
                    var c = a(b.target).closest("tbody").find("span").index(a(b.target));
                    f.month(c), k === p ? (aa(e.clone().year(f.year()).month(f.month())), d.inline || ba()) : (L(-1), W()), K("M")
                }, selectYear: function (b) {
                    var c = parseInt(a(b.target).text(), 10) || 0;
                    f.year(c), k === p ? (aa(e.clone().year(f.year())), d.inline || ba()) : (L(-1), W()), K("YYYY")
                }, selectDecade: function (b) {
                    var c = parseInt(a(b.target).data("selection"), 10) || 0;
                    f.year(c), k === p ? (aa(e.clone().year(f.year())), d.inline || ba()) : (L(-1), W()), K("YYYY")
                }, selectDay: function (b) {
                    var c = f.clone();
                    a(b.target).is(".old") && c.subtract(1, "M"), a(b.target).is(".new") && c.add(1, "M"), aa(c.date(parseInt(a(b.target).text(), 10))), A() || d.keepOpen || d.inline || ba()
                }, incrementHours: function () {
                    var a = e.clone().add(1, "h");
                    R(a, "h") && aa(a)
                }, incrementMinutes: function () {
                    var a = e.clone().add(d.stepping, "m");
                    R(a, "m") && aa(a)
                }, incrementSeconds: function () {
                    var a = e.clone().add(1, "s");
                    R(a, "s") && aa(a)
                }, decrementHours: function () {
                    var a = e.clone().subtract(1, "h");
                    R(a, "h") && aa(a)
                }, decrementMinutes: function () {
                    var a = e.clone().subtract(d.stepping, "m");
                    R(a, "m") && aa(a)
                }, decrementSeconds: function () {
                    var a = e.clone().subtract(1, "s");
                    R(a, "s") && aa(a)
                }, togglePeriod: function () {
                    aa(e.clone().add(e.hours() >= 12 ? -12 : 12, "h"))
                }, togglePicker: function (b) {
                    var c, e = a(b.target), f = e.closest("ul"), g = f.find(".in"), h = f.find(".collapse:not(.in)");
                    if (g && g.length) {
                        if (c = g.data("collapse"), c && c.transitioning) return;
                        g.collapse ? (g.collapse("hide"), h.collapse("show")) : (g.removeClass("in"), h.addClass("in")), e.is("span") ? e.toggleClass(d.icons.time + " " + d.icons.date) : e.find("span").toggleClass(d.icons.time + " " + d.icons.date)
                    }
                }, showPicker: function () {
                    o.find(".timepicker > div:not(.timepicker-picker)").hide(), o.find(".timepicker .timepicker-picker").show()
                }, showHours: function () {
                    o.find(".timepicker .timepicker-picker").hide(), o.find(".timepicker .timepicker-hours").show()
                }, showMinutes: function () {
                    o.find(".timepicker .timepicker-picker").hide(), o.find(".timepicker .timepicker-minutes").show()
                }, showSeconds: function () {
                    o.find(".timepicker .timepicker-picker").hide(), o.find(".timepicker .timepicker-seconds").show()
                }, selectHour: function (b) {
                    var c = parseInt(a(b.target).text(), 10);
                    h || (e.hours() >= 12 ? 12 !== c && (c += 12) : 12 === c && (c = 0)), aa(e.clone().hours(c)), ea.showPicker.call(l)
                }, selectMinute: function (b) {
                    aa(e.clone().minutes(parseInt(a(b.target).text(), 10))), ea.showPicker.call(l)
                }, selectSecond: function (b) {
                    aa(e.clone().seconds(parseInt(a(b.target).text(), 10))), ea.showPicker.call(l)
                }, clear: ca, today: function () {
                    var a = y();
                    R(a, "d") && aa(a)
                }, close: ba
            }, fa = function (b) {
                return !a(b.currentTarget).is(".disabled") && (ea[a(b.currentTarget).data("action")].apply(l, arguments), !1)
            }, ga = function () {
                var b, c = {
                    year: function (a) {
                        return a.month(0).date(1).hours(0).seconds(0).minutes(0)
                    }, month: function (a) {
                        return a.date(1).hours(0).seconds(0).minutes(0)
                    }, day: function (a) {
                        return a.hours(0).seconds(0).minutes(0)
                    }, hour: function (a) {
                        return a.seconds(0).minutes(0)
                    }, minute: function (a) {
                        return a.seconds(0)
                    }
                };
                return g.prop("disabled") || !d.ignoreReadonly && g.prop("readonly") || o ? l : (void 0 !== g.val() && 0 !== g.val().trim().length ? aa(da(g.val().trim())) : m && d.useCurrent && (d.inline || g.is("input") && 0 === g.val().trim().length) && (b = y(), "string" == typeof d.useCurrent && (b = c[d.useCurrent](b)), aa(b)), o = G(), M(), S(), o.find(".timepicker-hours").hide(), o.find(".timepicker-minutes").hide(), o.find(".timepicker-seconds").hide(), _(), L(), a(window).on("resize", I), o.on("click", "[data-action]", fa), o.on("mousedown", !1), n && n.hasClass("btn") && n.toggleClass("active"), I(), o.show(), d.focusOnShow && !g.is(":focus") && g.focus(), J({type: "dp.show"}), l)
            }, ha = function () {
                return o ? ba() : ga()
            }, ia = function (a) {
                var b, c, e, f, g = null, h = [], i = {}, j = a.which, k = "p";
                w[j] = k;
                for (b in w) w.hasOwnProperty(b) && w[b] === k && (h.push(b), parseInt(b, 10) !== j && (i[b] = !0));
                for (b in d.keyBinds) if (d.keyBinds.hasOwnProperty(b) && "function" == typeof d.keyBinds[b] && (e = b.split(" "), e.length === h.length && v[j] === e[e.length - 1])) {
                    for (f = !0, c = e.length - 2; c >= 0; c--) if (!(v[e[c]] in i)) {
                        f = !1;
                        break
                    }
                    if (f) {
                        g = d.keyBinds[b];
                        break
                    }
                }
                g && (g.call(l, o), a.stopPropagation(), a.preventDefault())
            }, ja = function (a) {
                w[a.which] = "r", a.stopPropagation(), a.preventDefault()
            }, ka = function (b) {
                var c = a(b.target).val().trim(), d = c ? da(c) : null;
                return aa(d), b.stopImmediatePropagation(), !1
            }, la = function () {
                g.on({
                    change: ka,
                    blur: d.debug ? "" : ba,
                    keydown: ia,
                    keyup: ja,
                    focus: d.allowInputToggle ? ga : ""
                }), c.is("input") ? g.on({focus: ga}) : n && (n.on("click", ha), n.on("mousedown", !1))
            }, ma = function () {
                g.off({
                    change: ka,
                    blur: blur,
                    keydown: ia,
                    keyup: ja,
                    focus: d.allowInputToggle ? ba : ""
                }), c.is("input") ? g.off({focus: ga}) : n && (n.off("click", ha), n.off("mousedown", !1))
            }, na = function (b) {
                var c = {};
                return a.each(b, function () {
                    var a = da(this);
                    a.isValid() && (c[a.format("YYYY-MM-DD")] = !0)
                }), !!Object.keys(c).length && c
            }, oa = function (b) {
                var c = {};
                return a.each(b, function () {
                    c[this] = !0
                }), !!Object.keys(c).length && c
            }, pa = function () {
                var a = d.format || "L LT";
                i = a.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (a) {
                    var b = e.localeData().longDateFormat(a) || a;
                    return b.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (a) {
                        return e.localeData().longDateFormat(a) || a
                    })
                }), j = d.extraFormats ? d.extraFormats.slice() : [], j.indexOf(a) < 0 && j.indexOf(i) < 0 && j.push(i), h = i.toLowerCase().indexOf("a") < 1 && i.replace(/\[.*?\]/g, "").indexOf("h") < 1, z("y") && (p = 2), z("M") && (p = 1), z("d") && (p = 0), k = Math.max(p, k), m || aa(e)
            };
        if (l.destroy = function () {
                ba(), ma(), c.removeData("DateTimePicker"), c.removeData("date")
            }, l.toggle = ha, l.show = ga, l.hide = ba, l.disable = function () {
                return ba(), n && n.hasClass("btn") && n.addClass("disabled"), g.prop("disabled", !0), l
            }, l.enable = function () {
                return n && n.hasClass("btn") && n.removeClass("disabled"), g.prop("disabled", !1), l
            }, l.ignoreReadonly = function (a) {
                if (0 === arguments.length) return d.ignoreReadonly;
                if ("boolean" != typeof a) throw new TypeError("ignoreReadonly () expects a boolean parameter");
                return d.ignoreReadonly = a, l
            }, l.options = function (b) {
                if (0 === arguments.length) return a.extend(!0, {}, d);
                if (!(b instanceof Object)) throw new TypeError("options() options parameter should be an object");
                return a.extend(!0, d, b), a.each(d, function (a, b) {
                    if (void 0 === l[a]) throw new TypeError("option " + a + " is not recognized!");
                    l[a](b)
                }), l
            }, l.date = function (a) {
                if (0 === arguments.length) return m ? null : e.clone();
                if (!(null === a || "string" == typeof a || b.isMoment(a) || a instanceof Date)) throw new TypeError("date() parameter must be one of [null, string, moment or Date]");
                return aa(null === a ? null : da(a)), l
            }, l.format = function (a) {
                if (0 === arguments.length) return d.format;
                if ("string" != typeof a && ("boolean" != typeof a || a !== !1)) throw new TypeError("format() expects a string or boolean:false parameter " + a);
                return d.format = a, i && pa(), l
            }, l.timeZone = function (a) {
                if (0 === arguments.length) return d.timeZone;
                if ("string" != typeof a) throw new TypeError("newZone() expects a string parameter");
                return d.timeZone = a, l
            }, l.dayViewHeaderFormat = function (a) {
                if (0 === arguments.length) return d.dayViewHeaderFormat;
                if ("string" != typeof a) throw new TypeError("dayViewHeaderFormat() expects a string parameter");
                return d.dayViewHeaderFormat = a, l
            }, l.extraFormats = function (a) {
                if (0 === arguments.length) return d.extraFormats;
                if (a !== !1 && !(a instanceof Array)) throw new TypeError("extraFormats() expects an array or false parameter");
                return d.extraFormats = a, j && pa(), l
            }, l.disabledDates = function (b) {
                if (0 === arguments.length) return d.disabledDates ? a.extend({}, d.disabledDates) : d.disabledDates;
                if (!b) return d.disabledDates = !1, _(), l;
                if (!(b instanceof Array)) throw new TypeError("disabledDates() expects an array parameter");
                return d.disabledDates = na(b), d.enabledDates = !1, _(), l
            }, l.enabledDates = function (b) {
                if (0 === arguments.length) return d.enabledDates ? a.extend({}, d.enabledDates) : d.enabledDates;
                if (!b) return d.enabledDates = !1, _(), l;
                if (!(b instanceof Array)) throw new TypeError("enabledDates() expects an array parameter");
                return d.enabledDates = na(b), d.disabledDates = !1, _(), l
            }, l.daysOfWeekDisabled = function (a) {
                if (0 === arguments.length) return d.daysOfWeekDisabled.splice(0);
                if ("boolean" == typeof a && !a) return d.daysOfWeekDisabled = !1, _(), l;
                if (!(a instanceof Array)) throw new TypeError("daysOfWeekDisabled() expects an array parameter");
                if (d.daysOfWeekDisabled = a.reduce(function (a, b) {
                        return b = parseInt(b, 10), b > 6 || b < 0 || isNaN(b) ? a : (a.indexOf(b) === -1 && a.push(b), a)
                    }, []).sort(), d.useCurrent && !d.keepInvalid) {
                    for (var b = 0; !R(e, "d");) {
                        if (e.add(1, "d"), 31 === b) throw"Tried 31 times to find a valid date";
                        b++
                    }
                    aa(e)
                }
                return _(), l
            }, l.maxDate = function (a) {
                if (0 === arguments.length) return d.maxDate ? d.maxDate.clone() : d.maxDate;
                if ("boolean" == typeof a && a === !1) return d.maxDate = !1, _(), l;
                "string" == typeof a && ("now" !== a && "moment" !== a || (a = y()));
                var b = da(a);
                if (!b.isValid()) throw new TypeError("maxDate() Could not parse date parameter: " + a);
                if (d.minDate && b.isBefore(d.minDate)) throw new TypeError("maxDate() date parameter is before options.minDate: " + b.format(i));
                return d.maxDate = b, d.useCurrent && !d.keepInvalid && e.isAfter(a) && aa(d.maxDate), f.isAfter(b) && (f = b.clone().subtract(d.stepping, "m")), _(), l
            }, l.minDate = function (a) {
                if (0 === arguments.length) return d.minDate ? d.minDate.clone() : d.minDate;
                if ("boolean" == typeof a && a === !1) return d.minDate = !1, _(), l;
                "string" == typeof a && ("now" !== a && "moment" !== a || (a = y()));
                var b = da(a);
                if (!b.isValid()) throw new TypeError("minDate() Could not parse date parameter: " + a);
                if (d.maxDate && b.isAfter(d.maxDate)) throw new TypeError("minDate() date parameter is after options.maxDate: " + b.format(i));
                return d.minDate = b, d.useCurrent && !d.keepInvalid && e.isBefore(a) && aa(d.minDate), f.isBefore(b) && (f = b.clone().add(d.stepping, "m")), _(), l
            }, l.defaultDate = function (a) {
                if (0 === arguments.length) return d.defaultDate ? d.defaultDate.clone() : d.defaultDate;
                if (!a) return d.defaultDate = !1, l;
                "string" == typeof a && (a = "now" === a || "moment" === a ? y() : y(a));
                var b = da(a);
                if (!b.isValid()) throw new TypeError("defaultDate() Could not parse date parameter: " + a);
                if (!R(b)) throw new TypeError("defaultDate() date passed is invalid according to component setup validations");
                return d.defaultDate = b, (d.defaultDate && d.inline || "" === g.val().trim()) && aa(d.defaultDate), l
            }, l.locale = function (a) {
                if (0 === arguments.length) return d.locale;
                if (!b.localeData(a)) throw new TypeError("locale() locale " + a + " is not loaded from moment locales!");
                return d.locale = a, e.locale(d.locale), f.locale(d.locale), i && pa(), o && (ba(), ga()), l
            }, l.stepping = function (a) {
                return 0 === arguments.length ? d.stepping : (a = parseInt(a, 10), (isNaN(a) || a < 1) && (a = 1), d.stepping = a, l)
            }, l.useCurrent = function (a) {
                var b = ["year", "month", "day", "hour", "minute"];
                if (0 === arguments.length) return d.useCurrent;
                if ("boolean" != typeof a && "string" != typeof a) throw new TypeError("useCurrent() expects a boolean or string parameter");
                if ("string" == typeof a && b.indexOf(a.toLowerCase()) === -1) throw new TypeError("useCurrent() expects a string parameter of " + b.join(", "));
                return d.useCurrent = a, l
            }, l.collapse = function (a) {
                if (0 === arguments.length) return d.collapse;
                if ("boolean" != typeof a) throw new TypeError("collapse() expects a boolean parameter");
                return d.collapse === a ? l : (d.collapse = a, o && (ba(), ga()), l)
            }, l.icons = function (b) {
                if (0 === arguments.length) return a.extend({}, d.icons);
                if (!(b instanceof Object)) throw new TypeError("icons() expects parameter to be an Object");
                return a.extend(d.icons, b), o && (ba(), ga()), l
            }, l.tooltips = function (b) {
                if (0 === arguments.length) return a.extend({}, d.tooltips);
                if (!(b instanceof Object)) throw new TypeError("tooltips() expects parameter to be an Object");
                return a.extend(d.tooltips, b), o && (ba(), ga()), l
            }, l.useStrict = function (a) {
                if (0 === arguments.length) return d.useStrict;
                if ("boolean" != typeof a) throw new TypeError("useStrict() expects a boolean parameter");
                return d.useStrict = a, l
            }, l.sideBySide = function (a) {
                if (0 === arguments.length) return d.sideBySide;
                if ("boolean" != typeof a) throw new TypeError("sideBySide() expects a boolean parameter");
                return d.sideBySide = a, o && (ba(), ga()), l
            }, l.viewMode = function (a) {
                if (0 === arguments.length) return d.viewMode;
                if ("string" != typeof a) throw new TypeError("viewMode() expects a string parameter");
                if (r.indexOf(a) === -1) throw new TypeError("viewMode() parameter must be one of (" + r.join(", ") + ") value");
                return d.viewMode = a, k = Math.max(r.indexOf(a), p), L(), l
            }, l.toolbarPlacement = function (a) {
                if (0 === arguments.length) return d.toolbarPlacement;
                if ("string" != typeof a) throw new TypeError("toolbarPlacement() expects a string parameter");
                if (u.indexOf(a) === -1) throw new TypeError("toolbarPlacement() parameter must be one of (" + u.join(", ") + ") value");
                return d.toolbarPlacement = a, o && (ba(), ga()), l
            }, l.widgetPositioning = function (b) {
                if (0 === arguments.length) return a.extend({}, d.widgetPositioning);
                if ("[object Object]" !== {}.toString.call(b)) throw new TypeError("widgetPositioning() expects an object variable");
                if (b.horizontal) {
                    if ("string" != typeof b.horizontal) throw new TypeError("widgetPositioning() horizontal variable must be a string");
                    if (b.horizontal = b.horizontal.toLowerCase(), t.indexOf(b.horizontal) === -1) throw new TypeError("widgetPositioning() expects horizontal parameter to be one of (" + t.join(", ") + ")");
                    d.widgetPositioning.horizontal = b.horizontal
                }
                if (b.vertical) {
                    if ("string" != typeof b.vertical) throw new TypeError("widgetPositioning() vertical variable must be a string");
                    if (b.vertical = b.vertical.toLowerCase(), s.indexOf(b.vertical) === -1) throw new TypeError("widgetPositioning() expects vertical parameter to be one of (" + s.join(", ") + ")");
                    d.widgetPositioning.vertical = b.vertical
                }
                return _(), l
            }, l.calendarWeeks = function (a) {
                if (0 === arguments.length) return d.calendarWeeks;
                if ("boolean" != typeof a) throw new TypeError("calendarWeeks() expects parameter to be a boolean value");
                return d.calendarWeeks = a, _(), l
            }, l.showTodayButton = function (a) {
                if (0 === arguments.length) return d.showTodayButton;
                if ("boolean" != typeof a) throw new TypeError("showTodayButton() expects a boolean parameter");
                return d.showTodayButton = a, o && (ba(), ga()), l
            }, l.showClear = function (a) {
                if (0 === arguments.length) return d.showClear;
                if ("boolean" != typeof a) throw new TypeError("showClear() expects a boolean parameter");
                return d.showClear = a, o && (ba(), ga()), l
            }, l.widgetParent = function (b) {
                if (0 === arguments.length) return d.widgetParent;
                if ("string" == typeof b && (b = a(b)), null !== b && "string" != typeof b && !(b instanceof a)) throw new TypeError("widgetParent() expects a string or a jQuery object parameter");
                return d.widgetParent = b, o && (ba(), ga()), l
            }, l.keepOpen = function (a) {
                if (0 === arguments.length) return d.keepOpen;
                if ("boolean" != typeof a) throw new TypeError("keepOpen() expects a boolean parameter");
                return d.keepOpen = a, l
            }, l.focusOnShow = function (a) {
                if (0 === arguments.length) return d.focusOnShow;
                if ("boolean" != typeof a) throw new TypeError("focusOnShow() expects a boolean parameter");
                return d.focusOnShow = a, l
            }, l.inline = function (a) {
                if (0 === arguments.length) return d.inline;
                if ("boolean" != typeof a) throw new TypeError("inline() expects a boolean parameter");
                return d.inline = a, l
            }, l.clear = function () {
                return ca(), l
            }, l.keyBinds = function (a) {
                return 0 === arguments.length ? d.keyBinds : (d.keyBinds = a, l)
            }, l.getMoment = function (a) {
                return y(a)
            }, l.debug = function (a) {
                if ("boolean" != typeof a) throw new TypeError("debug() expects a boolean parameter");
                return d.debug = a, l
            }, l.allowInputToggle = function (a) {
                if (0 === arguments.length) return d.allowInputToggle;
                if ("boolean" != typeof a) throw new TypeError("allowInputToggle() expects a boolean parameter");
                return d.allowInputToggle = a, l
            }, l.showClose = function (a) {
                if (0 === arguments.length) return d.showClose;
                if ("boolean" != typeof a) throw new TypeError("showClose() expects a boolean parameter");
                return d.showClose = a, l
            }, l.keepInvalid = function (a) {
                if (0 === arguments.length) return d.keepInvalid;
                if ("boolean" != typeof a) throw new TypeError("keepInvalid() expects a boolean parameter");
                return d.keepInvalid = a, l
            }, l.datepickerInput = function (a) {
                if (0 === arguments.length) return d.datepickerInput;
                if ("string" != typeof a) throw new TypeError("datepickerInput() expects a string parameter");
                return d.datepickerInput = a, l
            }, l.parseInputDate = function (a) {
                if (0 === arguments.length) return d.parseInputDate;
                if ("function" != typeof a) throw new TypeError("parseInputDate() sholud be as function");
                return d.parseInputDate = a, l
            }, l.disabledTimeIntervals = function (b) {
                if (0 === arguments.length) return d.disabledTimeIntervals ? a.extend({}, d.disabledTimeIntervals) : d.disabledTimeIntervals;
                if (!b) return d.disabledTimeIntervals = !1, _(), l;
                if (!(b instanceof Array)) throw new TypeError("disabledTimeIntervals() expects an array parameter");
                return d.disabledTimeIntervals = b, _(), l
            }, l.disabledHours = function (b) {
                if (0 === arguments.length) return d.disabledHours ? a.extend({}, d.disabledHours) : d.disabledHours;
                if (!b) return d.disabledHours = !1, _(), l;
                if (!(b instanceof Array)) throw new TypeError("disabledHours() expects an array parameter");
                if (d.disabledHours = oa(b), d.enabledHours = !1, d.useCurrent && !d.keepInvalid) {
                    for (var c = 0; !R(e, "h");) {
                        if (e.add(1, "h"), 24 === c) throw"Tried 24 times to find a valid date";
                        c++
                    }
                    aa(e)
                }
                return _(), l
            }, l.enabledHours = function (b) {
                if (0 === arguments.length) return d.enabledHours ? a.extend({}, d.enabledHours) : d.enabledHours;
                if (!b) return d.enabledHours = !1, _(), l;
                if (!(b instanceof Array)) throw new TypeError("enabledHours() expects an array parameter");
                if (d.enabledHours = oa(b), d.disabledHours = !1, d.useCurrent && !d.keepInvalid) {
                    for (var c = 0; !R(e, "h");) {
                        if (e.add(1, "h"), 24 === c) throw"Tried 24 times to find a valid date";
                        c++
                    }
                    aa(e)
                }
                return _(), l
            }, l.viewDate = function (a) {
                if (0 === arguments.length) return f.clone();
                if (!a) return f = e.clone(), l;
                if (!("string" == typeof a || b.isMoment(a) || a instanceof Date)) throw new TypeError("viewDate() parameter must be one of [string, moment or Date]");
                return f = da(a), K(), l
            }, c.is("input")) g = c; else if (g = c.find(d.datepickerInput), 0 === g.length) g = c.find("input"); else if (!g.is("input")) throw new Error('CSS class "' + d.datepickerInput + '" cannot be applied to non input element');
        if (c.hasClass("input-group") && (n = 0 === c.find(".datepickerbutton").length ? c.find(".input-group-addon") : c.find(".datepickerbutton")), !d.inline && !g.is("input")) throw new Error("Could not initialize DateTimePicker without an input element");
        return e = y(), f = e.clone(), a.extend(!0, d, H()), l.options(d), pa(), la(), g.prop("disabled") && l.disable(), g.is("input") && 0 !== g.val().trim().length ? aa(da(g.val().trim())) : d.defaultDate && void 0 === g.attr("placeholder") && aa(d.defaultDate), d.inline && ga(), l
    };
    return a.fn.datetimepicker = function (b) {
        b = b || {};
        var d, e = Array.prototype.slice.call(arguments, 1), f = !0, g = ["destroy", "hide", "show", "toggle"];
        if ("object" == typeof b) return this.each(function () {
            var d, e = a(this);
            e.data("DateTimePicker") || (d = a.extend(!0, {}, a.fn.datetimepicker.defaults, b), e.data("DateTimePicker", c(e, d)))
        });
        if ("string" == typeof b) return this.each(function () {
            var c = a(this), g = c.data("DateTimePicker");
            if (!g) throw new Error('bootstrap-datetimepicker("' + b + '") method was called on an element that is not using DateTimePicker');
            d = g[b].apply(g, e), f = d === g
        }), f || a.inArray(b, g) > -1 ? this : d;
        throw new TypeError("Invalid arguments for DateTimePicker: " + b)
    }, a.fn.datetimepicker.defaults = {
        timeZone: "",
        format: !1,
        dayViewHeaderFormat: "MMMM YYYY",
        extraFormats: !1,
        stepping: 1,
        minDate: !1,
        maxDate: !1,
        useCurrent: !0,
        collapse: !0,
        locale: b.locale(),
        defaultDate: !1,
        disabledDates: !1,
        enabledDates: !1,
        icons: {
            time: "glyphicon glyphicon-time",
            date: "glyphicon glyphicon-calendar",
            up: "glyphicon glyphicon-chevron-up",
            down: "glyphicon glyphicon-chevron-down",
            previous: "glyphicon glyphicon-chevron-left",
            next: "glyphicon glyphicon-chevron-right",
            today: "glyphicon glyphicon-screenshot",
            clear: "glyphicon glyphicon-trash",
            close: "glyphicon glyphicon-remove"
        },
        tooltips: {
            today: "Go to today",
            clear: "Clear selection",
            close: "Close the picker",
            selectMonth: "Select Month",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            selectYear: "Select Year",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            selectDecade: "Select Decade",
            prevDecade: "Previous Decade",
            nextDecade: "Next Decade",
            prevCentury: "Previous Century",
            nextCentury: "Next Century",
            pickHour: "Pick Hour",
            incrementHour: "Increment Hour",
            decrementHour: "Decrement Hour",
            pickMinute: "Pick Minute",
            incrementMinute: "Increment Minute",
            decrementMinute: "Decrement Minute",
            pickSecond: "Pick Second",
            incrementSecond: "Increment Second",
            decrementSecond: "Decrement Second",
            togglePeriod: "Toggle Period",
            selectTime: "Select Time"
        },
        useStrict: !1,
        sideBySide: !1,
        daysOfWeekDisabled: !1,
        calendarWeeks: !1,
        viewMode: "days",
        toolbarPlacement: "default",
        showTodayButton: !1,
        showClear: !1,
        showClose: !1,
        widgetPositioning: {horizontal: "auto", vertical: "auto"},
        widgetParent: null,
        ignoreReadonly: !1,
        keepOpen: !1,
        focusOnShow: !0,
        inline: !1,
        keepInvalid: !1,
        datepickerInput: ".datepickerinput",
        keyBinds: {
            up: function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") ? this.date(b.clone().subtract(7, "d")) : this.date(b.clone().add(this.stepping(), "m"))
                }
            }, down: function (a) {
                if (!a) return void this.show();
                var b = this.date() || this.getMoment();
                a.find(".datepicker").is(":visible") ? this.date(b.clone().add(7, "d")) : this.date(b.clone().subtract(this.stepping(), "m"))
            }, "control up": function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") ? this.date(b.clone().subtract(1, "y")) : this.date(b.clone().add(1, "h"))
                }
            }, "control down": function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") ? this.date(b.clone().add(1, "y")) : this.date(b.clone().subtract(1, "h"))
                }
            }, left: function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") && this.date(b.clone().subtract(1, "d"))
                }
            }, right: function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") && this.date(b.clone().add(1, "d"))
                }
            }, pageUp: function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") && this.date(b.clone().subtract(1, "M"))
                }
            }, pageDown: function (a) {
                if (a) {
                    var b = this.date() || this.getMoment();
                    a.find(".datepicker").is(":visible") && this.date(b.clone().add(1, "M"))
                }
            }, enter: function () {
                this.hide()
            }, escape: function () {
                this.hide()
            }, "control space": function (a) {
                a && a.find(".timepicker").is(":visible") && a.find('.btn[data-action="togglePeriod"]').click()
            }, t: function () {
                this.date(this.getMoment())
            }, delete: function () {
                this.clear()
            }
        },
        debug: !1,
        allowInputToggle: !1,
        disabledTimeIntervals: !1,
        disabledHours: !1,
        enabledHours: !1,
        viewDate: !1
    }, a.fn.datetimepicker
});
/*!
 * FullCalendar v2.4.0
 * Docs & License: http://fullcalendar.io/
 * (c) 2015 Adam Shaw
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery', 'moment'], factory);
    }
    else if (typeof exports === 'object') { // Node/CommonJS
        module.exports = factory(require('jquery'), require('moment'));
    }
    else {
        factory(jQuery, moment);
    }
})(function ($, moment) {

    ;
    ;

    var fc = $.fullCalendar = {version: "2.4.0"};
    var fcViews = fc.views = {};


    $.fn.fullCalendar = function (options) {
        var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
        var res = this; // what this function will return (this jQuery object by default)

        this.each(function (i, _element) { // loop each DOM element involved
            var element = $(_element);
            var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
            var singleRes; // the returned value of this single method call

            // a method call
            if (typeof options === 'string') {
                if (calendar && $.isFunction(calendar[options])) {
                    singleRes = calendar[options].apply(calendar, args);
                    if (!i) {
                        res = singleRes; // record the first method call result
                    }
                    if (options === 'destroy') { // for the destroy method, must remove Calendar object data
                        element.removeData('fullCalendar');
                    }
                }
            }
            // a new calendar initialization
            else if (!calendar) { // don't initialize twice
                calendar = new Calendar(element, options);
                element.data('fullCalendar', calendar);
                calendar.render();
            }
        });

        return res;
    };


    var complexOptions = [ // names of options that are objects whose properties should be combined
        'header',
        'buttonText',
        'buttonIcons',
        'themeButtonIcons'
    ];


// Merges an array of option objects into a single object
    function mergeOptions(optionObjs) {
        return mergeProps(optionObjs, complexOptions);
    }


// Given options specified for the calendar's constructor, massages any legacy options into a non-legacy form.
// Converts View-Option-Hashes into the View-Specific-Options format.
    function massageOverrides(input) {
        var overrides = {views: input.views || {}}; // the output. ensure a `views` hash
        var subObj;

        // iterate through all option override properties (except `views`)
        $.each(input, function (name, val) {
            if (name != 'views') {

                // could the value be a legacy View-Option-Hash?
                if (
                    $.isPlainObject(val) &&
                    !/(time|duration|interval)$/i.test(name) && // exclude duration options. might be given as objects
                    $.inArray(name, complexOptions) == -1 // complex options aren't allowed to be View-Option-Hashes
                ) {
                    subObj = null;

                    // iterate through the properties of this possible View-Option-Hash value
                    $.each(val, function (subName, subVal) {

                        // is the property targeting a view?
                        if (/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)) {
                            if (!overrides.views[subName]) { // ensure the view-target entry exists
                                overrides.views[subName] = {};
                            }
                            overrides.views[subName][name] = subVal; // record the value in the `views` object
                        }
                        else { // a non-View-Option-Hash property
                            if (!subObj) {
                                subObj = {};
                            }
                            subObj[subName] = subVal; // accumulate these unrelated values for later
                        }
                    });

                    if (subObj) { // non-View-Option-Hash properties? transfer them as-is
                        overrides[name] = subObj;
                    }
                }
                else {
                    overrides[name] = val; // transfer normal options as-is
                }
            }
        });

        return overrides;
    }

    ;
    ;

// exports
    fc.intersectionToSeg = intersectionToSeg;
    fc.applyAll = applyAll;
    fc.debounce = debounce;
    fc.isInt = isInt;
    fc.htmlEscape = htmlEscape;
    fc.cssToStr = cssToStr;
    fc.proxy = proxy;
    fc.capitaliseFirstLetter = capitaliseFirstLetter;


    /* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
    function compensateScroll(rowEls, scrollbarWidths) {
        if (scrollbarWidths.left) {
            rowEls.css({
                'border-left-width': 1,
                'margin-left': scrollbarWidths.left - 1
            });
        }
        if (scrollbarWidths.right) {
            rowEls.css({
                'border-right-width': 1,
                'margin-right': scrollbarWidths.right - 1
            });
        }
    }


// Undoes compensateScroll and restores all borders/margins
    function uncompensateScroll(rowEls) {
        rowEls.css({
            'margin-left': '',
            'margin-right': '',
            'border-left-width': '',
            'border-right-width': ''
        });
    }


// Make the mouse cursor express that an event is not allowed in the current area
    function disableCursor() {
        $('body').addClass('fc-not-allowed');
    }


// Returns the mouse cursor to its original look
    function enableCursor() {
        $('body').removeClass('fc-not-allowed');
    }


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
    function distributeHeight(els, availableHeight, shouldRedistribute) {

        // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
        // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

        var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
        var flexEls = []; // elements that are allowed to expand. array of DOM nodes
        var flexOffsets = []; // amount of vertical space it takes up
        var flexHeights = []; // actual css height
        var usedHeight = 0;

        undistributeHeight(els); // give all elements their natural height

        // find elements that are below the recommended height (expandable).
        // important to query for heights in a single first pass (to avoid reflow oscillation).
        els.each(function (i, el) {
            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = $(el).outerHeight(true);

            if (naturalOffset < minOffset) {
                flexEls.push(el);
                flexOffsets.push(naturalOffset);
                flexHeights.push($(el).height());
            }
            else {
                // this element stretches past recommended height (non-expandable). mark the space as occupied.
                usedHeight += naturalOffset;
            }
        });

        // readjust the recommended height to only consider the height available to non-maxed-out rows.
        if (shouldRedistribute) {
            availableHeight -= usedHeight;
            minOffset1 = Math.floor(availableHeight / flexEls.length);
            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
        }

        // assign heights to all expandable elements
        $(flexEls).each(function (i, el) {
            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = flexOffsets[i];
            var naturalHeight = flexHeights[i];
            var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

            if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
                $(el).height(newHeight);
            }
        });
    }


// Undoes distrubuteHeight, restoring all els to their natural height
    function undistributeHeight(els) {
        els.height('');
    }


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
    function matchCellWidths(els) {
        var maxInnerWidth = 0;

        els.find('> *').each(function (i, innerEl) {
            var innerWidth = $(innerEl).outerWidth();
            if (innerWidth > maxInnerWidth) {
                maxInnerWidth = innerWidth;
            }
        });

        maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

        els.width(maxInnerWidth);

        return maxInnerWidth;
    }


// Turns a container element into a scroller if its contents is taller than the allotted height.
// Returns true if the element is now a scroller, false otherwise.
// NOTE: this method is best because it takes weird zooming dimensions into account
    function setPotentialScroller(containerEl, height) {
        containerEl.height(height).addClass('fc-scroller');

        // are scrollbars needed?
        if (containerEl[0].scrollHeight - 1 > containerEl[0].clientHeight) { // !!! -1 because IE is often off-by-one :(
            return true;
        }

        unsetScroller(containerEl); // undo
        return false;
    }


// Takes an element that might have been a scroller, and turns it back into a normal element.
    function unsetScroller(containerEl) {
        containerEl.height('').removeClass('fc-scroller');
    }


    /* General DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/

    fc.getClientRect = getClientRect;
    fc.getContentRect = getContentRect;
    fc.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
    function getScrollParent(el) {
        var position = el.css('position'),
            scrollParent = el.parents().filter(function () {
                var parent = $(this);
                return (/(auto|scroll)/).test(
                    parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
                );
            }).eq(0);

        return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
    }


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
    function getOuterRect(el) {
        var offset = el.offset();

        return {
            left: offset.left,
            right: offset.left + el.outerWidth(),
            top: offset.top,
            bottom: offset.top + el.outerHeight()
        };
    }


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
    function getClientRect(el) {
        var offset = el.offset();
        var scrollbarWidths = getScrollbarWidths(el);
        var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left;
        var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top;

        return {
            left: left,
            right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
            top: top,
            bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
        };
    }


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
    function getContentRect(el) {
        var offset = el.offset(); // just outside of border, margin not included
        var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left');
        var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top');

        return {
            left: left,
            right: left + el.width(),
            top: top,
            bottom: top + el.height()
        };
    }


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
    function getScrollbarWidths(el) {
        var leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars
        var widths = {
            left: 0,
            right: 0,
            top: 0,
            bottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar
        };

        if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
            widths.left = leftRightWidth;
        }
        else {
            widths.right = leftRightWidth;
        }

        return widths;
    }


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

    var _isLeftRtlScrollbars = null;

    function getIsLeftRtlScrollbars() { // responsible for caching the computation
        if (_isLeftRtlScrollbars === null) {
            _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
        }
        return _isLeftRtlScrollbars;
    }

    function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
        var el = $('<div><div/></div>')
            .css({
                position: 'absolute',
                top: -1000,
                left: 0,
                border: 0,
                padding: 0,
                overflow: 'scroll',
                direction: 'rtl'
            })
            .appendTo('body');
        var innerEl = el.children();
        var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
        el.remove();
        return res;
    }


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
    function getCssFloat(el, prop) {
        return parseFloat(el.css(prop)) || 0;
    }


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
    function isPrimaryMouseButton(ev) {
        return ev.which == 1 && !ev.ctrlKey;
    }


    /* Geometry
----------------------------------------------------------------------------------------------------------------------*/

    fc.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
    function intersectRects(rect1, rect2) {
        var res = {
            left: Math.max(rect1.left, rect2.left),
            right: Math.min(rect1.right, rect2.right),
            top: Math.max(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom)
        };

        if (res.left < res.right && res.top < res.bottom) {
            return res;
        }
        return false;
    }


// Returns a new point that will have been moved to reside within the given rectangle
    function constrainPoint(point, rect) {
        return {
            left: Math.min(Math.max(point.left, rect.left), rect.right),
            top: Math.min(Math.max(point.top, rect.top), rect.bottom)
        };
    }


// Returns a point that is the center of the given rectangle
    function getRectCenter(rect) {
        return {
            left: (rect.left + rect.right) / 2,
            top: (rect.top + rect.bottom) / 2
        };
    }


// Subtracts point2's coordinates from point1's coordinates, returning a delta
    function diffPoints(point1, point2) {
        return {
            left: point1.left - point2.left,
            top: point1.top - point2.top
        };
    }


    /* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/

    fc.parseFieldSpecs = parseFieldSpecs;
    fc.compareByFieldSpecs = compareByFieldSpecs;
    fc.compareByFieldSpec = compareByFieldSpec;
    fc.flexibleCompare = flexibleCompare;


    function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i, token;

        if (typeof input === 'string') {
            tokens = input.split(/\s*,\s*/);
        }
        else if (typeof input === 'function') {
            tokens = [input];
        }
        else if ($.isArray(input)) {
            tokens = input;
        }

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];

            if (typeof token === 'string') {
                specs.push(
                    token.charAt(0) == '-' ?
                        {field: token.substring(1), order: -1} :
                        {field: token, order: 1}
                );
            }
            else if (typeof token === 'function') {
                specs.push({func: token});
            }
        }

        return specs;
    }


    function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
        var i;
        var cmp;

        for (i = 0; i < fieldSpecs.length; i++) {
            cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
            if (cmp) {
                return cmp;
            }
        }

        return 0;
    }


    function compareByFieldSpec(obj1, obj2, fieldSpec) {
        if (fieldSpec.func) {
            return fieldSpec.func(obj1, obj2);
        }
        return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
            (fieldSpec.order || 1);
    }


    function flexibleCompare(a, b) {
        if (!a && !b) {
            return 0;
        }
        if (b == null) {
            return -1;
        }
        if (a == null) {
            return 1;
        }
        if ($.type(a) === 'string' || $.type(b) === 'string') {
            return String(a).localeCompare(String(b));
        }
        return a - b;
    }


    /* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Creates a basic segment with the intersection of the two ranges. Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
    function intersectionToSeg(subjectRange, constraintRange) {
        var subjectStart = subjectRange.start;
        var subjectEnd = subjectRange.end;
        var constraintStart = constraintRange.start;
        var constraintEnd = constraintRange.end;
        var segStart, segEnd;
        var isStart, isEnd;

        if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

            if (subjectStart >= constraintStart) {
                segStart = subjectStart.clone();
                isStart = true;
            }
            else {
                segStart = constraintStart.clone();
                isStart = false;
            }

            if (subjectEnd <= constraintEnd) {
                segEnd = subjectEnd.clone();
                isEnd = true;
            }
            else {
                segEnd = constraintEnd.clone();
                isEnd = false;
            }

            return {
                start: segStart,
                end: segEnd,
                isStart: isStart,
                isEnd: isEnd
            };
        }
    }


    /* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/

    fc.computeIntervalUnit = computeIntervalUnit;
    fc.divideRangeByDuration = divideRangeByDuration;
    fc.divideDurationByDuration = divideDurationByDuration;
    fc.multiplyDuration = multiplyDuration;
    fc.durationHasTime = durationHasTime;

    var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
    var intervalUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
    function diffDayTime(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
            ms: a.time() - b.time() // time-of-day from day start. disregards timezone
        });
    }


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
    function diffDay(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
        });
    }


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
    function diffByUnit(a, b, unit) {
        return moment.duration(
            Math.round(a.diff(b, unit, true)), // returnFloat=true
            unit
        );
    }


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
    function computeIntervalUnit(start, end) {
        var i, unit;
        var val;

        for (i = 0; i < intervalUnits.length; i++) {
            unit = intervalUnits[i];
            val = computeRangeAs(unit, start, end);

            if (val >= 1 && isInt(val)) {
                break;
            }
        }

        return unit; // will be "milliseconds" if nothing else matches
    }


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
    function computeRangeAs(unit, start, end) {

        if (end != null) { // given start, end
            return end.diff(start, unit, true);
        }
        else if (moment.isDuration(start)) { // given duration
            return start.as(unit);
        }
        else { // given { start, end } range object
            return start.end.diff(start.start, unit, true);
        }
    }


// Intelligently divides a range (specified by a start/end params) by a duration
    function divideRangeByDuration(start, end, dur) {
        var months;

        if (durationHasTime(dur)) {
            return (end - start) / dur;
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return end.diff(start, 'months', true) / months;
        }
        return end.diff(start, 'days', true) / dur.asDays();
    }


// Intelligently divides one duration by another
    function divideDurationByDuration(dur1, dur2) {
        var months1, months2;

        if (durationHasTime(dur1) || durationHasTime(dur2)) {
            return dur1 / dur2;
        }
        months1 = dur1.asMonths();
        months2 = dur2.asMonths();
        if (
            Math.abs(months1) >= 1 && isInt(months1) &&
            Math.abs(months2) >= 1 && isInt(months2)
        ) {
            return months1 / months2;
        }
        return dur1.asDays() / dur2.asDays();
    }


// Intelligently multiplies a duration by a number
    function multiplyDuration(dur, n) {
        var months;

        if (durationHasTime(dur)) {
            return moment.duration(dur * n);
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return moment.duration({months: months * n});
        }
        return moment.duration({days: dur.asDays() * n});
    }


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
    function durationHasTime(dur) {
        return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
    }


    function isNativeDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
    }


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
    function isTimeString(str) {
        return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
    }


    /* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/

    fc.log = function () {
        var console = window.console;

        if (console && console.log) {
            return console.log.apply(console, arguments);
        }
    };

    fc.warn = function () {
        var console = window.console;

        if (console && console.warn) {
            return console.warn.apply(console, arguments);
        }
        else {
            return fc.log.apply(fc, arguments);
        }
    };


    /* General Utilities
----------------------------------------------------------------------------------------------------------------------*/

    var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
    function mergeProps(propObjs, complexProps) {
        var dest = {};
        var i, name;
        var complexObjs;
        var j, val;
        var props;

        if (complexProps) {
            for (i = 0; i < complexProps.length; i++) {
                name = complexProps[i];
                complexObjs = [];

                // collect the trailing object values, stopping when a non-object is discovered
                for (j = propObjs.length - 1; j >= 0; j--) {
                    val = propObjs[j][name];

                    if (typeof val === 'object') {
                        complexObjs.unshift(val);
                    }
                    else if (val !== undefined) {
                        dest[name] = val; // if there were no objects, this value will be used
                        break;
                    }
                }

                // if the trailing values were objects, use the merged value
                if (complexObjs.length) {
                    dest[name] = mergeProps(complexObjs);
                }
            }
        }

        // copy values into the destination, going from last to first
        for (i = propObjs.length - 1; i >= 0; i--) {
            props = propObjs[i];

            for (name in props) {
                if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
                    dest[name] = props[name];
                }
            }
        }

        return dest;
    }


// Create an object that has the given prototype. Just like Object.create
    function createObject(proto) {
        var f = function () {
        };
        f.prototype = proto;
        return new f();
    }


    function copyOwnProps(src, dest) {
        for (var name in src) {
            if (hasOwnProp(src, name)) {
                dest[name] = src[name];
            }
        }
    }


// Copies over certain methods with the same names as Object.prototype methods. Overcomes an IE<=8 bug:
// https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
    function copyNativeMethods(src, dest) {
        var names = ['constructor', 'toString', 'valueOf'];
        var i, name;

        for (i = 0; i < names.length; i++) {
            name = names[i];

            if (src[name] !== Object.prototype[name]) {
                dest[name] = src[name];
            }
        }
    }


    function hasOwnProp(obj, name) {
        return hasOwnPropMethod.call(obj, name);
    }


// Is the given value a non-object non-function value?
    function isAtomic(val) {
        return /undefined|null|boolean|number|string/.test($.type(val));
    }


    function applyAll(functions, thisObj, args) {
        if ($.isFunction(functions)) {
            functions = [functions];
        }
        if (functions) {
            var i;
            var ret;
            for (i = 0; i < functions.length; i++) {
                ret = functions[i].apply(thisObj, args) || ret;
            }
            return ret;
        }
    }


    function firstDefined() {
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) {
                return arguments[i];
            }
        }
    }


    function htmlEscape(s) {
        return (s + '').replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#039;')
            .replace(/"/g, '&quot;')
            .replace(/\n/g, '<br />');
    }


    function stripHtmlEntities(text) {
        return text.replace(/&.*?;/g, '');
    }


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
    function cssToStr(cssProps) {
        var statements = [];

        $.each(cssProps, function (name, val) {
            if (val != null) {
                statements.push(name + ':' + val);
            }
        });

        return statements.join(';');
    }


    function capitaliseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }


    function compareNumbers(a, b) { // for .sort()
        return a - b;
    }


    function isInt(n) {
        return n % 1 === 0;
    }


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
    function proxy(obj, methodName) {
        var method = obj[methodName];

        return function () {
            return method.apply(obj, arguments);
        };
    }


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
    function debounce(func, wait) {
        var timeoutId;
        var args;
        var context;
        var timestamp; // of most recent call
        var later = function () {
            var last = +new Date() - timestamp;
            if (last < wait && last > 0) {
                timeoutId = setTimeout(later, wait - last);
            }
            else {
                timeoutId = null;
                func.apply(context, args);
                if (!timeoutId) {
                    context = args = null;
                }
            }
        };

        return function () {
            context = this;
            args = arguments;
            timestamp = +new Date();
            if (!timeoutId) {
                timeoutId = setTimeout(later, wait);
            }
        };
    }

    ;
    ;

    var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
    var ambigTimeOrZoneRegex =
        /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
    var newMomentProto = moment.fn; // where we will attach our new methods
    var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
    var allowValueOptimization;
    var setUTCValues; // function defined below
    var setLocalValues; // function defined below


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
    fc.moment = function () {
        return makeMoment(arguments);
    };

// Sames as fc.moment, but forces the resulting moment to be in the UTC timezone.
    fc.moment.utc = function () {
        var mom = makeMoment(arguments, true);

        // Force it into UTC because makeMoment doesn't guarantee it
        // (if given a pre-existing moment for example)
        if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
            mom.utc();
        }

        return mom;
    };

// Same as fc.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
    fc.moment.parseZone = function () {
        return makeMoment(arguments, true, true);
    };

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
    function makeMoment(args, parseAsUTC, parseZone) {
        var input = args[0];
        var isSingleString = args.length == 1 && typeof input === 'string';
        var isAmbigTime;
        var isAmbigZone;
        var ambigMatch;
        var mom;

        if (moment.isMoment(input)) {
            mom = moment.apply(null, args); // clone it
            transferAmbigs(input, mom); // the ambig flags weren't transfered with the clone
        }
        else if (isNativeDate(input) || input === undefined) {
            mom = moment.apply(null, args); // will be local
        }
        else { // "parsing" is required
            isAmbigTime = false;
            isAmbigZone = false;

            if (isSingleString) {
                if (ambigDateOfMonthRegex.test(input)) {
                    // accept strings like '2014-05', but convert to the first of the month
                    input += '-01';
                    args = [input]; // for when we pass it on to moment's constructor
                    isAmbigTime = true;
                    isAmbigZone = true;
                }
                else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                    isAmbigTime = !ambigMatch[5]; // no time part?
                    isAmbigZone = true;
                }
            }
            else if ($.isArray(input)) {
                // arrays have no timezone information, so assume ambiguous zone
                isAmbigZone = true;
            }
            // otherwise, probably a string with a format

            if (parseAsUTC || isAmbigTime) {
                mom = moment.utc.apply(moment, args);
            }
            else {
                mom = moment.apply(null, args);
            }

            if (isAmbigTime) {
                mom._ambigTime = true;
                mom._ambigZone = true; // ambiguous time always means ambiguous zone
            }
            else if (parseZone) { // let's record the inputted zone somehow
                if (isAmbigZone) {
                    mom._ambigZone = true;
                }
                else if (isSingleString) {
                    if (mom.utcOffset) {
                        mom.utcOffset(input); // if not a valid zone, will assign UTC
                    }
                    else {
                        mom.zone(input); // for moment-pre-2.9
                    }
                }
            }
        }

        mom._fullCalendar = true; // flag for extended functionality

        return mom;
    }


// A clone method that works with the flags related to our enhanced functionality.
// In the future, use moment.momentProperties
    newMomentProto.clone = function () {
        var mom = oldMomentProto.clone.apply(this, arguments);

        // these flags weren't transfered with the clone
        transferAmbigs(this, mom);
        if (this._fullCalendar) {
            mom._fullCalendar = true;
        }

        return mom;
    };


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
    newMomentProto.week = newMomentProto.weeks = function (input) {
        var weekCalc = (this._locale || this._lang) // works pre-moment-2.8
            ._fullCalendar_weekCalc;

        if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
            return weekCalc(this);
        }
        else if (weekCalc === 'ISO') {
            return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
        }

        return oldMomentProto.week.apply(this, arguments); // local getter/setter
    };


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
    newMomentProto.time = function (time) {

        // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
        // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
        if (!this._fullCalendar) {
            return oldMomentProto.time.apply(this, arguments);
        }

        if (time == null) { // getter
            return moment.duration({
                hours: this.hours(),
                minutes: this.minutes(),
                seconds: this.seconds(),
                milliseconds: this.milliseconds()
            });
        }
        else { // setter

            this._ambigTime = false; // mark that the moment now has a time

            if (!moment.isDuration(time) && !moment.isMoment(time)) {
                time = moment.duration(time);
            }

            // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
            // Only for Duration times, not Moment times.
            var dayHours = 0;
            if (moment.isDuration(time)) {
                dayHours = Math.floor(time.asDays()) * 24;
            }

            // We need to set the individual fields.
            // Can't use startOf('day') then add duration. In case of DST at start of day.
            return this.hours(dayHours + time.hours())
                .minutes(time.minutes())
                .seconds(time.seconds())
                .milliseconds(time.milliseconds());
        }
    };

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
    newMomentProto.stripTime = function () {
        var a;

        if (!this._ambigTime) {

            // get the values before any conversion happens
            a = this.toArray(); // array of y/m/d/h/m/s/ms

            // TODO: use keepLocalTime in the future
            this.utc(); // set the internal UTC flag (will clear the ambig flags)
            setUTCValues(this, a.slice(0, 3)); // set the year/month/date. time will be zero

            // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
            // which clears all ambig flags. Same with setUTCValues with moment-timezone.
            this._ambigTime = true;
            this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
        }

        return this; // for chaining
    };

// Returns if the moment has a non-ambiguous time (boolean)
    newMomentProto.hasTime = function () {
        return !this._ambigTime;
    };


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
// TODO: look into Moment's keepLocalTime functionality
    newMomentProto.stripZone = function () {
        var a, wasAmbigTime;

        if (!this._ambigZone) {

            // get the values before any conversion happens
            a = this.toArray(); // array of y/m/d/h/m/s/ms
            wasAmbigTime = this._ambigTime;

            this.utc(); // set the internal UTC flag (might clear the ambig flags, depending on Moment internals)
            setUTCValues(this, a); // will set the year/month/date/hours/minutes/seconds/ms

            // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
            this._ambigTime = wasAmbigTime || false;

            // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
            // which clears the ambig flags. Same with setUTCValues with moment-timezone.
            this._ambigZone = true;
        }

        return this; // for chaining
    };

// Returns of the moment has a non-ambiguous timezone offset (boolean)
    newMomentProto.hasZone = function () {
        return !this._ambigZone;
    };


// this method implicitly marks a zone
    newMomentProto.local = function () {
        var a = this.toArray(); // year,month,date,hours,minutes,seconds,ms as an array
        var wasAmbigZone = this._ambigZone;

        oldMomentProto.local.apply(this, arguments);

        // ensure non-ambiguous
        // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
        this._ambigTime = false;
        this._ambigZone = false;

        if (wasAmbigZone) {
            // If the moment was ambiguously zoned, the date fields were stored as UTC.
            // We want to preserve these, but in local time.
            // TODO: look into Moment's keepLocalTime functionality
            setLocalValues(this, a);
        }

        return this; // for chaining
    };


// implicitly marks a zone
    newMomentProto.utc = function () {
        oldMomentProto.utc.apply(this, arguments);

        // ensure non-ambiguous
        // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
        this._ambigTime = false;
        this._ambigZone = false;

        return this;
    };


// methods for arbitrarily manipulating timezone offset.
// should clear time/zone ambiguity when called.
    $.each([
        'zone', // only in moment-pre-2.9. deprecated afterwards
        'utcOffset'
    ], function (i, name) {
        if (oldMomentProto[name]) { // original method exists?

            // this method implicitly marks a zone (will probably get called upon .utc() and .local())
            newMomentProto[name] = function (tzo) {

                if (tzo != null) { // setter
                    // these assignments needs to happen before the original zone method is called.
                    // I forget why, something to do with a browser crash.
                    this._ambigTime = false;
                    this._ambigZone = false;
                }

                return oldMomentProto[name].apply(this, arguments);
            };
        }
    });


// Formatting
// -------------------------------------------------------------------------------------------------

    newMomentProto.format = function () {
        if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
            return formatDate(this, arguments[0]); // our extended formatting
        }
        if (this._ambigTime) {
            return oldMomentFormat(this, 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
            return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
        }
        return oldMomentProto.format.apply(this, arguments);
    };

    newMomentProto.toISOString = function () {
        if (this._ambigTime) {
            return oldMomentFormat(this, 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
            return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
        }
        return oldMomentProto.toISOString.apply(this, arguments);
    };


// Querying
// -------------------------------------------------------------------------------------------------

// Is the moment within the specified range? `end` is exclusive.
// FYI, this method is not a standard Moment method, so always do our enhanced logic.
    newMomentProto.isWithin = function (start, end) {
        var a = commonlyAmbiguate([this, start, end]);
        return a[0] >= a[1] && a[0] < a[2];
    };

// When isSame is called with units, timezone ambiguity is normalized before the comparison happens.
// If no units specified, the two moments must be identically the same, with matching ambig flags.
    newMomentProto.isSame = function (input, units) {
        var a;

        // only do custom logic if this is an enhanced moment
        if (!this._fullCalendar) {
            return oldMomentProto.isSame.apply(this, arguments);
        }

        if (units) {
            a = commonlyAmbiguate([this, input], true); // normalize timezones but don't erase times
            return oldMomentProto.isSame.call(a[0], a[1], units);
        }
        else {
            input = fc.moment.parseZone(input); // normalize input
            return oldMomentProto.isSame.call(this, input) &&
                Boolean(this._ambigTime) === Boolean(input._ambigTime) &&
                Boolean(this._ambigZone) === Boolean(input._ambigZone);
        }
    };

// Make these query methods work with ambiguous moments
    $.each([
        'isBefore',
        'isAfter'
    ], function (i, methodName) {
        newMomentProto[methodName] = function (input, units) {
            var a;

            // only do custom logic if this is an enhanced moment
            if (!this._fullCalendar) {
                return oldMomentProto[methodName].apply(this, arguments);
            }

            a = commonlyAmbiguate([this, input]);
            return oldMomentProto[methodName].call(a[0], a[1], units);
        };
    });


// Misc Internals
// -------------------------------------------------------------------------------------------------

// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
// set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.
// returns the original moments if no modifications are necessary.
    function commonlyAmbiguate(inputs, preserveTime) {
        var anyAmbigTime = false;
        var anyAmbigZone = false;
        var len = inputs.length;
        var moms = [];
        var i, mom;

        // parse inputs into real moments and query their ambig flags
        for (i = 0; i < len; i++) {
            mom = inputs[i];
            if (!moment.isMoment(mom)) {
                mom = fc.moment.parseZone(mom);
            }
            anyAmbigTime = anyAmbigTime || mom._ambigTime;
            anyAmbigZone = anyAmbigZone || mom._ambigZone;
            moms.push(mom);
        }

        // strip each moment down to lowest common ambiguity
        // use clones to avoid modifying the original moments
        for (i = 0; i < len; i++) {
            mom = moms[i];
            if (!preserveTime && anyAmbigTime && !mom._ambigTime) {
                moms[i] = mom.clone().stripTime();
            }
            else if (anyAmbigZone && !mom._ambigZone) {
                moms[i] = mom.clone().stripZone();
            }
        }

        return moms;
    }

// Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment
// TODO: look into moment.momentProperties for this.
    function transferAmbigs(src, dest) {
        if (src._ambigTime) {
            dest._ambigTime = true;
        }
        else if (dest._ambigTime) {
            dest._ambigTime = false;
        }

        if (src._ambigZone) {
            dest._ambigZone = true;
        }
        else if (dest._ambigZone) {
            dest._ambigZone = false;
        }
    }


// Sets the year/month/date/etc values of the moment from the given array.
// Inefficient because it calls each individual setter.
    function setMomentValues(mom, a) {
        mom.year(a[0] || 0)
            .month(a[1] || 0)
            .date(a[2] || 0)
            .hours(a[3] || 0)
            .minutes(a[4] || 0)
            .seconds(a[5] || 0)
            .milliseconds(a[6] || 0);
    }

// Can we set the moment's internal date directly?
    allowValueOptimization = '_d' in moment() && 'updateOffset' in moment;

// Utility function. Accepts a moment and an array of the UTC year/month/date/etc values to set.
// Assumes the given moment is already in UTC mode.
    setUTCValues = allowValueOptimization ? function (mom, a) {
        // simlate what moment's accessors do
        mom._d.setTime(Date.UTC.apply(Date, a));
        moment.updateOffset(mom, false); // keepTime=false
    } : setMomentValues;

// Utility function. Accepts a moment and an array of the local year/month/date/etc values to set.
// Assumes the given moment is already in local mode.
    setLocalValues = allowValueOptimization ? function (mom, a) {
        // simlate what moment's accessors do
        mom._d.setTime(+new Date( // FYI, there is now way to apply an array of args to a constructor
            a[0] || 0,
            a[1] || 0,
            a[2] || 0,
            a[3] || 0,
            a[4] || 0,
            a[5] || 0,
            a[6] || 0
        ));
        moment.updateOffset(mom, false); // keepTime=false
    } : setMomentValues;

    ;
    ;

// Single Date Formatting
// -------------------------------------------------------------------------------------------------


// call this if you want Moment's original format method to be used
    function oldMomentFormat(mom, formatStr) {
        return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
    }


// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
    function formatDate(date, formatStr) {
        return formatDateWithChunks(date, getFormatStringChunks(formatStr));
    }


    function formatDateWithChunks(date, chunks) {
        var s = '';
        var i;

        for (i = 0; i < chunks.length; i++) {
            s += formatDateWithChunk(date, chunks[i]);
        }

        return s;
    }


// addition formatting tokens we want recognized
    var tokenOverrides = {
        t: function (date) { // "a" or "p"
            return oldMomentFormat(date, 'a').charAt(0);
        },
        T: function (date) { // "A" or "P"
            return oldMomentFormat(date, 'A').charAt(0);
        }
    };


    function formatDateWithChunk(date, chunk) {
        var token;
        var maybeStr;

        if (typeof chunk === 'string') { // a literal string
            return chunk;
        }
        else if ((token = chunk.token)) { // a token, like "YYYY"
            if (tokenOverrides[token]) {
                return tokenOverrides[token](date); // use our custom token
            }
            return oldMomentFormat(date, token);
        }
        else if (chunk.maybe) { // a grouping of other chunks that must be non-zero
            maybeStr = formatDateWithChunks(date, chunk.maybe);
            if (maybeStr.match(/[1-9]/)) {
                return maybeStr;
            }
        }

        return '';
    }


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

// Using a formatting string meant for a single date, generate a range string, like
// "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
    function formatRange(date1, date2, formatStr, separator, isRTL) {
        var localeData;

        date1 = fc.moment.parseZone(date1);
        date2 = fc.moment.parseZone(date2);

        localeData = (date1.localeData || date1.lang).call(date1); // works with moment-pre-2.8

        // Expand localized format strings, like "LL" -> "MMMM D YYYY"
        formatStr = localeData.longDateFormat(formatStr) || formatStr;
        // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
        // or non-zero areas in Moment's localized format strings.

        separator = separator || ' - ';

        return formatRangeWithChunks(
            date1,
            date2,
            getFormatStringChunks(formatStr),
            separator,
            isRTL
        );
    }

    fc.formatRange = formatRange; // expose


    function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {
        var chunkStr; // the rendering of the chunk
        var leftI;
        var leftStr = '';
        var rightI;
        var rightStr = '';
        var middleI;
        var middleStr1 = '';
        var middleStr2 = '';
        var middleStr = '';

        // Start at the leftmost side of the formatting string and continue until you hit a token
        // that is not the same between dates.
        for (leftI = 0; leftI < chunks.length; leftI++) {
            chunkStr = formatSimilarChunk(date1, date2, chunks[leftI]);
            if (chunkStr === false) {
                break;
            }
            leftStr += chunkStr;
        }

        // Similarly, start at the rightmost side of the formatting string and move left
        for (rightI = chunks.length - 1; rightI > leftI; rightI--) {
            chunkStr = formatSimilarChunk(date1, date2, chunks[rightI]);
            if (chunkStr === false) {
                break;
            }
            rightStr = chunkStr + rightStr;
        }

        // The area in the middle is different for both of the dates.
        // Collect them distinctly so we can jam them together later.
        for (middleI = leftI; middleI <= rightI; middleI++) {
            middleStr1 += formatDateWithChunk(date1, chunks[middleI]);
            middleStr2 += formatDateWithChunk(date2, chunks[middleI]);
        }

        if (middleStr1 || middleStr2) {
            if (isRTL) {
                middleStr = middleStr2 + separator + middleStr1;
            }
            else {
                middleStr = middleStr1 + separator + middleStr2;
            }
        }

        return leftStr + middleStr + rightStr;
    }


    var similarUnitMap = {
        Y: 'year',
        M: 'month',
        D: 'day', // day of month
        d: 'day', // day of week
        // prevents a separator between anything time-related...
        A: 'second', // AM/PM
        a: 'second', // am/pm
        T: 'second', // A/P
        t: 'second', // a/p
        H: 'second', // hour (24)
        h: 'second', // hour (12)
        m: 'second', // minute
        s: 'second' // second
    };
// TODO: week maybe?


// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
    function formatSimilarChunk(date1, date2, chunk) {
        var token;
        var unit;

        if (typeof chunk === 'string') { // a literal string
            return chunk;
        }
        else if ((token = chunk.token)) {
            unit = similarUnitMap[token.charAt(0)];
            // are the dates the same for this unit of measurement?
            if (unit && date1.isSame(date2, unit)) {
                return oldMomentFormat(date1, token); // would be the same if we used `date2`
                // BTW, don't support custom tokens
            }
        }

        return false; // the chunk is NOT the same for the two dates
        // BTW, don't support splitting on non-zero areas
    }


// Chunking Utils
// -------------------------------------------------------------------------------------------------


    var formatStringChunkCache = {};


    function getFormatStringChunks(formatStr) {
        if (formatStr in formatStringChunkCache) {
            return formatStringChunkCache[formatStr];
        }
        return (formatStringChunkCache[formatStr] = chunkFormatString(formatStr));
    }


// Break the formatting string into an array of chunks
    function chunkFormatString(formatStr) {
        var chunks = [];
        var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g; // TODO: more descrimination
        var match;

        while ((match = chunker.exec(formatStr))) {
            if (match[1]) { // a literal string inside [ ... ]
                chunks.push(match[1]);
            }
            else if (match[2]) { // non-zero formatting inside ( ... )
                chunks.push({maybe: chunkFormatString(match[2])});
            }
            else if (match[3]) { // a formatting token
                chunks.push({token: match[3]});
            }
            else if (match[5]) { // an unenclosed literal string
                chunks.push(match[5]);
            }
        }

        return chunks;
    }

    ;
    ;

    fc.Class = Class; // export

// class that all other classes will inherit from
    function Class() {
    }

// called upon a class to create a subclass
    Class.extend = function (members) {
        var superClass = this;
        var subClass;

        members = members || {};

        // ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
        if (hasOwnProp(members, 'constructor')) {
            subClass = members.constructor;
        }
        if (typeof subClass !== 'function') {
            subClass = members.constructor = function () {
                superClass.apply(this, arguments);
            };
        }

        // build the base prototype for the subclass, which is an new object chained to the superclass's prototype
        subClass.prototype = createObject(superClass.prototype);

        // copy each member variable/method onto the the subclass's prototype
        copyOwnProps(members, subClass.prototype);
        copyNativeMethods(members, subClass.prototype); // hack for IE8

        // copy over all class variables/methods to the subclass, such as `extend` and `mixin`
        copyOwnProps(superClass, subClass);

        return subClass;
    };

// adds new member variables/methods to the class's prototype.
// can be called with another class, or a plain object hash containing new members.
    Class.mixin = function (members) {
        copyOwnProps(members.prototype || members, this.prototype); // TODO: copyNativeMethods?
    };
    ;
    ;

    var Emitter = fc.Emitter = Class.extend({

        callbackHash: null,


        on: function (name, callback) {
            this.getCallbacks(name).add(callback);
            return this; // for chaining
        },


        off: function (name, callback) {
            this.getCallbacks(name).remove(callback);
            return this; // for chaining
        },


        trigger: function (name) { // args...
            var args = Array.prototype.slice.call(arguments, 1);

            this.triggerWith(name, this, args);

            return this; // for chaining
        },


        triggerWith: function (name, context, args) {
            var callbacks = this.getCallbacks(name);

            callbacks.fireWith(context, args);

            return this; // for chaining
        },


        getCallbacks: function (name) {
            var callbacks;

            if (!this.callbackHash) {
                this.callbackHash = {};
            }

            callbacks = this.callbackHash[name];
            if (!callbacks) {
                callbacks = this.callbackHash[name] = $.Callbacks();
            }

            return callbacks;
        }

    });
    ;
    ;

    /* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/

    var Popover = Class.extend({

        isHidden: true,
        options: null,
        el: null, // the container element for the popover. generated by this object
        documentMousedownProxy: null, // document mousedown handler bound to `this`
        margin: 10, // the space required between the popover and the edges of the scroll container


        constructor: function (options) {
            this.options = options || {};
        },


        // Shows the popover on the specified position. Renders it if not already
        show: function () {
            if (this.isHidden) {
                if (!this.el) {
                    this.render();
                }
                this.el.show();
                this.position();
                this.isHidden = false;
                this.trigger('show');
            }
        },


        // Hides the popover, through CSS, but does not remove it from the DOM
        hide: function () {
            if (!this.isHidden) {
                this.el.hide();
                this.isHidden = true;
                this.trigger('hide');
            }
        },


        // Creates `this.el` and renders content inside of it
        render: function () {
            var _this = this;
            var options = this.options;

            this.el = $('<div class="fc-popover"/>')
                .addClass(options.className || '')
                .css({
                    // position initially to the top left to avoid creating scrollbars
                    top: 0,
                    left: 0
                })
                .append(options.content)
                .appendTo(options.parentEl);

            // when a click happens on anything inside with a 'fc-close' className, hide the popover
            this.el.on('click', '.fc-close', function () {
                _this.hide();
            });

            if (options.autoHide) {
                $(document).on('mousedown', this.documentMousedownProxy = proxy(this, 'documentMousedown'));
            }
        },


        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
        documentMousedown: function (ev) {
            // only hide the popover if the click happened outside the popover
            if (this.el && !$(ev.target).closest(this.el).length) {
                this.hide();
            }
        },


        // Hides and unregisters any handlers
        removeElement: function () {
            this.hide();

            if (this.el) {
                this.el.remove();
                this.el = null;
            }

            $(document).off('mousedown', this.documentMousedownProxy);
        },


        // Positions the popover optimally, using the top/left/right options
        position: function () {
            var options = this.options;
            var origin = this.el.offsetParent().offset();
            var width = this.el.outerWidth();
            var height = this.el.outerHeight();
            var windowEl = $(window);
            var viewportEl = getScrollParent(this.el);
            var viewportTop;
            var viewportLeft;
            var viewportOffset;
            var top; // the "position" (not "offset") values for the popover
            var left; //

            // compute top and left
            top = options.top || 0;
            if (options.left !== undefined) {
                left = options.left;
            }
            else if (options.right !== undefined) {
                left = options.right - width; // derive the left value from the right value
            }
            else {
                left = 0;
            }

            if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
                viewportEl = windowEl;
                viewportTop = 0; // the window is always at the top left
                viewportLeft = 0; // (and .offset() won't work if called here)
            }
            else {
                viewportOffset = viewportEl.offset();
                viewportTop = viewportOffset.top;
                viewportLeft = viewportOffset.left;
            }

            // if the window is scrolled, it causes the visible area to be further down
            viewportTop += windowEl.scrollTop();
            viewportLeft += windowEl.scrollLeft();

            // constrain to the view port. if constrained by two edges, give precedence to top/left
            if (options.viewportConstrain !== false) {
                top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
                top = Math.max(top, viewportTop + this.margin);
                left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
                left = Math.max(left, viewportLeft + this.margin);
            }

            this.el.css({
                top: top - origin.top,
                left: left - origin.left
            });
        },


        // Triggers a callback. Calls a function in the option hash of the same name.
        // Arguments beyond the first `name` are forwarded on.
        // TODO: better code reuse for this. Repeat code
        trigger: function (name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }

    });

    ;
    ;

    /* A "coordinate map" converts pixel coordinates into an associated cell, which has an associated date
------------------------------------------------------------------------------------------------------------------------
Common interface:

	CoordMap.prototype = {
		build: function() {},
		getCell: function(x, y) {}
	};

*/

    /* Coordinate map for a grid component
----------------------------------------------------------------------------------------------------------------------*/

    var GridCoordMap = Class.extend({

        grid: null, // reference to the Grid
        rowCoords: null, // array of {top,bottom} objects
        colCoords: null, // array of {left,right} objects

        containerEl: null, // container element that all coordinates are constrained to. optionally assigned
        bounds: null,


        constructor: function (grid) {
            this.grid = grid;
        },


        // Queries the grid for the coordinates of all the cells
        build: function () {
            this.grid.build();
            this.rowCoords = this.grid.computeRowCoords();
            this.colCoords = this.grid.computeColCoords();
            this.computeBounds();
        },


        // Clears the coordinates data to free up memory
        clear: function () {
            this.grid.clear();
            this.rowCoords = null;
            this.colCoords = null;
        },


        // Given a coordinate of the document, gets the associated cell. If no cell is underneath, returns null
        getCell: function (x, y) {
            var rowCoords = this.rowCoords;
            var rowCnt = rowCoords.length;
            var colCoords = this.colCoords;
            var colCnt = colCoords.length;
            var hitRow = null;
            var hitCol = null;
            var i, coords;
            var cell;

            if (this.inBounds(x, y)) {

                for (i = 0; i < rowCnt; i++) {
                    coords = rowCoords[i];
                    if (y >= coords.top && y < coords.bottom) {
                        hitRow = i;
                        break;
                    }
                }

                for (i = 0; i < colCnt; i++) {
                    coords = colCoords[i];
                    if (x >= coords.left && x < coords.right) {
                        hitCol = i;
                        break;
                    }
                }

                if (hitRow !== null && hitCol !== null) {

                    cell = this.grid.getCell(hitRow, hitCol); // expected to return a fresh object we can modify
                    cell.grid = this.grid; // for CellDragListener's isCellsEqual. dragging between grids

                    // make the coordinates available on the cell object
                    $.extend(cell, rowCoords[hitRow], colCoords[hitCol]);

                    return cell;
                }
            }

            return null;
        },


        // If there is a containerEl, compute the bounds into min/max values
        computeBounds: function () {
            this.bounds = this.containerEl ?
                getClientRect(this.containerEl) : // area within scrollbars
                null;
        },


        // Determines if the given coordinates are in bounds. If no `containerEl`, always true
        inBounds: function (x, y) {
            var bounds = this.bounds;

            if (bounds) {
                return x >= bounds.left && x < bounds.right && y >= bounds.top && y < bounds.bottom;
            }

            return true;
        }

    });


    /* Coordinate map that is a combination of multiple other coordinate maps
----------------------------------------------------------------------------------------------------------------------*/

    var ComboCoordMap = Class.extend({

        coordMaps: null, // an array of CoordMaps


        constructor: function (coordMaps) {
            this.coordMaps = coordMaps;
        },


        // Builds all coordMaps
        build: function () {
            var coordMaps = this.coordMaps;
            var i;

            for (i = 0; i < coordMaps.length; i++) {
                coordMaps[i].build();
            }
        },


        // Queries all coordMaps for the cell underneath the given coordinates, returning the first result
        getCell: function (x, y) {
            var coordMaps = this.coordMaps;
            var cell = null;
            var i;

            for (i = 0; i < coordMaps.length && !cell; i++) {
                cell = coordMaps[i].getCell(x, y);
            }

            return cell;
        },


        // Clears all coordMaps
        clear: function () {
            var coordMaps = this.coordMaps;
            var i;

            for (i = 0; i < coordMaps.length; i++) {
                coordMaps[i].clear();
            }
        }

    });

    ;
    ;

    /* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/

    var DragListener = fc.DragListener = Class.extend({

        options: null,

        isListening: false,
        isDragging: false,

        // coordinates of the initial mousedown
        originX: null,
        originY: null,

        // handler attached to the document, bound to the DragListener's `this`
        mousemoveProxy: null,
        mouseupProxy: null,

        // for IE8 bug-fighting behavior, for now
        subjectEl: null, // the element being draged. optional
        subjectHref: null,

        scrollEl: null,
        scrollBounds: null, // { top, bottom, left, right }
        scrollTopVel: null, // pixels per second
        scrollLeftVel: null, // pixels per second
        scrollIntervalId: null, // ID of setTimeout for scrolling animation loop
        scrollHandlerProxy: null, // this-scoped function for handling when scrollEl is scrolled

        scrollSensitivity: 30, // pixels from edge for scrolling to start
        scrollSpeed: 200, // pixels per second, at maximum speed
        scrollIntervalMs: 50, // millisecond wait between scroll increment


        constructor: function (options) {
            options = options || {};
            this.options = options;
            this.subjectEl = options.subjectEl;
        },


        // Call this when the user does a mousedown. Will probably lead to startListening
        mousedown: function (ev) {
            if (isPrimaryMouseButton(ev)) {

                ev.preventDefault(); // prevents native selection in most browsers

                this.startListening(ev);

                // start the drag immediately if there is no minimum distance for a drag start
                if (!this.options.distance) {
                    this.startDrag(ev);
                }
            }
        },


        // Call this to start tracking mouse movements
        startListening: function (ev) {
            var scrollParent;

            if (!this.isListening) {

                // grab scroll container and attach handler
                if (ev && this.options.scroll) {
                    scrollParent = getScrollParent($(ev.target));
                    if (!scrollParent.is(window) && !scrollParent.is(document)) {
                        this.scrollEl = scrollParent;

                        // scope to `this`, and use `debounce` to make sure rapid calls don't happen
                        this.scrollHandlerProxy = debounce(proxy(this, 'scrollHandler'), 100);
                        this.scrollEl.on('scroll', this.scrollHandlerProxy);
                    }
                }

                $(document)
                    .on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'))
                    .on('mouseup', this.mouseupProxy = proxy(this, 'mouseup'))
                    .on('selectstart', this.preventDefault); // prevents native selection in IE<=8

                if (ev) {
                    this.originX = ev.pageX;
                    this.originY = ev.pageY;
                }
                else {
                    // if no starting information was given, origin will be the topleft corner of the screen.
                    // if so, dx/dy in the future will be the absolute coordinates.
                    this.originX = 0;
                    this.originY = 0;
                }

                this.isListening = true;
                this.listenStart(ev);
            }
        },


        // Called when drag listening has started (but a real drag has not necessarily began)
        listenStart: function (ev) {
            this.trigger('listenStart', ev);
        },


        // Called when the user moves the mouse
        mousemove: function (ev) {
            var dx = ev.pageX - this.originX;
            var dy = ev.pageY - this.originY;
            var minDistance;
            var distanceSq; // current distance from the origin, squared

            if (!this.isDragging) { // if not already dragging...
                // then start the drag if the minimum distance criteria is met
                minDistance = this.options.distance || 1;
                distanceSq = dx * dx + dy * dy;
                if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                    this.startDrag(ev);
                }
            }

            if (this.isDragging) {
                this.drag(dx, dy, ev); // report a drag, even if this mousemove initiated the drag
            }
        },


        // Call this to initiate a legitimate drag.
        // This function is called internally from this class, but can also be called explicitly from outside
        startDrag: function (ev) {

            if (!this.isListening) { // startDrag must have manually initiated
                this.startListening();
            }

            if (!this.isDragging) {
                this.isDragging = true;
                this.dragStart(ev);
            }
        },


        // Called when the actual drag has started (went beyond minDistance)
        dragStart: function (ev) {
            var subjectEl = this.subjectEl;

            this.trigger('dragStart', ev);

            // remove a mousedown'd <a>'s href so it is not visited (IE8 bug)
            if ((this.subjectHref = subjectEl ? subjectEl.attr('href') : null)) {
                subjectEl.removeAttr('href');
            }
        },


        // Called while the mouse is being moved and when we know a legitimate drag is taking place
        drag: function (dx, dy, ev) {
            this.trigger('drag', dx, dy, ev);
            this.updateScroll(ev); // will possibly cause scrolling
        },


        // Called when the user does a mouseup
        mouseup: function (ev) {
            this.stopListening(ev);
        },


        // Called when the drag is over. Will not cause listening to stop however.
        // A concluding 'cellOut' event will NOT be triggered.
        stopDrag: function (ev) {
            if (this.isDragging) {
                this.stopScrolling();
                this.dragStop(ev);
                this.isDragging = false;
            }
        },


        // Called when dragging has been stopped
        dragStop: function (ev) {
            var _this = this;

            this.trigger('dragStop', ev);

            // restore a mousedown'd <a>'s href (for IE8 bug)
            setTimeout(function () { // must be outside of the click's execution
                if (_this.subjectHref) {
                    _this.subjectEl.attr('href', _this.subjectHref);
                }
            }, 0);
        },


        // Call this to stop listening to the user's mouse events
        stopListening: function (ev) {
            this.stopDrag(ev); // if there's a current drag, kill it

            if (this.isListening) {

                // remove the scroll handler if there is a scrollEl
                if (this.scrollEl) {
                    this.scrollEl.off('scroll', this.scrollHandlerProxy);
                    this.scrollHandlerProxy = null;
                }

                $(document)
                    .off('mousemove', this.mousemoveProxy)
                    .off('mouseup', this.mouseupProxy)
                    .off('selectstart', this.preventDefault);

                this.mousemoveProxy = null;
                this.mouseupProxy = null;

                this.isListening = false;
                this.listenStop(ev);
            }
        },


        // Called when drag listening has stopped
        listenStop: function (ev) {
            this.trigger('listenStop', ev);
        },


        // Triggers a callback. Calls a function in the option hash of the same name.
        // Arguments beyond the first `name` are forwarded on.
        trigger: function (name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        },


        // Stops a given mouse event from doing it's native browser action. In our case, text selection.
        preventDefault: function (ev) {
            ev.preventDefault();
        },


        /* Scrolling
	------------------------------------------------------------------------------------------------------------------*/


        // Computes and stores the bounding rectangle of scrollEl
        computeScrollBounds: function () {
            var el = this.scrollEl;

            this.scrollBounds = el ? getOuterRect(el) : null;
            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
        },


        // Called when the dragging is in progress and scrolling should be updated
        updateScroll: function (ev) {
            var sensitivity = this.scrollSensitivity;
            var bounds = this.scrollBounds;
            var topCloseness, bottomCloseness;
            var leftCloseness, rightCloseness;
            var topVel = 0;
            var leftVel = 0;

            if (bounds) { // only scroll if scrollEl exists

                // compute closeness to edges. valid range is from 0.0 - 1.0
                topCloseness = (sensitivity - (ev.pageY - bounds.top)) / sensitivity;
                bottomCloseness = (sensitivity - (bounds.bottom - ev.pageY)) / sensitivity;
                leftCloseness = (sensitivity - (ev.pageX - bounds.left)) / sensitivity;
                rightCloseness = (sensitivity - (bounds.right - ev.pageX)) / sensitivity;

                // translate vertical closeness into velocity.
                // mouse must be completely in bounds for velocity to happen.
                if (topCloseness >= 0 && topCloseness <= 1) {
                    topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
                }
                else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                    topVel = bottomCloseness * this.scrollSpeed;
                }

                // translate horizontal closeness into velocity
                if (leftCloseness >= 0 && leftCloseness <= 1) {
                    leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
                }
                else if (rightCloseness >= 0 && rightCloseness <= 1) {
                    leftVel = rightCloseness * this.scrollSpeed;
                }
            }

            this.setScrollVel(topVel, leftVel);
        },


        // Sets the speed-of-scrolling for the scrollEl
        setScrollVel: function (topVel, leftVel) {

            this.scrollTopVel = topVel;
            this.scrollLeftVel = leftVel;

            this.constrainScrollVel(); // massages into realistic values

            // if there is non-zero velocity, and an animation loop hasn't already started, then START
            if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
                this.scrollIntervalId = setInterval(
                    proxy(this, 'scrollIntervalFunc'), // scope to `this`
                    this.scrollIntervalMs
                );
            }
        },


        // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
        constrainScrollVel: function () {
            var el = this.scrollEl;

            if (this.scrollTopVel < 0) { // scrolling up?
                if (el.scrollTop() <= 0) { // already scrolled all the way up?
                    this.scrollTopVel = 0;
                }
            }
            else if (this.scrollTopVel > 0) { // scrolling down?
                if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
                    this.scrollTopVel = 0;
                }
            }

            if (this.scrollLeftVel < 0) { // scrolling left?
                if (el.scrollLeft() <= 0) { // already scrolled all the left?
                    this.scrollLeftVel = 0;
                }
            }
            else if (this.scrollLeftVel > 0) { // scrolling right?
                if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
                    this.scrollLeftVel = 0;
                }
            }
        },


        // This function gets called during every iteration of the scrolling animation loop
        scrollIntervalFunc: function () {
            var el = this.scrollEl;
            var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

            // change the value of scrollEl's scroll
            if (this.scrollTopVel) {
                el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
            }
            if (this.scrollLeftVel) {
                el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
            }

            this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

            // if scrolled all the way, which causes the vels to be zero, stop the animation loop
            if (!this.scrollTopVel && !this.scrollLeftVel) {
                this.stopScrolling();
            }
        },


        // Kills any existing scrolling animation loop
        stopScrolling: function () {
            if (this.scrollIntervalId) {
                clearInterval(this.scrollIntervalId);
                this.scrollIntervalId = null;

                // when all done with scrolling, recompute positions since they probably changed
                this.scrollStop();
            }
        },


        // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
        scrollHandler: function () {
            // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
            if (!this.scrollIntervalId) {
                this.scrollStop();
            }
        },


        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
        scrollStop: function () {
        }

    });

    ;
    ;

    /* Tracks mouse movements over a CoordMap and raises events about which cell the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/

    var CellDragListener = DragListener.extend({

        coordMap: null, // converts coordinates to date cells
        origCell: null, // the cell the mouse was over when listening started
        cell: null, // the cell the mouse is over
        coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


        constructor: function (coordMap, options) {
            DragListener.prototype.constructor.call(this, options); // call the super-constructor

            this.coordMap = coordMap;
        },


        // Called when drag listening starts (but a real drag has not necessarily began).
        // ev might be undefined if dragging was started manually.
        listenStart: function (ev) {
            var subjectEl = this.subjectEl;
            var subjectRect;
            var origPoint;
            var point;

            DragListener.prototype.listenStart.apply(this, arguments); // call the super-method

            this.computeCoords();

            if (ev) {
                origPoint = {left: ev.pageX, top: ev.pageY};
                point = origPoint;

                // constrain the point to bounds of the element being dragged
                if (subjectEl) {
                    subjectRect = getOuterRect(subjectEl); // used for centering as well
                    point = constrainPoint(point, subjectRect);
                }

                this.origCell = this.getCell(point.left, point.top);

                // treat the center of the subject as the collision point?
                if (subjectEl && this.options.subjectCenter) {

                    // only consider the area the subject overlaps the cell. best for large subjects
                    if (this.origCell) {
                        subjectRect = intersectRects(this.origCell, subjectRect) ||
                            subjectRect; // in case there is no intersection
                    }

                    point = getRectCenter(subjectRect);
                }

                this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
            }
            else {
                this.origCell = null;
                this.coordAdjust = null;
            }
        },


        // Recomputes the drag-critical positions of elements
        computeCoords: function () {
            this.coordMap.build();
            this.computeScrollBounds();
        },


        // Called when the actual drag has started
        dragStart: function (ev) {
            var cell;

            DragListener.prototype.dragStart.apply(this, arguments); // call the super-method

            cell = this.getCell(ev.pageX, ev.pageY); // might be different from this.origCell if the min-distance is large

            // report the initial cell the mouse is over
            // especially important if no min-distance and drag starts immediately
            if (cell) {
                this.cellOver(cell);
            }
        },


        // Called when the drag moves
        drag: function (dx, dy, ev) {
            var cell;

            DragListener.prototype.drag.apply(this, arguments); // call the super-method

            cell = this.getCell(ev.pageX, ev.pageY);

            if (!isCellsEqual(cell, this.cell)) { // a different cell than before?
                if (this.cell) {
                    this.cellOut();
                }
                if (cell) {
                    this.cellOver(cell);
                }
            }
        },


        // Called when dragging has been stopped
        dragStop: function () {
            this.cellDone();
            DragListener.prototype.dragStop.apply(this, arguments); // call the super-method
        },


        // Called when a the mouse has just moved over a new cell
        cellOver: function (cell) {
            this.cell = cell;
            this.trigger('cellOver', cell, isCellsEqual(cell, this.origCell), this.origCell);
        },


        // Called when the mouse has just moved out of a cell
        cellOut: function () {
            if (this.cell) {
                this.trigger('cellOut', this.cell);
                this.cellDone();
                this.cell = null;
            }
        },


        // Called after a cellOut. Also called before a dragStop
        cellDone: function () {
            if (this.cell) {
                this.trigger('cellDone', this.cell);
            }
        },


        // Called when drag listening has stopped
        listenStop: function () {
            DragListener.prototype.listenStop.apply(this, arguments); // call the super-method

            this.origCell = this.cell = null;
            this.coordMap.clear();
        },


        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
        scrollStop: function () {
            DragListener.prototype.scrollStop.apply(this, arguments); // call the super-method

            this.computeCoords(); // cells' absolute positions will be in new places. recompute
        },


        // Gets the cell underneath the coordinates for the given mouse event
        getCell: function (left, top) {

            if (this.coordAdjust) {
                left += this.coordAdjust.left;
                top += this.coordAdjust.top;
            }

            return this.coordMap.getCell(left, top);
        }

    });


// Returns `true` if the cells are identically equal. `false` otherwise.
// They must have the same row, col, and be from the same grid.
// Two null values will be considered equal, as two "out of the grid" states are the same.
    function isCellsEqual(cell1, cell2) {

        if (!cell1 && !cell2) {
            return true;
        }

        if (cell1 && cell2) {
            return cell1.grid === cell2.grid &&
                cell1.row === cell2.row &&
                cell1.col === cell2.col;
        }

        return false;
    }

    ;
    ;

    /* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/

    var MouseFollower = Class.extend({

        options: null,

        sourceEl: null, // the element that will be cloned and made to look like it is dragging
        el: null, // the clone of `sourceEl` that will track the mouse
        parentEl: null, // the element that `el` (the clone) will be attached to

        // the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
        top0: null,
        left0: null,

        // the initial position of the mouse
        mouseY0: null,
        mouseX0: null,

        // the number of pixels the mouse has moved from its initial position
        topDelta: null,
        leftDelta: null,

        mousemoveProxy: null, // document mousemove handler, bound to the MouseFollower's `this`

        isFollowing: false,
        isHidden: false,
        isAnimating: false, // doing the revert animation?

        constructor: function (sourceEl, options) {
            this.options = options = options || {};
            this.sourceEl = sourceEl;
            this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
        },


        // Causes the element to start following the mouse
        start: function (ev) {
            if (!this.isFollowing) {
                this.isFollowing = true;

                this.mouseY0 = ev.pageY;
                this.mouseX0 = ev.pageX;
                this.topDelta = 0;
                this.leftDelta = 0;

                if (!this.isHidden) {
                    this.updatePosition();
                }

                $(document).on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'));
            }
        },


        // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
        // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
        stop: function (shouldRevert, callback) {
            var _this = this;
            var revertDuration = this.options.revertDuration;

            function complete() {
                this.isAnimating = false;
                _this.removeElement();

                this.top0 = this.left0 = null; // reset state for future updatePosition calls

                if (callback) {
                    callback();
                }
            }

            if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
                this.isFollowing = false;

                $(document).off('mousemove', this.mousemoveProxy);

                if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
                    this.isAnimating = true;
                    this.el.animate({
                        top: this.top0,
                        left: this.left0
                    }, {
                        duration: revertDuration,
                        complete: complete
                    });
                }
                else {
                    complete();
                }
            }
        },


        // Gets the tracking element. Create it if necessary
        getEl: function () {
            var el = this.el;

            if (!el) {
                this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
                el = this.el = this.sourceEl.clone()
                    .css({
                        position: 'absolute',
                        visibility: '', // in case original element was hidden (commonly through hideEvents())
                        display: this.isHidden ? 'none' : '', // for when initially hidden
                        margin: 0,
                        right: 'auto', // erase and set width instead
                        bottom: 'auto', // erase and set height instead
                        width: this.sourceEl.width(), // explicit height in case there was a 'right' value
                        height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
                        opacity: this.options.opacity || '',
                        zIndex: this.options.zIndex
                    })
                    .appendTo(this.parentEl);
            }

            return el;
        },


        // Removes the tracking element if it has already been created
        removeElement: function () {
            if (this.el) {
                this.el.remove();
                this.el = null;
            }
        },


        // Update the CSS position of the tracking element
        updatePosition: function () {
            var sourceOffset;
            var origin;

            this.getEl(); // ensure this.el

            // make sure origin info was computed
            if (this.top0 === null) {
                this.sourceEl.width(); // hack to force IE8 to compute correct bounding box
                sourceOffset = this.sourceEl.offset();
                origin = this.el.offsetParent().offset();
                this.top0 = sourceOffset.top - origin.top;
                this.left0 = sourceOffset.left - origin.left;
            }

            this.el.css({
                top: this.top0 + this.topDelta,
                left: this.left0 + this.leftDelta
            });
        },


        // Gets called when the user moves the mouse
        mousemove: function (ev) {
            this.topDelta = ev.pageY - this.mouseY0;
            this.leftDelta = ev.pageX - this.mouseX0;

            if (!this.isHidden) {
                this.updatePosition();
            }
        },


        // Temporarily makes the tracking element invisible. Can be called before following starts
        hide: function () {
            if (!this.isHidden) {
                this.isHidden = true;
                if (this.el) {
                    this.el.hide();
                }
            }
        },


        // Show the tracking element after it has been temporarily hidden
        show: function () {
            if (this.isHidden) {
                this.isHidden = false;
                this.updatePosition();
                this.getEl().show();
            }
        }

    });

    ;
    ;

    /* A utility class for rendering <tr> rows.
----------------------------------------------------------------------------------------------------------------------*/
// It leverages methods of the subclass and the View to determine custom rendering behavior for each row "type"
// (such as highlight rows, day rows, helper rows, etc).

    var RowRenderer = Class.extend({

        view: null, // a View object
        isRTL: null, // shortcut to the view's isRTL option
        cellHtml: '<td/>', // plain default HTML used for a cell when no other is available


        constructor: function (view) {
            this.view = view;
            this.isRTL = view.opt('isRTL');
        },


        // Renders the HTML for a row, leveraging custom cell-HTML-renderers based on the `rowType`.
        // Also applies the "intro" and "outro" cells, which are specified by the subclass and views.
        // `row` is an optional row number.
        rowHtml: function (rowType, row) {
            var renderCell = this.getHtmlRenderer('cell', rowType);
            var rowCellHtml = '';
            var col;
            var cell;

            row = row || 0;

            for (col = 0; col < this.colCnt; col++) {
                cell = this.getCell(row, col);
                rowCellHtml += renderCell(cell);
            }

            rowCellHtml = this.bookendCells(rowCellHtml, rowType, row); // apply intro and outro

            return '<tr>' + rowCellHtml + '</tr>';
        },


        // Applies the "intro" and "outro" HTML to the given cells.
        // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
        // `cells` can be an HTML string of <td>'s or a jQuery <tr> element
        // `row` is an optional row number.
        bookendCells: function (cells, rowType, row) {
            var intro = this.getHtmlRenderer('intro', rowType)(row || 0);
            var outro = this.getHtmlRenderer('outro', rowType)(row || 0);
            var prependHtml = this.isRTL ? outro : intro;
            var appendHtml = this.isRTL ? intro : outro;

            if (typeof cells === 'string') {
                return prependHtml + cells + appendHtml;
            }
            else { // a jQuery <tr> element
                return cells.prepend(prependHtml).append(appendHtml);
            }
        },


        // Returns an HTML-rendering function given a specific `rendererName` (like cell, intro, or outro) and a specific
        // `rowType` (like day, eventSkeleton, helperSkeleton), which is optional.
        // If a renderer for the specific rowType doesn't exist, it will fall back to a generic renderer.
        // We will query the View object first for any custom rendering functions, then the methods of the subclass.
        getHtmlRenderer: function (rendererName, rowType) {
            var view = this.view;
            var generalName; // like "cellHtml"
            var specificName; // like "dayCellHtml". based on rowType
            var provider; // either the View or the RowRenderer subclass, whichever provided the method
            var renderer;

            generalName = rendererName + 'Html';
            if (rowType) {
                specificName = rowType + capitaliseFirstLetter(rendererName) + 'Html';
            }

            if (specificName && (renderer = view[specificName])) {
                provider = view;
            }
            else if (specificName && (renderer = this[specificName])) {
                provider = this;
            }
            else if ((renderer = view[generalName])) {
                provider = view;
            }
            else if ((renderer = this[generalName])) {
                provider = this;
            }

            if (typeof renderer === 'function') {
                return function () {
                    return renderer.apply(provider, arguments) || ''; // use correct `this` and always return a string
                };
            }

            // the rendered can be a plain string as well. if not specified, always an empty string.
            return function () {
                return renderer || '';
            };
        }

    });

    ;
    ;

    /* An abstract class comprised of a "grid" of cells that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/

    var Grid = fc.Grid = RowRenderer.extend({

        start: null, // the date of the first cell
        end: null, // the date after the last cell

        rowCnt: 0, // number of rows
        colCnt: 0, // number of cols

        el: null, // the containing element
        coordMap: null, // a GridCoordMap that converts pixel values to datetimes
        elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

        externalDragStartProxy: null, // binds the Grid's scope to externalDragStart (in DayGrid.events)

        // derived from options
        colHeadFormat: null, // TODO: move to another class. not applicable to all Grids
        eventTimeFormat: null,
        displayEventTime: null,
        displayEventEnd: null,

        // if all cells are the same length of time, the duration they all share. optional.
        // when defined, allows the computeCellRange shortcut, as well as improved resizing behavior.
        cellDuration: null,

        // if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
        // of the date cells. if not defined, assumes to be day and time granularity.
        largeUnit: null,


        constructor: function () {
            RowRenderer.apply(this, arguments); // call the super-constructor

            this.coordMap = new GridCoordMap(this);
            this.elsByFill = {};
            this.externalDragStartProxy = proxy(this, 'externalDragStart');
        },


        /* Options
	------------------------------------------------------------------------------------------------------------------*/


        // Generates the format string used for the text in column headers, if not explicitly defined by 'columnFormat'
        // TODO: move to another class. not applicable to all Grids
        computeColHeadFormat: function () {
            // subclasses must implement if they want to use headHtml()
        },


        // Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
        computeEventTimeFormat: function () {
            return this.view.opt('smallTimeFormat');
        },


        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
        // Only applies to non-all-day events.
        computeDisplayEventTime: function () {
            return true;
        },


        // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
        computeDisplayEventEnd: function () {
            return true;
        },


        /* Dates
	------------------------------------------------------------------------------------------------------------------*/


        // Tells the grid about what period of time to display.
        // Any date-related cell system internal data should be generated.
        setRange: function (range) {
            this.start = range.start.clone();
            this.end = range.end.clone();

            this.rangeUpdated();
            this.processRangeOptions();
        },


        // Called when internal variables that rely on the range should be updated
        rangeUpdated: function () {
        },


        // Updates values that rely on options and also relate to range
        processRangeOptions: function () {
            var view = this.view;
            var displayEventTime;
            var displayEventEnd;

            // Populate option-derived settings. Look for override first, then compute if necessary.
            this.colHeadFormat = view.opt('columnFormat') || this.computeColHeadFormat();

            this.eventTimeFormat =
                view.opt('eventTimeFormat') ||
                view.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();

            displayEventTime = view.opt('displayEventTime');
            if (displayEventTime == null) {
                displayEventTime = this.computeDisplayEventTime(); // might be based off of range
            }

            displayEventEnd = view.opt('displayEventEnd');
            if (displayEventEnd == null) {
                displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
            }

            this.displayEventTime = displayEventTime;
            this.displayEventEnd = displayEventEnd;
        },


        // Called before the grid's coordinates will need to be queried for cells.
        // Any non-date-related cell system internal data should be built.
        build: function () {
        },


        // Called after the grid's coordinates are done being relied upon.
        // Any non-date-related cell system internal data should be cleared.
        clear: function () {
        },


        // Converts a range with an inclusive `start` and an exclusive `end` into an array of segment objects
        rangeToSegs: function (range) {
            // subclasses must implement
        },


        // Diffs the two dates, returning a duration, based on granularity of the grid
        diffDates: function (a, b) {
            if (this.largeUnit) {
                return diffByUnit(a, b, this.largeUnit);
            }
            else {
                return diffDayTime(a, b);
            }
        },


        /* Cells
	------------------------------------------------------------------------------------------------------------------*/
        // NOTE: columns are ordered left-to-right


        // Gets an object containing row/col number, misc data, and range information about the cell.
        // Accepts row/col values, an object with row/col properties, or a single-number offset from the first cell.
        getCell: function (row, col) {
            var cell;

            if (col == null) {
                if (typeof row === 'number') { // a single-number offset
                    col = row % this.colCnt;
                    row = Math.floor(row / this.colCnt);
                }
                else { // an object with row/col properties
                    col = row.col;
                    row = row.row;
                }
            }

            cell = {row: row, col: col};

            $.extend(cell, this.getRowData(row), this.getColData(col));
            $.extend(cell, this.computeCellRange(cell));

            return cell;
        },


        // Given a cell object with index and misc data, generates a range object
        // If the grid is leveraging cellDuration, this doesn't need to be defined. Only computeCellDate does.
        // If being overridden, should return a range with reference-free date copies.
        computeCellRange: function (cell) {
            var date = this.computeCellDate(cell);

            return {
                start: date,
                end: date.clone().add(this.cellDuration)
            };
        },


        // Given a cell, returns its start date. Should return a reference-free date copy.
        computeCellDate: function (cell) {
            // subclasses can implement
        },


        // Retrieves misc data about the given row
        getRowData: function (row) {
            return {};
        },


        // Retrieves misc data baout the given column
        getColData: function (col) {
            return {};
        },


        // Retrieves the element representing the given row
        getRowEl: function (row) {
            // subclasses should implement if leveraging the default getCellDayEl() or computeRowCoords()
        },


        // Retrieves the element representing the given column
        getColEl: function (col) {
            // subclasses should implement if leveraging the default getCellDayEl() or computeColCoords()
        },


        // Given a cell object, returns the element that represents the cell's whole-day
        getCellDayEl: function (cell) {
            return this.getColEl(cell.col) || this.getRowEl(cell.row);
        },


        /* Cell Coordinates
	------------------------------------------------------------------------------------------------------------------*/


        // Computes the top/bottom coordinates of all rows.
        // By default, queries the dimensions of the element provided by getRowEl().
        computeRowCoords: function () {
            var items = [];
            var i, el;
            var top;

            for (i = 0; i < this.rowCnt; i++) {
                el = this.getRowEl(i);
                top = el.offset().top;
                items.push({
                    top: top,
                    bottom: top + el.outerHeight()
                });
            }

            return items;
        },


        // Computes the left/right coordinates of all rows.
        // By default, queries the dimensions of the element provided by getColEl(). Columns can be LTR or RTL.
        computeColCoords: function () {
            var items = [];
            var i, el;
            var left;

            for (i = 0; i < this.colCnt; i++) {
                el = this.getColEl(i);
                left = el.offset().left;
                items.push({
                    left: left,
                    right: left + el.outerWidth()
                });
            }

            return items;
        },


        /* Rendering
	------------------------------------------------------------------------------------------------------------------*/


        // Sets the container element that the grid should render inside of.
        // Does other DOM-related initializations.
        setElement: function (el) {
            var _this = this;

            this.el = el;

            // attach a handler to the grid's root element.
            // jQuery will take care of unregistering them when removeElement gets called.
            el.on('mousedown', function (ev) {
                if (
                    !$(ev.target).is('.fc-event-container *, .fc-more') && // not an an event element, or "more.." link
                    !$(ev.target).closest('.fc-popover').length // not on a popover (like the "more.." events one)
                ) {
                    _this.dayMousedown(ev);
                }
            });

            // attach event-element-related handlers. in Grid.events
            // same garbage collection note as above.
            this.bindSegHandlers();

            this.bindGlobalHandlers();
        },


        // Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
        // DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
        removeElement: function () {
            this.unbindGlobalHandlers();

            this.el.remove();

            // NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
        },


        // Renders the basic structure of grid view before any content is rendered
        renderSkeleton: function () {
            // subclasses should implement
        },


        // Renders the grid's date-related content (like cells that represent days/times).
        // Assumes setRange has already been called and the skeleton has already been rendered.
        renderDates: function () {
            // subclasses should implement
        },


        // Unrenders the grid's date-related content
        unrenderDates: function () {
            // subclasses should implement
        },


        /* Handlers
	------------------------------------------------------------------------------------------------------------------*/


        // Binds DOM handlers to elements that reside outside the grid, such as the document
        bindGlobalHandlers: function () {
            $(document).on('dragstart sortstart', this.externalDragStartProxy); // jqui
        },


        // Unbinds DOM handlers from elements that reside outside the grid
        unbindGlobalHandlers: function () {
            $(document).off('dragstart sortstart', this.externalDragStartProxy); // jqui
        },


        // Process a mousedown on an element that represents a day. For day clicking and selecting.
        dayMousedown: function (ev) {
            var _this = this;
            var view = this.view;
            var isSelectable = view.opt('selectable');
            var dayClickCell; // null if invalid dayClick
            var selectionRange; // null if invalid selection

            // this listener tracks a mousedown on a day element, and a subsequent drag.
            // if the drag ends on the same day, it is a 'dayClick'.
            // if 'selectable' is enabled, this listener also detects selections.
            var dragListener = new CellDragListener(this.coordMap, {
                //distance: 5, // needs more work if we want dayClick to fire correctly
                scroll: view.opt('dragScroll'),
                dragStart: function () {
                    view.unselect(); // since we could be rendering a new selection, we want to clear any old one
                },
                cellOver: function (cell, isOrig, origCell) {
                    if (origCell) { // click needs to have started on a cell
                        dayClickCell = isOrig ? cell : null; // single-cell selection is a day click
                        if (isSelectable) {
                            selectionRange = _this.computeSelection(origCell, cell);
                            if (selectionRange) {
                                _this.renderSelection(selectionRange);
                            }
                            else {
                                disableCursor();
                            }
                        }
                    }
                },
                cellOut: function (cell) {
                    dayClickCell = null;
                    selectionRange = null;
                    _this.unrenderSelection();
                    enableCursor();
                },
                listenStop: function (ev) {
                    if (dayClickCell) {
                        view.triggerDayClick(dayClickCell, _this.getCellDayEl(dayClickCell), ev);
                    }
                    if (selectionRange) {
                        // the selection will already have been rendered. just report it
                        view.reportSelection(selectionRange, ev);
                    }
                    enableCursor();
                }
            });

            dragListener.mousedown(ev); // start listening, which will eventually initiate a dragStart
        },


        /* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
        // TODO: should probably move this to Grid.events, like we did event dragging / resizing


        // Renders a mock event over the given range
        renderRangeHelper: function (range, sourceSeg) {
            var fakeEvent = this.fabricateHelperEvent(range, sourceSeg);

            this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
        },


        // Builds a fake event given a date range it should cover, and a segment is should be inspired from.
        // The range's end can be null, in which case the mock event that is rendered will have a null end time.
        // `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
        fabricateHelperEvent: function (range, sourceSeg) {
            var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

            fakeEvent.start = range.start.clone();
            fakeEvent.end = range.end ? range.end.clone() : null;
            fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventRange
            this.view.calendar.normalizeEventRange(fakeEvent);

            // this extra className will be useful for differentiating real events from mock events in CSS
            fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

            // if something external is being dragged in, don't render a resizer
            if (!sourceSeg) {
                fakeEvent.editable = false;
            }

            return fakeEvent;
        },


        // Renders a mock event
        renderHelper: function (event, sourceSeg) {
            // subclasses must implement
        },


        // Unrenders a mock event
        unrenderHelper: function () {
            // subclasses must implement
        },


        /* Selection
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
        renderSelection: function (range) {
            this.renderHighlight(this.selectionRangeToSegs(range));
        },


        // Unrenders any visual indications of a selection. Will unrender a highlight by default.
        unrenderSelection: function () {
            this.unrenderHighlight();
        },


        // Given the first and last cells of a selection, returns a range object.
        // Will return something falsy if the selection is invalid (when outside of selectionConstraint for example).
        // Subclasses can override and provide additional data in the range object. Will be passed to renderSelection().
        computeSelection: function (firstCell, lastCell) {
            var dates = [
                firstCell.start,
                firstCell.end,
                lastCell.start,
                lastCell.end
            ];
            var range;

            dates.sort(compareNumbers); // sorts chronologically. works with Moments

            range = {
                start: dates[0].clone(),
                end: dates[3].clone()
            };

            if (!this.view.calendar.isSelectionRangeAllowed(range)) {
                return null;
            }

            return range;
        },


        selectionRangeToSegs: function (range) {
            return this.rangeToSegs(range);
        },


        /* Highlight
	------------------------------------------------------------------------------------------------------------------*/


        // Renders an emphasis on the given date range. Given an array of segments.
        renderHighlight: function (segs) {
            this.renderFill('highlight', segs);
        },


        // Unrenders the emphasis on a date range
        unrenderHighlight: function () {
            this.unrenderFill('highlight');
        },


        // Generates an array of classNames for rendering the highlight. Used by the fill system.
        highlightSegClasses: function () {
            return ['fc-highlight'];
        },


        /* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a set of rectangles over the given segments of time.
        // MUST RETURN a subset of segs, the segs that were actually rendered.
        // Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
        renderFill: function (type, segs) {
            // subclasses must implement
        },


        // Unrenders a specific type of fill that is currently rendered on the grid
        unrenderFill: function (type) {
            var el = this.elsByFill[type];

            if (el) {
                el.remove();
                delete this.elsByFill[type];
            }
        },


        // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
        // Only returns segments that successfully rendered.
        // To be harnessed by renderFill (implemented by subclasses).
        // Analagous to renderFgSegEls.
        renderFillSegEls: function (type, segs) {
            var _this = this;
            var segElMethod = this[type + 'SegEl'];
            var html = '';
            var renderedSegs = [];
            var i;

            if (segs.length) {

                // build a large concatenation of segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.fillSegHtml(type, segs[i]);
                }

                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment.
                $(html).each(function (i, node) {
                    var seg = segs[i];
                    var el = $(node);

                    // allow custom filter methods per-type
                    if (segElMethod) {
                        el = segElMethod.call(_this, seg, el);
                    }

                    if (el) { // custom filters did not cancel the render
                        el = $(el); // allow custom filter to return raw DOM node

                        // correct element type? (would be bad if a non-TD were inserted into a table for example)
                        if (el.is(_this.fillSegTag)) {
                            seg.el = el;
                            renderedSegs.push(seg);
                        }
                    }
                });
            }

            return renderedSegs;
        },


        fillSegTag: 'div', // subclasses can override


        // Builds the HTML needed for one fill segment. Generic enought o work with different types.
        fillSegHtml: function (type, seg) {

            // custom hooks per-type
            var classesMethod = this[type + 'SegClasses'];
            var cssMethod = this[type + 'SegCss'];

            var classes = classesMethod ? classesMethod.call(this, seg) : [];
            var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

            return '<' + this.fillSegTag +
                (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
                (css ? ' style="' + css + '"' : '') +
                ' />';
        },


        /* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a day-of-week header row.
        // TODO: move to another class. not applicable to all Grids
        headHtml: function () {
            return '' +
                '<div class="fc-row ' + this.view.widgetHeaderClass + '">' +
                '<table>' +
                '<thead>' +
                this.rowHtml('head') + // leverages RowRenderer
                '</thead>' +
                '</table>' +
                '</div>';
        },


        // Used by the `headHtml` method, via RowRenderer, for rendering the HTML of a day-of-week header cell
        // TODO: move to another class. not applicable to all Grids
        headCellHtml: function (cell) {
            var view = this.view;
            var date = cell.start;

            return '' +
                '<th class="fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '">' +
                htmlEscape(date.format(this.colHeadFormat)) +
                '</th>';
        },


        // Renders the HTML for a single-day background cell
        bgCellHtml: function (cell) {
            var view = this.view;
            var date = cell.start;
            var classes = this.getDayClasses(date);

            classes.unshift('fc-day', view.widgetContentClass);

            return '<td class="' + classes.join(' ') + '"' +
                ' data-date="' + date.format('YYYY-MM-DD') + '"' + // if date has a time, won't format it
                '></td>';
        },


        // Computes HTML classNames for a single-day cell
        getDayClasses: function (date) {
            var view = this.view;
            var today = view.calendar.getNow().stripTime();
            var classes = ['fc-' + dayIDs[date.day()]];

            if (
                view.intervalDuration.as('months') == 1 &&
                date.month() != view.intervalStart.month()
            ) {
                classes.push('fc-other-month');
            }

            if (date.isSame(today, 'day')) {
                classes.push(
                    'fc-today',
                    view.highlightStateClass
                );
            }
            else if (date < today) {
                classes.push('fc-past');
            }
            else {
                classes.push('fc-future');
            }

            return classes;
        }

    });

    ;
    ;

    /* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------*/

    Grid.mixin({

        mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
        isDraggingSeg: false, // is a segment being dragged? boolean
        isResizingSeg: false, // is a segment being resized? boolean
        isDraggingExternal: false, // jqui-dragging an external element? boolean
        segs: null, // the event segments currently rendered in the grid


        // Renders the given events onto the grid
        renderEvents: function (events) {
            var segs = this.eventsToSegs(events);
            var bgSegs = [];
            var fgSegs = [];
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];

                if (isBgEvent(seg.event)) {
                    bgSegs.push(seg);
                }
                else {
                    fgSegs.push(seg);
                }
            }

            // Render each different type of segment.
            // Each function may return a subset of the segs, segs that were actually rendered.
            bgSegs = this.renderBgSegs(bgSegs) || bgSegs;
            fgSegs = this.renderFgSegs(fgSegs) || fgSegs;

            this.segs = bgSegs.concat(fgSegs);
        },


        // Unrenders all events currently rendered on the grid
        unrenderEvents: function () {
            this.triggerSegMouseout(); // trigger an eventMouseout if user's mouse is over an event

            this.unrenderFgSegs();
            this.unrenderBgSegs();

            this.segs = null;
        },


        // Retrieves all rendered segment objects currently rendered on the grid
        getEventSegs: function () {
            return this.segs || [];
        },


        /* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


        // Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
        renderFgSegs: function (segs) {
            // subclasses must implement
        },


        // Unrenders all currently rendered foreground segments
        unrenderFgSegs: function () {
            // subclasses must implement
        },


        // Renders and assigns an `el` property for each foreground event segment.
        // Only returns segments that successfully rendered.
        // A utility that subclasses may use.
        renderFgSegEls: function (segs, disableResizing) {
            var view = this.view;
            var html = '';
            var renderedSegs = [];
            var i;

            if (segs.length) { // don't build an empty html string

                // build a large concatenation of event segment HTML
                for (i = 0; i < segs.length; i++) {
                    html += this.fgSegHtml(segs[i], disableResizing);
                }

                // Grab individual elements from the combined HTML string. Use each as the default rendering.
                // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
                $(html).each(function (i, node) {
                    var seg = segs[i];
                    var el = view.resolveEventEl(seg.event, $(node));

                    if (el) {
                        el.data('fc-seg', seg); // used by handlers
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                });
            }

            return renderedSegs;
        },


        // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
        fgSegHtml: function (seg, disableResizing) {
            // subclasses should implement
        },


        /* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


        // Renders the given background event segments onto the grid.
        // Returns a subset of the segs that were actually rendered.
        renderBgSegs: function (segs) {
            return this.renderFill('bgEvent', segs);
        },


        // Unrenders all the currently rendered background event segments
        unrenderBgSegs: function () {
            this.unrenderFill('bgEvent');
        },


        // Renders a background event element, given the default rendering. Called by the fill system.
        bgEventSegEl: function (seg, el) {
            return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
        },


        // Generates an array of classNames to be used for the default rendering of a background event.
        // Called by the fill system.
        bgEventSegClasses: function (seg) {
            var event = seg.event;
            var source = event.source || {};

            return ['fc-bgevent'].concat(
                event.className,
                source.className || []
            );
        },


        // Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
        // Called by the fill system.
        // TODO: consolidate with getEventSkinCss?
        bgEventSegCss: function (seg) {
            var view = this.view;
            var event = seg.event;
            var source = event.source || {};

            return {
                'background-color':
                event.backgroundColor ||
                event.color ||
                source.backgroundColor ||
                source.color ||
                view.opt('eventBackgroundColor') ||
                view.opt('eventColor')
            };
        },


        // Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
        businessHoursSegClasses: function (seg) {
            return ['fc-nonbusiness', 'fc-bgevent'];
        },


        /* Handlers
	------------------------------------------------------------------------------------------------------------------*/


        // Attaches event-element-related handlers to the container element and leverage bubbling
        bindSegHandlers: function () {
            var _this = this;
            var view = this.view;

            $.each(
                {
                    mouseenter: function (seg, ev) {
                        _this.triggerSegMouseover(seg, ev);
                    },
                    mouseleave: function (seg, ev) {
                        _this.triggerSegMouseout(seg, ev);
                    },
                    click: function (seg, ev) {
                        return view.trigger('eventClick', this, seg.event, ev); // can return `false` to cancel
                    },
                    mousedown: function (seg, ev) {
                        if ($(ev.target).is('.fc-resizer') && view.isEventResizable(seg.event)) {
                            _this.segResizeMousedown(seg, ev, $(ev.target).is('.fc-start-resizer'));
                        }
                        else if (view.isEventDraggable(seg.event)) {
                            _this.segDragMousedown(seg, ev);
                        }
                    }
                },
                function (name, func) {
                    // attach the handler to the container element and only listen for real event elements via bubbling
                    _this.el.on(name, '.fc-event-container > *', function (ev) {
                        var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

                        // only call the handlers if there is not a drag/resize in progress
                        if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
                            return func.call(this, seg, ev); // `this` will be the event element
                        }
                    });
                }
            );
        },


        // Updates internal state and triggers handlers for when an event element is moused over
        triggerSegMouseover: function (seg, ev) {
            if (!this.mousedOverSeg) {
                this.mousedOverSeg = seg;
                this.view.trigger('eventMouseover', seg.el[0], seg.event, ev);
            }
        },


        // Updates internal state and triggers handlers for when an event element is moused out.
        // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
        triggerSegMouseout: function (seg, ev) {
            ev = ev || {}; // if given no args, make a mock mouse event

            if (this.mousedOverSeg) {
                seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
                this.mousedOverSeg = null;
                this.view.trigger('eventMouseout', seg.el[0], seg.event, ev);
            }
        },


        /* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/


        // Called when the user does a mousedown on an event, which might lead to dragging.
        // Generic enough to work with any type of Grid.
        segDragMousedown: function (seg, ev) {
            var _this = this;
            var view = this.view;
            var calendar = view.calendar;
            var el = seg.el;
            var event = seg.event;
            var dropLocation;

            // A clone of the original element that will move with the mouse
            var mouseFollower = new MouseFollower(seg.el, {
                parentEl: view.el,
                opacity: view.opt('dragOpacity'),
                revertDuration: view.opt('dragRevertDuration'),
                zIndex: 2 // one above the .fc-view
            });

            // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
            // of the view.
            var dragListener = new CellDragListener(view.coordMap, {
                distance: 5,
                scroll: view.opt('dragScroll'),
                subjectEl: el,
                subjectCenter: true,
                listenStart: function (ev) {
                    mouseFollower.hide(); // don't show until we know this is a real drag
                    mouseFollower.start(ev);
                },
                dragStart: function (ev) {
                    _this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
                    _this.segDragStart(seg, ev);
                    view.hideEvent(event); // hide all event segments. our mouseFollower will take over
                },
                cellOver: function (cell, isOrig, origCell) {

                    // starting cell could be forced (DayGrid.limit)
                    if (seg.cell) {
                        origCell = seg.cell;
                    }

                    dropLocation = _this.computeEventDrop(origCell, cell, event);

                    if (dropLocation && !calendar.isEventRangeAllowed(dropLocation, event)) {
                        disableCursor();
                        dropLocation = null;
                    }

                    // if a valid drop location, have the subclass render a visual indication
                    if (dropLocation && view.renderDrag(dropLocation, seg)) {
                        mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                    }
                    else {
                        mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                    }

                    if (isOrig) {
                        dropLocation = null; // needs to have moved cells to be a valid drop
                    }
                },
                cellOut: function () { // called before mouse moves to a different cell OR moved out of all cells
                    view.unrenderDrag(); // unrender whatever was done in renderDrag
                    mouseFollower.show(); // show in case we are moving out of all cells
                    dropLocation = null;
                },
                cellDone: function () { // Called after a cellOut OR before a dragStop
                    enableCursor();
                },
                dragStop: function (ev) {
                    // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                    mouseFollower.stop(!dropLocation, function () {
                        view.unrenderDrag();
                        view.showEvent(event);
                        _this.segDragStop(seg, ev);

                        if (dropLocation) {
                            view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);
                        }
                    });
                },
                listenStop: function () {
                    mouseFollower.stop(); // put in listenStop in case there was a mousedown but the drag never started
                }
            });

            dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
        },


        // Called before event segment dragging starts
        segDragStart: function (seg, ev) {
            this.isDraggingSeg = true;
            this.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Called after event segment dragging stops
        segDragStop: function (seg, ev) {
            this.isDraggingSeg = false;
            this.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Given the cell an event drag began, and the cell event was dropped, calculates the new start/end/allDay
        // values for the event. Subclasses may override and set additional properties to be used by renderDrag.
        // A falsy returned value indicates an invalid drop.
        computeEventDrop: function (startCell, endCell, event) {
            var calendar = this.view.calendar;
            var dragStart = startCell.start;
            var dragEnd = endCell.start;
            var delta;
            var dropLocation;

            if (dragStart.hasTime() === dragEnd.hasTime()) {
                delta = this.diffDates(dragEnd, dragStart);

                // if an all-day event was in a timed area and it was dragged to a different time,
                // guarantee an end and adjust start/end to have times
                if (event.allDay && durationHasTime(delta)) {
                    dropLocation = {
                        start: event.start.clone(),
                        end: calendar.getEventEnd(event), // will be an ambig day
                        allDay: false // for normalizeEventRangeTimes
                    };
                    calendar.normalizeEventRangeTimes(dropLocation);
                }
                // othewise, work off existing values
                else {
                    dropLocation = {
                        start: event.start.clone(),
                        end: event.end ? event.end.clone() : null,
                        allDay: event.allDay // keep it the same
                    };
                }

                dropLocation.start.add(delta);
                if (dropLocation.end) {
                    dropLocation.end.add(delta);
                }
            }
            else {
                // if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
                dropLocation = {
                    start: dragEnd.clone(),
                    end: null, // end should be cleared
                    allDay: !dragEnd.hasTime()
                };
            }

            return dropLocation;
        },


        // Utility for apply dragOpacity to a jQuery set
        applyDragOpacity: function (els) {
            var opacity = this.view.opt('dragOpacity');

            if (opacity != null) {
                els.each(function (i, node) {
                    // Don't use jQuery (will set an IE filter), do it the old fashioned way.
                    // In IE8, a helper element will disappears if there's a filter.
                    node.style.opacity = opacity;
                });
            }
        },


        /* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/


        // Called when a jQuery UI drag is initiated anywhere in the DOM
        externalDragStart: function (ev, ui) {
            var view = this.view;
            var el;
            var accept;

            if (view.opt('droppable')) { // only listen if this setting is on
                el = $((ui ? ui.item : null) || ev.target);

                // Test that the dragged element passes the dropAccept selector or filter function.
                // FYI, the default is "*" (matches all)
                accept = view.opt('dropAccept');
                if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                    if (!this.isDraggingExternal) { // prevent double-listening if fired twice
                        this.listenToExternalDrag(el, ev, ui);
                    }
                }
            }
        },


        // Called when a jQuery UI drag starts and it needs to be monitored for cell dropping
        listenToExternalDrag: function (el, ev, ui) {
            var _this = this;
            var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
            var dragListener;
            var dropLocation; // a null value signals an unsuccessful drag

            // listener that tracks mouse movement over date-associated pixel regions
            dragListener = new CellDragListener(this.coordMap, {
                listenStart: function () {
                    _this.isDraggingExternal = true;
                },
                cellOver: function (cell) {
                    dropLocation = _this.computeExternalDrop(cell, meta);
                    if (dropLocation) {
                        _this.renderDrag(dropLocation); // called without a seg parameter
                    }
                    else { // invalid drop cell
                        disableCursor();
                    }
                },
                cellOut: function () {
                    dropLocation = null; // signal unsuccessful
                    _this.unrenderDrag();
                    enableCursor();
                },
                dragStop: function () {
                    _this.unrenderDrag();
                    enableCursor();

                    if (dropLocation) { // element was dropped on a valid date/time cell
                        _this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
                    }
                },
                listenStop: function () {
                    _this.isDraggingExternal = false;
                }
            });

            dragListener.startDrag(ev); // start listening immediately
        },


        // Given a cell to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
        // returns start/end dates for the event that would result from the hypothetical drop. end might be null.
        // Returning a null value signals an invalid drop cell.
        computeExternalDrop: function (cell, meta) {
            var dropLocation = {
                start: cell.start.clone(),
                end: null
            };

            // if dropped on an all-day cell, and element's metadata specified a time, set it
            if (meta.startTime && !dropLocation.start.hasTime()) {
                dropLocation.start.time(meta.startTime);
            }

            if (meta.duration) {
                dropLocation.end = dropLocation.start.clone().add(meta.duration);
            }

            if (!this.view.calendar.isExternalDropRangeAllowed(dropLocation, meta.eventProps)) {
                return null;
            }

            return dropLocation;
        },


        /* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event or external element being dragged.
        // `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
        // `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
        // A truthy returned value indicates this method has rendered a helper element.
        renderDrag: function (dropLocation, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event or external element being dragged
        unrenderDrag: function () {
            // subclasses must implement
        },


        /* Resizing
	------------------------------------------------------------------------------------------------------------------*/


        // Called when the user does a mousedown on an event's resizer, which might lead to resizing.
        // Generic enough to work with any type of Grid.
        segResizeMousedown: function (seg, ev, isStart) {
            var _this = this;
            var view = this.view;
            var calendar = view.calendar;
            var el = seg.el;
            var event = seg.event;
            var eventEnd = calendar.getEventEnd(event);
            var dragListener;
            var resizeLocation; // falsy if invalid resize

            // Tracks mouse movement over the *grid's* coordinate map
            dragListener = new CellDragListener(this.coordMap, {
                distance: 5,
                scroll: view.opt('dragScroll'),
                subjectEl: el,
                dragStart: function (ev) {
                    _this.triggerSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
                    _this.segResizeStart(seg, ev);
                },
                cellOver: function (cell, isOrig, origCell) {
                    resizeLocation = isStart ?
                        _this.computeEventStartResize(origCell, cell, event) :
                        _this.computeEventEndResize(origCell, cell, event);

                    if (resizeLocation) {
                        if (!calendar.isEventRangeAllowed(resizeLocation, event)) {
                            disableCursor();
                            resizeLocation = null;
                        }
                        // no change? (TODO: how does this work with timezones?)
                        else if (resizeLocation.start.isSame(event.start) && resizeLocation.end.isSame(eventEnd)) {
                            resizeLocation = null;
                        }
                    }

                    if (resizeLocation) {
                        view.hideEvent(event);
                        _this.renderEventResize(resizeLocation, seg);
                    }
                },
                cellOut: function () { // called before mouse moves to a different cell OR moved out of all cells
                    resizeLocation = null;
                },
                cellDone: function () { // resets the rendering to show the original event
                    _this.unrenderEventResize();
                    view.showEvent(event);
                    enableCursor();
                },
                dragStop: function (ev) {
                    _this.segResizeStop(seg, ev);

                    if (resizeLocation) { // valid date to resize to?
                        view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);
                    }
                }
            });

            dragListener.mousedown(ev); // start listening, which will eventually lead to a dragStart
        },


        // Called before event segment resizing starts
        segResizeStart: function (seg, ev) {
            this.isResizingSeg = true;
            this.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Called after event segment resizing stops
        segResizeStop: function (seg, ev) {
            this.isResizingSeg = false;
            this.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
        },


        // Returns new date-information for an event segment being resized from its start
        computeEventStartResize: function (startCell, endCell, event) {
            return this.computeEventResize('start', startCell, endCell, event);
        },


        // Returns new date-information for an event segment being resized from its end
        computeEventEndResize: function (startCell, endCell, event) {
            return this.computeEventResize('end', startCell, endCell, event);
        },


        // Returns new date-information for an event segment being resized from its start OR end
        // `type` is either 'start' or 'end'
        computeEventResize: function (type, startCell, endCell, event) {
            var calendar = this.view.calendar;
            var delta = this.diffDates(endCell[type], startCell[type]);
            var range;
            var defaultDuration;

            // build original values to work from, guaranteeing a start and end
            range = {
                start: event.start.clone(),
                end: calendar.getEventEnd(event),
                allDay: event.allDay
            };

            // if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
            if (range.allDay && durationHasTime(delta)) {
                range.allDay = false;
                calendar.normalizeEventRangeTimes(range);
            }

            range[type].add(delta); // apply delta to start or end

            // if the event was compressed too small, find a new reasonable duration for it
            if (!range.start.isBefore(range.end)) {

                defaultDuration = event.allDay ?
                    calendar.defaultAllDayEventDuration :
                    calendar.defaultTimedEventDuration;

                // between the cell's duration and the event's default duration, use the smaller of the two.
                // example: if year-length slots, and compressed to one slot, we don't want the event to be a year long
                if (this.cellDuration && this.cellDuration < defaultDuration) {
                    defaultDuration = this.cellDuration;
                }

                if (type == 'start') { // resizing the start?
                    range.start = range.end.clone().subtract(defaultDuration);
                }
                else { // resizing the end?
                    range.end = range.start.clone().add(defaultDuration);
                }
            }

            return range;
        },


        // Renders a visual indication of an event being resized.
        // `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
        renderEventResize: function (range, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event being resized.
        unrenderEventResize: function () {
            // subclasses must implement
        },


        /* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


        // Compute the text that should be displayed on an event's element.
        // `range` can be the Event object itself, or something range-like, with at least a `start`.
        // If event times are disabled, or the event has no time, will return a blank string.
        // If not specified, formatStr will default to the eventTimeFormat setting,
        // and displayEnd will default to the displayEventEnd setting.
        getEventTimeText: function (range, formatStr, displayEnd) {

            if (formatStr == null) {
                formatStr = this.eventTimeFormat;
            }

            if (displayEnd == null) {
                displayEnd = this.displayEventEnd;
            }

            if (this.displayEventTime && range.start.hasTime()) {
                if (displayEnd && range.end) {
                    return this.view.formatRange(range, formatStr);
                }
                else {
                    return range.start.format(formatStr);
                }
            }

            return '';
        },


        // Generic utility for generating the HTML classNames for an event segment's element
        getSegClasses: function (seg, isDraggable, isResizable) {
            var event = seg.event;
            var classes = [
                'fc-event',
                seg.isStart ? 'fc-start' : 'fc-not-start',
                seg.isEnd ? 'fc-end' : 'fc-not-end'
            ].concat(
                event.className,
                event.source ? event.source.className : []
            );

            if (isDraggable) {
                classes.push('fc-draggable');
            }
            if (isResizable) {
                classes.push('fc-resizable');
            }

            return classes;
        },


        // Utility for generating event skin-related CSS properties
        getEventSkinCss: function (event) {
            var view = this.view;
            var source = event.source || {};
            var eventColor = event.color;
            var sourceColor = source.color;
            var optionColor = view.opt('eventColor');

            return {
                'background-color':
                event.backgroundColor ||
                eventColor ||
                source.backgroundColor ||
                sourceColor ||
                view.opt('eventBackgroundColor') ||
                optionColor,
                'border-color':
                event.borderColor ||
                eventColor ||
                source.borderColor ||
                sourceColor ||
                view.opt('eventBorderColor') ||
                optionColor,
                color:
                event.textColor ||
                source.textColor ||
                view.opt('eventTextColor')
            };
        },


        /* Converting events -> ranges -> segs
	------------------------------------------------------------------------------------------------------------------*/


        // Converts an array of event objects into an array of event segment objects.
        // A custom `rangeToSegsFunc` may be given for arbitrarily slicing up events.
        // Doesn't guarantee an order for the resulting array.
        eventsToSegs: function (events, rangeToSegsFunc) {
            var eventRanges = this.eventsToRanges(events);
            var segs = [];
            var i;

            for (i = 0; i < eventRanges.length; i++) {
                segs.push.apply(
                    segs,
                    this.eventRangeToSegs(eventRanges[i], rangeToSegsFunc)
                );
            }

            return segs;
        },


        // Converts an array of events into an array of "range" objects.
        // A "range" object is a plain object with start/end properties denoting the time it covers. Also an event property.
        // For "normal" events, this will be identical to the event's start/end, but for "inverse-background" events,
        // will create an array of ranges that span the time *not* covered by the given event.
        // Doesn't guarantee an order for the resulting array.
        eventsToRanges: function (events) {
            var _this = this;
            var eventsById = groupEventsById(events);
            var ranges = [];

            // group by ID so that related inverse-background events can be rendered together
            $.each(eventsById, function (id, eventGroup) {
                if (eventGroup.length) {
                    ranges.push.apply(
                        ranges,
                        isInverseBgEvent(eventGroup[0]) ?
                            _this.eventsToInverseRanges(eventGroup) :
                            _this.eventsToNormalRanges(eventGroup)
                    );
                }
            });

            return ranges;
        },


        // Converts an array of "normal" events (not inverted rendering) into a parallel array of ranges
        eventsToNormalRanges: function (events) {
            var calendar = this.view.calendar;
            var ranges = [];
            var i, event;
            var eventStart, eventEnd;

            for (i = 0; i < events.length; i++) {
                event = events[i];

                // make copies and normalize by stripping timezone
                eventStart = event.start.clone().stripZone();
                eventEnd = calendar.getEventEnd(event).stripZone();

                ranges.push({
                    event: event,
                    start: eventStart,
                    end: eventEnd,
                    eventStartMS: +eventStart,
                    eventDurationMS: eventEnd - eventStart
                });
            }

            return ranges;
        },


        // Converts an array of events, with inverse-background rendering, into an array of range objects.
        // The range objects will cover all the time NOT covered by the events.
        eventsToInverseRanges: function (events) {
            var view = this.view;
            var viewStart = view.start.clone().stripZone(); // normalize timezone
            var viewEnd = view.end.clone().stripZone(); // normalize timezone
            var normalRanges = this.eventsToNormalRanges(events); // will give us normalized dates we can use w/o copies
            var inverseRanges = [];
            var event0 = events[0]; // assign this to each range's `.event`
            var start = viewStart; // the end of the previous range. the start of the new range
            var i, normalRange;

            // ranges need to be in order. required for our date-walking algorithm
            normalRanges.sort(compareNormalRanges);

            for (i = 0; i < normalRanges.length; i++) {
                normalRange = normalRanges[i];

                // add the span of time before the event (if there is any)
                if (normalRange.start > start) { // compare millisecond time (skip any ambig logic)
                    inverseRanges.push({
                        event: event0,
                        start: start,
                        end: normalRange.start
                    });
                }

                start = normalRange.end;
            }

            // add the span of time after the last event (if there is any)
            if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
                inverseRanges.push({
                    event: event0,
                    start: start,
                    end: viewEnd
                });
            }

            return inverseRanges;
        },


        // Slices the given event range into one or more segment objects.
        // A `rangeToSegsFunc` custom slicing function can be given.
        eventRangeToSegs: function (eventRange, rangeToSegsFunc) {
            var segs;
            var i, seg;

            eventRange = this.view.calendar.ensureVisibleEventRange(eventRange);

            if (rangeToSegsFunc) {
                segs = rangeToSegsFunc(eventRange);
            }
            else {
                segs = this.rangeToSegs(eventRange); // defined by the subclass
            }

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.event = eventRange.event;
                seg.eventStartMS = eventRange.eventStartMS;
                seg.eventDurationMS = eventRange.eventDurationMS;
            }

            return segs;
        },


        sortSegs: function (segs) {
            segs.sort(proxy(this, 'compareSegs'));
        },


        // A cmp function for determining which segments should take visual priority
        // DOES NOT WORK ON INVERTED BACKGROUND EVENTS because they have no eventStartMS/eventDurationMS
        compareSegs: function (seg1, seg2) {
            return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
                seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
                seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
                compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
        }

    });


    /* Utilities
----------------------------------------------------------------------------------------------------------------------*/


    function isBgEvent(event) { // returns true if background OR inverse-background
        var rendering = getEventRendering(event);
        return rendering === 'background' || rendering === 'inverse-background';
    }


    function isInverseBgEvent(event) {
        return getEventRendering(event) === 'inverse-background';
    }


    function getEventRendering(event) {
        return firstDefined((event.source || {}).rendering, event.rendering);
    }


    function groupEventsById(events) {
        var eventsById = {};
        var i, event;

        for (i = 0; i < events.length; i++) {
            event = events[i];
            (eventsById[event._id] || (eventsById[event._id] = [])).push(event);
        }

        return eventsById;
    }


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
    function compareNormalRanges(range1, range2) {
        return range1.eventStartMS - range2.eventStartMS; // earlier ranges go first
    }


    /* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
    fc.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
    function getDraggedElMeta(el) {
        var prefix = fc.dataAttrPrefix;
        var eventProps; // properties for creating the event, not related to date/time
        var startTime; // a Duration
        var duration;
        var stick;

        if (prefix) {
            prefix += '-';
        }
        eventProps = el.data(prefix + 'event') || null;

        if (eventProps) {
            if (typeof eventProps === 'object') {
                eventProps = $.extend({}, eventProps); // make a copy
            }
            else { // something like 1 or true. still signal event creation
                eventProps = {};
            }

            // pluck special-cased date/time properties
            startTime = eventProps.start;
            if (startTime == null) {
                startTime = eventProps.time;
            } // accept 'time' as well
            duration = eventProps.duration;
            stick = eventProps.stick;
            delete eventProps.start;
            delete eventProps.time;
            delete eventProps.duration;
            delete eventProps.stick;
        }

        // fallback to standalone attribute values for each of the date/time properties
        if (startTime == null) {
            startTime = el.data(prefix + 'start');
        }
        if (startTime == null) {
            startTime = el.data(prefix + 'time');
        } // accept 'time' as well
        if (duration == null) {
            duration = el.data(prefix + 'duration');
        }
        if (stick == null) {
            stick = el.data(prefix + 'stick');
        }

        // massage into correct data types
        startTime = startTime != null ? moment.duration(startTime) : null;
        duration = duration != null ? moment.duration(duration) : null;
        stick = Boolean(stick);

        return {eventProps: eventProps, startTime: startTime, duration: duration, stick: stick};
    }


    ;
    ;

    /* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/

    var DayGrid = Grid.extend({

        numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
        bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid
        breakOnWeeks: null, // should create a new row for each week? set by outside view

        cellDates: null, // flat chronological array of each cell's dates
        dayToCellOffsets: null, // maps days offsets from grid's start date, to cell offsets

        rowEls: null, // set of fake row elements
        dayEls: null, // set of whole-day elements comprising the row's background
        helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"


        constructor: function () {
            Grid.apply(this, arguments);

            this.cellDuration = moment.duration(1, 'day'); // for Grid system
        },


        // Renders the rows and columns into the component's `this.el`, which should already be assigned.
        // isRigid determins whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        renderDates: function (isRigid) {
            var view = this.view;
            var rowCnt = this.rowCnt;
            var colCnt = this.colCnt;
            var cellCnt = rowCnt * colCnt;
            var html = '';
            var row;
            var i, cell;

            for (row = 0; row < rowCnt; row++) {
                html += this.dayRowHtml(row, isRigid);
            }
            this.el.html(html);

            this.rowEls = this.el.find('.fc-row');
            this.dayEls = this.el.find('.fc-day');

            // trigger dayRender with each cell's element
            for (i = 0; i < cellCnt; i++) {
                cell = this.getCell(i);
                view.trigger('dayRender', null, cell.start, this.dayEls.eq(i));
            }
        },


        unrenderDates: function () {
            this.removeSegPopover();
        },


        renderBusinessHours: function () {
            var events = this.view.calendar.getBusinessHoursEvents(true); // wholeDay=true
            var segs = this.eventsToSegs(events);

            this.renderFill('businessHours', segs, 'bgevent');
        },


        // Generates the HTML for a single row. `row` is the row number.
        dayRowHtml: function (row, isRigid) {
            var view = this.view;
            var classes = ['fc-row', 'fc-week', view.widgetContentClass];

            if (isRigid) {
                classes.push('fc-rigid');
            }

            return '' +
                '<div class="' + classes.join(' ') + '">' +
                '<div class="fc-bg">' +
                '<table>' +
                this.rowHtml('day', row) + // leverages RowRenderer. calls dayCellHtml()
                '</table>' +
                '</div>' +
                '<div class="fc-content-skeleton">' +
                '<table>' +
                (this.numbersVisible ?
                        '<thead>' +
                        this.rowHtml('number', row) + // leverages RowRenderer. View will define render method
                        '</thead>' :
                        ''
                ) +
                '</table>' +
                '</div>' +
                '</div>';
        },


        // Renders the HTML for a whole-day cell. Will eventually end up in the day-row's background.
        // We go through a 'day' row type instead of just doing a 'bg' row type so that the View can do custom rendering
        // specifically for whole-day rows, whereas a 'bg' might also be used for other purposes (TimeGrid bg for example).
        dayCellHtml: function (cell) {
            return this.bgCellHtml(cell);
        },


        /* Options
	------------------------------------------------------------------------------------------------------------------*/


        // Computes a default column header formatting string if `colFormat` is not explicitly defined
        computeColHeadFormat: function () {
            if (this.rowCnt > 1) { // more than one week row. day numbers will be in each cell
                return 'ddd'; // "Sat"
            }
            else if (this.colCnt > 1) { // multiple days, so full single date string WON'T be in title text
                return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
            }
            else { // single day, so full single date string will probably be in title text
                return 'dddd'; // "Saturday"
            }
        },


        // Computes a default event time formatting string if `timeFormat` is not explicitly defined
        computeEventTimeFormat: function () {
            return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
        },


        // Computes a default `displayEventEnd` value if one is not expliclty defined
        computeDisplayEventEnd: function () {
            return this.colCnt == 1; // we'll likely have space if there's only one day
        },


        /* Cell System
	------------------------------------------------------------------------------------------------------------------*/


        rangeUpdated: function () {
            var cellDates;
            var firstDay;
            var rowCnt;
            var colCnt;

            this.updateCellDates(); // populates cellDates and dayToCellOffsets
            cellDates = this.cellDates;

            if (this.breakOnWeeks) {
                // count columns until the day-of-week repeats
                firstDay = cellDates[0].day();
                for (colCnt = 1; colCnt < cellDates.length; colCnt++) {
                    if (cellDates[colCnt].day() == firstDay) {
                        break;
                    }
                }
                rowCnt = Math.ceil(cellDates.length / colCnt);
            }
            else {
                rowCnt = 1;
                colCnt = cellDates.length;
            }

            this.rowCnt = rowCnt;
            this.colCnt = colCnt;
        },


        // Populates cellDates and dayToCellOffsets
        updateCellDates: function () {
            var view = this.view;
            var date = this.start.clone();
            var dates = [];
            var offset = -1;
            var offsets = [];

            while (date.isBefore(this.end)) { // loop each day from start to end
                if (view.isHiddenDay(date)) {
                    offsets.push(offset + 0.5); // mark that it's between offsets
                }
                else {
                    offset++;
                    offsets.push(offset);
                    dates.push(date.clone());
                }
                date.add(1, 'days');
            }

            this.cellDates = dates;
            this.dayToCellOffsets = offsets;
        },


        // Given a cell object, generates its start date. Returns a reference-free copy.
        computeCellDate: function (cell) {
            var colCnt = this.colCnt;
            var index = cell.row * colCnt + (this.isRTL ? colCnt - cell.col - 1 : cell.col);

            return this.cellDates[index].clone();
        },


        // Retrieves the element representing the given row
        getRowEl: function (row) {
            return this.rowEls.eq(row);
        },


        // Retrieves the element representing the given column
        getColEl: function (col) {
            return this.dayEls.eq(col);
        },


        // Gets the whole-day element associated with the cell
        getCellDayEl: function (cell) {
            return this.dayEls.eq(cell.row * this.colCnt + cell.col);
        },


        // Overrides Grid's method for when row coordinates are computed
        computeRowCoords: function () {
            var rowCoords = Grid.prototype.computeRowCoords.call(this); // call the super-method

            // hack for extending last row (used by AgendaView)
            rowCoords[rowCoords.length - 1].bottom += this.bottomCoordPadding;

            return rowCoords;
        },


        /* Dates
	------------------------------------------------------------------------------------------------------------------*/


        // Slices up a date range by row into an array of segments
        rangeToSegs: function (range) {
            var isRTL = this.isRTL;
            var rowCnt = this.rowCnt;
            var colCnt = this.colCnt;
            var segs = [];
            var first, last; // inclusive cell-offset range for given range
            var row;
            var rowFirst, rowLast; // inclusive cell-offset range for current row
            var isStart, isEnd;
            var segFirst, segLast; // inclusive cell-offset range for segment
            var seg;

            range = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
            first = this.dateToCellOffset(range.start);
            last = this.dateToCellOffset(range.end.subtract(1, 'days')); // offset of inclusive end date

            for (row = 0; row < rowCnt; row++) {
                rowFirst = row * colCnt;
                rowLast = rowFirst + colCnt - 1;

                // intersect segment's offset range with the row's
                segFirst = Math.max(rowFirst, first);
                segLast = Math.min(rowLast, last);

                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell

                if (segFirst <= segLast) { // was there any intersection with the current row?

                    // must be matching integers to be the segment's start/end
                    isStart = segFirst === first;
                    isEnd = segLast === last;

                    // translate offsets to be relative to start-of-row
                    segFirst -= rowFirst;
                    segLast -= rowFirst;

                    seg = {row: row, isStart: isStart, isEnd: isEnd};
                    if (isRTL) {
                        seg.leftCol = colCnt - segLast - 1;
                        seg.rightCol = colCnt - segFirst - 1;
                    }
                    else {
                        seg.leftCol = segFirst;
                        seg.rightCol = segLast;
                    }
                    segs.push(seg);
                }
            }

            return segs;
        },


        // Given a date, returns its chronolocial cell-offset from the first cell of the grid.
        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
        // If before the first offset, returns a negative number.
        // If after the last offset, returns an offset past the last cell offset.
        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
        dateToCellOffset: function (date) {
            var offsets = this.dayToCellOffsets;
            var day = date.diff(this.start, 'days');

            if (day < 0) {
                return offsets[0] - 1;
            }
            else if (day >= offsets.length) {
                return offsets[offsets.length - 1] + 1;
            }
            else {
                return offsets[day];
            }
        },


        /* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
        // TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


        // Renders a visual indication of an event or external element being dragged.
        // The dropLocation's end can be null. seg can be null. See Grid::renderDrag for more info.
        renderDrag: function (dropLocation, seg) {

            // always render a highlight underneath
            this.renderHighlight(this.eventRangeToSegs(dropLocation));

            // if a segment from the same calendar but another component is being dragged, render a helper event
            if (seg && !seg.el.closest(this.el).length) {

                this.renderRangeHelper(dropLocation, seg);
                this.applyDragOpacity(this.helperEls);

                return true; // a helper has been rendered
            }
        },


        // Unrenders any visual indication of a hovering event
        unrenderDrag: function () {
            this.unrenderHighlight();
            this.unrenderHelper();
        },


        /* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being resized
        renderEventResize: function (range, seg) {
            this.renderHighlight(this.eventRangeToSegs(range));
            this.renderRangeHelper(range, seg);
        },


        // Unrenders a visual indication of an event being resized
        unrenderEventResize: function () {
            this.unrenderHighlight();
            this.unrenderHelper();
        },


        /* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
        renderHelper: function (event, sourceSeg) {
            var helperNodes = [];
            var segs = this.eventsToSegs([event]);
            var rowStructs;

            segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
            rowStructs = this.renderSegRows(segs);

            // inject each new event skeleton into each associated row
            this.rowEls.each(function (row, rowNode) {
                var rowEl = $(rowNode); // the .fc-row
                var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
                var skeletonTop;

                // If there is an original segment, match the top position. Otherwise, put it at the row's top level
                if (sourceSeg && sourceSeg.row === row) {
                    skeletonTop = sourceSeg.el.position().top;
                }
                else {
                    skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
                }

                skeletonEl.css('top', skeletonTop)
                    .find('table')
                    .append(rowStructs[row].tbodyEl);

                rowEl.append(skeletonEl);
                helperNodes.push(skeletonEl[0]);
            });

            this.helperEls = $(helperNodes); // array -> jQuery set
        },


        // Unrenders any visual indication of a mock helper event
        unrenderHelper: function () {
            if (this.helperEls) {
                this.helperEls.remove();
                this.helperEls = null;
            }
        },


        /* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


        fillSegTag: 'td', // override the default tag name


        // Renders a set of rectangles over the given segments of days.
        // Only returns segments that successfully rendered.
        renderFill: function (type, segs, className) {
            var nodes = [];
            var i, seg;
            var skeletonEl;

            segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                skeletonEl = this.renderFillRow(type, seg, className);
                this.rowEls.eq(seg.row).append(skeletonEl);
                nodes.push(skeletonEl[0]);
            }

            this.elsByFill[type] = $(nodes);

            return segs;
        },


        // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
        renderFillRow: function (type, seg, className) {
            var colCnt = this.colCnt;
            var startCol = seg.leftCol;
            var endCol = seg.rightCol + 1;
            var skeletonEl;
            var trEl;

            className = className || type.toLowerCase();

            skeletonEl = $(
                '<div class="fc-' + className + '-skeleton">' +
                '<table><tr/></table>' +
                '</div>'
            );
            trEl = skeletonEl.find('tr');

            if (startCol > 0) {
                trEl.append('<td colspan="' + startCol + '"/>');
            }

            trEl.append(
                seg.el.attr('colspan', endCol - startCol)
            );

            if (endCol < colCnt) {
                trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
            }

            this.bookendCells(trEl, type);

            return skeletonEl;
        }

    });

    ;
    ;

    /* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/

    DayGrid.mixin({

        rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


        // Unrenders all events currently rendered on the grid
        unrenderEvents: function () {
            this.removeSegPopover(); // removes the "more.." events popover
            Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
        },


        // Retrieves all rendered segment objects currently rendered on the grid
        getEventSegs: function () {
            return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
                .concat(this.popoverSegs || []); // append the segments from the "more..." popover
        },


        // Renders the given background event segments onto the grid
        renderBgSegs: function (segs) {

            // don't render timed background events
            var allDaySegs = $.grep(segs, function (seg) {
                return seg.event.allDay;
            });

            return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
        },


        // Renders the given foreground event segments onto the grid
        renderFgSegs: function (segs) {
            var rowStructs;

            // render an `.el` on each seg
            // returns a subset of the segs. segs that were actually rendered
            segs = this.renderFgSegEls(segs);

            rowStructs = this.rowStructs = this.renderSegRows(segs);

            // append to each row's content skeleton
            this.rowEls.each(function (i, rowNode) {
                $(rowNode).find('.fc-content-skeleton > table').append(
                    rowStructs[i].tbodyEl
                );
            });

            return segs; // return only the segs that were actually rendered
        },


        // Unrenders all currently rendered foreground event segments
        unrenderFgSegs: function () {
            var rowStructs = this.rowStructs || [];
            var rowStruct;

            while ((rowStruct = rowStructs.pop())) {
                rowStruct.tbodyEl.remove();
            }

            this.rowStructs = null;
        },


        // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
        // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
        // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
        renderSegRows: function (segs) {
            var rowStructs = [];
            var segRows;
            var row;

            segRows = this.groupSegRows(segs); // group into nested arrays

            // iterate each row of segment groupings
            for (row = 0; row < segRows.length; row++) {
                rowStructs.push(
                    this.renderSegRow(row, segRows[row])
                );
            }

            return rowStructs;
        },


        // Builds the HTML to be used for the default element for an individual segment
        fgSegHtml: function (seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && event.allDay &&
                seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && event.allDay &&
                seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getEventSkinCss(event));
            var timeHtml = '';
            var timeText;
            var titleHtml;

            classes.unshift('fc-day-grid-event', 'fc-h-event');

            // Only display a timed events time if it is the starting segment
            if (seg.isStart) {
                timeText = this.getEventTimeText(event);
                if (timeText) {
                    timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
                }
            }

            titleHtml =
                '<span class="fc-title">' +
                (htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';

            return '<a class="' + classes.join(' ') + '"' +
                (event.url ?
                        ' href="' + htmlEscape(event.url) + '"' :
                        ''
                ) +
                (skinCss ?
                        ' style="' + skinCss + '"' :
                        ''
                ) +
                '>' +
                '<div class="fc-content">' +
                (this.isRTL ?
                        titleHtml + ' ' + timeHtml : // put a natural space in between
                        timeHtml + ' ' + titleHtml   //
                ) +
                '</div>' +
                (isResizableFromStart ?
                        '<div class="fc-resizer fc-start-resizer" />' :
                        ''
                ) +
                (isResizableFromEnd ?
                        '<div class="fc-resizer fc-end-resizer" />' :
                        ''
                ) +
                '</a>';
        },


        // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
        // the segments. Returns object with a bunch of internal data about how the render was calculated.
        // NOTE: modifies rowSegs
        renderSegRow: function (row, rowSegs) {
            var colCnt = this.colCnt;
            var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
            var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
            var tbody = $('<tbody/>');
            var segMatrix = []; // lookup for which segments are rendered into which level+col cells
            var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
            var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
            var i, levelSegs;
            var col;
            var tr;
            var j, seg;
            var td;

            // populates empty cells from the current column (`col`) to `endCol`
            function emptyCellsUntil(endCol) {
                while (col < endCol) {
                    // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                    td = (loneCellMatrix[i - 1] || [])[col];
                    if (td) {
                        td.attr(
                            'rowspan',
                            parseInt(td.attr('rowspan') || 1, 10) + 1
                        );
                    }
                    else {
                        td = $('<td/>');
                        tr.append(td);
                    }
                    cellMatrix[i][col] = td;
                    loneCellMatrix[i][col] = td;
                    col++;
                }
            }

            for (i = 0; i < levelCnt; i++) { // iterate through all levels
                levelSegs = segLevels[i];
                col = 0;
                tr = $('<tr/>');

                segMatrix.push([]);
                cellMatrix.push([]);
                loneCellMatrix.push([]);

                // levelCnt might be 1 even though there are no actual levels. protect against this.
                // this single empty row is useful for styling.
                if (levelSegs) {
                    for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
                        seg = levelSegs[j];

                        emptyCellsUntil(seg.leftCol);

                        // create a container that occupies or more columns. append the event element.
                        td = $('<td class="fc-event-container"/>').append(seg.el);
                        if (seg.leftCol != seg.rightCol) {
                            td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                        }
                        else { // a single-column segment
                            loneCellMatrix[i][col] = td;
                        }

                        while (col <= seg.rightCol) {
                            cellMatrix[i][col] = td;
                            segMatrix[i][col] = seg;
                            col++;
                        }

                        tr.append(td);
                    }
                }

                emptyCellsUntil(colCnt); // finish off the row
                this.bookendCells(tr, 'eventSkeleton');
                tbody.append(tr);
            }

            return { // a "rowStruct"
                row: row, // the row number
                tbodyEl: tbody,
                cellMatrix: cellMatrix,
                segMatrix: segMatrix,
                segLevels: segLevels,
                segs: rowSegs
            };
        },


        // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
        // NOTE: modifies segs
        buildSegLevels: function (segs) {
            var levels = [];
            var i, seg;
            var j;

            // Give preference to elements with certain criteria, so they have
            // a chance to be closer to the top.
            this.sortSegs(segs);

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];

                // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
                for (j = 0; j < levels.length; j++) {
                    if (!isDaySegCollision(seg, levels[j])) {
                        break;
                    }
                }
                // `j` now holds the desired subrow index
                seg.level = j;

                // create new level array if needed and append segment
                (levels[j] || (levels[j] = [])).push(seg);
            }

            // order segments left-to-right. very important if calendar is RTL
            for (j = 0; j < levels.length; j++) {
                levels[j].sort(compareDaySegCols);
            }

            return levels;
        },


        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
        groupSegRows: function (segs) {
            var segRows = [];
            var i;

            for (i = 0; i < this.rowCnt; i++) {
                segRows.push([]);
            }

            for (i = 0; i < segs.length; i++) {
                segRows[segs[i].row].push(segs[i]);
            }

            return segRows;
        }

    });


// Computes whether two segments' columns collide. They are assumed to be in the same row.
    function isDaySegCollision(seg, otherSegs) {
        var i, otherSeg;

        for (i = 0; i < otherSegs.length; i++) {
            otherSeg = otherSegs[i];

            if (
                otherSeg.leftCol <= seg.rightCol &&
                otherSeg.rightCol >= seg.leftCol
            ) {
                return true;
            }
        }

        return false;
    }


// A cmp function for determining the leftmost event
    function compareDaySegCols(a, b) {
        return a.leftCol - b.leftCol;
    }

    ;
    ;

    /* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

    DayGrid.mixin({

        segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
        popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


        removeSegPopover: function () {
            if (this.segPopover) {
                this.segPopover.hide(); // in handler, will call segPopover's removeElement
            }
        },


        // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
        // `levelLimit` can be false (don't limit), a number, or true (should be computed).
        limitRows: function (levelLimit) {
            var rowStructs = this.rowStructs || [];
            var row; // row #
            var rowLevelLimit;

            for (row = 0; row < rowStructs.length; row++) {
                this.unlimitRow(row);

                if (!levelLimit) {
                    rowLevelLimit = false;
                }
                else if (typeof levelLimit === 'number') {
                    rowLevelLimit = levelLimit;
                }
                else {
                    rowLevelLimit = this.computeRowLevelLimit(row);
                }

                if (rowLevelLimit !== false) {
                    this.limitRow(row, rowLevelLimit);
                }
            }
        },


        // Computes the number of levels a row will accomodate without going outside its bounds.
        // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
        // `row` is the row number.
        computeRowLevelLimit: function (row) {
            var rowEl = this.rowEls.eq(row); // the containing "fake" row div
            var rowHeight = rowEl.height(); // TODO: cache somehow?
            var trEls = this.rowStructs[row].tbodyEl.children();
            var i, trEl;
            var trHeight;

            function iterInnerHeights(i, childNode) {
                trHeight = Math.max(trHeight, $(childNode).outerHeight());
            }

            // Reveal one level <tr> at a time and stop when we find one out of bounds
            for (i = 0; i < trEls.length; i++) {
                trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

                // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
                // so instead, find the tallest inner content element.
                trHeight = 0;
                trEl.find('> td > :first-child').each(iterInnerHeights);

                if (trEl.position().top + trHeight > rowHeight) {
                    return i;
                }
            }

            return false; // should not limit at all
        },


        // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
        // `row` is the row number.
        // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
        limitRow: function (row, levelLimit) {
            var _this = this;
            var rowStruct = this.rowStructs[row];
            var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
            var col = 0; // col #, left-to-right (not chronologically)
            var cell;
            var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
            var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
            var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
            var i, seg;
            var segsBelow; // array of segment objects below `seg` in the current `col`
            var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
            var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
            var td, rowspan;
            var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
            var j;
            var moreTd, moreWrap, moreLink;

            // Iterates through empty level cells and places "more" links inside if need be
            function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
                while (col < endCol) {
                    cell = _this.getCell(row, col);
                    segsBelow = _this.getCellSegs(cell, levelLimit);
                    if (segsBelow.length) {
                        td = cellMatrix[levelLimit - 1][col];
                        moreLink = _this.renderMoreLink(cell, segsBelow);
                        moreWrap = $('<div/>').append(moreLink);
                        td.append(moreWrap);
                        moreNodes.push(moreWrap[0]);
                    }
                    col++;
                }
            }

            if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
                levelSegs = rowStruct.segLevels[levelLimit - 1];
                cellMatrix = rowStruct.cellMatrix;

                limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                    .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

                // iterate though segments in the last allowable level
                for (i = 0; i < levelSegs.length; i++) {
                    seg = levelSegs[i];
                    emptyCellsUntil(seg.leftCol); // process empty cells before the segment

                    // determine *all* segments below `seg` that occupy the same columns
                    colSegsBelow = [];
                    totalSegsBelow = 0;
                    while (col <= seg.rightCol) {
                        cell = this.getCell(row, col);
                        segsBelow = this.getCellSegs(cell, levelLimit);
                        colSegsBelow.push(segsBelow);
                        totalSegsBelow += segsBelow.length;
                        col++;
                    }

                    if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
                        td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                        rowspan = td.attr('rowspan') || 1;
                        segMoreNodes = [];

                        // make a replacement <td> for each column the segment occupies. will be one for each colspan
                        for (j = 0; j < colSegsBelow.length; j++) {
                            moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                            segsBelow = colSegsBelow[j];
                            cell = this.getCell(row, seg.leftCol + j);
                            moreLink = this.renderMoreLink(cell, [seg].concat(segsBelow)); // count seg as hidden too
                            moreWrap = $('<div/>').append(moreLink);
                            moreTd.append(moreWrap);
                            segMoreNodes.push(moreTd[0]);
                            moreNodes.push(moreTd[0]);
                        }

                        td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                        limitedNodes.push(td[0]);
                    }
                }

                emptyCellsUntil(this.colCnt); // finish off the level
                rowStruct.moreEls = $(moreNodes); // for easy undoing later
                rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
            }
        },


        // Reveals all levels and removes all "more"-related elements for a grid's row.
        // `row` is a row number.
        unlimitRow: function (row) {
            var rowStruct = this.rowStructs[row];

            if (rowStruct.moreEls) {
                rowStruct.moreEls.remove();
                rowStruct.moreEls = null;
            }

            if (rowStruct.limitedEls) {
                rowStruct.limitedEls.removeClass('fc-limited');
                rowStruct.limitedEls = null;
            }
        },


        // Renders an <a> element that represents hidden event element for a cell.
        // Responsible for attaching click handler as well.
        renderMoreLink: function (cell, hiddenSegs) {
            var _this = this;
            var view = this.view;

            return $('<a class="fc-more"/>')
                .text(
                    this.getMoreLinkText(hiddenSegs.length)
                )
                .on('click', function (ev) {
                    var clickOption = view.opt('eventLimitClick');
                    var date = cell.start;
                    var moreEl = $(this);
                    var dayEl = _this.getCellDayEl(cell);
                    var allSegs = _this.getCellSegs(cell);

                    // rescope the segments to be within the cell's date
                    var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
                    var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

                    if (typeof clickOption === 'function') {
                        // the returned value can be an atomic option
                        clickOption = view.trigger('eventLimitClick', null, {
                            date: date,
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        }, ev);
                    }

                    if (clickOption === 'popover') {
                        _this.showSegPopover(cell, moreEl, reslicedAllSegs);
                    }
                    else if (typeof clickOption === 'string') { // a view name
                        view.calendar.zoomTo(date, clickOption);
                    }
                });
        },


        // Reveals the popover that displays all events within a cell
        showSegPopover: function (cell, moreLink, segs) {
            var _this = this;
            var view = this.view;
            var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
            var topEl; // the element we want to match the top coordinate of
            var options;

            if (this.rowCnt == 1) {
                topEl = view.el; // will cause the popover to cover any sort of header
            }
            else {
                topEl = this.rowEls.eq(cell.row); // will align with top of row
            }

            options = {
                className: 'fc-more-popover',
                content: this.renderSegPopoverContent(cell, segs),
                parentEl: this.el,
                top: topEl.offset().top,
                autoHide: true, // when the user clicks elsewhere, hide the popover
                viewportConstrain: view.opt('popoverViewportConstrain'),
                hide: function () {
                    // kill everything when the popover is hidden
                    _this.segPopover.removeElement();
                    _this.segPopover = null;
                    _this.popoverSegs = null;
                }
            };

            // Determine horizontal coordinate.
            // We use the moreWrap instead of the <td> to avoid border confusion.
            if (this.isRTL) {
                options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
            }
            else {
                options.left = moreWrap.offset().left - 1; // -1 to be over cell border
            }

            this.segPopover = new Popover(options);
            this.segPopover.show();
        },


        // Builds the inner DOM contents of the segment popover
        renderSegPopoverContent: function (cell, segs) {
            var view = this.view;
            var isTheme = view.opt('theme');
            var title = cell.start.format(view.opt('dayPopoverFormat'));
            var content = $(
                '<div class="fc-header ' + view.widgetHeaderClass + '">' +
                '<span class="fc-close ' +
                (isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
                '"></span>' +
                '<span class="fc-title">' +
                htmlEscape(title) +
                '</span>' +
                '<div class="fc-clear"/>' +
                '</div>' +
                '<div class="fc-body ' + view.widgetContentClass + '">' +
                '<div class="fc-event-container"></div>' +
                '</div>'
            );
            var segContainer = content.find('.fc-event-container');
            var i;

            // render each seg's `el` and only return the visible segs
            segs = this.renderFgSegEls(segs, true); // disableResizing=true
            this.popoverSegs = segs;

            for (i = 0; i < segs.length; i++) {

                // because segments in the popover are not part of a grid coordinate system, provide a hint to any
                // grids that want to do drag-n-drop about which cell it came from
                segs[i].cell = cell;

                segContainer.append(segs[i].el);
            }

            return content;
        },


        // Given the events within an array of segment objects, reslice them to be in a single day
        resliceDaySegs: function (segs, dayDate) {

            // build an array of the original events
            var events = $.map(segs, function (seg) {
                return seg.event;
            });

            var dayStart = dayDate.clone().stripTime();
            var dayEnd = dayStart.clone().add(1, 'days');
            var dayRange = {start: dayStart, end: dayEnd};

            // slice the events with a custom slicing function
            segs = this.eventsToSegs(
                events,
                function (range) {
                    var seg = intersectionToSeg(range, dayRange); // undefind if no intersection
                    return seg ? [seg] : []; // must return an array of segments
                }
            );

            // force an order because eventsToSegs doesn't guarantee one
            this.sortSegs(segs);

            return segs;
        },


        // Generates the text that should be inside a "more" link, given the number of events it represents
        getMoreLinkText: function (num) {
            var opt = this.view.opt('eventLimitText');

            if (typeof opt === 'function') {
                return opt(num);
            }
            else {
                return '+' + num + ' ' + opt;
            }
        },


        // Returns segments within a given cell.
        // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
        getCellSegs: function (cell, startLevel) {
            var segMatrix = this.rowStructs[cell.row].segMatrix;
            var level = startLevel || 0;
            var segs = [];
            var seg;

            while (level < segMatrix.length) {
                seg = segMatrix[level][cell.col];
                if (seg) {
                    segs.push(seg);
                }
                level++;
            }

            return segs;
        }

    });

    ;
    ;

    /* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/

    var TimeGrid = Grid.extend({

        slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
        snapDuration: null, // granularity of time for dragging and selecting
        minTime: null, // Duration object that denotes the first visible time of any given day
        maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
        colDates: null, // whole-day dates for each column. left to right
        labelFormat: null, // formatting string for times running along vertical axis
        labelInterval: null, // duration of how often a label should be displayed for a slot

        dayEls: null, // cells elements in the day-row background
        slatEls: null, // elements running horizontally across all columns

        slatTops: null, // an array of top positions, relative to the container. last item holds bottom of last slot

        helperEl: null, // cell skeleton element for rendering the mock event "helper"

        businessHourSegs: null,


        constructor: function () {
            Grid.apply(this, arguments); // call the super-constructor
            this.processOptions();
        },


        // Renders the time grid into `this.el`, which should already be assigned.
        // Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
        renderDates: function () {
            this.el.html(this.renderHtml());
            this.dayEls = this.el.find('.fc-day');
            this.slatEls = this.el.find('.fc-slats tr');
        },


        renderBusinessHours: function () {
            var events = this.view.calendar.getBusinessHoursEvents();
            this.businessHourSegs = this.renderFill('businessHours', this.eventsToSegs(events), 'bgevent');
        },


        // Renders the basic HTML skeleton for the grid
        renderHtml: function () {
            return '' +
                '<div class="fc-bg">' +
                '<table>' +
                this.rowHtml('slotBg') + // leverages RowRenderer, which will call slotBgCellHtml
                '</table>' +
                '</div>' +
                '<div class="fc-slats">' +
                '<table>' +
                this.slatRowHtml() +
                '</table>' +
                '</div>';
        },


        // Renders the HTML for a vertical background cell behind the slots.
        // This method is distinct from 'bg' because we wanted a new `rowType` so the View could customize the rendering.
        slotBgCellHtml: function (cell) {
            return this.bgCellHtml(cell);
        },


        // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
        slatRowHtml: function () {
            var view = this.view;
            var isRTL = this.isRTL;
            var html = '';
            var slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations
            var slotDate; // will be on the view's first day, but we only care about its time
            var isLabeled;
            var axisHtml;

            // Calculate the time for each slot
            while (slotTime < this.maxTime) {
                slotDate = this.start.clone().time(slotTime); // after .time() will be in UTC. but that's good, avoids DST issues
                isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

                axisHtml =
                    '<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                            '<span>' + // for matchCellWidths
                            htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                            ''
                    ) +
                    '</td>';

                html +=
                    '<tr ' + (isLabeled ? '' : 'class="fc-minor"') + '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + view.widgetContentClass + '"/>' +
                    (isRTL ? axisHtml : '') +
                    "</tr>";

                slotTime.add(this.slotDuration);
            }

            return html;
        },


        /* Options
	------------------------------------------------------------------------------------------------------------------*/


        // Parses various options into properties of this object
        processOptions: function () {
            var view = this.view;
            var slotDuration = view.opt('slotDuration');
            var snapDuration = view.opt('snapDuration');
            var input;

            slotDuration = moment.duration(slotDuration);
            snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

            this.slotDuration = slotDuration;
            this.snapDuration = snapDuration;
            this.cellDuration = snapDuration; // for Grid system

            this.minTime = moment.duration(view.opt('minTime'));
            this.maxTime = moment.duration(view.opt('maxTime'));

            // might be an array value (for TimelineView).
            // if so, getting the most granular entry (the last one probably).
            input = view.opt('slotLabelFormat');
            if ($.isArray(input)) {
                input = input[input.length - 1];
            }

            this.labelFormat =
                input ||
                view.opt('axisFormat') || // deprecated
                view.opt('smallTimeFormat'); // the computed default

            input = view.opt('slotLabelInterval');
            this.labelInterval = input ?
                moment.duration(input) :
                this.computeLabelInterval(slotDuration);
        },


        // Computes an automatic value for slotLabelInterval
        computeLabelInterval: function (slotDuration) {
            var i;
            var labelInterval;
            var slotsPerLabel;

            // find the smallest stock label interval that results in more than one slots-per-label
            for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
                labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
                slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
                if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
                    return labelInterval;
                }
            }

            return moment.duration(slotDuration); // fall back. clone
        },


        // Computes a default column header formatting string if `colFormat` is not explicitly defined
        computeColHeadFormat: function () {
            if (this.colCnt > 1) { // multiple days, so full single date string WON'T be in title text
                return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
            }
            else { // single day, so full single date string will probably be in title text
                return 'dddd'; // "Saturday"
            }
        },


        // Computes a default event time formatting string if `timeFormat` is not explicitly defined
        computeEventTimeFormat: function () {
            return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
        },


        // Computes a default `displayEventEnd` value if one is not expliclty defined
        computeDisplayEventEnd: function () {
            return true;
        },


        /* Cell System
	------------------------------------------------------------------------------------------------------------------*/


        rangeUpdated: function () {
            var view = this.view;
            var colDates = [];
            var date;

            date = this.start.clone();
            while (date.isBefore(this.end)) {
                colDates.push(date.clone());
                date.add(1, 'day');
                date = view.skipHiddenDays(date);
            }

            if (this.isRTL) {
                colDates.reverse();
            }

            this.colDates = colDates;
            this.colCnt = colDates.length;
            this.rowCnt = Math.ceil((this.maxTime - this.minTime) / this.snapDuration); // # of vertical snaps
        },


        // Given a cell object, generates its start date. Returns a reference-free copy.
        computeCellDate: function (cell) {
            var date = this.colDates[cell.col];
            var time = this.computeSnapTime(cell.row);

            date = this.view.calendar.rezoneDate(date); // give it a 00:00 time
            date.time(time);

            return date;
        },


        // Retrieves the element representing the given column
        getColEl: function (col) {
            return this.dayEls.eq(col);
        },


        /* Dates
	------------------------------------------------------------------------------------------------------------------*/


        // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
        computeSnapTime: function (row) {
            return moment.duration(this.minTime + this.snapDuration * row);
        },


        // Slices up a date range by column into an array of segments
        rangeToSegs: function (range) {
            var colCnt = this.colCnt;
            var segs = [];
            var seg;
            var col;
            var colDate;
            var colRange;

            // normalize :(
            range = {
                start: range.start.clone().stripZone(),
                end: range.end.clone().stripZone()
            };

            for (col = 0; col < colCnt; col++) {
                colDate = this.colDates[col]; // will be ambig time/timezone
                colRange = {
                    start: colDate.clone().time(this.minTime),
                    end: colDate.clone().time(this.maxTime)
                };
                seg = intersectionToSeg(range, colRange); // both will be ambig timezone
                if (seg) {
                    seg.col = col;
                    segs.push(seg);
                }
            }

            return segs;
        },


        /* Coordinates
	------------------------------------------------------------------------------------------------------------------*/


        updateSize: function (isResize) { // NOT a standard Grid method
            this.computeSlatTops();

            if (isResize) {
                this.updateSegVerticals();
            }
        },


        // Computes the top/bottom coordinates of each "snap" rows
        computeRowCoords: function () {
            var originTop = this.el.offset().top;
            var items = [];
            var i;
            var item;

            for (i = 0; i < this.rowCnt; i++) {
                item = {
                    top: originTop + this.computeTimeTop(this.computeSnapTime(i))
                };
                if (i > 0) {
                    items[i - 1].bottom = item.top;
                }
                items.push(item);
            }
            item.bottom = item.top + this.computeTimeTop(this.computeSnapTime(i));

            return items;
        },


        // Computes the top coordinate, relative to the bounds of the grid, of the given date.
        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
        computeDateTop: function (date, startOfDayDate) {
            return this.computeTimeTop(
                moment.duration(
                    date.clone().stripZone() - startOfDayDate.clone().stripTime()
                )
            );
        },


        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
        computeTimeTop: function (time) {
            var slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered
            var slatIndex;
            var slatRemainder;
            var slatTop;
            var slatBottom;

            // constrain. because minTime/maxTime might be customized
            slatCoverage = Math.max(0, slatCoverage);
            slatCoverage = Math.min(this.slatEls.length, slatCoverage);

            slatIndex = Math.floor(slatCoverage); // an integer index of the furthest whole slot
            slatRemainder = slatCoverage - slatIndex;
            slatTop = this.slatTops[slatIndex]; // the top position of the furthest whole slot

            if (slatRemainder) { // time spans part-way into the slot
                slatBottom = this.slatTops[slatIndex + 1];
                return slatTop + (slatBottom - slatTop) * slatRemainder; // part-way between slots
            }
            else {
                return slatTop;
            }
        },


        // Queries each `slatEl` for its position relative to the grid's container and stores it in `slatTops`.
        // Includes the the bottom of the last slat as the last item in the array.
        computeSlatTops: function () {
            var tops = [];
            var top;

            this.slatEls.each(function (i, node) {
                top = $(node).position().top;
                tops.push(top);
            });

            tops.push(top + this.slatEls.last().outerHeight()); // bottom of the last slat

            this.slatTops = tops;
        },


        /* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being dragged over the specified date(s).
        // dropLocation's end might be null, as well as `seg`. See Grid::renderDrag for more info.
        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function (dropLocation, seg) {

            if (seg) { // if there is event information for this drag, render a helper event
                this.renderRangeHelper(dropLocation, seg);
                this.applyDragOpacity(this.helperEl);

                return true; // signal that a helper has been rendered
            }
            else {
                // otherwise, just render a highlight
                this.renderHighlight(this.eventRangeToSegs(dropLocation));
            }
        },


        // Unrenders any visual indication of an event being dragged
        unrenderDrag: function () {
            this.unrenderHelper();
            this.unrenderHighlight();
        },


        /* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of an event being resized
        renderEventResize: function (range, seg) {
            this.renderRangeHelper(range, seg);
        },


        // Unrenders any visual indication of an event being resized
        unrenderEventResize: function () {
            this.unrenderHelper();
        },


        /* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
        renderHelper: function (event, sourceSeg) {
            var segs = this.eventsToSegs([event]);
            var tableEl;
            var i, seg;
            var sourceEl;

            segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
            tableEl = this.renderSegTable(segs);

            // Try to make the segment that is in the same row as sourceSeg look the same
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                if (sourceSeg && sourceSeg.col === seg.col) {
                    sourceEl = sourceSeg.el;
                    seg.el.css({
                        left: sourceEl.css('left'),
                        right: sourceEl.css('right'),
                        'margin-left': sourceEl.css('margin-left'),
                        'margin-right': sourceEl.css('margin-right')
                    });
                }
            }

            this.helperEl = $('<div class="fc-helper-skeleton"/>')
                .append(tableEl)
                .appendTo(this.el);
        },


        // Unrenders any mock helper event
        unrenderHelper: function () {
            if (this.helperEl) {
                this.helperEl.remove();
                this.helperEl = null;
            }
        },


        /* Selection
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
        renderSelection: function (range) {
            if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered
                this.renderRangeHelper(range);
            }
            else {
                this.renderHighlight(this.selectionRangeToSegs(range));
            }
        },


        // Unrenders any visual indication of a selection
        unrenderSelection: function () {
            this.unrenderHelper();
            this.unrenderHighlight();
        },


        /* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a set of rectangles over the given time segments.
        // Only returns segments that successfully rendered.
        renderFill: function (type, segs, className) {
            var segCols;
            var skeletonEl;
            var trEl;
            var col, colSegs;
            var tdEl;
            var containerEl;
            var dayDate;
            var i, seg;

            if (segs.length) {

                segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs
                segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg

                className = className || type.toLowerCase();
                skeletonEl = $(
                    '<div class="fc-' + className + '-skeleton">' +
                    '<table><tr/></table>' +
                    '</div>'
                );
                trEl = skeletonEl.find('tr');

                for (col = 0; col < segCols.length; col++) {
                    colSegs = segCols[col];
                    tdEl = $('<td/>').appendTo(trEl);

                    if (colSegs.length) {
                        containerEl = $('<div class="fc-' + className + '-container"/>').appendTo(tdEl);
                        dayDate = this.colDates[col];

                        for (i = 0; i < colSegs.length; i++) {
                            seg = colSegs[i];
                            containerEl.append(
                                seg.el.css({
                                    top: this.computeDateTop(seg.start, dayDate),
                                    bottom: -this.computeDateTop(seg.end, dayDate) // the y position of the bottom edge
                                })
                            );
                        }
                    }
                }

                this.bookendCells(trEl, type);

                this.el.append(skeletonEl);
                this.elsByFill[type] = skeletonEl;
            }

            return segs;
        }

    });

    ;
    ;

    /* Event-rendering methods for the TimeGrid class
----------------------------------------------------------------------------------------------------------------------*/

    TimeGrid.mixin({

        eventSkeletonEl: null, // has cells with event-containers, which contain absolutely positioned event elements


        // Renders the given foreground event segments onto the grid
        renderFgSegs: function (segs) {
            segs = this.renderFgSegEls(segs); // returns a subset of the segs. segs that were actually rendered

            this.el.append(
                this.eventSkeletonEl = $('<div class="fc-content-skeleton"/>')
                    .append(this.renderSegTable(segs))
            );

            return segs; // return only the segs that were actually rendered
        },


        // Unrenders all currently rendered foreground event segments
        unrenderFgSegs: function (segs) {
            if (this.eventSkeletonEl) {
                this.eventSkeletonEl.remove();
                this.eventSkeletonEl = null;
            }
        },


        // Renders and returns the <table> portion of the event-skeleton.
        // Returns an object with properties 'tbodyEl' and 'segs'.
        renderSegTable: function (segs) {
            var tableEl = $('<table><tr/></table>');
            var trEl = tableEl.find('tr');
            var segCols;
            var i, seg;
            var col, colSegs;
            var containerEl;

            segCols = this.groupSegCols(segs); // group into sub-arrays, and assigns 'col' to each seg

            this.computeSegVerticals(segs); // compute and assign top/bottom

            for (col = 0; col < segCols.length; col++) { // iterate each column grouping
                colSegs = segCols[col];
                this.placeSlotSegs(colSegs); // compute horizontal coordinates, z-index's, and reorder the array

                containerEl = $('<div class="fc-event-container"/>');

                // assign positioning CSS and insert into container
                for (i = 0; i < colSegs.length; i++) {
                    seg = colSegs[i];
                    seg.el.css(this.generateSegPositionCss(seg));

                    // if the height is short, add a className for alternate styling
                    if (seg.bottom - seg.top < 30) {
                        seg.el.addClass('fc-short');
                    }

                    containerEl.append(seg.el);
                }

                trEl.append($('<td/>').append(containerEl));
            }

            this.bookendCells(trEl, 'eventSkeleton');

            return tableEl;
        },


        // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
        // NOTE: Also reorders the given array by date!
        placeSlotSegs: function (segs) {
            var levels;
            var level0;
            var i;

            this.sortSegs(segs); // order by date
            levels = buildSlotSegLevels(segs);
            computeForwardSlotSegs(levels);

            if ((level0 = levels[0])) {

                for (i = 0; i < level0.length; i++) {
                    computeSlotSegPressures(level0[i]);
                }

                for (i = 0; i < level0.length; i++) {
                    this.computeSlotSegCoords(level0[i], 0, 0);
                }
            }
        },


        // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
        // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
        // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
        //
        // The segment might be part of a "series", which means consecutive segments with the same pressure
        // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
        // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
        // coordinate of the first segment in the series.
        computeSlotSegCoords: function (seg, seriesBackwardPressure, seriesBackwardCoord) {
            var forwardSegs = seg.forwardSegs;
            var i;

            if (seg.forwardCoord === undefined) { // not already computed

                if (!forwardSegs.length) {

                    // if there are no forward segments, this segment should butt up against the edge
                    seg.forwardCoord = 1;
                }
                else {

                    // sort highest pressure first
                    this.sortForwardSlotSegs(forwardSegs);

                    // this segment's forwardCoord will be calculated from the backwardCoord of the
                    // highest-pressure forward segment.
                    this.computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                    seg.forwardCoord = forwardSegs[0].backwardCoord;
                }

                // calculate the backwardCoord from the forwardCoord. consider the series
                seg.backwardCoord = seg.forwardCoord -
                    (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series

                // use this segment's coordinates to computed the coordinates of the less-pressurized
                // forward segments
                for (i = 0; i < forwardSegs.length; i++) {
                    this.computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
                }
            }
        },


        // Refreshes the CSS top/bottom coordinates for each segment element. Probably after a window resize/zoom.
        // Repositions business hours segs too, so not just for events. Maybe shouldn't be here.
        updateSegVerticals: function () {
            var allSegs = (this.segs || []).concat(this.businessHourSegs || []);
            var i;

            this.computeSegVerticals(allSegs);

            for (i = 0; i < allSegs.length; i++) {
                allSegs[i].el.css(
                    this.generateSegVerticalCss(allSegs[i])
                );
            }
        },


        // For each segment in an array, computes and assigns its top and bottom properties
        computeSegVerticals: function (segs) {
            var i, seg;

            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.top = this.computeDateTop(seg.start, seg.start);
                seg.bottom = this.computeDateTop(seg.end, seg.start);
            }
        },


        // Renders the HTML for a single event segment's default rendering
        fgSegHtml: function (seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getEventSkinCss(event));
            var timeText;
            var fullTimeText; // more verbose time text. for the print stylesheet
            var startTimeText; // just the start time text

            classes.unshift('fc-time-grid-event', 'fc-v-event');

            if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
                // Don't display time text on segments that run entirely through a day.
                // That would appear as midnight-midnight and would look dumb.
                // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
                if (seg.isStart || seg.isEnd) {
                    timeText = this.getEventTimeText(seg);
                    fullTimeText = this.getEventTimeText(seg, 'LT');
                    startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
                }
            } else {
                // Display the normal time text for the *event's* times
                timeText = this.getEventTimeText(event);
                fullTimeText = this.getEventTimeText(event, 'LT');
                startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
            }

            return '<a class="' + classes.join(' ') + '"' +
                (event.url ?
                        ' href="' + htmlEscape(event.url) + '"' :
                        ''
                ) +
                (skinCss ?
                        ' style="' + skinCss + '"' :
                        ''
                ) +
                '>' +
                '<div class="fc-content">' +
                (timeText ?
                        '<div class="fc-time"' +
                        ' data-start="' + htmlEscape(startTimeText) + '"' +
                        ' data-full="' + htmlEscape(fullTimeText) + '"' +
                        '>' +
                        '<span>' + htmlEscape(timeText) + '</span>' +
                        '</div>' :
                        ''
                ) +
                (event.title ?
                        '<div class="fc-title">' +
                        htmlEscape(event.title) +
                        '</div>' :
                        ''
                ) +
                '</div>' +
                '<div class="fc-bg"/>' +
                /* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/
                (isResizableFromEnd ?
                        '<div class="fc-resizer fc-end-resizer" />' :
                        ''
                ) +
                '</a>';
        },


        // Generates an object with CSS properties/values that should be applied to an event segment element.
        // Contains important positioning-related properties that should be applied to any event element, customized or not.
        generateSegPositionCss: function (seg) {
            var shouldOverlap = this.view.opt('slotEventOverlap');
            var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
            var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
            var props = this.generateSegVerticalCss(seg); // get top/bottom first
            var left; // amount of space from left edge, a fraction of the total width
            var right; // amount of space from right edge, a fraction of the total width

            if (shouldOverlap) {
                // double the width, but don't go beyond the maximum forward coordinate (1.0)
                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
            }

            if (this.isRTL) {
                left = 1 - forwardCoord;
                right = backwardCoord;
            }
            else {
                left = backwardCoord;
                right = 1 - forwardCoord;
            }

            props.zIndex = seg.level + 1; // convert from 0-base to 1-based
            props.left = left * 100 + '%';
            props.right = right * 100 + '%';

            if (shouldOverlap && seg.forwardPressure) {
                // add padding to the edge so that forward stacked events don't cover the resizer's icon
                props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
            }

            return props;
        },


        // Generates an object with CSS properties for the top/bottom coordinates of a segment element
        generateSegVerticalCss: function (seg) {
            return {
                top: seg.top,
                bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
            };
        },


        // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
        groupSegCols: function (segs) {
            var segCols = [];
            var i;

            for (i = 0; i < this.colCnt; i++) {
                segCols.push([]);
            }

            for (i = 0; i < segs.length; i++) {
                segCols[segs[i].col].push(segs[i]);
            }

            return segCols;
        },


        sortForwardSlotSegs: function (forwardSegs) {
            forwardSegs.sort(proxy(this, 'compareForwardSlotSegs'));
        },


        // A cmp function for determining which forward segment to rely on more when computing coordinates.
        compareForwardSlotSegs: function (seg1, seg2) {
            // put higher-pressure first
            return seg2.forwardPressure - seg1.forwardPressure ||
                // put segments that are closer to initial edge first (and favor ones with no coords yet)
                (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
                // do normal sorting...
                this.compareSegs(seg1, seg2);
        }

    });


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
    function buildSlotSegLevels(segs) {
        var levels = [];
        var i, seg;
        var j;

        for (i = 0; i < segs.length; i++) {
            seg = segs[i];

            // go through all the levels and stop on the first level where there are no collisions
            for (j = 0; j < levels.length; j++) {
                if (!computeSlotSegCollisions(seg, levels[j]).length) {
                    break;
                }
            }

            seg.level = j;

            (levels[j] || (levels[j] = [])).push(seg);
        }

        return levels;
    }


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
    function computeForwardSlotSegs(levels) {
        var i, level;
        var j, seg;
        var k;

        for (i = 0; i < levels.length; i++) {
            level = levels[i];

            for (j = 0; j < level.length; j++) {
                seg = level[j];

                seg.forwardSegs = [];
                for (k = i + 1; k < levels.length; k++) {
                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
                }
            }
        }
    }


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
    function computeSlotSegPressures(seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i, forwardSeg;

        if (seg.forwardPressure === undefined) { // not already computed

            for (i = 0; i < forwardSegs.length; i++) {
                forwardSeg = forwardSegs[i];

                // figure out the child's maximum forward path
                computeSlotSegPressures(forwardSeg);

                // either use the existing maximum, or use the child's forward pressure
                // plus one (for the forwardSeg itself)
                forwardPressure = Math.max(
                    forwardPressure,
                    1 + forwardSeg.forwardPressure
                );
            }

            seg.forwardPressure = forwardPressure;
        }
    }


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
    function computeSlotSegCollisions(seg, otherSegs, results) {
        results = results || [];

        for (var i = 0; i < otherSegs.length; i++) {
            if (isSlotSegCollision(seg, otherSegs[i])) {
                results.push(otherSegs[i]);
            }
        }

        return results;
    }


// Do these segments occupy the same vertical space?
    function isSlotSegCollision(seg1, seg2) {
        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
    }

    ;
    ;

    /* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/

    var View = fc.View = Class.extend({

        type: null, // subclass' view name (string)
        name: null, // deprecated. use `type` instead
        title: null, // the text that will be displayed in the header's title

        calendar: null, // owner Calendar object
        options: null, // hash containing all options. already merged with view-specific-options
        coordMap: null, // a CoordMap object for converting pixel regions to dates
        el: null, // the view's containing element. set by Calendar

        displaying: null, // a promise representing the state of rendering. null if no render requested
        isSkeletonRendered: false,
        isEventsRendered: false,

        // range the view is actually displaying (moments)
        start: null,
        end: null, // exclusive

        // range the view is formally responsible for (moments)
        // may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates
        intervalStart: null,
        intervalEnd: null, // exclusive
        intervalDuration: null,
        intervalUnit: null, // name of largest unit being displayed, like "month" or "week"

        isRTL: false,
        isSelected: false, // boolean whether a range of time is user-selected or not

        eventOrderSpecs: null, // criteria for ordering events when they have same date/time

        // subclasses can optionally use a scroll container
        scrollerEl: null, // the element that will most likely scroll when content is too tall
        scrollTop: null, // cached vertical scroll value

        // classNames styled by jqui themes
        widgetHeaderClass: null,
        widgetContentClass: null,
        highlightStateClass: null,

        // for date utils, computed from options
        nextDayThreshold: null,
        isHiddenDayHash: null,

        // document handlers, bound to `this` object
        documentMousedownProxy: null, // TODO: doesn't work with touch


        constructor: function (calendar, type, options, intervalDuration) {

            this.calendar = calendar;
            this.type = this.name = type; // .name is deprecated
            this.options = options;
            this.intervalDuration = intervalDuration || moment.duration(1, 'day');

            this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
            this.initThemingProps();
            this.initHiddenDays();
            this.isRTL = this.opt('isRTL');

            this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

            this.documentMousedownProxy = proxy(this, 'documentMousedown');

            this.initialize();
        },


        // A good place for subclasses to initialize member variables
        initialize: function () {
            // subclasses can implement
        },


        // Retrieves an option with the given name
        opt: function (name) {
            return this.options[name];
        },


        // Triggers handlers that are view-related. Modifies args before passing to calendar.
        trigger: function (name, thisObj) { // arguments beyond thisObj are passed along
            var calendar = this.calendar;

            return calendar.trigger.apply(
                calendar,
                [name, thisObj || this].concat(
                    Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
                    [this] // always make the last argument a reference to the view. TODO: deprecate
                )
            );
        },


        /* Dates
	------------------------------------------------------------------------------------------------------------------*/


        // Updates all internal dates to center around the given current date
        setDate: function (date) {
            this.setRange(this.computeRange(date));
        },


        // Updates all internal dates for displaying the given range.
        // Expects all values to be normalized (like what computeRange does).
        setRange: function (range) {
            $.extend(this, range);
            this.updateTitle();
        },


        // Given a single current date, produce information about what range to display.
        // Subclasses can override. Must return all properties.
        computeRange: function (date) {
            var intervalUnit = computeIntervalUnit(this.intervalDuration);
            var intervalStart = date.clone().startOf(intervalUnit);
            var intervalEnd = intervalStart.clone().add(this.intervalDuration);
            var start, end;

            // normalize the range's time-ambiguity
            if (/year|month|week|day/.test(intervalUnit)) { // whole-days?
                intervalStart.stripTime();
                intervalEnd.stripTime();
            }
            else { // needs to have a time?
                if (!intervalStart.hasTime()) {
                    intervalStart = this.calendar.rezoneDate(intervalStart); // convert to current timezone, with 00:00
                }
                if (!intervalEnd.hasTime()) {
                    intervalEnd = this.calendar.rezoneDate(intervalEnd); // convert to current timezone, with 00:00
                }
            }

            start = intervalStart.clone();
            start = this.skipHiddenDays(start);
            end = intervalEnd.clone();
            end = this.skipHiddenDays(end, -1, true); // exclusively move backwards

            return {
                intervalUnit: intervalUnit,
                intervalStart: intervalStart,
                intervalEnd: intervalEnd,
                start: start,
                end: end
            };
        },


        // Computes the new date when the user hits the prev button, given the current date
        computePrevDate: function (date) {
            return this.massageCurrentDate(
                date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1
            );
        },


        // Computes the new date when the user hits the next button, given the current date
        computeNextDate: function (date) {
            return this.massageCurrentDate(
                date.clone().startOf(this.intervalUnit).add(this.intervalDuration)
            );
        },


        // Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely
        // visible. `direction` is optional and indicates which direction the current date was being
        // incremented or decremented (1 or -1).
        massageCurrentDate: function (date, direction) {
            if (this.intervalDuration.as('days') <= 1) { // if the view displays a single day or smaller
                if (this.isHiddenDay(date)) {
                    date = this.skipHiddenDays(date, direction);
                    date.startOf('day');
                }
            }

            return date;
        },


        /* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/


        // Sets the view's title property to the most updated computed value
        updateTitle: function () {
            this.title = this.computeTitle();
        },


        // Computes what the title at the top of the calendar should be for this view
        computeTitle: function () {
            return this.formatRange(
                {start: this.intervalStart, end: this.intervalEnd},
                this.opt('titleFormat') || this.computeTitleFormat(),
                this.opt('titleRangeSeparator')
            );
        },


        // Generates the format string that should be used to generate the title for the current date range.
        // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
        computeTitleFormat: function () {
            if (this.intervalUnit == 'year') {
                return 'YYYY';
            }
            else if (this.intervalUnit == 'month') {
                return this.opt('monthYearFormat'); // like "September 2014"
            }
            else if (this.intervalDuration.as('days') > 1) {
                return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
            }
            else {
                return 'LL'; // one day. longer, like "September 9 2014"
            }
        },


        // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
        // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
        formatRange: function (range, formatStr, separator) {
            var end = range.end;

            if (!end.hasTime()) { // all-day?
                end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
            }

            return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
        },


        /* Rendering
	------------------------------------------------------------------------------------------------------------------*/


        // Sets the container element that the view should render inside of.
        // Does other DOM-related initializations.
        setElement: function (el) {
            this.el = el;
            this.bindGlobalHandlers();
        },


        // Removes the view's container element from the DOM, clearing any content beforehand.
        // Undoes any other DOM-related attachments.
        removeElement: function () {
            this.clear(); // clears all content

            // clean up the skeleton
            if (this.isSkeletonRendered) {
                this.unrenderSkeleton();
                this.isSkeletonRendered = false;
            }

            this.unbindGlobalHandlers();

            this.el.remove();

            // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
            // We don't null-out the View's other jQuery element references upon destroy,
            //  so we shouldn't kill this.el either.
        },


        // Does everything necessary to display the view centered around the given date.
        // Does every type of rendering EXCEPT rendering events.
        // Is asychronous and returns a promise.
        display: function (date) {
            var _this = this;
            var scrollState = null;

            if (this.displaying) {
                scrollState = this.queryScroll();
            }

            return this.clear().then(function () { // clear the content first (async)
                return (
                    _this.displaying =
                        $.when(_this.displayView(date)) // displayView might return a promise
                            .then(function () {
                                _this.forceScroll(_this.computeInitialScroll(scrollState));
                                _this.triggerRender();
                            })
                );
            });
        },


        // Does everything necessary to clear the content of the view.
        // Clears dates and events. Does not clear the skeleton.
        // Is asychronous and returns a promise.
        clear: function () {
            var _this = this;
            var displaying = this.displaying;

            if (displaying) { // previously displayed, or in the process of being displayed?
                return displaying.then(function () { // wait for the display to finish
                    _this.displaying = null;
                    _this.clearEvents();
                    return _this.clearView(); // might return a promise. chain it
                });
            }
            else {
                return $.when(); // an immediately-resolved promise
            }
        },


        // Displays the view's non-event content, such as date-related content or anything required by events.
        // Renders the view's non-content skeleton if necessary.
        // Can be asynchronous and return a promise.
        displayView: function (date) {
            if (!this.isSkeletonRendered) {
                this.renderSkeleton();
                this.isSkeletonRendered = true;
            }
            this.setDate(date);
            if (this.render) {
                this.render(); // TODO: deprecate
            }
            this.renderDates();
            this.updateSize();
            this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
        },


        // Unrenders the view content that was rendered in displayView.
        // Can be asynchronous and return a promise.
        clearView: function () {
            this.unselect();
            this.triggerUnrender();
            this.unrenderBusinessHours();
            this.unrenderDates();
            if (this.destroy) {
                this.destroy(); // TODO: deprecate
            }
        },


        // Renders the basic structure of the view before any content is rendered
        renderSkeleton: function () {
            // subclasses should implement
        },


        // Unrenders the basic structure of the view
        unrenderSkeleton: function () {
            // subclasses should implement
        },


        // Renders the view's date-related content (like cells that represent days/times).
        // Assumes setRange has already been called and the skeleton has already been rendered.
        renderDates: function () {
            // subclasses should implement
        },


        // Unrenders the view's date-related content
        unrenderDates: function () {
            // subclasses should override
        },


        // Renders business-hours onto the view. Assumes updateSize has already been called.
        renderBusinessHours: function () {
            // subclasses should implement
        },


        // Unrenders previously-rendered business-hours
        unrenderBusinessHours: function () {
            // subclasses should implement
        },


        // Signals that the view's content has been rendered
        triggerRender: function () {
            this.trigger('viewRender', this, this, this.el);
        },


        // Signals that the view's content is about to be unrendered
        triggerUnrender: function () {
            this.trigger('viewDestroy', this, this, this.el);
        },


        // Binds DOM handlers to elements that reside outside the view container, such as the document
        bindGlobalHandlers: function () {
            $(document).on('mousedown', this.documentMousedownProxy);
        },


        // Unbinds DOM handlers from elements that reside outside the view container
        unbindGlobalHandlers: function () {
            $(document).off('mousedown', this.documentMousedownProxy);
        },


        // Initializes internal variables related to theming
        initThemingProps: function () {
            var tm = this.opt('theme') ? 'ui' : 'fc';

            this.widgetHeaderClass = tm + '-widget-header';
            this.widgetContentClass = tm + '-widget-content';
            this.highlightStateClass = tm + '-state-highlight';
        },


        /* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


        // Refreshes anything dependant upon sizing of the container element of the grid
        updateSize: function (isResize) {
            var scrollState;

            if (isResize) {
                scrollState = this.queryScroll();
            }

            this.updateHeight(isResize);
            this.updateWidth(isResize);

            if (isResize) {
                this.setScroll(scrollState);
            }
        },


        // Refreshes the horizontal dimensions of the calendar
        updateWidth: function (isResize) {
            // subclasses should implement
        },


        // Refreshes the vertical dimensions of the calendar
        updateHeight: function (isResize) {
            var calendar = this.calendar; // we poll the calendar for height information

            this.setHeight(
                calendar.getSuggestedViewHeight(),
                calendar.isHeightAuto()
            );
        },


        // Updates the vertical dimensions of the calendar to the specified height.
        // if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
        setHeight: function (height, isAuto) {
            // subclasses should implement
        },


        /* Scroller
	------------------------------------------------------------------------------------------------------------------*/


        // Given the total height of the view, return the number of pixels that should be used for the scroller.
        // Utility for subclasses.
        computeScrollerHeight: function (totalHeight) {
            var scrollerEl = this.scrollerEl;
            var both;
            var otherHeight; // cumulative height of everything that is not the scrollerEl in the view (header+borders)

            both = this.el.add(scrollerEl);

            // fuckin IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
            both.css({
                position: 'relative', // cause a reflow, which will force fresh dimension recalculation
                left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
            });
            otherHeight = this.el.outerHeight() - scrollerEl.height(); // grab the dimensions
            both.css({position: '', left: ''}); // undo hack

            return totalHeight - otherHeight;
        },


        // Computes the initial pre-configured scroll state prior to allowing the user to change it.
        // Given the scroll state from the previous rendering. If first time rendering, given null.
        computeInitialScroll: function (previousScrollState) {
            return 0;
        },


        // Retrieves the view's current natural scroll state. Can return an arbitrary format.
        queryScroll: function () {
            if (this.scrollerEl) {
                return this.scrollerEl.scrollTop(); // operates on scrollerEl by default
            }
        },


        // Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.
        setScroll: function (scrollState) {
            if (this.scrollerEl) {
                return this.scrollerEl.scrollTop(scrollState); // operates on scrollerEl by default
            }
        },


        // Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind
        forceScroll: function (scrollState) {
            var _this = this;

            this.setScroll(scrollState);
            setTimeout(function () {
                _this.setScroll(scrollState);
            }, 0);
        },


        /* Event Elements / Segments
	------------------------------------------------------------------------------------------------------------------*/


        // Does everything necessary to display the given events onto the current view
        displayEvents: function (events) {
            var scrollState = this.queryScroll();

            this.clearEvents();
            this.renderEvents(events);
            this.isEventsRendered = true;
            this.setScroll(scrollState);
            this.triggerEventRender();
        },


        // Does everything necessary to clear the view's currently-rendered events
        clearEvents: function () {
            if (this.isEventsRendered) {
                this.triggerEventUnrender();
                if (this.destroyEvents) {
                    this.destroyEvents(); // TODO: deprecate
                }
                this.unrenderEvents();
                this.isEventsRendered = false;
            }
        },


        // Renders the events onto the view.
        renderEvents: function (events) {
            // subclasses should implement
        },


        // Removes event elements from the view.
        unrenderEvents: function () {
            // subclasses should implement
        },


        // Signals that all events have been rendered
        triggerEventRender: function () {
            this.renderedEventSegEach(function (seg) {
                this.trigger('eventAfterRender', seg.event, seg.event, seg.el);
            });
            this.trigger('eventAfterAllRender');
        },


        // Signals that all event elements are about to be removed
        triggerEventUnrender: function () {
            this.renderedEventSegEach(function (seg) {
                this.trigger('eventDestroy', seg.event, seg.event, seg.el);
            });
        },


        // Given an event and the default element used for rendering, returns the element that should actually be used.
        // Basically runs events and elements through the eventRender hook.
        resolveEventEl: function (event, el) {
            var custom = this.trigger('eventRender', event, event, el);

            if (custom === false) { // means don't render at all
                el = null;
            }
            else if (custom && custom !== true) {
                el = $(custom);
            }

            return el;
        },


        // Hides all rendered event segments linked to the given event
        showEvent: function (event) {
            this.renderedEventSegEach(function (seg) {
                seg.el.css('visibility', '');
            }, event);
        },


        // Shows all rendered event segments linked to the given event
        hideEvent: function (event) {
            this.renderedEventSegEach(function (seg) {
                seg.el.css('visibility', 'hidden');
            }, event);
        },


        // Iterates through event segments that have been rendered (have an el). Goes through all by default.
        // If the optional `event` argument is specified, only iterates through segments linked to that event.
        // The `this` value of the callback function will be the view.
        renderedEventSegEach: function (func, event) {
            var segs = this.getEventSegs();
            var i;

            for (i = 0; i < segs.length; i++) {
                if (!event || segs[i].event._id === event._id) {
                    if (segs[i].el) {
                        func.call(this, segs[i]);
                    }
                }
            }
        },


        // Retrieves all the rendered segment objects for the view
        getEventSegs: function () {
            // subclasses must implement
            return [];
        },


        /* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


        // Computes if the given event is allowed to be dragged by the user
        isEventDraggable: function (event) {
            var source = event.source || {};

            return firstDefined(
                event.startEditable,
                source.startEditable,
                this.opt('eventStartEditable'),
                event.editable,
                source.editable,
                this.opt('editable')
            );
        },


        // Must be called when an event in the view is dropped onto new location.
        // `dropLocation` is an object that contains the new start/end/allDay values for the event.
        reportEventDrop: function (event, dropLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
            var undoFunc = function () {
                mutateResult.undo();
                calendar.reportEventChange();
            };

            this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
            calendar.reportEventChange(); // will rerender events
        },


        // Triggers event-drop handlers that have subscribed via the API
        triggerEventDrop: function (event, dateDelta, undoFunc, el, ev) {
            this.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
        },


        /* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


        // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
        // `meta` is the parsed data that has been embedded into the dragging event.
        // `dropLocation` is an object that contains the new start/end/allDay values for the event.
        reportExternalDrop: function (meta, dropLocation, el, ev, ui) {
            var eventProps = meta.eventProps;
            var eventInput;
            var event;

            // Try to build an event object and render it. TODO: decouple the two
            if (eventProps) {
                eventInput = $.extend({}, eventProps, dropLocation);
                event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
            }

            this.triggerExternalDrop(event, dropLocation, el, ev, ui);
        },


        // Triggers external-drop handlers that have subscribed via the API
        triggerExternalDrop: function (event, dropLocation, el, ev, ui) {

            // trigger 'drop' regardless of whether element represents an event
            this.trigger('drop', el[0], dropLocation.start, ev, ui);

            if (event) {
                this.trigger('eventReceive', null, event); // signal an external event landed
            }
        },


        /* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a event or external-element drag over the given drop zone.
        // If an external-element, seg will be `null`
        renderDrag: function (dropLocation, seg) {
            // subclasses must implement
        },


        // Unrenders a visual indication of an event or external-element being dragged.
        unrenderDrag: function () {
            // subclasses must implement
        },


        /* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/


        // Computes if the given event is allowed to be resized from its starting edge
        isEventResizableFromStart: function (event) {
            return this.opt('eventResizableFromStart') && this.isEventResizable(event);
        },


        // Computes if the given event is allowed to be resized from its ending edge
        isEventResizableFromEnd: function (event) {
            return this.isEventResizable(event);
        },


        // Computes if the given event is allowed to be resized by the user at all
        isEventResizable: function (event) {
            var source = event.source || {};

            return firstDefined(
                event.durationEditable,
                source.durationEditable,
                this.opt('eventDurationEditable'),
                event.editable,
                source.editable,
                this.opt('editable')
            );
        },


        // Must be called when an event in the view has been resized to a new length
        reportEventResize: function (event, resizeLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
            var undoFunc = function () {
                mutateResult.undo();
                calendar.reportEventChange();
            };

            this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
            calendar.reportEventChange(); // will rerender events
        },


        // Triggers event-resize handlers that have subscribed via the API
        triggerEventResize: function (event, durationDelta, undoFunc, el, ev) {
            this.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
        },


        /* Selection
	------------------------------------------------------------------------------------------------------------------*/


        // Selects a date range on the view. `start` and `end` are both Moments.
        // `ev` is the native mouse event that begin the interaction.
        select: function (range, ev) {
            this.unselect(ev);
            this.renderSelection(range);
            this.reportSelection(range, ev);
        },


        // Renders a visual indication of the selection
        renderSelection: function (range) {
            // subclasses should implement
        },


        // Called when a new selection is made. Updates internal state and triggers handlers.
        reportSelection: function (range, ev) {
            this.isSelected = true;
            this.triggerSelect(range, ev);
        },


        // Triggers handlers to 'select'
        triggerSelect: function (range, ev) {
            this.trigger('select', null, range.start, range.end, ev);
        },


        // Undoes a selection. updates in the internal state and triggers handlers.
        // `ev` is the native mouse event that began the interaction.
        unselect: function (ev) {
            if (this.isSelected) {
                this.isSelected = false;
                if (this.destroySelection) {
                    this.destroySelection(); // TODO: deprecate
                }
                this.unrenderSelection();
                this.trigger('unselect', null, ev);
            }
        },


        // Unrenders a visual indication of selection
        unrenderSelection: function () {
            // subclasses should implement
        },


        // Handler for unselecting when the user clicks something and the 'unselectAuto' setting is on
        documentMousedown: function (ev) {
            var ignore;

            // is there a selection, and has the user made a proper left click?
            if (this.isSelected && this.opt('unselectAuto') && isPrimaryMouseButton(ev)) {

                // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
                ignore = this.opt('unselectCancel');
                if (!ignore || !$(ev.target).closest(ignore).length) {
                    this.unselect(ev);
                }
            }
        },


        /* Day Click
	------------------------------------------------------------------------------------------------------------------*/


        // Triggers handlers to 'dayClick'
        triggerDayClick: function (cell, dayEl, ev) {
            this.trigger('dayClick', dayEl, cell.start, ev);
        },


        /* Date Utils
	------------------------------------------------------------------------------------------------------------------*/


        // Initializes internal variables related to calculating hidden days-of-week
        initHiddenDays: function () {
            var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
            var dayCnt = 0;
            var i;

            if (this.opt('weekends') === false) {
                hiddenDays.push(0, 6); // 0=sunday, 6=saturday
            }

            for (i = 0; i < 7; i++) {
                if (
                    !(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
                ) {
                    dayCnt++;
                }
            }

            if (!dayCnt) {
                throw 'invalid hiddenDays'; // all days were hidden? bad.
            }

            this.isHiddenDayHash = isHiddenDayHash;
        },


        // Is the current day hidden?
        // `day` is a day-of-week index (0-6), or a Moment
        isHiddenDay: function (day) {
            if (moment.isMoment(day)) {
                day = day.day();
            }
            return this.isHiddenDayHash[day];
        },


        // Incrementing the current day until it is no longer a hidden day, returning a copy.
        // If the initial value of `date` is not a hidden day, don't do anything.
        // Pass `isExclusive` as `true` if you are dealing with an end date.
        // `inc` defaults to `1` (increment one day forward each time)
        skipHiddenDays: function (date, inc, isExclusive) {
            var out = date.clone();
            inc = inc || 1;
            while (
                this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
                ) {
                out.add(inc, 'days');
            }
            return out;
        },


        // Returns the date range of the full days the given range visually appears to occupy.
        // Returns a new range object.
        computeDayRange: function (range) {
            var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
            var end = range.end;
            var endDay = null;
            var endTimeMS;

            if (end) {
                endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
                endTimeMS = +end.time(); // # of milliseconds into `endDay`

                // If the end time is actually inclusively part of the next day and is equal to or
                // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
                // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
                if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
                    endDay.add(1, 'days');
                }
            }

            // If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
            // assign the default duration of one day.
            if (!end || endDay <= startDay) {
                endDay = startDay.clone().add(1, 'days');
            }

            return {start: startDay, end: endDay};
        },


        // Does the given event visually appear to occupy more than one day?
        isMultiDayEvent: function (event) {
            var range = this.computeDayRange(event); // event is range-ish

            return range.end.diff(range.start, 'days') > 1;
        }

    });

    ;
    ;

    var Calendar = fc.Calendar = Class.extend({

        dirDefaults: null, // option defaults related to LTR or RTL
        langDefaults: null, // option defaults related to current locale
        overrides: null, // option overrides given to the fullCalendar constructor
        options: null, // all defaults combined with overrides
        viewSpecCache: null, // cache of view definitions
        view: null, // current View object
        header: null,
        loadingLevel: 0, // number of simultaneous loading tasks


        // a lot of this class' OOP logic is scoped within this constructor function,
        // but in the future, write individual methods on the prototype.
        constructor: Calendar_constructor,


        // Subclasses can override this for initialization logic after the constructor has been called
        initialize: function () {
        },


        // Initializes `this.options` and other important options-related objects
        initOptions: function (overrides) {
            var lang, langDefaults;
            var isRTL, dirDefaults;

            // converts legacy options into non-legacy ones.
            // in the future, when this is removed, don't use `overrides` reference. make a copy.
            overrides = massageOverrides(overrides);

            lang = overrides.lang;
            langDefaults = langOptionHash[lang];
            if (!langDefaults) {
                lang = Calendar.defaults.lang;
                langDefaults = langOptionHash[lang] || {};
            }

            isRTL = firstDefined(
                overrides.isRTL,
                langDefaults.isRTL,
                Calendar.defaults.isRTL
            );
            dirDefaults = isRTL ? Calendar.rtlDefaults : {};

            this.dirDefaults = dirDefaults;
            this.langDefaults = langDefaults;
            this.overrides = overrides;
            this.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
                Calendar.defaults, // global defaults
                dirDefaults,
                langDefaults,
                overrides
            ]);
            populateInstanceComputableOptions(this.options);

            this.viewSpecCache = {}; // somewhat unrelated
        },


        // Gets information about how to create a view. Will use a cache.
        getViewSpec: function (viewType) {
            var cache = this.viewSpecCache;

            return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
        },


        // Given a duration singular unit, like "week" or "day", finds a matching view spec.
        // Preference is given to views that have corresponding buttons.
        getUnitViewSpec: function (unit) {
            var viewTypes;
            var i;
            var spec;

            if ($.inArray(unit, intervalUnits) != -1) {

                // put views that have buttons first. there will be duplicates, but oh well
                viewTypes = this.header.getViewsWithButtons();
                $.each(fc.views, function (viewType) { // all views
                    viewTypes.push(viewType);
                });

                for (i = 0; i < viewTypes.length; i++) {
                    spec = this.getViewSpec(viewTypes[i]);
                    if (spec) {
                        if (spec.singleUnit == unit) {
                            return spec;
                        }
                    }
                }
            }
        },


        // Builds an object with information on how to create a given view
        buildViewSpec: function (requestedViewType) {
            var viewOverrides = this.overrides.views || {};
            var specChain = []; // for the view. lowest to highest priority
            var defaultsChain = []; // for the view. lowest to highest priority
            var overridesChain = []; // for the view. lowest to highest priority
            var viewType = requestedViewType;
            var spec; // for the view
            var overrides; // for the view
            var duration;
            var unit;

            // iterate from the specific view definition to a more general one until we hit an actual View class
            while (viewType) {
                spec = fcViews[viewType];
                overrides = viewOverrides[viewType];
                viewType = null; // clear. might repopulate for another iteration

                if (typeof spec === 'function') { // TODO: deprecate
                    spec = {'class': spec};
                }

                if (spec) {
                    specChain.unshift(spec);
                    defaultsChain.unshift(spec.defaults || {});
                    duration = duration || spec.duration;
                    viewType = viewType || spec.type;
                }

                if (overrides) {
                    overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                    duration = duration || overrides.duration;
                    viewType = viewType || overrides.type;
                }
            }

            spec = mergeProps(specChain);
            spec.type = requestedViewType;
            if (!spec['class']) {
                return false;
            }

            if (duration) {
                duration = moment.duration(duration);
                if (duration.valueOf()) { // valid?
                    spec.duration = duration;
                    unit = computeIntervalUnit(duration);

                    // view is a single-unit duration, like "week" or "day"
                    // incorporate options for this. lowest priority
                    if (duration.as(unit) === 1) {
                        spec.singleUnit = unit;
                        overridesChain.unshift(viewOverrides[unit] || {});
                    }
                }
            }

            spec.defaults = mergeOptions(defaultsChain);
            spec.overrides = mergeOptions(overridesChain);

            this.buildViewSpecOptions(spec);
            this.buildViewSpecButtonText(spec, requestedViewType);

            return spec;
        },


        // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
        buildViewSpecOptions: function (spec) {
            spec.options = mergeOptions([ // lowest to highest priority
                Calendar.defaults, // global defaults
                spec.defaults, // view's defaults (from ViewSubclass.defaults)
                this.dirDefaults,
                this.langDefaults, // locale and dir take precedence over view's defaults!
                this.overrides, // calendar's overrides (options given to constructor)
                spec.overrides // view's overrides (view-specific options)
            ]);
            populateInstanceComputableOptions(spec.options);
        },


        // Computes and assigns a view spec's buttonText-related options
        buildViewSpecButtonText: function (spec, requestedViewType) {

            // given an options object with a possible `buttonText` hash, lookup the buttonText for the
            // requested view, falling back to a generic unit entry like "week" or "day"
            function queryButtonText(options) {
                var buttonText = options.buttonText || {};
                return buttonText[requestedViewType] ||
                    (spec.singleUnit ? buttonText[spec.singleUnit] : null);
            }

            // highest to lowest priority
            spec.buttonTextOverride =
                queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string

            // highest to lowest priority. mirrors buildViewSpecOptions
            spec.buttonTextDefault =
                queryButtonText(this.langDefaults) ||
                queryButtonText(this.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(Calendar.defaults) ||
                (spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
        },


        // Given a view name for a custom view or a standard view, creates a ready-to-go View object
        instantiateView: function (viewType) {
            var spec = this.getViewSpec(viewType);

            return new spec['class'](this, viewType, spec.options, spec.duration);
        },


        // Returns a boolean about whether the view is okay to instantiate at some point
        isValidViewType: function (viewType) {
            return Boolean(this.getViewSpec(viewType));
        },


        // Should be called when any type of async data fetching begins
        pushLoading: function () {
            if (!(this.loadingLevel++)) {
                this.trigger('loading', null, true, this.view);
            }
        },


        // Should be called when any type of async data fetching completes
        popLoading: function () {
            if (!(--this.loadingLevel)) {
                this.trigger('loading', null, false, this.view);
            }
        },


        // Given arguments to the select method in the API, returns a range
        buildSelectRange: function (start, end) {

            start = this.moment(start);
            if (end) {
                end = this.moment(end);
            }
            else if (start.hasTime()) {
                end = start.clone().add(this.defaultTimedEventDuration);
            }
            else {
                end = start.clone().add(this.defaultAllDayEventDuration);
            }

            return {start: start, end: end};
        }

    });


    Calendar.mixin(Emitter);


    function Calendar_constructor(element, overrides) {
        var t = this;


        t.initOptions(overrides || {});
        var options = this.options;


        // Exports
        // -----------------------------------------------------------------------------------

        t.render = render;
        t.destroy = destroy;
        t.refetchEvents = refetchEvents;
        t.reportEvents = reportEvents;
        t.reportEventChange = reportEventChange;
        t.rerenderEvents = renderEvents; // `renderEvents` serves as a rerender. an API method
        t.changeView = renderView; // `renderView` will switch to another view
        t.select = select;
        t.unselect = unselect;
        t.prev = prev;
        t.next = next;
        t.prevYear = prevYear;
        t.nextYear = nextYear;
        t.today = today;
        t.gotoDate = gotoDate;
        t.incrementDate = incrementDate;
        t.zoomTo = zoomTo;
        t.getDate = getDate;
        t.getCalendar = getCalendar;
        t.getView = getView;
        t.option = option;
        t.trigger = trigger;


        // Language-data Internals
        // -----------------------------------------------------------------------------------
        // Apply overrides to the current language's data


        var localeData = createObject( // make a cheap copy
            getMomentLocaleData(options.lang) // will fall back to en
        );

        if (options.monthNames) {
            localeData._months = options.monthNames;
        }
        if (options.monthNamesShort) {
            localeData._monthsShort = options.monthNamesShort;
        }
        if (options.dayNames) {
            localeData._weekdays = options.dayNames;
        }
        if (options.dayNamesShort) {
            localeData._weekdaysShort = options.dayNamesShort;
        }
        if (options.firstDay != null) {
            var _week = createObject(localeData._week); // _week: { dow: # }
            _week.dow = options.firstDay;
            localeData._week = _week;
        }

        // assign a normalized value, to be used by our .week() moment extension
        localeData._fullCalendar_weekCalc = (function (weekCalc) {
            if (typeof weekCalc === 'function') {
                return weekCalc;
            }
            else if (weekCalc === 'local') {
                return weekCalc;
            }
            else if (weekCalc === 'iso' || weekCalc === 'ISO') {
                return 'ISO';
            }
        })(options.weekNumberCalculation);


        // Calendar-specific Date Utilities
        // -----------------------------------------------------------------------------------


        t.defaultAllDayEventDuration = moment.duration(options.defaultAllDayEventDuration);
        t.defaultTimedEventDuration = moment.duration(options.defaultTimedEventDuration);


        // Builds a moment using the settings of the current calendar: timezone and language.
        // Accepts anything the vanilla moment() constructor accepts.
        t.moment = function () {
            var mom;

            if (options.timezone === 'local') {
                mom = fc.moment.apply(null, arguments);

                // Force the moment to be local, because fc.moment doesn't guarantee it.
                if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
                    mom.local();
                }
            }
            else if (options.timezone === 'UTC') {
                mom = fc.moment.utc.apply(null, arguments); // process as UTC
            }
            else {
                mom = fc.moment.parseZone.apply(null, arguments); // let the input decide the zone
            }

            if ('_locale' in mom) { // moment 2.8 and above
                mom._locale = localeData;
            }
            else { // pre-moment-2.8
                mom._lang = localeData;
            }

            return mom;
        };


        // Returns a boolean about whether or not the calendar knows how to calculate
        // the timezone offset of arbitrary dates in the current timezone.
        t.getIsAmbigTimezone = function () {
            return options.timezone !== 'local' && options.timezone !== 'UTC';
        };


        // Returns a copy of the given date in the current timezone of it is ambiguously zoned.
        // This will also give the date an unambiguous time.
        t.rezoneDate = function (date) {
            return t.moment(date.toArray());
        };


        // Returns a moment for the current date, as defined by the client's computer,
        // or overridden by the `now` option.
        t.getNow = function () {
            var now = options.now;
            if (typeof now === 'function') {
                now = now();
            }
            return t.moment(now);
        };


        // Get an event's normalized end date. If not present, calculate it from the defaults.
        t.getEventEnd = function (event) {
            if (event.end) {
                return event.end.clone();
            }
            else {
                return t.getDefaultEventEnd(event.allDay, event.start);
            }
        };


        // Given an event's allDay status and start date, return swhat its fallback end date should be.
        t.getDefaultEventEnd = function (allDay, start) { // TODO: rename to computeDefaultEventEnd
            var end = start.clone();

            if (allDay) {
                end.stripTime().add(t.defaultAllDayEventDuration);
            }
            else {
                end.add(t.defaultTimedEventDuration);
            }

            if (t.getIsAmbigTimezone()) {
                end.stripZone(); // we don't know what the tzo should be
            }

            return end;
        };


        // Produces a human-readable string for the given duration.
        // Side-effect: changes the locale of the given duration.
        t.humanizeDuration = function (duration) {
            return (duration.locale || duration.lang).call(duration, options.lang) // works moment-pre-2.8
                .humanize();
        };


        // Imports
        // -----------------------------------------------------------------------------------


        EventManager.call(t, options);
        var isFetchNeeded = t.isFetchNeeded;
        var fetchEvents = t.fetchEvents;


        // Locals
        // -----------------------------------------------------------------------------------


        var _element = element[0];
        var header;
        var headerElement;
        var content;
        var tm; // for making theme classes
        var currentView; // NOTE: keep this in sync with this.view
        var viewsByType = {}; // holds all instantiated view instances, current or not
        var suggestedViewHeight;
        var windowResizeProxy; // wraps the windowResize function
        var ignoreWindowResize = 0;
        var date;
        var events = [];


        // Main Rendering
        // -----------------------------------------------------------------------------------


        if (options.defaultDate != null) {
            date = t.moment(options.defaultDate);
        }
        else {
            date = t.getNow();
        }


        function render() {
            if (!content) {
                initialRender();
            }
            else if (elementVisible()) {
                // mainly for the public API
                calcSize();
                renderView();
            }
        }


        function initialRender() {
            tm = options.theme ? 'ui' : 'fc';
            element.addClass('fc');

            if (options.isRTL) {
                element.addClass('fc-rtl');
            }
            else {
                element.addClass('fc-ltr');
            }

            if (options.theme) {
                element.addClass('ui-widget');
            }
            else {
                element.addClass('fc-unthemed');
            }

            content = $("<div class='fc-view-container'/>").prependTo(element);

            header = t.header = new Header(t, options);
            headerElement = header.render();
            if (headerElement) {
                element.prepend(headerElement);
            }

            renderView(options.defaultView);

            if (options.handleWindowResize) {
                windowResizeProxy = debounce(windowResize, options.windowResizeDelay); // prevents rapid calls
                $(window).resize(windowResizeProxy);
            }
        }


        function destroy() {

            if (currentView) {
                currentView.removeElement();

                // NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
                // It is still the "current" view, just not rendered.
            }

            header.removeElement();
            content.remove();
            element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

            if (windowResizeProxy) {
                $(window).unbind('resize', windowResizeProxy);
            }
        }


        function elementVisible() {
            return element.is(':visible');
        }


        // View Rendering
        // -----------------------------------------------------------------------------------


        // Renders a view because of a date change, view-type change, or for the first time.
        // If not given a viewType, keep the current view but render different dates.
        function renderView(viewType) {
            ignoreWindowResize++;

            // if viewType is changing, remove the old view's rendering
            if (currentView && viewType && currentView.type !== viewType) {
                header.deactivateButton(currentView.type);
                freezeContentHeight(); // prevent a scroll jump when view element is removed
                currentView.removeElement();
                currentView = t.view = null;
            }

            // if viewType changed, or the view was never created, create a fresh view
            if (!currentView && viewType) {
                currentView = t.view =
                    viewsByType[viewType] ||
                    (viewsByType[viewType] = t.instantiateView(viewType));

                currentView.setElement(
                    $("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content)
                );
                header.activateButton(viewType);
            }

            if (currentView) {

                // in case the view should render a period of time that is completely hidden
                date = currentView.massageCurrentDate(date);

                // render or rerender the view
                if (
                    !currentView.displaying ||
                    !date.isWithin(currentView.intervalStart, currentView.intervalEnd) // implicit date window change
                ) {
                    if (elementVisible()) {

                        freezeContentHeight();
                        currentView.display(date);
                        unfreezeContentHeight(); // immediately unfreeze regardless of whether display is async

                        // need to do this after View::render, so dates are calculated
                        updateHeaderTitle();
                        updateTodayButton();

                        getAndRenderEvents();
                    }
                }
            }

            unfreezeContentHeight(); // undo any lone freezeContentHeight calls
            ignoreWindowResize--;
        }


        // Resizing
        // -----------------------------------------------------------------------------------


        t.getSuggestedViewHeight = function () {
            if (suggestedViewHeight === undefined) {
                calcSize();
            }
            return suggestedViewHeight;
        };


        t.isHeightAuto = function () {
            return options.contentHeight === 'auto' || options.height === 'auto';
        };


        function updateSize(shouldRecalc) {
            if (elementVisible()) {

                if (shouldRecalc) {
                    _calcSize();
                }

                ignoreWindowResize++;
                currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
                ignoreWindowResize--;

                return true; // signal success
            }
        }


        function calcSize() {
            if (elementVisible()) {
                _calcSize();
            }
        }


        function _calcSize() { // assumes elementVisible
            if (typeof options.contentHeight === 'number') { // exists and not 'auto'
                suggestedViewHeight = options.contentHeight;
            }
            else if (typeof options.height === 'number') { // exists and not 'auto'
                suggestedViewHeight = options.height - (headerElement ? headerElement.outerHeight(true) : 0);
            }
            else {
                suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
            }
        }


        function windowResize(ev) {
            if (
                !ignoreWindowResize &&
                ev.target === window && // so we don't process jqui "resize" events that have bubbled up
                currentView.start // view has already been rendered
            ) {
                if (updateSize(true)) {
                    currentView.trigger('windowResize', _element);
                }
            }
        }


        /* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/

        // TODO: going forward, most of this stuff should be directly handled by the view


        function refetchEvents() { // can be called as an API method
            destroyEvents(); // so that events are cleared before user starts waiting for AJAX
            fetchAndRenderEvents();
        }


        function renderEvents() { // destroys old events if previously rendered
            if (elementVisible()) {
                freezeContentHeight();
                currentView.displayEvents(events);
                unfreezeContentHeight();
            }
        }


        function destroyEvents() {
            freezeContentHeight();
            currentView.clearEvents();
            unfreezeContentHeight();
        }


        function getAndRenderEvents() {
            if (!options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {
                fetchAndRenderEvents();
            }
            else {
                renderEvents();
            }
        }


        function fetchAndRenderEvents() {
            fetchEvents(currentView.start, currentView.end);
            // ... will call reportEvents
            // ... which will call renderEvents
        }


        // called when event data arrives
        function reportEvents(_events) {
            events = _events;
            renderEvents();
        }


        // called when a single event's data has been changed
        function reportEventChange() {
            renderEvents();
        }


        /* Header Updating
	-----------------------------------------------------------------------------*/


        function updateHeaderTitle() {
            header.updateTitle(currentView.title);
        }


        function updateTodayButton() {
            var now = t.getNow();
            if (now.isWithin(currentView.intervalStart, currentView.intervalEnd)) {
                header.disableButton('today');
            }
            else {
                header.enableButton('today');
            }
        }


        /* Selection
	-----------------------------------------------------------------------------*/


        function select(start, end) {
            currentView.select(
                t.buildSelectRange.apply(t, arguments)
            );
        }


        function unselect() { // safe to be called before renderView
            if (currentView) {
                currentView.unselect();
            }
        }


        /* Date
	-----------------------------------------------------------------------------*/


        function prev() {
            date = currentView.computePrevDate(date);
            renderView();
        }


        function next() {
            date = currentView.computeNextDate(date);
            renderView();
        }


        function prevYear() {
            date.add(-1, 'years');
            renderView();
        }


        function nextYear() {
            date.add(1, 'years');
            renderView();
        }


        function today() {
            date = t.getNow();
            renderView();
        }


        function gotoDate(dateInput) {
            date = t.moment(dateInput);
            renderView();
        }


        function incrementDate(delta) {
            date.add(moment.duration(delta));
            renderView();
        }


        // Forces navigation to a view for the given date.
        // `viewType` can be a specific view name or a generic one like "week" or "day".
        function zoomTo(newDate, viewType) {
            var spec;

            viewType = viewType || 'day'; // day is default zoom
            spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);

            date = newDate;
            renderView(spec ? spec.type : null);
        }


        function getDate() {
            return date.clone();
        }


        /* Height "Freezing"
	-----------------------------------------------------------------------------*/

        // TODO: move this into the view


        function freezeContentHeight() {
            content.css({
                width: '100%',
                height: content.height(),
                overflow: 'hidden'
            });
        }


        function unfreezeContentHeight() {
            content.css({
                width: '',
                height: '',
                overflow: ''
            });
        }


        /* Misc
	-----------------------------------------------------------------------------*/


        function getCalendar() {
            return t;
        }


        function getView() {
            return currentView;
        }


        function option(name, value) {
            if (value === undefined) {
                return options[name];
            }
            if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
                options[name] = value;
                updateSize(true); // true = allow recalculation of height
            }
        }


        function trigger(name, thisObj) { // overrides the Emitter's trigger method :(
            var args = Array.prototype.slice.call(arguments, 2);

            thisObj = thisObj || _element;
            this.triggerWith(name, thisObj, args); // Emitter's method

            if (options[name]) {
                return options[name].apply(thisObj, args);
            }
        }

        t.initialize();
    }

    ;
    ;

    Calendar.defaults = {

        titleRangeSeparator: ' \u2014 ', // emphasized dash
        monthYearFormat: 'MMMM YYYY', // required for en. other languages rely on datepicker computable option

        defaultTimedEventDuration: '02:00:00',
        defaultAllDayEventDuration: {days: 1},
        forceEventDuration: false,
        nextDayThreshold: '09:00:00', // 9am

        // display
        defaultView: 'month',
        aspectRatio: 1.35,
        header: {
            left: 'title',
            center: '',
            right: 'today prev,next'
        },
        weekends: true,
        weekNumbers: false,

        weekNumberTitle: 'W',
        weekNumberCalculation: 'local',

        //editable: false,

        scrollTime: '06:00:00',

        // event ajax
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',
        timezoneParam: 'timezone',

        timezone: false,

        //allDayDefault: undefined,

        // locale
        isRTL: false,
        buttonText: {
            prev: "prev",
            next: "next",
            prevYear: "prev year",
            nextYear: "next year",
            year: 'year', // TODO: locale files need to specify this
            today: 'today',
            month: 'month',
            week: 'week',
            day: 'day'
        },

        buttonIcons: {
            prev: 'left-single-arrow',
            next: 'right-single-arrow',
            prevYear: 'left-double-arrow',
            nextYear: 'right-double-arrow'
        },

        // jquery-ui theming
        theme: false,
        themeButtonIcons: {
            prev: 'circle-triangle-w',
            next: 'circle-triangle-e',
            prevYear: 'seek-prev',
            nextYear: 'seek-next'
        },

        //eventResizableFromStart: false,
        dragOpacity: .75,
        dragRevertDuration: 500,
        dragScroll: true,

        //selectable: false,
        unselectAuto: true,

        dropAccept: '*',

        eventOrder: 'title',

        eventLimit: false,
        eventLimitText: 'more',
        eventLimitClick: 'popover',
        dayPopoverFormat: 'LL',

        handleWindowResize: true,
        windowResizeDelay: 200 // milliseconds before an updateSize happens

    };


    Calendar.englishDefaults = { // used by lang.js
        dayPopoverFormat: 'dddd, MMMM D'
    };


    Calendar.rtlDefaults = { // right-to-left defaults
        header: { // TODO: smarter solution (first/center/last ?)
            left: 'next,prev today',
            center: '',
            right: 'title'
        },
        buttonIcons: {
            prev: 'right-single-arrow',
            next: 'left-single-arrow',
            prevYear: 'right-double-arrow',
            nextYear: 'left-double-arrow'
        },
        themeButtonIcons: {
            prev: 'circle-triangle-e',
            next: 'circle-triangle-w',
            nextYear: 'seek-prev',
            prevYear: 'seek-next'
        }
    };

    ;
    ;

    var langOptionHash = fc.langs = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar lang file
// TODO: rename everything "lang" to "locale", like what the moment project did


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default language for datepicker.
    fc.datepickerLang = function (langCode, dpLangCode, dpOptions) {

        // get the FullCalendar internal option hash for this language. create if necessary
        var fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});

        // transfer some simple options from datepicker to fc
        fcOptions.isRTL = dpOptions.isRTL;
        fcOptions.weekNumberTitle = dpOptions.weekHeader;

        // compute some more complex options from datepicker
        $.each(dpComputableOptions, function (name, func) {
            fcOptions[name] = func(dpOptions);
        });

        // is jQuery UI Datepicker is on the page?
        if ($.datepicker) {

            // Register the language data.
            // FullCalendar and MomentJS use language codes like "pt-br" but Datepicker
            // does it like "pt-BR" or if it doesn't have the language, maybe just "pt".
            // Make an alias so the language can be referenced either way.
            $.datepicker.regional[dpLangCode] =
                $.datepicker.regional[langCode] = // alias
                    dpOptions;

            // Alias 'en' to the default language data. Do this every time.
            $.datepicker.regional.en = $.datepicker.regional[''];

            // Set as Datepicker's global defaults.
            $.datepicker.setDefaults(dpOptions);
        }
    };


// Sets FullCalendar-specific translations. Will set the language as the global default.
    fc.lang = function (langCode, newFcOptions) {
        var fcOptions;
        var momOptions;

        // get the FullCalendar internal option hash for this language. create if necessary
        fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});

        // provided new options for this language? merge them in
        if (newFcOptions) {
            fcOptions = langOptionHash[langCode] = mergeOptions([fcOptions, newFcOptions]);
        }

        // compute language options that weren't defined.
        // always do this. newFcOptions can be undefined when initializing from i18n file,
        // so no way to tell if this is an initialization or a default-setting.
        momOptions = getMomentLocaleData(langCode); // will fall back to en
        $.each(momComputableOptions, function (name, func) {
            if (fcOptions[name] == null) {
                fcOptions[name] = func(momOptions, fcOptions);
            }
        });

        // set it as the default language for FullCalendar
        Calendar.defaults.lang = langCode;
    };


// NOTE: can't guarantee any of these computations will run because not every language has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
    var dpComputableOptions = {

        buttonText: function (dpOptions) {
            return {
                // the translations sometimes wrongly contain HTML entities
                prev: stripHtmlEntities(dpOptions.prevText),
                next: stripHtmlEntities(dpOptions.nextText),
                today: stripHtmlEntities(dpOptions.currentText)
            };
        },

        // Produces format strings like "MMMM YYYY" -> "September 2014"
        monthYearFormat: function (dpOptions) {
            return dpOptions.showMonthAfterYear ?
                'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
                'MMMM YYYY[' + dpOptions.yearSuffix + ']';
        }

    };

    var momComputableOptions = {

        // Produces format strings like "ddd M/D" -> "Fri 9/15"
        dayOfMonthFormat: function (momOptions, fcOptions) {
            var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

            // strip the year off the edge, as well as other misc non-whitespace chars
            format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

            if (fcOptions.isRTL) {
                format += ' ddd'; // for RTL, add day-of-week to end
            }
            else {
                format = 'ddd ' + format; // for LTR, add day-of-week to beginning
            }
            return format;
        },

        // Produces format strings like "h:mma" -> "6:00pm"
        mediumTimeFormat: function (momOptions) { // can't be called `timeFormat` because collides with option
            return momOptions.longDateFormat('LT')
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
        smallTimeFormat: function (momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '(:mm)')
                .replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
        extraSmallTimeFormat: function (momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '(:mm)')
                .replace(/(\Wmm)$/, '($1)') // like above, but for foreign langs
                .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
        },

        // Produces format strings like "ha" / "H" -> "6pm" / "18"
        hourFormat: function (momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(':mm', '')
                .replace(/(\Wmm)$/, '') // like above, but for foreign langs
                .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
        },

        // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
        noMeridiemTimeFormat: function (momOptions) {
            return momOptions.longDateFormat('LT')
                .replace(/\s*a$/i, ''); // remove trailing AM/PM
        }

    };


// options that should be computed off live calendar options (considers override options)
    var instanceComputableOptions = { // TODO: best place for this? related to lang?

        // Produces format strings for results like "Mo 16"
        smallDayDateFormat: function (options) {
            return options.isRTL ?
                'D dd' :
                'dd D';
        },

        // Produces format strings for results like "Wk 5"
        weekFormat: function (options) {
            return options.isRTL ?
                'w[ ' + options.weekNumberTitle + ']' :
                '[' + options.weekNumberTitle + ' ]w';
        },

        // Produces format strings for results like "Wk5"
        smallWeekFormat: function (options) {
            return options.isRTL ?
                'w[' + options.weekNumberTitle + ']' :
                '[' + options.weekNumberTitle + ']w';
        }

    };

    function populateInstanceComputableOptions(options) {
        $.each(instanceComputableOptions, function (name, func) {
            if (options[name] == null) {
                options[name] = func(options);
            }
        });
    }


// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
    function getMomentLocaleData(langCode) {
        var func = moment.localeData || moment.langData;
        return func.call(moment, langCode) ||
            func.call(moment, 'en'); // the newer localData could return null, so fall back to en
    }


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
    fc.lang('en', Calendar.englishDefaults);

    ;
    ;

    /* Top toolbar area with buttons and title
----------------------------------------------------------------------------------------------------------------------*/

// TODO: rename all header-related things to "toolbar"

    function Header(calendar, options) {
        var t = this;

        // exports
        t.render = render;
        t.removeElement = removeElement;
        t.updateTitle = updateTitle;
        t.activateButton = activateButton;
        t.deactivateButton = deactivateButton;
        t.disableButton = disableButton;
        t.enableButton = enableButton;
        t.getViewsWithButtons = getViewsWithButtons;

        // locals
        var el = $();
        var viewsWithButtons = [];
        var tm;


        function render() {
            var sections = options.header;

            tm = options.theme ? 'ui' : 'fc';

            if (sections) {
                el = $("<div class='fc-toolbar'/>")
                    .append(renderSection('left'))
                    .append(renderSection('right'))
                    .append(renderSection('center'))
                    .append('<div class="fc-clear"/>');

                return el;
            }
        }


        function removeElement() {
            el.remove();
            el = $();
        }


        function renderSection(position) {
            var sectionEl = $('<div class="fc-' + position + '"/>');
            var buttonStr = options.header[position];

            if (buttonStr) {
                $.each(buttonStr.split(' '), function (i) {
                    var groupChildren = $();
                    var isOnlyButtons = true;
                    var groupEl;

                    $.each(this.split(','), function (j, buttonName) {
                        var customButtonProps;
                        var viewSpec;
                        var buttonClick;
                        var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
                        var defaultText;
                        var themeIcon;
                        var normalIcon;
                        var innerHtml;
                        var classes;
                        var button; // the element

                        if (buttonName == 'title') {
                            groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                            isOnlyButtons = false;
                        }
                        else {
                            if ((customButtonProps = (calendar.options.customButtons || {})[buttonName])) {
                                buttonClick = function (ev) {
                                    if (customButtonProps.click) {
                                        customButtonProps.click.call(button[0], ev);
                                    }
                                };
                                overrideText = ''; // icons will override text
                                defaultText = customButtonProps.text;
                            }
                            else if ((viewSpec = calendar.getViewSpec(buttonName))) {
                                buttonClick = function () {
                                    calendar.changeView(buttonName);
                                };
                                viewsWithButtons.push(buttonName);
                                overrideText = viewSpec.buttonTextOverride;
                                defaultText = viewSpec.buttonTextDefault;
                            }
                            else if (calendar[buttonName]) { // a calendar method
                                buttonClick = function () {
                                    calendar[buttonName]();
                                };
                                overrideText = (calendar.overrides.buttonText || {})[buttonName];
                                defaultText = options.buttonText[buttonName]; // everything else is considered default
                            }

                            if (buttonClick) {

                                themeIcon =
                                    customButtonProps ?
                                        customButtonProps.themeIcon :
                                        options.themeButtonIcons[buttonName];

                                normalIcon =
                                    customButtonProps ?
                                        customButtonProps.icon :
                                        options.buttonIcons[buttonName];

                                if (overrideText) {
                                    innerHtml = htmlEscape(overrideText);
                                }
                                else if (themeIcon && options.theme) {
                                    innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
                                }
                                else if (normalIcon && !options.theme) {
                                    innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
                                }
                                else {
                                    innerHtml = htmlEscape(defaultText);
                                }

                                classes = [
                                    'fc-' + buttonName + '-button',
                                    tm + '-button',
                                    tm + '-state-default'
                                ];

                                button = $( // type="button" so that it doesn't submit a form
                                    '<button type="button" class="' + classes.join(' ') + '">' +
                                    innerHtml +
                                    '</button>'
                                )
                                    .click(function (ev) {
                                        // don't process clicks for disabled buttons
                                        if (!button.hasClass(tm + '-state-disabled')) {

                                            buttonClick(ev);

                                            // after the click action, if the button becomes the "active" tab, or disabled,
                                            // it should never have a hover class, so remove it now.
                                            if (
                                                button.hasClass(tm + '-state-active') ||
                                                button.hasClass(tm + '-state-disabled')
                                            ) {
                                                button.removeClass(tm + '-state-hover');
                                            }
                                        }
                                    })
                                    .mousedown(function () {
                                        // the *down* effect (mouse pressed in).
                                        // only on buttons that are not the "active" tab, or disabled
                                        button
                                            .not('.' + tm + '-state-active')
                                            .not('.' + tm + '-state-disabled')
                                            .addClass(tm + '-state-down');
                                    })
                                    .mouseup(function () {
                                        // undo the *down* effect
                                        button.removeClass(tm + '-state-down');
                                    })
                                    .hover(
                                        function () {
                                            // the *hover* effect.
                                            // only on buttons that are not the "active" tab, or disabled
                                            button
                                                .not('.' + tm + '-state-active')
                                                .not('.' + tm + '-state-disabled')
                                                .addClass(tm + '-state-hover');
                                        },
                                        function () {
                                            // undo the *hover* effect
                                            button
                                                .removeClass(tm + '-state-hover')
                                                .removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
                                        }
                                    );

                                groupChildren = groupChildren.add(button);
                            }
                        }
                    });

                    if (isOnlyButtons) {
                        groupChildren
                            .first().addClass(tm + '-corner-left').end()
                            .last().addClass(tm + '-corner-right').end();
                    }

                    if (groupChildren.length > 1) {
                        groupEl = $('<div/>');
                        if (isOnlyButtons) {
                            groupEl.addClass('fc-button-group');
                        }
                        groupEl.append(groupChildren);
                        sectionEl.append(groupEl);
                    }
                    else {
                        sectionEl.append(groupChildren); // 1 or 0 children
                    }
                });
            }

            return sectionEl;
        }


        function updateTitle(text) {
            el.find('h2').text(text);
        }


        function activateButton(buttonName) {
            el.find('.fc-' + buttonName + '-button')
                .addClass(tm + '-state-active');
        }


        function deactivateButton(buttonName) {
            el.find('.fc-' + buttonName + '-button')
                .removeClass(tm + '-state-active');
        }


        function disableButton(buttonName) {
            el.find('.fc-' + buttonName + '-button')
                .attr('disabled', 'disabled')
                .addClass(tm + '-state-disabled');
        }


        function enableButton(buttonName) {
            el.find('.fc-' + buttonName + '-button')
                .removeAttr('disabled')
                .removeClass(tm + '-state-disabled');
        }


        function getViewsWithButtons() {
            return viewsWithButtons;
        }

    }

    ;
    ;

    fc.sourceNormalizers = [];
    fc.sourceFetchers = [];

    var ajaxDefaults = {
        dataType: 'json',
        cache: false
    };

    var eventGUID = 1;


    function EventManager(options) { // assumed to be a calendar
        var t = this;


        // exports
        t.isFetchNeeded = isFetchNeeded;
        t.fetchEvents = fetchEvents;
        t.addEventSource = addEventSource;
        t.removeEventSource = removeEventSource;
        t.updateEvent = updateEvent;
        t.renderEvent = renderEvent;
        t.removeEvents = removeEvents;
        t.clientEvents = clientEvents;
        t.mutateEvent = mutateEvent;
        t.normalizeEventRange = normalizeEventRange;
        t.normalizeEventRangeTimes = normalizeEventRangeTimes;
        t.ensureVisibleEventRange = ensureVisibleEventRange;


        // imports
        var reportEvents = t.reportEvents;


        // locals
        var stickySource = {events: []};
        var sources = [stickySource];
        var rangeStart, rangeEnd;
        var currentFetchID = 0;
        var pendingSourceCnt = 0;
        var cache = []; // holds events that have already been expanded


        $.each(
            (options.events ? [options.events] : []).concat(options.eventSources || []),
            function (i, sourceInput) {
                var source = buildEventSource(sourceInput);
                if (source) {
                    sources.push(source);
                }
            }
        );


        /* Fetching
	-----------------------------------------------------------------------------*/


        function isFetchNeeded(start, end) {
            return !rangeStart || // nothing has been fetched yet?
                // or, a part of the new range is outside of the old range? (after normalizing)
                start.clone().stripZone() < rangeStart.clone().stripZone() ||
                end.clone().stripZone() > rangeEnd.clone().stripZone();
        }


        function fetchEvents(start, end) {
            rangeStart = start;
            rangeEnd = end;
            cache = [];
            var fetchID = ++currentFetchID;
            var len = sources.length;
            pendingSourceCnt = len;
            for (var i = 0; i < len; i++) {
                fetchEventSource(sources[i], fetchID);
            }
        }


        function fetchEventSource(source, fetchID) {
            _fetchEventSource(source, function (eventInputs) {
                var isArraySource = $.isArray(source.events);
                var i, eventInput;
                var abstractEvent;

                if (fetchID == currentFetchID) {

                    if (eventInputs) {
                        for (i = 0; i < eventInputs.length; i++) {
                            eventInput = eventInputs[i];

                            if (isArraySource) { // array sources have already been convert to Event Objects
                                abstractEvent = eventInput;
                            }
                            else {
                                abstractEvent = buildEventFromInput(eventInput, source);
                            }

                            if (abstractEvent) { // not false (an invalid event)
                                cache.push.apply(
                                    cache,
                                    expandEvent(abstractEvent) // add individual expanded events to the cache
                                );
                            }
                        }
                    }

                    pendingSourceCnt--;
                    if (!pendingSourceCnt) {
                        reportEvents(cache);
                    }
                }
            });
        }


        function _fetchEventSource(source, callback) {
            var i;
            var fetchers = fc.sourceFetchers;
            var res;

            for (i = 0; i < fetchers.length; i++) {
                res = fetchers[i].call(
                    t, // this, the Calendar object
                    source,
                    rangeStart.clone(),
                    rangeEnd.clone(),
                    options.timezone,
                    callback
                );

                if (res === true) {
                    // the fetcher is in charge. made its own async request
                    return;
                }
                else if (typeof res == 'object') {
                    // the fetcher returned a new source. process it
                    _fetchEventSource(res, callback);
                    return;
                }
            }

            var events = source.events;
            if (events) {
                if ($.isFunction(events)) {
                    t.pushLoading();
                    events.call(
                        t, // this, the Calendar object
                        rangeStart.clone(),
                        rangeEnd.clone(),
                        options.timezone,
                        function (events) {
                            callback(events);
                            t.popLoading();
                        }
                    );
                }
                else if ($.isArray(events)) {
                    callback(events);
                }
                else {
                    callback();
                }
            } else {
                var url = source.url;
                if (url) {
                    var success = source.success;
                    var error = source.error;
                    var complete = source.complete;

                    // retrieve any outbound GET/POST $.ajax data from the options
                    var customData;
                    if ($.isFunction(source.data)) {
                        // supplied as a function that returns a key/value object
                        customData = source.data();
                    }
                    else {
                        // supplied as a straight key/value object
                        customData = source.data;
                    }

                    // use a copy of the custom data so we can modify the parameters
                    // and not affect the passed-in object.
                    var data = $.extend({}, customData || {});

                    var startParam = firstDefined(source.startParam, options.startParam);
                    var endParam = firstDefined(source.endParam, options.endParam);
                    var timezoneParam = firstDefined(source.timezoneParam, options.timezoneParam);

                    if (startParam) {
                        data[startParam] = rangeStart.format();
                    }
                    if (endParam) {
                        data[endParam] = rangeEnd.format();
                    }
                    if (options.timezone && options.timezone != 'local') {
                        data[timezoneParam] = options.timezone;
                    }

                    t.pushLoading();
                    $.ajax($.extend({}, ajaxDefaults, source, {
                        data: data,
                        success: function (events) {
                            events = events || [];
                            var res = applyAll(success, this, arguments);
                            if ($.isArray(res)) {
                                events = res;
                            }
                            callback(events);
                        },
                        error: function () {
                            applyAll(error, this, arguments);
                            callback();
                        },
                        complete: function () {
                            applyAll(complete, this, arguments);
                            t.popLoading();
                        }
                    }));
                } else {
                    callback();
                }
            }
        }


        /* Sources
	-----------------------------------------------------------------------------*/


        function addEventSource(sourceInput) {
            var source = buildEventSource(sourceInput);
            if (source) {
                sources.push(source);
                pendingSourceCnt++;
                fetchEventSource(source, currentFetchID); // will eventually call reportEvents
            }
        }


        function buildEventSource(sourceInput) { // will return undefined if invalid source
            var normalizers = fc.sourceNormalizers;
            var source;
            var i;

            if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
                source = {events: sourceInput};
            }
            else if (typeof sourceInput === 'string') {
                source = {url: sourceInput};
            }
            else if (typeof sourceInput === 'object') {
                source = $.extend({}, sourceInput); // shallow copy
            }

            if (source) {

                // TODO: repeat code, same code for event classNames
                if (source.className) {
                    if (typeof source.className === 'string') {
                        source.className = source.className.split(/\s+/);
                    }
                    // otherwise, assumed to be an array
                }
                else {
                    source.className = [];
                }

                // for array sources, we convert to standard Event Objects up front
                if ($.isArray(source.events)) {
                    source.origArray = source.events; // for removeEventSource
                    source.events = $.map(source.events, function (eventInput) {
                        return buildEventFromInput(eventInput, source);
                    });
                }

                for (i = 0; i < normalizers.length; i++) {
                    normalizers[i].call(t, source);
                }

                return source;
            }
        }


        function removeEventSource(source) {
            sources = $.grep(sources, function (src) {
                return !isSourcesEqual(src, source);
            });
            // remove all client events from that source
            cache = $.grep(cache, function (e) {
                return !isSourcesEqual(e.source, source);
            });
            reportEvents(cache);
        }


        function isSourcesEqual(source1, source2) {
            return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
        }


        function getSourcePrimitive(source) {
            return (
                    (typeof source === 'object') ? // a normalized event source?
                        (source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
                        null
                ) ||
                source; // the given argument *is* the primitive
        }


        /* Manipulation
	-----------------------------------------------------------------------------*/


        // Only ever called from the externally-facing API
        function updateEvent(event) {

            // massage start/end values, even if date string values
            event.start = t.moment(event.start);
            if (event.end) {
                event.end = t.moment(event.end);
            }
            else {
                event.end = null;
            }

            mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
            reportEvents(cache); // reports event modifications (so we can redraw)
        }


        // Returns a hash of misc event properties that should be copied over to related events.
        function getMiscEventProps(event) {
            var props = {};

            $.each(event, function (name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined && isAtomic(val)) { // a defined non-object
                        props[name] = val;
                    }
                }
            });

            return props;
        }

        // non-date-related, non-id-related, non-secret
        function isMiscEventPropName(name) {
            return !/^_|^(id|allDay|start|end)$/.test(name);
        }


        // returns the expanded events that were created
        function renderEvent(eventInput, stick) {
            var abstractEvent = buildEventFromInput(eventInput);
            var events;
            var i, event;

            if (abstractEvent) { // not false (a valid input)
                events = expandEvent(abstractEvent);

                for (i = 0; i < events.length; i++) {
                    event = events[i];

                    if (!event.source) {
                        if (stick) {
                            stickySource.events.push(event);
                            event.source = stickySource;
                        }
                        cache.push(event);
                    }
                }

                reportEvents(cache);

                return events;
            }

            return [];
        }


        function removeEvents(filter) {
            var eventID;
            var i;

            if (filter == null) { // null or undefined. remove all events
                filter = function () {
                    return true;
                }; // will always match
            }
            else if (!$.isFunction(filter)) { // an event ID
                eventID = filter + '';
                filter = function (event) {
                    return event._id == eventID;
                };
            }

            // Purge event(s) from our local cache
            cache = $.grep(cache, filter, true); // inverse=true

            // Remove events from array sources.
            // This works because they have been converted to official Event Objects up front.
            // (and as a result, event._id has been calculated).
            for (i = 0; i < sources.length; i++) {
                if ($.isArray(sources[i].events)) {
                    sources[i].events = $.grep(sources[i].events, filter, true);
                }
            }

            reportEvents(cache);
        }


        function clientEvents(filter) {
            if ($.isFunction(filter)) {
                return $.grep(cache, filter);
            }
            else if (filter != null) { // not null, not undefined. an event ID
                filter += '';
                return $.grep(cache, function (e) {
                    return e._id == filter;
                });
            }
            return cache; // else, return all
        }


        /* Event Normalization
	-----------------------------------------------------------------------------*/


        // Given a raw object with key/value properties, returns an "abstract" Event object.
        // An "abstract" event is an event that, if recurring, will not have been expanded yet.
        // Will return `false` when input is invalid.
        // `source` is optional
        function buildEventFromInput(input, source) {
            var out = {};
            var start, end;
            var allDay;

            if (options.eventDataTransform) {
                input = options.eventDataTransform(input);
            }
            if (source && source.eventDataTransform) {
                input = source.eventDataTransform(input);
            }

            // Copy all properties over to the resulting object.
            // The special-case properties will be copied over afterwards.
            $.extend(out, input);

            if (source) {
                out.source = source;
            }

            out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

            if (input.className) {
                if (typeof input.className == 'string') {
                    out.className = input.className.split(/\s+/);
                }
                else { // assumed to be an array
                    out.className = input.className;
                }
            }
            else {
                out.className = [];
            }

            start = input.start || input.date; // "date" is an alias for "start"
            end = input.end;

            // parse as a time (Duration) if applicable
            if (isTimeString(start)) {
                start = moment.duration(start);
            }
            if (isTimeString(end)) {
                end = moment.duration(end);
            }

            if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

                // the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
                out.start = start ? moment.duration(start) : null; // will be a Duration or null
                out.end = end ? moment.duration(end) : null; // will be a Duration or null
                out._recurring = true; // our internal marker
            }
            else {

                if (start) {
                    start = t.moment(start);
                    if (!start.isValid()) {
                        return false;
                    }
                }

                if (end) {
                    end = t.moment(end);
                    if (!end.isValid()) {
                        end = null; // let defaults take over
                    }
                }

                allDay = input.allDay;
                if (allDay === undefined) { // still undefined? fallback to default
                    allDay = firstDefined(
                        source ? source.allDayDefault : undefined,
                        options.allDayDefault
                    );
                    // still undefined? normalizeEventRange will calculate it
                }

                assignDatesToEvent(start, end, allDay, out);
            }

            return out;
        }


        // Normalizes and assigns the given dates to the given partially-formed event object.
        // NOTE: mutates the given start/end moments. does not make a copy.
        function assignDatesToEvent(start, end, allDay, event) {
            event.start = start;
            event.end = end;
            event.allDay = allDay;
            normalizeEventRange(event);
            backupEventDates(event);
        }


        // Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
        // NOTE: Will modify the given object.
        function normalizeEventRange(props) {

            normalizeEventRangeTimes(props);

            if (props.end && !props.end.isAfter(props.start)) {
                props.end = null;
            }

            if (!props.end) {
                if (options.forceEventDuration) {
                    props.end = t.getDefaultEventEnd(props.allDay, props.start);
                }
                else {
                    props.end = null;
                }
            }
        }


        // Ensures the allDay property exists and the timeliness of the start/end dates are consistent
        function normalizeEventRangeTimes(range) {
            if (range.allDay == null) {
                range.allDay = !(range.start.hasTime() || (range.end && range.end.hasTime()));
            }

            if (range.allDay) {
                range.start.stripTime();
                if (range.end) {
                    // TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
                    range.end.stripTime();
                }
            }
            else {
                if (!range.start.hasTime()) {
                    range.start = t.rezoneDate(range.start); // will assign a 00:00 time
                }
                if (range.end && !range.end.hasTime()) {
                    range.end = t.rezoneDate(range.end); // will assign a 00:00 time
                }
            }
        }


        // If `range` is a proper range with a start and end, returns the original object.
        // If missing an end, computes a new range with an end, computing it as if it were an event.
        // TODO: make this a part of the event -> eventRange system
        function ensureVisibleEventRange(range) {
            var allDay;

            if (!range.end) {

                allDay = range.allDay; // range might be more event-ish than we think
                if (allDay == null) {
                    allDay = !range.start.hasTime();
                }

                range = $.extend({}, range); // make a copy, copying over other misc properties
                range.end = t.getDefaultEventEnd(allDay, range.start);
            }
            return range;
        }


        // If the given event is a recurring event, break it down into an array of individual instances.
        // If not a recurring event, return an array with the single original event.
        // If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
        // HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
        function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
            var events = [];
            var dowHash;
            var dow;
            var i;
            var date;
            var startTime, endTime;
            var start, end;
            var event;

            _rangeStart = _rangeStart || rangeStart;
            _rangeEnd = _rangeEnd || rangeEnd;

            if (abstractEvent) {
                if (abstractEvent._recurring) {

                    // make a boolean hash as to whether the event occurs on each day-of-week
                    if ((dow = abstractEvent.dow)) {
                        dowHash = {};
                        for (i = 0; i < dow.length; i++) {
                            dowHash[dow[i]] = true;
                        }
                    }

                    // iterate through every day in the current range
                    date = _rangeStart.clone().stripTime(); // holds the date of the current day
                    while (date.isBefore(_rangeEnd)) {

                        if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

                            startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
                            endTime = abstractEvent.end; // "
                            start = date.clone();
                            end = null;

                            if (startTime) {
                                start = start.time(startTime);
                            }
                            if (endTime) {
                                end = date.clone().time(endTime);
                            }

                            event = $.extend({}, abstractEvent); // make a copy of the original
                            assignDatesToEvent(
                                start, end,
                                !startTime && !endTime, // allDay?
                                event
                            );
                            events.push(event);
                        }

                        date.add(1, 'days');
                    }
                }
                else {
                    events.push(abstractEvent); // return the original event. will be a one-item array
                }
            }

            return events;
        }


        /* Event Modification Math
	-----------------------------------------------------------------------------------------*/


        // Modifies an event and all related events by applying the given properties.
        // Special date-diffing logic is used for manipulation of dates.
        // If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
        // All date comparisons are done against the event's pristine _start and _end dates.
        // Returns an object with delta information and a function to undo all operations.
        // For making computations in a granularity greater than day/time, specify largeUnit.
        // NOTE: The given `newProps` might be mutated for normalization purposes.
        function mutateEvent(event, newProps, largeUnit) {
            var miscProps = {};
            var oldProps;
            var clearEnd;
            var startDelta;
            var endDelta;
            var durationDelta;
            var undoFunc;

            // diffs the dates in the appropriate way, returning a duration
            function diffDates(date1, date0) { // date1 - date0
                if (largeUnit) {
                    return diffByUnit(date1, date0, largeUnit);
                }
                else if (newProps.allDay) {
                    return diffDay(date1, date0);
                }
                else {
                    return diffDayTime(date1, date0);
                }
            }

            newProps = newProps || {};

            // normalize new date-related properties
            if (!newProps.start) {
                newProps.start = event.start.clone();
            }
            if (newProps.end === undefined) {
                newProps.end = event.end ? event.end.clone() : null;
            }
            if (newProps.allDay == null) { // is null or undefined?
                newProps.allDay = event.allDay;
            }
            normalizeEventRange(newProps);

            // create normalized versions of the original props to compare against
            // need a real end value, for diffing
            oldProps = {
                start: event._start.clone(),
                end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
                allDay: newProps.allDay // normalize the dates in the same regard as the new properties
            };
            normalizeEventRange(oldProps);

            // need to clear the end date if explicitly changed to null
            clearEnd = event._end !== null && newProps.end === null;

            // compute the delta for moving the start date
            startDelta = diffDates(newProps.start, oldProps.start);

            // compute the delta for moving the end date
            if (newProps.end) {
                endDelta = diffDates(newProps.end, oldProps.end);
                durationDelta = endDelta.subtract(startDelta);
            }
            else {
                durationDelta = null;
            }

            // gather all non-date-related properties
            $.each(newProps, function (name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined) {
                        miscProps[name] = val;
                    }
                }
            });

            // apply the operations to the event and all related events
            undoFunc = mutateEvents(
                clientEvents(event._id), // get events with this ID
                clearEnd,
                newProps.allDay,
                startDelta,
                durationDelta,
                miscProps
            );

            return {
                dateDelta: startDelta,
                durationDelta: durationDelta,
                undo: undoFunc
            };
        }


        // Modifies an array of events in the following ways (operations are in order):
        // - clear the event's `end`
        // - convert the event to allDay
        // - add `dateDelta` to the start and end
        // - add `durationDelta` to the event's duration
        // - assign `miscProps` to the event
        //
        // Returns a function that can be called to undo all the operations.
        //
        // TODO: don't use so many closures. possible memory issues when lots of events with same ID.
        //
        function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
            var isAmbigTimezone = t.getIsAmbigTimezone();
            var undoFunctions = [];

            // normalize zero-length deltas to be null
            if (dateDelta && !dateDelta.valueOf()) {
                dateDelta = null;
            }
            if (durationDelta && !durationDelta.valueOf()) {
                durationDelta = null;
            }

            $.each(events, function (i, event) {
                var oldProps;
                var newProps;

                // build an object holding all the old values, both date-related and misc.
                // for the undo function.
                oldProps = {
                    start: event.start.clone(),
                    end: event.end ? event.end.clone() : null,
                    allDay: event.allDay
                };
                $.each(miscProps, function (name) {
                    oldProps[name] = event[name];
                });

                // new date-related properties. work off the original date snapshot.
                // ok to use references because they will be thrown away when backupEventDates is called.
                newProps = {
                    start: event._start,
                    end: event._end,
                    allDay: allDay // normalize the dates in the same regard as the new properties
                };
                normalizeEventRange(newProps); // massages start/end/allDay

                // strip or ensure the end date
                if (clearEnd) {
                    newProps.end = null;
                }
                else if (durationDelta && !newProps.end) { // the duration translation requires an end date
                    newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
                }

                if (dateDelta) {
                    newProps.start.add(dateDelta);
                    if (newProps.end) {
                        newProps.end.add(dateDelta);
                    }
                }

                if (durationDelta) {
                    newProps.end.add(durationDelta); // end already ensured above
                }

                // if the dates have changed, and we know it is impossible to recompute the
                // timezone offsets, strip the zone.
                if (
                    isAmbigTimezone &&
                    !newProps.allDay &&
                    (dateDelta || durationDelta)
                ) {
                    newProps.start.stripZone();
                    if (newProps.end) {
                        newProps.end.stripZone();
                    }
                }

                $.extend(event, miscProps, newProps); // copy over misc props, then date-related props
                backupEventDates(event); // regenerate internal _start/_end/_allDay

                undoFunctions.push(function () {
                    $.extend(event, oldProps);
                    backupEventDates(event); // regenerate internal _start/_end/_allDay
                });
            });

            return function () {
                for (var i = 0; i < undoFunctions.length; i++) {
                    undoFunctions[i]();
                }
            };
        }


        /* Business Hours
	-----------------------------------------------------------------------------------------*/

        t.getBusinessHoursEvents = getBusinessHoursEvents;


        // Returns an array of events as to when the business hours occur in the given view.
        // Abuse of our event system :(
        function getBusinessHoursEvents(wholeDay) {
            var optionVal = options.businessHours;
            var defaultVal = {
                className: 'fc-nonbusiness',
                start: '09:00',
                end: '17:00',
                dow: [1, 2, 3, 4, 5], // monday - friday
                rendering: 'inverse-background'
            };
            var view = t.getView();
            var eventInput;

            if (optionVal) { // `true` (which means "use the defaults") or an override object
                eventInput = $.extend(
                    {}, // copy to a new object in either case
                    defaultVal,
                    typeof optionVal === 'object' ? optionVal : {} // override the defaults
                );
            }

            if (eventInput) {

                // if a whole-day series is requested, clear the start/end times
                if (wholeDay) {
                    eventInput.start = null;
                    eventInput.end = null;
                }

                return expandEvent(
                    buildEventFromInput(eventInput),
                    view.start,
                    view.end
                );
            }

            return [];
        }


        /* Overlapping / Constraining
	-----------------------------------------------------------------------------------------*/

        t.isEventRangeAllowed = isEventRangeAllowed;
        t.isSelectionRangeAllowed = isSelectionRangeAllowed;
        t.isExternalDropRangeAllowed = isExternalDropRangeAllowed;


        function isEventRangeAllowed(range, event) {
            var source = event.source || {};
            var constraint = firstDefined(
                event.constraint,
                source.constraint,
                options.eventConstraint
            );
            var overlap = firstDefined(
                event.overlap,
                source.overlap,
                options.eventOverlap
            );

            range = ensureVisibleEventRange(range); // ensure a proper range with an end for isRangeAllowed

            return isRangeAllowed(range, constraint, overlap, event);
        }


        function isSelectionRangeAllowed(range) {
            return isRangeAllowed(range, options.selectConstraint, options.selectOverlap);
        }


        // when `eventProps` is defined, consider this an event.
        // `eventProps` can contain misc non-date-related info about the event.
        function isExternalDropRangeAllowed(range, eventProps) {
            var eventInput;
            var event;

            // note: very similar logic is in View's reportExternalDrop
            if (eventProps) {
                eventInput = $.extend({}, eventProps, range);
                event = expandEvent(buildEventFromInput(eventInput))[0];
            }

            if (event) {
                return isEventRangeAllowed(range, event);
            }
            else { // treat it as a selection

                range = ensureVisibleEventRange(range); // ensure a proper range with an end for isSelectionRangeAllowed

                return isSelectionRangeAllowed(range);
            }
        }


        // Returns true if the given range (caused by an event drop/resize or a selection) is allowed to exist
        // according to the constraint/overlap settings.
        // `event` is not required if checking a selection.
        function isRangeAllowed(range, constraint, overlap, event) {
            var constraintEvents;
            var anyContainment;
            var peerEvents;
            var i, peerEvent;
            var peerOverlap;

            // normalize. fyi, we're normalizing in too many places :(
            range = $.extend({}, range); // copy all properties in case there are misc non-date properties
            range.start = range.start.clone().stripZone();
            range.end = range.end.clone().stripZone();

            // the range must be fully contained by at least one of produced constraint events
            if (constraint != null) {

                // not treated as an event! intermediate data structure
                // TODO: use ranges in the future
                constraintEvents = constraintToEvents(constraint);

                anyContainment = false;
                for (i = 0; i < constraintEvents.length; i++) {
                    if (eventContainsRange(constraintEvents[i], range)) {
                        anyContainment = true;
                        break;
                    }
                }

                if (!anyContainment) {
                    return false;
                }
            }

            peerEvents = t.getPeerEvents(event, range);

            for (i = 0; i < peerEvents.length; i++) {
                peerEvent = peerEvents[i];

                // there needs to be an actual intersection before disallowing anything
                if (eventIntersectsRange(peerEvent, range)) {

                    // evaluate overlap for the given range and short-circuit if necessary
                    if (overlap === false) {
                        return false;
                    }
                    // if the event's overlap is a test function, pass the peer event in question as the first param
                    else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
                        return false;
                    }

                    // if we are computing if the given range is allowable for an event, consider the other event's
                    // EventObject-specific or Source-specific `overlap` property
                    if (event) {
                        peerOverlap = firstDefined(
                            peerEvent.overlap,
                            (peerEvent.source || {}).overlap
                            // we already considered the global `eventOverlap`
                        );
                        if (peerOverlap === false) {
                            return false;
                        }
                        // if the peer event's overlap is a test function, pass the subject event as the first param
                        if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
                            return false;
                        }
                    }
                }
            }

            return true;
        }


        // Given an event input from the API, produces an array of event objects. Possible event inputs:
        // 'businessHours'
        // An event ID (number or string)
        // An object with specific start/end dates or a recurring event (like what businessHours accepts)
        function constraintToEvents(constraintInput) {

            if (constraintInput === 'businessHours') {
                return getBusinessHoursEvents();
            }

            if (typeof constraintInput === 'object') {
                return expandEvent(buildEventFromInput(constraintInput));
            }

            return clientEvents(constraintInput); // probably an ID
        }


        // Does the event's date range fully contain the given range?
        // start/end already assumed to have stripped zones :(
        function eventContainsRange(event, range) {
            var eventStart = event.start.clone().stripZone();
            var eventEnd = t.getEventEnd(event).stripZone();

            return range.start >= eventStart && range.end <= eventEnd;
        }


        // Does the event's date range intersect with the given range?
        // start/end already assumed to have stripped zones :(
        function eventIntersectsRange(event, range) {
            var eventStart = event.start.clone().stripZone();
            var eventEnd = t.getEventEnd(event).stripZone();

            return range.start < eventEnd && range.end > eventStart;
        }


        t.getEventCache = function () {
            return cache;
        };

    }


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified range. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
    Calendar.prototype.getPeerEvents = function (event, range) {
        var cache = this.getEventCache();
        var peerEvents = [];
        var i, otherEvent;

        for (i = 0; i < cache.length; i++) {
            otherEvent = cache[i];
            if (
                !event ||
                event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
            ) {
                peerEvents.push(otherEvent);
            }
        }

        return peerEvents;
    };


// updates the "backup" properties, which are preserved in order to compute diffs later on.
    function backupEventDates(event) {
        event._allDay = event.allDay;
        event._start = event.start.clone();
        event._end = event.end ? event.end.clone() : null;
    }

    ;
    ;

    /* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

    var BasicView = View.extend({

        dayGrid: null, // the main subcomponent that does most of the heavy lifting

        dayNumbersVisible: false, // display day numbers on each day cell?
        weekNumbersVisible: false, // display week numbers along the side?

        weekNumberWidth: null, // width of all the week-number cells running down the side

        headRowEl: null, // the fake row element of the day-of-week header


        initialize: function () {
            this.dayGrid = new DayGrid(this);
            this.coordMap = this.dayGrid.coordMap; // the view's date-to-cell mapping is identical to the subcomponent's
        },


        // Sets the display range and computes all necessary dates
        setRange: function (range) {
            View.prototype.setRange.call(this, range); // call the super-method

            this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange
            this.dayGrid.setRange(range);
        },


        // Compute the value to feed into setRange. Overrides superclass.
        computeRange: function (date) {
            var range = View.prototype.computeRange.call(this, date); // get value from the super-method

            // year and month views should be aligned with weeks. this is already done for week
            if (/year|month/.test(range.intervalUnit)) {
                range.start.startOf('week');
                range.start = this.skipHiddenDays(range.start);

                // make end-of-week if not already
                if (range.end.weekday()) {
                    range.end.add(1, 'week').startOf('week');
                    range.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards
                }
            }

            return range;
        },


        // Renders the view into `this.el`, which should already be assigned
        renderDates: function () {

            this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
            this.weekNumbersVisible = this.opt('weekNumbers');
            this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible;

            this.el.addClass('fc-basic-view').html(this.renderHtml());

            this.headRowEl = this.el.find('thead .fc-row');

            this.scrollerEl = this.el.find('.fc-day-grid-container');
            this.dayGrid.coordMap.containerEl = this.scrollerEl; // constrain clicks/etc to the dimensions of the scroller

            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            this.dayGrid.renderDates(this.hasRigidRows());
        },


        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
        // always completely kill the dayGrid's rendering.
        unrenderDates: function () {
            this.dayGrid.unrenderDates();
            this.dayGrid.removeElement();
        },


        renderBusinessHours: function () {
            this.dayGrid.renderBusinessHours();
        },


        // Builds the HTML skeleton for the view.
        // The day-grid component will render inside of a container defined by this HTML.
        renderHtml: function () {
            return '' +
                '<table>' +
                '<thead class="fc-head">' +
                '<tr>' +
                '<td class="' + this.widgetHeaderClass + '">' +
                this.dayGrid.headHtml() + // render the day-of-week headers
                '</td>' +
                '</tr>' +
                '</thead>' +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + this.widgetContentClass + '">' +
                '<div class="fc-day-grid-container">' +
                '<div class="fc-day-grid"/>' +
                '</div>' +
                '</td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        },


        // Generates the HTML that will go before the day-of week header cells.
        // Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
        headIntroHtml: function () {
            if (this.weekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + this.widgetHeaderClass + '" ' + this.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    htmlEscape(this.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }
        },


        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers.
        // Queried by the DayGrid subcomponent. Ordering depends on isRTL.
        numberIntroHtml: function (row) {
            if (this.weekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    this.dayGrid.getCell(row, 0).start.format('w') +
                    '</span>' +
                    '</td>';
            }
        },


        // Generates the HTML that goes before the day bg cells for each day-row.
        // Queried by the DayGrid subcomponent. Ordering depends on isRTL.
        dayIntroHtml: function () {
            if (this.weekNumbersVisible) {
                return '<td class="fc-week-number ' + this.widgetContentClass + '" ' +
                    this.weekNumberStyleAttr() + '></td>';
            }
        },


        // Generates the HTML that goes before every other type of row generated by DayGrid. Ordering depends on isRTL.
        // Affects helper-skeleton and highlight-skeleton rows.
        introHtml: function () {
            if (this.weekNumbersVisible) {
                return '<td class="fc-week-number" ' + this.weekNumberStyleAttr() + '></td>';
            }
        },


        // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
        // The number row will only exist if either day numbers or week numbers are turned on.
        numberCellHtml: function (cell) {
            var date = cell.start;
            var classes;

            if (!this.dayNumbersVisible) { // if there are week numbers but not day numbers
                return '<td/>'; //  will create an empty space above events :(
            }

            classes = this.dayGrid.getDayClasses(date);
            classes.unshift('fc-day-number');

            return '' +
                '<td class="' + classes.join(' ') + '" data-date="' + date.format() + '">' +
                date.date() +
                '</td>';
        },


        // Generates an HTML attribute string for setting the width of the week number column, if it is known
        weekNumberStyleAttr: function () {
            if (this.weekNumberWidth !== null) {
                return 'style="width:' + this.weekNumberWidth + 'px"';
            }
            return '';
        },


        // Determines whether each row should have a constant height
        hasRigidRows: function () {
            var eventLimit = this.opt('eventLimit');
            return eventLimit && typeof eventLimit !== 'number';
        },


        /* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


        // Refreshes the horizontal dimensions of the view
        updateWidth: function () {
            if (this.weekNumbersVisible) {
                // Make sure all week number cells running down the side have the same width.
                // Record the width for cells created later.
                this.weekNumberWidth = matchCellWidths(
                    this.el.find('.fc-week-number')
                );
            }
        },


        // Adjusts the vertical dimensions of the view to the specified values
        setHeight: function (totalHeight, isAuto) {
            var eventLimit = this.opt('eventLimit');
            var scrollerHeight;

            // reset all heights to be natural
            unsetScroller(this.scrollerEl);
            uncompensateScroll(this.headRowEl);

            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

            // is the event limit a constant level number?
            if (eventLimit && typeof eventLimit === 'number') {
                this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
            }

            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.setGridHeight(scrollerHeight, isAuto);

            // is the event limit dynamically calculated?
            if (eventLimit && typeof eventLimit !== 'number') {
                this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
            }

            if (!isAuto && setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?

                compensateScroll(this.headRowEl, getScrollbarWidths(this.scrollerEl));

                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scrollerEl.height(scrollerHeight);
            }
        },


        // Sets the height of just the DayGrid component in this view
        setGridHeight: function (height, isAuto) {
            if (isAuto) {
                undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
            }
            else {
                distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
            }
        },


        /* Events
	------------------------------------------------------------------------------------------------------------------*/


        // Renders the given events onto the view and populates the segments array
        renderEvents: function (events) {
            this.dayGrid.renderEvents(events);

            this.updateHeight(); // must compensate for events that overflow the row
        },


        // Retrieves all segment objects that are rendered in the view
        getEventSegs: function () {
            return this.dayGrid.getEventSegs();
        },


        // Unrenders all event elements and clears internal segment data
        unrenderEvents: function () {
            this.dayGrid.unrenderEvents();

            // we DON'T need to call updateHeight() because:
            // A) a renderEvents() call always happens after this, which will eventually call updateHeight()
            // B) in IE8, this causes a flash whenever events are rerendered
        },


        /* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function (dropLocation, seg) {
            return this.dayGrid.renderDrag(dropLocation, seg);
        },


        unrenderDrag: function () {
            this.dayGrid.unrenderDrag();
        },


        /* Selection
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection
        renderSelection: function (range) {
            this.dayGrid.renderSelection(range);
        },


        // Unrenders a visual indications of a selection
        unrenderSelection: function () {
            this.dayGrid.unrenderSelection();
        }

    });

    ;
    ;

    /* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/

    var MonthView = BasicView.extend({

        // Produces information about what range to display
        computeRange: function (date) {
            var range = BasicView.prototype.computeRange.call(this, date); // get value from super-method
            var rowCnt;

            // ensure 6 weeks
            if (this.isFixedWeeks()) {
                rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays
                range.end.add(6 - rowCnt, 'weeks');
            }

            return range;
        },


        // Overrides the default BasicView behavior to have special multi-week auto-height logic
        setGridHeight: function (height, isAuto) {

            isAuto = isAuto || this.opt('weekMode') === 'variable'; // LEGACY: weekMode is deprecated

            // if auto, make the height of each row the height that it would be if there were 6 weeks
            if (isAuto) {
                height *= this.rowCnt / 6;
            }

            distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
        },


        isFixedWeeks: function () {
            var weekMode = this.opt('weekMode'); // LEGACY: weekMode is deprecated
            if (weekMode) {
                return weekMode === 'fixed'; // if any other type of weekMode, assume NOT fixed
            }

            return this.opt('fixedWeekCount');
        }

    });

    ;
    ;

    fcViews.basic = {
        'class': BasicView
    };

    fcViews.basicDay = {
        type: 'basic',
        duration: {days: 1}
    };

    fcViews.basicWeek = {
        type: 'basic',
        duration: {weeks: 1}
    };

    fcViews.month = {
        'class': MonthView,
        duration: {months: 1}, // important for prev/next
        defaults: {
            fixedWeekCount: true
        }
    };
    ;
    ;

    /* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

    var AgendaView = View.extend({

        timeGrid: null, // the main time-grid subcomponent of this view
        dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

        axisWidth: null, // the width of the time axis running down the side

        noScrollRowEls: null, // set of fake row elements that must compensate when scrollerEl has scrollbars

        // when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
        bottomRuleEl: null,
        bottomRuleHeight: null,


        initialize: function () {
            this.timeGrid = new TimeGrid(this);

            if (this.opt('allDaySlot')) { // should we display the "all-day" area?
                this.dayGrid = new DayGrid(this); // the all-day subcomponent of this view

                // the coordinate grid will be a combination of both subcomponents' grids
                this.coordMap = new ComboCoordMap([
                    this.dayGrid.coordMap,
                    this.timeGrid.coordMap
                ]);
            }
            else {
                this.coordMap = this.timeGrid.coordMap;
            }
        },


        /* Rendering
	------------------------------------------------------------------------------------------------------------------*/


        // Sets the display range and computes all necessary dates
        setRange: function (range) {
            View.prototype.setRange.call(this, range); // call the super-method

            this.timeGrid.setRange(range);
            if (this.dayGrid) {
                this.dayGrid.setRange(range);
            }
        },


        // Renders the view into `this.el`, which has already been assigned
        renderDates: function () {

            this.el.addClass('fc-agenda-view').html(this.renderHtml());

            // the element that wraps the time-grid that will probably scroll
            this.scrollerEl = this.el.find('.fc-time-grid-container');
            this.timeGrid.coordMap.containerEl = this.scrollerEl; // don't accept clicks/etc outside of this

            this.timeGrid.setElement(this.el.find('.fc-time-grid'));
            this.timeGrid.renderDates();

            // the <hr> that sometimes displays under the time-grid
            this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
                .appendTo(this.timeGrid.el); // inject it into the time-grid

            if (this.dayGrid) {
                this.dayGrid.setElement(this.el.find('.fc-day-grid'));
                this.dayGrid.renderDates();

                // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
                this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
            }

            this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
        },


        // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
        // always completely kill each grid's rendering.
        unrenderDates: function () {
            this.timeGrid.unrenderDates();
            this.timeGrid.removeElement();

            if (this.dayGrid) {
                this.dayGrid.unrenderDates();
                this.dayGrid.removeElement();
            }
        },


        renderBusinessHours: function () {
            this.timeGrid.renderBusinessHours();

            if (this.dayGrid) {
                this.dayGrid.renderBusinessHours();
            }
        },


        // Builds the HTML skeleton for the view.
        // The day-grid and time-grid components will render inside containers defined by this HTML.
        renderHtml: function () {
            return '' +
                '<table>' +
                '<thead class="fc-head">' +
                '<tr>' +
                '<td class="' + this.widgetHeaderClass + '">' +
                this.timeGrid.headHtml() + // render the day-of-week headers
                '</td>' +
                '</tr>' +
                '</thead>' +
                '<tbody class="fc-body">' +
                '<tr>' +
                '<td class="' + this.widgetContentClass + '">' +
                (this.dayGrid ?
                        '<div class="fc-day-grid"/>' +
                        '<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
                        ''
                ) +
                '<div class="fc-time-grid-container">' +
                '<div class="fc-time-grid"/>' +
                '</div>' +
                '</td>' +
                '</tr>' +
                '</tbody>' +
                '</table>';
        },


        // Generates the HTML that will go before the day-of week header cells.
        // Queried by the TimeGrid subcomponent when generating rows. Ordering depends on isRTL.
        headIntroHtml: function () {
            var date;
            var weekText;

            if (this.opt('weekNumbers')) {
                date = this.timeGrid.getCell(0).start;
                weekText = date.format(this.opt('smallWeekFormat'));

                return '' +
                    '<th class="fc-axis fc-week-number ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    htmlEscape(weekText) +
                    '</span>' +
                    '</th>';
            }
            else {
                return '<th class="fc-axis ' + this.widgetHeaderClass + '" ' + this.axisStyleAttr() + '></th>';
            }
        },


        // Generates the HTML that goes before the all-day cells.
        // Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
        dayIntroHtml: function () {
            return '' +
                '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + '>' +
                '<span>' + // needed for matchCellWidths
                (this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'))) +
                '</span>' +
                '</td>';
        },


        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
        slotBgIntroHtml: function () {
            return '<td class="fc-axis ' + this.widgetContentClass + '" ' + this.axisStyleAttr() + '></td>';
        },


        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        // Queried by the TimeGrid and DayGrid subcomponents when generating rows. Ordering depends on isRTL.
        introHtml: function () {
            return '<td class="fc-axis" ' + this.axisStyleAttr() + '></td>';
        },


        // Generates an HTML attribute string for setting the width of the axis, if it is known
        axisStyleAttr: function () {
            if (this.axisWidth !== null) {
                return 'style="width:' + this.axisWidth + 'px"';
            }
            return '';
        },


        /* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


        updateSize: function (isResize) {
            this.timeGrid.updateSize(isResize);

            View.prototype.updateSize.call(this, isResize); // call the super-method
        },


        // Refreshes the horizontal dimensions of the view
        updateWidth: function () {
            // make all axis cells line up, and record the width so newly created axis cells will have it
            this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
        },


        // Adjusts the vertical dimensions of the view to the specified values
        setHeight: function (totalHeight, isAuto) {
            var eventLimit;
            var scrollerHeight;

            if (this.bottomRuleHeight === null) {
                // calculate the height of the rule the very first time
                this.bottomRuleHeight = this.bottomRuleEl.outerHeight();
            }
            this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary

            // reset all dimensions back to the original state
            this.scrollerEl.css('overflow', '');
            unsetScroller(this.scrollerEl);
            uncompensateScroll(this.noScrollRowEls);

            // limit number of events in the all-day area
            if (this.dayGrid) {
                this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

                eventLimit = this.opt('eventLimit');
                if (eventLimit && typeof eventLimit !== 'number') {
                    eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
                }
                if (eventLimit) {
                    this.dayGrid.limitRows(eventLimit);
                }
            }

            if (!isAuto) { // should we force dimensions of the scroll container, or let the contents be natural height?

                scrollerHeight = this.computeScrollerHeight(totalHeight);
                if (setPotentialScroller(this.scrollerEl, scrollerHeight)) { // using scrollbars?

                    // make the all-day and header rows lines up
                    compensateScroll(this.noScrollRowEls, getScrollbarWidths(this.scrollerEl));

                    // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                    // and reapply the desired height to the scroller.
                    scrollerHeight = this.computeScrollerHeight(totalHeight);
                    this.scrollerEl.height(scrollerHeight);
                }
                else { // no scrollbars
                    // still, force a height and display the bottom rule (marks the end of day)
                    this.scrollerEl.height(scrollerHeight).css('overflow', 'hidden'); // in case <hr> goes outside
                    this.bottomRuleEl.show();
                }
            }
        },


        // Computes the initial pre-configured scroll state prior to allowing the user to change it
        computeInitialScroll: function () {
            var scrollTime = moment.duration(this.opt('scrollTime'));
            var top = this.timeGrid.computeTimeTop(scrollTime);

            // zoom can give weird floating-point values. rather scroll a little bit further
            top = Math.ceil(top);

            if (top) {
                top++; // to overcome top border that slots beyond the first have. looks better
            }

            return top;
        },


        /* Events
	------------------------------------------------------------------------------------------------------------------*/


        // Renders events onto the view and populates the View's segment array
        renderEvents: function (events) {
            var dayEvents = [];
            var timedEvents = [];
            var daySegs = [];
            var timedSegs;
            var i;

            // separate the events into all-day and timed
            for (i = 0; i < events.length; i++) {
                if (events[i].allDay) {
                    dayEvents.push(events[i]);
                }
                else {
                    timedEvents.push(events[i]);
                }
            }

            // render the events in the subcomponents
            timedSegs = this.timeGrid.renderEvents(timedEvents);
            if (this.dayGrid) {
                daySegs = this.dayGrid.renderEvents(dayEvents);
            }

            // the all-day area is flexible and might have a lot of events, so shift the height
            this.updateHeight();
        },


        // Retrieves all segment objects that are rendered in the view
        getEventSegs: function () {
            return this.timeGrid.getEventSegs().concat(
                this.dayGrid ? this.dayGrid.getEventSegs() : []
            );
        },


        // Unrenders all event elements and clears internal segment data
        unrenderEvents: function () {

            // unrender the events in the subcomponents
            this.timeGrid.unrenderEvents();
            if (this.dayGrid) {
                this.dayGrid.unrenderEvents();
            }

            // we DON'T need to call updateHeight() because:
            // A) a renderEvents() call always happens after this, which will eventually call updateHeight()
            // B) in IE8, this causes a flash whenever events are rerendered
        },


        /* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


        // A returned value of `true` signals that a mock "helper" event has been rendered.
        renderDrag: function (dropLocation, seg) {
            if (dropLocation.start.hasTime()) {
                return this.timeGrid.renderDrag(dropLocation, seg);
            }
            else if (this.dayGrid) {
                return this.dayGrid.renderDrag(dropLocation, seg);
            }
        },


        unrenderDrag: function () {
            this.timeGrid.unrenderDrag();
            if (this.dayGrid) {
                this.dayGrid.unrenderDrag();
            }
        },


        /* Selection
	------------------------------------------------------------------------------------------------------------------*/


        // Renders a visual indication of a selection
        renderSelection: function (range) {
            if (range.start.hasTime() || range.end.hasTime()) {
                this.timeGrid.renderSelection(range);
            }
            else if (this.dayGrid) {
                this.dayGrid.renderSelection(range);
            }
        },


        // Unrenders a visual indications of a selection
        unrenderSelection: function () {
            this.timeGrid.unrenderSelection();
            if (this.dayGrid) {
                this.dayGrid.unrenderSelection();
            }
        }

    });

    ;
    ;

    var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
    var AGENDA_STOCK_SUB_DURATIONS = [
        {hours: 1},
        {minutes: 30},
        {minutes: 15},
        {seconds: 30},
        {seconds: 15}
    ];

    fcViews.agenda = {
        'class': AgendaView,
        defaults: {
            allDaySlot: true,
            allDayText: 'all-day',
            slotDuration: '00:30:00',
            minTime: '00:00:00',
            maxTime: '24:00:00',
            slotEventOverlap: true // a bad name. confused with overlap/constraint system
        }
    };

    fcViews.agendaDay = {
        type: 'agenda',
        duration: {days: 1}
    };

    fcViews.agendaWeek = {
        type: 'agenda',
        duration: {weeks: 1}
    };
    ;
    ;

    return fc; // export for Node/CommonJS
});
/**
 * Super simple wysiwyg editor on Bootstrap v0.6.16
 * http://summernote.org/
 *
 * summernote.js
 * Copyright 2013-2015 Alan Hong. and other contributors
 * summernote may be freely distributed under the MIT license./
 *
 * Date: 2015-08-03T16:41Z
 */
(function (factory) {
    /* global define */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals: jQuery
        factory(window.jQuery);
    }
}(function ($) {


    if (!Array.prototype.reduce) {
        /**
         * Array.prototype.reduce polyfill
         *
         * @param {Function} callback
         * @param {Value} [initialValue]
         * @return {Value}
         *
         * @see http://goo.gl/WNriQD
         */
        Array.prototype.reduce = function (callback) {
            var t = Object(this), len = t.length >>> 0, k = 0, value;
            if (arguments.length === 2) {
                value = arguments[1];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }
                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        };
    }

    if ('function' !== typeof Array.prototype.filter) {
        /**
         * Array.prototype.filter polyfill
         *
         * @param {Function} func
         * @return {Array}
         *
         * @see http://goo.gl/T1KFnq
         */
        Array.prototype.filter = function (func) {
            var t = Object(this), len = t.length >>> 0;

            var res = [];
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    var val = t[i];
                    if (func.call(thisArg, val, i, t)) {
                        res.push(val);
                    }
                }
            }

            return res;
        };
    }

    if (!Array.prototype.map) {
        /**
         * Array.prototype.map polyfill
         *
         * @param {Function} callback
         * @return {Array}
         *
         * @see https://goo.gl/SMWaMK
         */
        Array.prototype.map = function (callback, thisArg) {
            var T, A, k;
            if (this === null) {
                throw new TypeError(' this is null or not defined');
            }

            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            if (arguments.length > 1) {
                T = thisArg;
            }

            A = new Array(len);
            k = 0;

            while (k < len) {
                var kValue, mappedValue;
                if (k in O) {
                    kValue = O[k];
                    mappedValue = callback.call(T, kValue, k, O);
                    A[k] = mappedValue;
                }
                k++;
            }
            return A;
        };
    }

    var isSupportAmd = typeof define === 'function' && define.amd;

    /**
     * returns whether font is installed or not.
     *
     * @param {String} fontName
     * @return {Boolean}
     */
    var isFontInstalled = function (fontName) {
        var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
        var $tester = $('<div>').css({
            position: 'absolute',
            left: '-9999px',
            top: '-9999px',
            fontSize: '200px'
        }).text('mmmmmmmmmwwwwwww').appendTo(document.body);

        var originalWidth = $tester.css('fontFamily', testFontName).width();
        var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();

        $tester.remove();

        return originalWidth !== width;
    };

    var userAgent = navigator.userAgent;
    var isMSIE = /MSIE|Trident/i.test(userAgent);
    var browserVersion;
    if (isMSIE) {
        var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
        matches = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(userAgent);
        if (matches) {
            browserVersion = parseFloat(matches[1]);
        }
    }

    /**
     * @class core.agent
     *
     * Object which check platform and agent
     *
     * @singleton
     * @alternateClassName agent
     */
    var agent = {
        /** @property {Boolean} [isMac=false] true if this agent is Mac  */
        isMac: navigator.appVersion.indexOf('Mac') > -1,
        /** @property {Boolean} [isMSIE=false] true if this agent is a Internet Explorer  */
        isMSIE: isMSIE,
        /** @property {Boolean} [isFF=false] true if this agent is a Firefox  */
        isFF: /firefox/i.test(userAgent),
        isWebkit: /webkit/i.test(userAgent),
        /** @property {Boolean} [isSafari=false] true if this agent is a Safari  */
        isSafari: /safari/i.test(userAgent),
        /** @property {Float} browserVersion current browser version  */
        browserVersion: browserVersion,
        /** @property {String} jqueryVersion current jQuery version string  */
        jqueryVersion: parseFloat($.fn.jquery),
        isSupportAmd: isSupportAmd,
        hasCodeMirror: isSupportAmd ? require.specified('CodeMirror') : !!window.CodeMirror,
        isFontInstalled: isFontInstalled,
        isW3CRangeSupport: !!document.createRange
    };

    /**
     * @class core.func
     *
     * func utils (for high-order func's arg)
     *
     * @singleton
     * @alternateClassName func
     */
    var func = (function () {
        var eq = function (itemA) {
            return function (itemB) {
                return itemA === itemB;
            };
        };

        var eq2 = function (itemA, itemB) {
            return itemA === itemB;
        };

        var peq2 = function (propName) {
            return function (itemA, itemB) {
                return itemA[propName] === itemB[propName];
            };
        };

        var ok = function () {
            return true;
        };

        var fail = function () {
            return false;
        };

        var not = function (f) {
            return function () {
                return !f.apply(f, arguments);
            };
        };

        var and = function (fA, fB) {
            return function (item) {
                return fA(item) && fB(item);
            };
        };

        var self = function (a) {
            return a;
        };

        var idCounter = 0;

        /**
         * generate a globally-unique id
         *
         * @param {String} [prefix]
         */
        var uniqueId = function (prefix) {
            var id = ++idCounter + '';
            return prefix ? prefix + id : id;
        };

        /**
         * returns bnd (bounds) from rect
         *
         * - IE Compatability Issue: http://goo.gl/sRLOAo
         * - Scroll Issue: http://goo.gl/sNjUc
         *
         * @param {Rect} rect
         * @return {Object} bounds
         * @return {Number} bounds.top
         * @return {Number} bounds.left
         * @return {Number} bounds.width
         * @return {Number} bounds.height
         */
        var rect2bnd = function (rect) {
            var $document = $(document);
            return {
                top: rect.top + $document.scrollTop(),
                left: rect.left + $document.scrollLeft(),
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        };

        /**
         * returns a copy of the object where the keys have become the values and the values the keys.
         * @param {Object} obj
         * @return {Object}
         */
        var invertObject = function (obj) {
            var inverted = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    inverted[obj[key]] = key;
                }
            }
            return inverted;
        };

        /**
         * @param {String} namespace
         * @param {String} [prefix]
         * @return {String}
         */
        var namespaceToCamel = function (namespace, prefix) {
            prefix = prefix || '';
            return prefix + namespace.split('.').map(function (name) {
                return name.substring(0, 1).toUpperCase() + name.substring(1);
            }).join('');
        };

        return {
            eq: eq,
            eq2: eq2,
            peq2: peq2,
            ok: ok,
            fail: fail,
            self: self,
            not: not,
            and: and,
            uniqueId: uniqueId,
            rect2bnd: rect2bnd,
            invertObject: invertObject,
            namespaceToCamel: namespaceToCamel
        };
    })();

    /**
     * @class core.list
     *
     * list utils
     *
     * @singleton
     * @alternateClassName list
     */
    var list = (function () {
        /**
         * returns the first item of an array.
         *
         * @param {Array} array
         */
        var head = function (array) {
            return array[0];
        };

        /**
         * returns the last item of an array.
         *
         * @param {Array} array
         */
        var last = function (array) {
            return array[array.length - 1];
        };

        /**
         * returns everything but the last entry of the array.
         *
         * @param {Array} array
         */
        var initial = function (array) {
            return array.slice(0, array.length - 1);
        };

        /**
         * returns the rest of the items in an array.
         *
         * @param {Array} array
         */
        var tail = function (array) {
            return array.slice(1);
        };

        /**
         * returns item of array
         */
        var find = function (array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                var item = array[idx];
                if (pred(item)) {
                    return item;
                }
            }
        };

        /**
         * returns true if all of the values in the array pass the predicate truth test.
         */
        var all = function (array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!pred(array[idx])) {
                    return false;
                }
            }
            return true;
        };

        /**
         * returns index of item
         */
        var indexOf = function (array, item) {
            return $.inArray(item, array);
        };

        /**
         * returns true if the value is present in the list.
         */
        var contains = function (array, item) {
            return indexOf(array, item) !== -1;
        };

        /**
         * get sum from a list
         *
         * @param {Array} array - array
         * @param {Function} fn - iterator
         */
        var sum = function (array, fn) {
            fn = fn || func.self;
            return array.reduce(function (memo, v) {
                return memo + fn(v);
            }, 0);
        };

        /**
         * returns a copy of the collection with array type.
         * @param {Collection} collection - collection eg) node.childNodes, ...
         */
        var from = function (collection) {
            var result = [], idx = -1, length = collection.length;
            while (++idx < length) {
                result[idx] = collection[idx];
            }
            return result;
        };

        /**
         * cluster elements by predicate function.
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         * @param {Array[]}
         */
        var clusterBy = function (array, fn) {
            if (!array.length) {
                return [];
            }
            var aTail = tail(array);
            return aTail.reduce(function (memo, v) {
                var aLast = last(memo);
                if (fn(last(aLast), v)) {
                    aLast[aLast.length] = v;
                } else {
                    memo[memo.length] = [v];
                }
                return memo;
            }, [[head(array)]]);
        };

        /**
         * returns a copy of the array with all falsy values removed
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         */
        var compact = function (array) {
            var aResult = [];
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (array[idx]) {
                    aResult.push(array[idx]);
                }
            }
            return aResult;
        };

        /**
         * produces a duplicate-free version of the array
         *
         * @param {Array} array
         */
        var unique = function (array) {
            var results = [];

            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!contains(results, array[idx])) {
                    results.push(array[idx]);
                }
            }

            return results;
        };

        /**
         * returns next item.
         * @param {Array} array
         */
        var next = function (array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }

            return array[idx + 1];
        };

        /**
         * returns prev item.
         * @param {Array} array
         */
        var prev = function (array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }

            return array[idx - 1];
        };

        return {
            head: head, last: last, initial: initial, tail: tail,
            prev: prev, next: next, find: find, contains: contains,
            all: all, sum: sum, from: from,
            clusterBy: clusterBy, compact: compact, unique: unique
        };
    })();


    var NBSP_CHAR = String.fromCharCode(160);
    var ZERO_WIDTH_NBSP_CHAR = '\ufeff';

    /**
     * @class core.dom
     *
     * Dom functions
     *
     * @singleton
     * @alternateClassName dom
     */
    var dom = (function () {
        /**
         * @method isEditable
         *
         * returns whether node is `note-editable` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isEditable = function (node) {
            return node && $(node).hasClass('note-editable');
        };

        /**
         * @method isControlSizing
         *
         * returns whether node is `note-control-sizing` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isControlSizing = function (node) {
            return node && $(node).hasClass('note-control-sizing');
        };

        /**
         * @method  buildLayoutInfo
         *
         * build layoutInfo from $editor(.note-editor)
         *
         * @param {jQuery} $editor
         * @return {Object}
         * @return {Function} return.editor
         * @return {Node} return.dropzone
         * @return {Node} return.toolbar
         * @return {Node} return.editable
         * @return {Node} return.codable
         * @return {Node} return.popover
         * @return {Node} return.handle
         * @return {Node} return.dialog
         */
        var buildLayoutInfo = function ($editor) {
            var makeFinder;

            // air mode
            if ($editor.hasClass('note-air-editor')) {
                var id = list.last($editor.attr('id').split('-'));
                makeFinder = function (sIdPrefix) {
                    return function () {
                        return $(sIdPrefix + id);
                    };
                };

                return {
                    editor: function () {
                        return $editor;
                    },
                    holder: function () {
                        return $editor.data('holder');
                    },
                    editable: function () {
                        return $editor;
                    },
                    popover: makeFinder('#note-popover-'),
                    handle: makeFinder('#note-handle-'),
                    dialog: makeFinder('#note-dialog-')
                };

                // frame mode
            } else {
                makeFinder = function (className, $base) {
                    $base = $base || $editor;
                    return function () {
                        return $base.find(className);
                    };
                };

                var options = $editor.data('options');
                var $dialogHolder = (options && options.dialogsInBody) ? $(document.body) : null;

                return {
                    editor: function () {
                        return $editor;
                    },
                    holder: function () {
                        return $editor.data('holder');
                    },
                    dropzone: makeFinder('.note-dropzone'),
                    toolbar: makeFinder('.note-toolbar'),
                    editable: makeFinder('.note-editable'),
                    codable: makeFinder('.note-codable'),
                    statusbar: makeFinder('.note-statusbar'),
                    popover: makeFinder('.note-popover'),
                    handle: makeFinder('.note-handle'),
                    dialog: makeFinder('.note-dialog', $dialogHolder)
                };
            }
        };

        /**
         * returns makeLayoutInfo from editor's descendant node.
         *
         * @private
         * @param {Node} descendant
         * @return {Object}
         */
        var makeLayoutInfo = function (descendant) {
            var $target = $(descendant).closest('.note-editor, .note-air-editor, .note-air-layout');

            if (!$target.length) {
                return null;
            }

            var $editor;
            if ($target.is('.note-editor, .note-air-editor')) {
                $editor = $target;
            } else {
                $editor = $('#note-editor-' + list.last($target.attr('id').split('-')));
            }

            return buildLayoutInfo($editor);
        };

        /**
         * @method makePredByNodeName
         *
         * returns predicate which judge whether nodeName is same
         *
         * @param {String} nodeName
         * @return {Function}
         */
        var makePredByNodeName = function (nodeName) {
            nodeName = nodeName.toUpperCase();
            return function (node) {
                return node && node.nodeName.toUpperCase() === nodeName;
            };
        };

        /**
         * @method isText
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is text(3)
         */
        var isText = function (node) {
            return node && node.nodeType === 3;
        };

        /**
         * ex) br, col, embed, hr, img, input, ...
         * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
         */
        var isVoid = function (node) {
            return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());
        };

        var isPara = function (node) {
            if (isEditable(node)) {
                return false;
            }

            // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph
            return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
        };

        var isLi = makePredByNodeName('LI');

        var isPurePara = function (node) {
            return isPara(node) && !isLi(node);
        };

        var isTable = makePredByNodeName('TABLE');

        var isInline = function (node) {
            return !isBodyContainer(node) &&
                !isList(node) &&
                !isHr(node) &&
                !isPara(node) &&
                !isTable(node) &&
                !isBlockquote(node);
        };

        var isList = function (node) {
            return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
        };

        var isHr = makePredByNodeName('HR');

        var isCell = function (node) {
            return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
        };

        var isBlockquote = makePredByNodeName('BLOCKQUOTE');

        var isBodyContainer = function (node) {
            return isCell(node) || isBlockquote(node) || isEditable(node);
        };

        var isAnchor = makePredByNodeName('A');

        var isParaInline = function (node) {
            return isInline(node) && !!ancestor(node, isPara);
        };

        var isBodyInline = function (node) {
            return isInline(node) && !ancestor(node, isPara);
        };

        var isBody = makePredByNodeName('BODY');

        /**
         * returns whether nodeB is closest sibling of nodeA
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         * @return {Boolean}
         */
        var isClosestSibling = function (nodeA, nodeB) {
            return nodeA.nextSibling === nodeB ||
                nodeA.previousSibling === nodeB;
        };

        /**
         * returns array of closest siblings with node
         *
         * @param {Node} node
         * @param {function} [pred] - predicate function
         * @return {Node[]}
         */
        var withClosestSiblings = function (node, pred) {
            pred = pred || func.ok;

            var siblings = [];
            if (node.previousSibling && pred(node.previousSibling)) {
                siblings.push(node.previousSibling);
            }
            siblings.push(node);
            if (node.nextSibling && pred(node.nextSibling)) {
                siblings.push(node.nextSibling);
            }
            return siblings;
        };

        /**
         * blank HTML for cursor position
         * - [workaround] old IE only works with &nbsp;
         * - [workaround] IE11 and other browser works with bogus br
         */
        var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';

        /**
         * @method nodeLength
         *
         * returns #text's text size or element's childNodes size
         *
         * @param {Node} node
         */
        var nodeLength = function (node) {
            if (isText(node)) {
                return node.nodeValue.length;
            }

            return node.childNodes.length;
        };

        /**
         * returns whether node is empty or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        var isEmpty = function (node) {
            var len = nodeLength(node);

            if (len === 0) {
                return true;
            } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
                // ex) <p><br></p>, <span><br></span>
                return true;
            } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {
                // ex) <p></p>, <span></span>
                return true;
            }

            return false;
        };

        /**
         * padding blankHTML if node is empty (for cursor position)
         */
        var paddingBlankHTML = function (node) {
            if (!isVoid(node) && !nodeLength(node)) {
                node.innerHTML = blankHTML;
            }
        };

        /**
         * find nearest ancestor predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        var ancestor = function (node, pred) {
            while (node) {
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }

                node = node.parentNode;
            }
            return null;
        };

        /**
         * find nearest ancestor only single child blood line and predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        var singleChildAncestor = function (node, pred) {
            node = node.parentNode;

            while (node) {
                if (nodeLength(node) !== 1) {
                    break;
                }
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }

                node = node.parentNode;
            }
            return null;
        };

        /**
         * returns new array of ancestor nodes (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        var listAncestor = function (node, pred) {
            pred = pred || func.fail;

            var ancestors = [];
            ancestor(node, function (el) {
                if (!isEditable(el)) {
                    ancestors.push(el);
                }

                return pred(el);
            });
            return ancestors;
        };

        /**
         * find farthest ancestor predicate hit
         */
        var lastAncestor = function (node, pred) {
            var ancestors = listAncestor(node);
            return list.last(ancestors.filter(pred));
        };

        /**
         * returns common ancestor node between two nodes.
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         */
        var commonAncestor = function (nodeA, nodeB) {
            var ancestors = listAncestor(nodeA);
            for (var n = nodeB; n; n = n.parentNode) {
                if ($.inArray(n, ancestors) > -1) {
                    return n;
                }
            }
            return null; // difference document area
        };

        /**
         * listing all previous siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        var listPrev = function (node, pred) {
            pred = pred || func.fail;

            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.previousSibling;
            }
            return nodes;
        };

        /**
         * listing next siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        var listNext = function (node, pred) {
            pred = pred || func.fail;

            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        };

        /**
         * listing descendant nodes
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        var listDescendant = function (node, pred) {
            var descendents = [];
            pred = pred || func.ok;

            // start DFS(depth first search) with node
            (function fnWalk(current) {
                if (node !== current && pred(current)) {
                    descendents.push(current);
                }
                for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
                    fnWalk(current.childNodes[idx]);
                }
            })(node);

            return descendents;
        };

        /**
         * wrap node with new tag.
         *
         * @param {Node} node
         * @param {Node} tagName of wrapper
         * @return {Node} - wrapper
         */
        var wrap = function (node, wrapperName) {
            var parent = node.parentNode;
            var wrapper = $('<' + wrapperName + '>')[0];

            parent.insertBefore(wrapper, node);
            wrapper.appendChild(node);

            return wrapper;
        };

        /**
         * insert node after preceding
         *
         * @param {Node} node
         * @param {Node} preceding - predicate function
         */
        var insertAfter = function (node, preceding) {
            var next = preceding.nextSibling, parent = preceding.parentNode;
            if (next) {
                parent.insertBefore(node, next);
            } else {
                parent.appendChild(node);
            }
            return node;
        };

        /**
         * append elements.
         *
         * @param {Node} node
         * @param {Collection} aChild
         */
        var appendChildNodes = function (node, aChild) {
            $.each(aChild, function (idx, child) {
                node.appendChild(child);
            });
            return node;
        };

        /**
         * returns whether boundaryPoint is left edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isLeftEdgePoint = function (point) {
            return point.offset === 0;
        };

        /**
         * returns whether boundaryPoint is right edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isRightEdgePoint = function (point) {
            return point.offset === nodeLength(point.node);
        };

        /**
         * returns whether boundaryPoint is edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isEdgePoint = function (point) {
            return isLeftEdgePoint(point) || isRightEdgePoint(point);
        };

        /**
         * returns wheter node is left edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isLeftEdgeOf = function (node, ancestor) {
            while (node && node !== ancestor) {
                if (position(node) !== 0) {
                    return false;
                }
                node = node.parentNode;
            }

            return true;
        };

        /**
         * returns whether node is right edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isRightEdgeOf = function (node, ancestor) {
            while (node && node !== ancestor) {
                if (position(node) !== nodeLength(node.parentNode) - 1) {
                    return false;
                }
                node = node.parentNode;
            }

            return true;
        };

        /**
         * returns whether point is left edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isLeftEdgePointOf = function (point, ancestor) {
            return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
        };

        /**
         * returns whether point is right edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        var isRightEdgePointOf = function (point, ancestor) {
            return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
        };

        /**
         * returns offset from parent.
         *
         * @param {Node} node
         */
        var position = function (node) {
            var offset = 0;
            while ((node = node.previousSibling)) {
                offset += 1;
            }
            return offset;
        };

        var hasChildren = function (node) {
            return !!(node && node.childNodes && node.childNodes.length);
        };

        /**
         * returns previous boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        var prevPoint = function (point, isSkipInnerOffset) {
            var node, offset;

            if (point.offset === 0) {
                if (isEditable(point.node)) {
                    return null;
                }

                node = point.node.parentNode;
                offset = position(point.node);
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset - 1];
                offset = nodeLength(node);
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? 0 : point.offset - 1;
            }

            return {
                node: node,
                offset: offset
            };
        };

        /**
         * returns next boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        var nextPoint = function (point, isSkipInnerOffset) {
            var node, offset;

            if (nodeLength(point.node) === point.offset) {
                if (isEditable(point.node)) {
                    return null;
                }

                node = point.node.parentNode;
                offset = position(point.node) + 1;
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset];
                offset = 0;
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
            }

            return {
                node: node,
                offset: offset
            };
        };

        /**
         * returns whether pointA and pointB is same or not.
         *
         * @param {BoundaryPoint} pointA
         * @param {BoundaryPoint} pointB
         * @return {Boolean}
         */
        var isSamePoint = function (pointA, pointB) {
            return pointA.node === pointB.node && pointA.offset === pointB.offset;
        };

        /**
         * returns whether point is visible (can set cursor) or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        var isVisiblePoint = function (point) {
            if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
                return true;
            }

            var leftNode = point.node.childNodes[point.offset - 1];
            var rightNode = point.node.childNodes[point.offset];
            if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
                return true;
            }

            return false;
        };

        /**
         * @method prevPointUtil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        var prevPointUntil = function (point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }

                point = prevPoint(point);
            }

            return null;
        };

        /**
         * @method nextPointUntil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        var nextPointUntil = function (point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }

                point = nextPoint(point);
            }

            return null;
        };

        /**
         * returns whether point has character or not.
         *
         * @param {Point} point
         * @return {Boolean}
         */
        var isCharPoint = function (point) {
            if (!isText(point.node)) {
                return false;
            }

            var ch = point.node.nodeValue.charAt(point.offset - 1);
            return ch && (ch !== ' ' && ch !== NBSP_CHAR);
        };

        /**
         * @method walkPoint
         *
         * @param {BoundaryPoint} startPoint
         * @param {BoundaryPoint} endPoint
         * @param {Function} handler
         * @param {Boolean} isSkipInnerOffset
         */
        var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {
            var point = startPoint;

            while (point) {
                handler(point);

                if (isSamePoint(point, endPoint)) {
                    break;
                }

                var isSkipOffset = isSkipInnerOffset &&
                    startPoint.node !== point.node &&
                    endPoint.node !== point.node;
                point = nextPoint(point, isSkipOffset);
            }
        };

        /**
         * @method makeOffsetPath
         *
         * return offsetPath(array of offset) from ancestor
         *
         * @param {Node} ancestor - ancestor node
         * @param {Node} node
         */
        var makeOffsetPath = function (ancestor, node) {
            var ancestors = listAncestor(node, func.eq(ancestor));
            return ancestors.map(position).reverse();
        };

        /**
         * @method fromOffsetPath
         *
         * return element from offsetPath(array of offset)
         *
         * @param {Node} ancestor - ancestor node
         * @param {array} offsets - offsetPath
         */
        var fromOffsetPath = function (ancestor, offsets) {
            var current = ancestor;
            for (var i = 0, len = offsets.length; i < len; i++) {
                if (current.childNodes.length <= offsets[i]) {
                    current = current.childNodes[current.childNodes.length - 1];
                } else {
                    current = current.childNodes[offsets[i]];
                }
            }
            return current;
        };

        /**
         * @method splitNode
         *
         * split element or #text
         *
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        var splitNode = function (point, options) {
            var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
            var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;

            // edge case
            if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
                if (isLeftEdgePoint(point)) {
                    return point.node;
                } else if (isRightEdgePoint(point)) {
                    return point.node.nextSibling;
                }
            }

            // split #text
            if (isText(point.node)) {
                return point.node.splitText(point.offset);
            } else {
                var childNode = point.node.childNodes[point.offset];
                var clone = insertAfter(point.node.cloneNode(false), point.node);
                appendChildNodes(clone, listNext(childNode));

                if (!isSkipPaddingBlankHTML) {
                    paddingBlankHTML(point.node);
                    paddingBlankHTML(clone);
                }

                return clone;
            }
        };

        /**
         * @method splitTree
         *
         * split tree by point
         *
         * @param {Node} root - split root
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        var splitTree = function (root, point, options) {
            // ex) [#text, <span>, <p>]
            var ancestors = listAncestor(point.node, func.eq(root));

            if (!ancestors.length) {
                return null;
            } else if (ancestors.length === 1) {
                return splitNode(point, options);
            }

            return ancestors.reduce(function (node, parent) {
                if (node === point.node) {
                    node = splitNode(point, options);
                }

                return splitNode({
                    node: parent,
                    offset: node ? dom.position(node) : nodeLength(parent)
                }, options);
            });
        };

        /**
         * split point
         *
         * @param {Point} point
         * @param {Boolean} isInline
         * @return {Object}
         */
        var splitPoint = function (point, isInline) {
            // find splitRoot, container
            //  - inline: splitRoot is a child of paragraph
            //  - block: splitRoot is a child of bodyContainer
            var pred = isInline ? isPara : isBodyContainer;
            var ancestors = listAncestor(point.node, pred);
            var topAncestor = list.last(ancestors) || point.node;

            var splitRoot, container;
            if (pred(topAncestor)) {
                splitRoot = ancestors[ancestors.length - 2];
                container = topAncestor;
            } else {
                splitRoot = topAncestor;
                container = splitRoot.parentNode;
            }

            // if splitRoot is exists, split with splitTree
            var pivot = splitRoot && splitTree(splitRoot, point, {
                isSkipPaddingBlankHTML: isInline,
                isNotSplitEdgePoint: isInline
            });

            // if container is point.node, find pivot with point.offset
            if (!pivot && container === point.node) {
                pivot = point.node.childNodes[point.offset];
            }

            return {
                rightNode: pivot,
                container: container
            };
        };

        var create = function (nodeName) {
            return document.createElement(nodeName);
        };

        var createText = function (text) {
            return document.createTextNode(text);
        };

        /**
         * @method remove
         *
         * remove node, (isRemoveChild: remove child or not)
         *
         * @param {Node} node
         * @param {Boolean} isRemoveChild
         */
        var remove = function (node, isRemoveChild) {
            if (!node || !node.parentNode) {
                return;
            }
            if (node.removeNode) {
                return node.removeNode(isRemoveChild);
            }

            var parent = node.parentNode;
            if (!isRemoveChild) {
                var nodes = [];
                var i, len;
                for (i = 0, len = node.childNodes.length; i < len; i++) {
                    nodes.push(node.childNodes[i]);
                }

                for (i = 0, len = nodes.length; i < len; i++) {
                    parent.insertBefore(nodes[i], node);
                }
            }

            parent.removeChild(node);
        };

        /**
         * @method removeWhile
         *
         * @param {Node} node
         * @param {Function} pred
         */
        var removeWhile = function (node, pred) {
            while (node) {
                if (isEditable(node) || !pred(node)) {
                    break;
                }

                var parent = node.parentNode;
                remove(node);
                node = parent;
            }
        };

        /**
         * @method replace
         *
         * replace node with provided nodeName
         *
         * @param {Node} node
         * @param {String} nodeName
         * @return {Node} - new node
         */
        var replace = function (node, nodeName) {
            if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
                return node;
            }

            var newNode = create(nodeName);

            if (node.style.cssText) {
                newNode.style.cssText = node.style.cssText;
            }

            appendChildNodes(newNode, list.from(node.childNodes));
            insertAfter(newNode, node);
            remove(node);

            return newNode;
        };

        var isTextarea = makePredByNodeName('TEXTAREA');

        /**
         * @param {jQuery} $node
         * @param {Boolean} [stripLinebreaks] - default: false
         */
        var value = function ($node, stripLinebreaks) {
            var val = isTextarea($node[0]) ? $node.val() : $node.html();
            if (stripLinebreaks) {
                return val.replace(/[\n\r]/g, '');
            }
            return val;
        };

        /**
         * @method html
         *
         * get the HTML contents of node
         *
         * @param {jQuery} $node
         * @param {Boolean} [isNewlineOnBlock]
         */
        var html = function ($node, isNewlineOnBlock) {
            var markup = value($node);

            if (isNewlineOnBlock) {
                var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
                markup = markup.replace(regexTag, function (match, endSlash, name) {
                    name = name.toUpperCase();
                    var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&
                        !!endSlash;
                    var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);

                    return match + ((isEndOfInlineContainer || isBlockNode) ? '\n' : '');
                });
                markup = $.trim(markup);
            }

            return markup;
        };

        return {
            /** @property {String} NBSP_CHAR */
            NBSP_CHAR: NBSP_CHAR,
            /** @property {String} ZERO_WIDTH_NBSP_CHAR */
            ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
            /** @property {String} blank */
            blank: blankHTML,
            /** @property {String} emptyPara */
            emptyPara: '<p>' + blankHTML + '</p>',
            makePredByNodeName: makePredByNodeName,
            isEditable: isEditable,
            isControlSizing: isControlSizing,
            buildLayoutInfo: buildLayoutInfo,
            makeLayoutInfo: makeLayoutInfo,
            isText: isText,
            isVoid: isVoid,
            isPara: isPara,
            isPurePara: isPurePara,
            isInline: isInline,
            isBlock: func.not(isInline),
            isBodyInline: isBodyInline,
            isBody: isBody,
            isParaInline: isParaInline,
            isList: isList,
            isTable: isTable,
            isCell: isCell,
            isBlockquote: isBlockquote,
            isBodyContainer: isBodyContainer,
            isAnchor: isAnchor,
            isDiv: makePredByNodeName('DIV'),
            isLi: isLi,
            isBR: makePredByNodeName('BR'),
            isSpan: makePredByNodeName('SPAN'),
            isB: makePredByNodeName('B'),
            isU: makePredByNodeName('U'),
            isS: makePredByNodeName('S'),
            isI: makePredByNodeName('I'),
            isImg: makePredByNodeName('IMG'),
            isTextarea: isTextarea,
            isEmpty: isEmpty,
            isEmptyAnchor: func.and(isAnchor, isEmpty),
            isClosestSibling: isClosestSibling,
            withClosestSiblings: withClosestSiblings,
            nodeLength: nodeLength,
            isLeftEdgePoint: isLeftEdgePoint,
            isRightEdgePoint: isRightEdgePoint,
            isEdgePoint: isEdgePoint,
            isLeftEdgeOf: isLeftEdgeOf,
            isRightEdgeOf: isRightEdgeOf,
            isLeftEdgePointOf: isLeftEdgePointOf,
            isRightEdgePointOf: isRightEdgePointOf,
            prevPoint: prevPoint,
            nextPoint: nextPoint,
            isSamePoint: isSamePoint,
            isVisiblePoint: isVisiblePoint,
            prevPointUntil: prevPointUntil,
            nextPointUntil: nextPointUntil,
            isCharPoint: isCharPoint,
            walkPoint: walkPoint,
            ancestor: ancestor,
            singleChildAncestor: singleChildAncestor,
            listAncestor: listAncestor,
            lastAncestor: lastAncestor,
            listNext: listNext,
            listPrev: listPrev,
            listDescendant: listDescendant,
            commonAncestor: commonAncestor,
            wrap: wrap,
            insertAfter: insertAfter,
            appendChildNodes: appendChildNodes,
            position: position,
            hasChildren: hasChildren,
            makeOffsetPath: makeOffsetPath,
            fromOffsetPath: fromOffsetPath,
            splitTree: splitTree,
            splitPoint: splitPoint,
            create: create,
            createText: createText,
            remove: remove,
            removeWhile: removeWhile,
            replace: replace,
            html: html,
            value: value
        };
    })();


    var range = (function () {

        /**
         * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
         *
         * @param {TextRange} textRange
         * @param {Boolean} isStart
         * @return {BoundaryPoint}
         *
         * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
         */
        var textRangeToPoint = function (textRange, isStart) {
            var container = textRange.parentElement(), offset;

            var tester = document.body.createTextRange(), prevContainer;
            var childNodes = list.from(container.childNodes);
            for (offset = 0; offset < childNodes.length; offset++) {
                if (dom.isText(childNodes[offset])) {
                    continue;
                }
                tester.moveToElementText(childNodes[offset]);
                if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
                    break;
                }
                prevContainer = childNodes[offset];
            }

            if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
                var textRangeStart = document.body.createTextRange(), curTextNode = null;
                textRangeStart.moveToElementText(prevContainer || container);
                textRangeStart.collapse(!prevContainer);
                curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;

                var pointTester = textRange.duplicate();
                pointTester.setEndPoint('StartToStart', textRangeStart);
                var textCount = pointTester.text.replace(/[\r\n]/g, '').length;

                while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }

                /* jshint ignore:start */
                var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack
                /* jshint ignore:end */

                if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&
                    textCount === curTextNode.nodeValue.length) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }

                container = curTextNode;
                offset = textCount;
            }

            return {
                cont: container,
                offset: offset
            };
        };

        /**
         * return TextRange from boundary point (inspired by google closure-library)
         * @param {BoundaryPoint} point
         * @return {TextRange}
         */
        var pointToTextRange = function (point) {
            var textRangeInfo = function (container, offset) {
                var node, isCollapseToStart;

                if (dom.isText(container)) {
                    var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
                    var prevContainer = list.last(prevTextNodes).previousSibling;
                    node = prevContainer || container.parentNode;
                    offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);
                    isCollapseToStart = !prevContainer;
                } else {
                    node = container.childNodes[offset] || container;
                    if (dom.isText(node)) {
                        return textRangeInfo(node, 0);
                    }

                    offset = 0;
                    isCollapseToStart = false;
                }

                return {
                    node: node,
                    collapseToStart: isCollapseToStart,
                    offset: offset
                };
            };

            var textRange = document.body.createTextRange();
            var info = textRangeInfo(point.node, point.offset);

            textRange.moveToElementText(info.node);
            textRange.collapse(info.collapseToStart);
            textRange.moveStart('character', info.offset);
            return textRange;
        };

        /**
         * Wrapped Range
         *
         * @constructor
         * @param {Node} sc - start container
         * @param {Number} so - start offset
         * @param {Node} ec - end container
         * @param {Number} eo - end offset
         */
        var WrappedRange = function (sc, so, ec, eo) {
            this.sc = sc;
            this.so = so;
            this.ec = ec;
            this.eo = eo;

            // nativeRange: get nativeRange from sc, so, ec, eo
            var nativeRange = function () {
                if (agent.isW3CRangeSupport) {
                    var w3cRange = document.createRange();
                    w3cRange.setStart(sc, so);
                    w3cRange.setEnd(ec, eo);

                    return w3cRange;
                } else {
                    var textRange = pointToTextRange({
                        node: sc,
                        offset: so
                    });

                    textRange.setEndPoint('EndToEnd', pointToTextRange({
                        node: ec,
                        offset: eo
                    }));

                    return textRange;
                }
            };

            this.getPoints = function () {
                return {
                    sc: sc,
                    so: so,
                    ec: ec,
                    eo: eo
                };
            };

            this.getStartPoint = function () {
                return {
                    node: sc,
                    offset: so
                };
            };

            this.getEndPoint = function () {
                return {
                    node: ec,
                    offset: eo
                };
            };

            /**
             * select update visible range
             */
            this.select = function () {
                var nativeRng = nativeRange();
                if (agent.isW3CRangeSupport) {
                    var selection = document.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.removeAllRanges();
                    }
                    selection.addRange(nativeRng);
                } else {
                    nativeRng.select();
                }

                return this;
            };

            /**
             * @return {WrappedRange}
             */
            this.normalize = function () {

                /**
                 * @param {BoundaryPoint} point
                 * @param {Boolean} isLeftToRight
                 * @return {BoundaryPoint}
                 */
                var getVisiblePoint = function (point, isLeftToRight) {
                    if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||
                        (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||
                        (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||
                        (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {
                        return point;
                    }

                    // point on block's edge
                    var block = dom.ancestor(point.node, dom.isBlock);
                    if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||
                        ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {

                        // returns point already on visible point
                        if (dom.isVisiblePoint(point)) {
                            return point;
                        }
                        // reverse direction
                        isLeftToRight = !isLeftToRight;
                    }

                    var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :
                        dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                    return nextPoint || point;
                };

                var endPoint = getVisiblePoint(this.getEndPoint(), false);
                var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);

                return new WrappedRange(
                    startPoint.node,
                    startPoint.offset,
                    endPoint.node,
                    endPoint.offset
                );
            };

            /**
             * returns matched nodes on range
             *
             * @param {Function} [pred] - predicate function
             * @param {Object} [options]
             * @param {Boolean} [options.includeAncestor]
             * @param {Boolean} [options.fullyContains]
             * @return {Node[]}
             */
            this.nodes = function (pred, options) {
                pred = pred || func.ok;

                var includeAncestor = options && options.includeAncestor;
                var fullyContains = options && options.fullyContains;

                // TODO compare points and sort
                var startPoint = this.getStartPoint();
                var endPoint = this.getEndPoint();

                var nodes = [];
                var leftEdgeNodes = [];

                dom.walkPoint(startPoint, endPoint, function (point) {
                    if (dom.isEditable(point.node)) {
                        return;
                    }

                    var node;
                    if (fullyContains) {
                        if (dom.isLeftEdgePoint(point)) {
                            leftEdgeNodes.push(point.node);
                        }
                        if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {
                            node = point.node;
                        }
                    } else if (includeAncestor) {
                        node = dom.ancestor(point.node, pred);
                    } else {
                        node = point.node;
                    }

                    if (node && pred(node)) {
                        nodes.push(node);
                    }
                }, true);

                return list.unique(nodes);
            };

            /**
             * returns commonAncestor of range
             * @return {Element} - commonAncestor
             */
            this.commonAncestor = function () {
                return dom.commonAncestor(sc, ec);
            };

            /**
             * returns expanded range by pred
             *
             * @param {Function} pred - predicate function
             * @return {WrappedRange}
             */
            this.expand = function (pred) {
                var startAncestor = dom.ancestor(sc, pred);
                var endAncestor = dom.ancestor(ec, pred);

                if (!startAncestor && !endAncestor) {
                    return new WrappedRange(sc, so, ec, eo);
                }

                var boundaryPoints = this.getPoints();

                if (startAncestor) {
                    boundaryPoints.sc = startAncestor;
                    boundaryPoints.so = 0;
                }

                if (endAncestor) {
                    boundaryPoints.ec = endAncestor;
                    boundaryPoints.eo = dom.nodeLength(endAncestor);
                }

                return new WrappedRange(
                    boundaryPoints.sc,
                    boundaryPoints.so,
                    boundaryPoints.ec,
                    boundaryPoints.eo
                );
            };

            /**
             * @param {Boolean} isCollapseToStart
             * @return {WrappedRange}
             */
            this.collapse = function (isCollapseToStart) {
                if (isCollapseToStart) {
                    return new WrappedRange(sc, so, sc, so);
                } else {
                    return new WrappedRange(ec, eo, ec, eo);
                }
            };

            /**
             * splitText on range
             */
            this.splitText = function () {
                var isSameContainer = sc === ec;
                var boundaryPoints = this.getPoints();

                if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {
                    ec.splitText(eo);
                }

                if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {
                    boundaryPoints.sc = sc.splitText(so);
                    boundaryPoints.so = 0;

                    if (isSameContainer) {
                        boundaryPoints.ec = boundaryPoints.sc;
                        boundaryPoints.eo = eo - so;
                    }
                }

                return new WrappedRange(
                    boundaryPoints.sc,
                    boundaryPoints.so,
                    boundaryPoints.ec,
                    boundaryPoints.eo
                );
            };

            /**
             * delete contents on range
             * @return {WrappedRange}
             */
            this.deleteContents = function () {
                if (this.isCollapsed()) {
                    return this;
                }

                var rng = this.splitText();
                var nodes = rng.nodes(null, {
                    fullyContains: true
                });

                // find new cursor point
                var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                    return !list.contains(nodes, point.node);
                });

                var emptyParents = [];
                $.each(nodes, function (idx, node) {
                    // find empty parents
                    var parent = node.parentNode;
                    if (point.node !== parent && dom.nodeLength(parent) === 1) {
                        emptyParents.push(parent);
                    }
                    dom.remove(node, false);
                });

                // remove empty parents
                $.each(emptyParents, function (idx, node) {
                    dom.remove(node, false);
                });

                return new WrappedRange(
                    point.node,
                    point.offset,
                    point.node,
                    point.offset
                ).normalize();
            };

            /**
             * makeIsOn: return isOn(pred) function
             */
            var makeIsOn = function (pred) {
                return function () {
                    var ancestor = dom.ancestor(sc, pred);
                    return !!ancestor && (ancestor === dom.ancestor(ec, pred));
                };
            };

            // isOnEditable: judge whether range is on editable or not
            this.isOnEditable = makeIsOn(dom.isEditable);
            // isOnList: judge whether range is on list node or not
            this.isOnList = makeIsOn(dom.isList);
            // isOnAnchor: judge whether range is on anchor node or not
            this.isOnAnchor = makeIsOn(dom.isAnchor);
            // isOnAnchor: judge whether range is on cell node or not
            this.isOnCell = makeIsOn(dom.isCell);

            /**
             * @param {Function} pred
             * @return {Boolean}
             */
            this.isLeftEdgeOf = function (pred) {
                if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                    return false;
                }

                var node = dom.ancestor(this.sc, pred);
                return node && dom.isLeftEdgeOf(this.sc, node);
            };

            /**
             * returns whether range was collapsed or not
             */
            this.isCollapsed = function () {
                return sc === ec && so === eo;
            };

            /**
             * wrap inline nodes which children of body with paragraph
             *
             * @return {WrappedRange}
             */
            this.wrapBodyInlineWithPara = function () {
                if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {
                    sc.innerHTML = dom.emptyPara;
                    return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);
                }

                /**
                 * [workaround] firefox often create range on not visible point. so normalize here.
                 *  - firefox: |<p>text</p>|
                 *  - chrome: <p>|text|</p>
                 */
                var rng = this.normalize();
                if (dom.isParaInline(sc) || dom.isPara(sc)) {
                    return rng;
                }

                // find inline top ancestor
                var topAncestor;
                if (dom.isInline(rng.sc)) {
                    var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                    topAncestor = list.last(ancestors);
                    if (!dom.isInline(topAncestor)) {
                        topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                    }
                } else {
                    topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
                }

                // siblings not in paragraph
                var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));

                // wrap with paragraph
                if (inlineSiblings.length) {
                    var para = dom.wrap(list.head(inlineSiblings), 'p');
                    dom.appendChildNodes(para, list.tail(inlineSiblings));
                }

                return this.normalize();
            };

            /**
             * insert node at current cursor
             *
             * @param {Node} node
             * @return {Node}
             */
            this.insertNode = function (node) {
                var rng = this.wrapBodyInlineWithPara().deleteContents();
                var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));

                if (info.rightNode) {
                    info.rightNode.parentNode.insertBefore(node, info.rightNode);
                } else {
                    info.container.appendChild(node);
                }

                return node;
            };

            /**
             * insert html at current cursor
             */
            this.pasteHTML = function (markup) {
                var contentsContainer = $('<div></div>').html(markup)[0];
                var childNodes = list.from(contentsContainer.childNodes);

                var rng = this.wrapBodyInlineWithPara().deleteContents();

                return childNodes.reverse().map(function (childNode) {
                    return rng.insertNode(childNode);
                }).reverse();
            };

            /**
             * returns text in range
             *
             * @return {String}
             */
            this.toString = function () {
                var nativeRng = nativeRange();
                return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
            };

            /**
             * returns range for word before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */
            this.getWordRange = function (findAfter) {
                var endPoint = this.getEndPoint();

                if (!dom.isCharPoint(endPoint)) {
                    return this;
                }

                var startPoint = dom.prevPointUntil(endPoint, function (point) {
                    return !dom.isCharPoint(point);
                });

                if (findAfter) {
                    endPoint = dom.nextPointUntil(endPoint, function (point) {
                        return !dom.isCharPoint(point);
                    });
                }

                return new WrappedRange(
                    startPoint.node,
                    startPoint.offset,
                    endPoint.node,
                    endPoint.offset
                );
            };

            /**
             * create offsetPath bookmark
             *
             * @param {Node} editable
             */
            this.bookmark = function (editable) {
                return {
                    s: {
                        path: dom.makeOffsetPath(editable, sc),
                        offset: so
                    },
                    e: {
                        path: dom.makeOffsetPath(editable, ec),
                        offset: eo
                    }
                };
            };

            /**
             * create offsetPath bookmark base on paragraph
             *
             * @param {Node[]} paras
             */
            this.paraBookmark = function (paras) {
                return {
                    s: {
                        path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),
                        offset: so
                    },
                    e: {
                        path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),
                        offset: eo
                    }
                };
            };

            /**
             * getClientRects
             * @return {Rect[]}
             */
            this.getClientRects = function () {
                var nativeRng = nativeRange();
                return nativeRng.getClientRects();
            };
        };

        /**
         * @class core.range
         *
         * Data structure
         *  * BoundaryPoint: a point of dom tree
         *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
         *
         * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
         *
         * @singleton
         * @alternateClassName range
         */
        return {
            /**
             * @method
             *
             * create Range Object From arguments or Browser Selection
             *
             * @param {Node} sc - start container
             * @param {Number} so - start offset
             * @param {Node} ec - end container
             * @param {Number} eo - end offset
             * @return {WrappedRange}
             */
            create: function (sc, so, ec, eo) {
                if (!arguments.length) { // from Browser Selection
                    if (agent.isW3CRangeSupport) {
                        var selection = document.getSelection();
                        if (!selection || selection.rangeCount === 0) {
                            return null;
                        } else if (dom.isBody(selection.anchorNode)) {
                            // Firefox: returns entire body as range on initialization. We won't never need it.
                            return null;
                        }

                        var nativeRng = selection.getRangeAt(0);
                        sc = nativeRng.startContainer;
                        so = nativeRng.startOffset;
                        ec = nativeRng.endContainer;
                        eo = nativeRng.endOffset;
                    } else { // IE8: TextRange
                        var textRange = document.selection.createRange();
                        var textRangeEnd = textRange.duplicate();
                        textRangeEnd.collapse(false);
                        var textRangeStart = textRange;
                        textRangeStart.collapse(true);

                        var startPoint = textRangeToPoint(textRangeStart, true),
                            endPoint = textRangeToPoint(textRangeEnd, false);

                        // same visible point case: range was collapsed.
                        if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&
                            dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&
                            endPoint.node.nextSibling === startPoint.node) {
                            startPoint = endPoint;
                        }

                        sc = startPoint.cont;
                        so = startPoint.offset;
                        ec = endPoint.cont;
                        eo = endPoint.offset;
                    }
                } else if (arguments.length === 2) { //collapsed
                    ec = sc;
                    eo = so;
                }
                return new WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from node
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNode: function (node) {
                var sc = node;
                var so = 0;
                var ec = node;
                var eo = dom.nodeLength(ec);

                // browsers can't target a picture or void node
                if (dom.isVoid(sc)) {
                    so = dom.listPrev(sc).length - 1;
                    sc = sc.parentNode;
                }
                if (dom.isBR(ec)) {
                    eo = dom.listPrev(ec).length - 1;
                    ec = ec.parentNode;
                } else if (dom.isVoid(ec)) {
                    eo = dom.listPrev(ec).length;
                    ec = ec.parentNode;
                }

                return this.create(sc, so, ec, eo);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeBefore: function (node) {
                return this.createFromNode(node).collapse(true);
            },

            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeAfter: function (node) {
                return this.createFromNode(node).collapse();
            },

            /**
             * @method
             *
             * create WrappedRange from bookmark
             *
             * @param {Node} editable
             * @param {Object} bookmark
             * @return {WrappedRange}
             */
            createFromBookmark: function (editable, bookmark) {
                var sc = dom.fromOffsetPath(editable, bookmark.s.path);
                var so = bookmark.s.offset;
                var ec = dom.fromOffsetPath(editable, bookmark.e.path);
                var eo = bookmark.e.offset;
                return new WrappedRange(sc, so, ec, eo);
            },

            /**
             * @method
             *
             * create WrappedRange from paraBookmark
             *
             * @param {Object} bookmark
             * @param {Node[]} paras
             * @return {WrappedRange}
             */
            createFromParaBookmark: function (bookmark, paras) {
                var so = bookmark.s.offset;
                var eo = bookmark.e.offset;
                var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);
                var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);

                return new WrappedRange(sc, so, ec, eo);
            }
        };
    })();

    /**
     * @class defaults
     *
     * @singleton
     */
    var defaults = {
        /** @property */
        version: '0.6.16',

        /**
         *
         * for event options, reference to EventHandler.attach
         *
         * @property {Object} options
         * @property {String/Number} [options.width=null] set editor width
         * @property {String/Number} [options.height=null] set editor height, ex) 300
         * @property {String/Number} options.minHeight set minimum height of editor
         * @property {String/Number} options.maxHeight
         * @property {String/Number} options.focus
         * @property {Number} options.tabsize
         * @property {Boolean} options.styleWithSpan
         * @property {Object} options.codemirror
         * @property {Object} [options.codemirror.mode='text/html']
         * @property {Object} [options.codemirror.htmlMode=true]
         * @property {Object} [options.codemirror.lineNumbers=true]
         * @property {String} [options.lang=en-US] language 'en-US', 'ko-KR', ...
         * @property {String} [options.direction=null] text direction, ex) 'rtl'
         * @property {Array} [options.toolbar]
         * @property {Boolean} [options.airMode=false]
         * @property {Array} [options.airPopover]
         * @property {Fucntion} [options.onInit] initialize
         * @property {Fucntion} [options.onsubmit]
         */
        options: {
            width: null,                  // set editor width
            height: null,                 // set editor height, ex) 300

            minHeight: null,              // set minimum height of editor
            maxHeight: null,              // set maximum height of editor

            focus: false,                 // set focus to editable area after initializing summernote

            tabsize: 4,                   // size of tab ex) 2 or 4
            styleWithSpan: true,          // style with span (Chrome and FF only)

            disableLinkTarget: false,     // hide link Target Checkbox
            disableDragAndDrop: false,    // disable drag and drop event
            disableResizeEditor: false,   // disable resizing editor
            disableResizeImage: false,    // disable resizing image

            shortcuts: true,              // enable keyboard shortcuts

            textareaAutoSync: true,       // enable textarea auto sync

            placeholder: false,           // enable placeholder text
            prettifyHtml: true,           // enable prettifying html while toggling codeview

            iconPrefix: 'fa fa-',         // prefix for css icon classes

            icons: {
                font: {
                    bold: 'bold',
                    italic: 'italic',
                    underline: 'underline',
                    clear: 'eraser',
                    height: 'text-height',
                    strikethrough: 'strikethrough',
                    superscript: 'superscript',
                    subscript: 'subscript'
                },
                image: {
                    image: 'picture-o',
                    floatLeft: 'align-left',
                    floatRight: 'align-right',
                    floatNone: 'align-justify',
                    shapeRounded: 'square',
                    shapeCircle: 'circle-o',
                    shapeThumbnail: 'picture-o',
                    shapeNone: 'times',
                    remove: 'trash-o'
                },
                link: {
                    link: 'link',
                    unlink: 'unlink',
                    edit: 'edit'
                },
                table: {
                    table: 'table'
                },
                hr: {
                    insert: 'minus'
                },
                style: {
                    style: 'magic'
                },
                lists: {
                    unordered: 'list-ul',
                    ordered: 'list-ol'
                },
                options: {
                    help: 'question',
                    fullscreen: 'arrows-alt',
                    codeview: 'code'
                },
                paragraph: {
                    paragraph: 'align-left',
                    outdent: 'outdent',
                    indent: 'indent',
                    left: 'align-left',
                    center: 'align-center',
                    right: 'align-right',
                    justify: 'align-justify'
                },
                color: {
                    recent: 'font'
                },
                history: {
                    undo: 'undo',
                    redo: 'repeat'
                },
                misc: {
                    check: 'check'
                }
            },

            dialogsInBody: false,          // false will add dialogs into editor

            codemirror: {                 // codemirror options
                mode: 'text/html',
                htmlMode: true,
                lineNumbers: true
            },

            // language
            lang: 'en-US',                // language 'en-US', 'ko-KR', ...
            direction: null,              // text direction, ex) 'rtl'

            // toolbar
            toolbar: [
                ['style', ['style']],
                ['font', ['bold', 'italic', 'underline', 'clear']],
                // ['font', ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'clear']],
                ['fontname', ['fontname']],
                ['fontsize', ['fontsize']],
                ['color', ['color']],
                ['para', ['ul', 'ol', 'paragraph']],
                ['height', ['height']],
                ['table', ['table']],
                ['insert', ['link', 'picture', 'hr']],
                ['view', ['fullscreen', 'codeview']],
                ['help', ['help']]
            ],

            plugin: {},

            // air mode: inline editor
            airMode: false,
            // airPopover: [
            //   ['style', ['style']],
            //   ['font', ['bold', 'italic', 'underline', 'clear']],
            //   ['fontname', ['fontname']],
            //   ['color', ['color']],
            //   ['para', ['ul', 'ol', 'paragraph']],
            //   ['height', ['height']],
            //   ['table', ['table']],
            //   ['insert', ['link', 'picture']],
            //   ['help', ['help']]
            // ],
            airPopover: [
                ['color', ['color']],
                ['font', ['bold', 'underline', 'clear']],
                ['para', ['ul', 'paragraph']],
                ['table', ['table']],
                ['insert', ['link', 'picture']]
            ],

            // style tag
            styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],

            // default fontName
            defaultFontName: 'Helvetica Neue',

            // fontName
            fontNames: [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',
                'Tahoma', 'Times New Roman', 'Verdana'
            ],
            fontNamesIgnoreCheck: [],

            fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],

            // pallete colors(n x n)
            colors: [
                ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],
                ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
                ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
                ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
                ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
                ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
                ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
                ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
            ],

            // lineHeight
            lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],

            // insertTable max size
            insertTableMaxSize: {
                col: 10,
                row: 10
            },

            // image
            maximumImageFileSize: null, // size in bytes, null = no limit

            // callbacks
            oninit: null,             // initialize
            onfocus: null,            // editable has focus
            onblur: null,             // editable out of focus
            onenter: null,            // enter key pressed
            onkeyup: null,            // keyup
            onkeydown: null,          // keydown
            onImageUpload: null,      // imageUpload
            onImageUploadError: null, // imageUploadError
            onMediaDelete: null,      // media delete
            onToolbarClick: null,
            onsubmit: null,

            /**
             * manipulate link address when user create link
             * @param {String} sLinkUrl
             * @return {String}
             */
            onCreateLink: function (sLinkUrl) {
                if (sLinkUrl.indexOf('@') !== -1 && sLinkUrl.indexOf(':') === -1) {
                    sLinkUrl = 'mailto:' + sLinkUrl;
                }

                return sLinkUrl;
            },

            keyMap: {
                pc: {
                    'ENTER': 'insertParagraph',
                    'CTRL+Z': 'undo',
                    'CTRL+Y': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CTRL+B': 'bold',
                    'CTRL+I': 'italic',
                    'CTRL+U': 'underline',
                    'CTRL+SHIFT+S': 'strikethrough',
                    'CTRL+BACKSLASH': 'removeFormat',
                    'CTRL+SHIFT+L': 'justifyLeft',
                    'CTRL+SHIFT+E': 'justifyCenter',
                    'CTRL+SHIFT+R': 'justifyRight',
                    'CTRL+SHIFT+J': 'justifyFull',
                    'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                    'CTRL+SHIFT+NUM8': 'insertOrderedList',
                    'CTRL+LEFTBRACKET': 'outdent',
                    'CTRL+RIGHTBRACKET': 'indent',
                    'CTRL+NUM0': 'formatPara',
                    'CTRL+NUM1': 'formatH1',
                    'CTRL+NUM2': 'formatH2',
                    'CTRL+NUM3': 'formatH3',
                    'CTRL+NUM4': 'formatH4',
                    'CTRL+NUM5': 'formatH5',
                    'CTRL+NUM6': 'formatH6',
                    'CTRL+ENTER': 'insertHorizontalRule',
                    'CTRL+K': 'showLinkDialog'
                },

                mac: {
                    'ENTER': 'insertParagraph',
                    'CMD+Z': 'undo',
                    'CMD+SHIFT+Z': 'redo',
                    'TAB': 'tab',
                    'SHIFT+TAB': 'untab',
                    'CMD+B': 'bold',
                    'CMD+I': 'italic',
                    'CMD+U': 'underline',
                    'CMD+SHIFT+S': 'strikethrough',
                    'CMD+BACKSLASH': 'removeFormat',
                    'CMD+SHIFT+L': 'justifyLeft',
                    'CMD+SHIFT+E': 'justifyCenter',
                    'CMD+SHIFT+R': 'justifyRight',
                    'CMD+SHIFT+J': 'justifyFull',
                    'CMD+SHIFT+NUM7': 'insertUnorderedList',
                    'CMD+SHIFT+NUM8': 'insertOrderedList',
                    'CMD+LEFTBRACKET': 'outdent',
                    'CMD+RIGHTBRACKET': 'indent',
                    'CMD+NUM0': 'formatPara',
                    'CMD+NUM1': 'formatH1',
                    'CMD+NUM2': 'formatH2',
                    'CMD+NUM3': 'formatH3',
                    'CMD+NUM4': 'formatH4',
                    'CMD+NUM5': 'formatH5',
                    'CMD+NUM6': 'formatH6',
                    'CMD+ENTER': 'insertHorizontalRule',
                    'CMD+K': 'showLinkDialog'
                }
            }
        },

        // default language: en-US
        lang: {
            'en-US': {
                font: {
                    bold: 'Bold',
                    italic: 'Italic',
                    underline: 'Underline',
                    clear: 'Remove Font Style',
                    height: 'Line Height',
                    name: 'Font Family',
                    strikethrough: 'Strikethrough',
                    subscript: 'Subscript',
                    superscript: 'Superscript',
                    size: 'Font Size'
                },
                image: {
                    image: 'Picture',
                    insert: 'Insert Image',
                    resizeFull: 'Resize Full',
                    resizeHalf: 'Resize Half',
                    resizeQuarter: 'Resize Quarter',
                    floatLeft: 'Float Left',
                    floatRight: 'Float Right',
                    floatNone: 'Float None',
                    shapeRounded: 'Shape: Rounded',
                    shapeCircle: 'Shape: Circle',
                    shapeThumbnail: 'Shape: Thumbnail',
                    shapeNone: 'Shape: None',
                    dragImageHere: 'Drag image or text here',
                    dropImage: 'Drop image or Text',
                    selectFromFiles: 'Select from files',
                    maximumFileSize: 'Maximum file size',
                    maximumFileSizeError: 'Maximum file size exceeded.',
                    url: 'Image URL',
                    remove: 'Remove Image'
                },
                link: {
                    link: 'Link',
                    insert: 'Insert Link',
                    unlink: 'Unlink',
                    edit: 'Edit',
                    textToDisplay: 'Text to display',
                    url: 'To what URL should this link go?',
                    openInNewWindow: 'Open in new window'
                },
                table: {
                    table: 'Table'
                },
                hr: {
                    insert: 'Insert Horizontal Rule'
                },
                style: {
                    style: 'Style',
                    normal: 'Normal',
                    blockquote: 'Quote',
                    pre: 'Code',
                    h1: 'Header 1',
                    h2: 'Header 2',
                    h3: 'Header 3',
                    h4: 'Header 4',
                    h5: 'Header 5',
                    h6: 'Header 6'
                },
                lists: {
                    unordered: 'Unordered list',
                    ordered: 'Ordered list'
                },
                options: {
                    help: 'Help',
                    fullscreen: 'Full Screen',
                    codeview: 'Code View'
                },
                paragraph: {
                    paragraph: 'Paragraph',
                    outdent: 'Outdent',
                    indent: 'Indent',
                    left: 'Align left',
                    center: 'Align center',
                    right: 'Align right',
                    justify: 'Justify full'
                },
                color: {
                    recent: 'Recent Color',
                    more: 'More Color',
                    background: 'Background Color',
                    foreground: 'Foreground Color',
                    transparent: 'Transparent',
                    setTransparent: 'Set transparent',
                    reset: 'Reset',
                    resetToDefault: 'Reset to default'
                },
                shortcut: {
                    shortcuts: 'Keyboard shortcuts',
                    close: 'Close',
                    textFormatting: 'Text formatting',
                    action: 'Action',
                    paragraphFormatting: 'Paragraph formatting',
                    documentStyle: 'Document Style',
                    extraKeys: 'Extra keys'
                },
                history: {
                    undo: 'Undo',
                    redo: 'Redo'
                }
            }
        }
    };

    /**
     * @class core.async
     *
     * Async functions which returns `Promise`
     *
     * @singleton
     * @alternateClassName async
     */
    var async = (function () {
        /**
         * @method readFileAsDataURL
         *
         * read contents of file as representing URL
         *
         * @param {File} file
         * @return {Promise} - then: sDataUrl
         */
        var readFileAsDataURL = function (file) {
            return $.Deferred(function (deferred) {
                $.extend(new FileReader(), {
                    onload: function (e) {
                        var sDataURL = e.target.result;
                        deferred.resolve(sDataURL);
                    },
                    onerror: function () {
                        deferred.reject(this);
                    }
                }).readAsDataURL(file);
            }).promise();
        };

        /**
         * @method createImage
         *
         * create `<image>` from url string
         *
         * @param {String} sUrl
         * @param {String} filename
         * @return {Promise} - then: $image
         */
        var createImage = function (sUrl, filename) {
            return $.Deferred(function (deferred) {
                var $img = $('<img>');

                $img.one('load', function () {
                    $img.off('error abort');
                    deferred.resolve($img);
                }).one('error abort', function () {
                    $img.off('load').detach();
                    deferred.reject($img);
                }).css({
                    display: 'none'
                }).appendTo(document.body).attr({
                    'src': sUrl,
                    'data-filename': filename
                });
            }).promise();
        };

        return {
            readFileAsDataURL: readFileAsDataURL,
            createImage: createImage
        };
    })();

    /**
     * @class core.key
     *
     * Object for keycodes.
     *
     * @singleton
     * @alternateClassName key
     */
    var key = (function () {
        var keyMap = {
            'BACKSPACE': 8,
            'TAB': 9,
            'ENTER': 13,
            'SPACE': 32,

            // Number: 0-9
            'NUM0': 48,
            'NUM1': 49,
            'NUM2': 50,
            'NUM3': 51,
            'NUM4': 52,
            'NUM5': 53,
            'NUM6': 54,
            'NUM7': 55,
            'NUM8': 56,

            // Alphabet: a-z
            'B': 66,
            'E': 69,
            'I': 73,
            'J': 74,
            'K': 75,
            'L': 76,
            'R': 82,
            'S': 83,
            'U': 85,
            'V': 86,
            'Y': 89,
            'Z': 90,

            'SLASH': 191,
            'LEFTBRACKET': 219,
            'BACKSLASH': 220,
            'RIGHTBRACKET': 221
        };

        return {
            /**
             * @method isEdit
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isEdit: function (keyCode) {
                return list.contains([8, 9, 13, 32], keyCode);
            },
            /**
             * @method isMove
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isMove: function (keyCode) {
                return list.contains([37, 38, 39, 40], keyCode);
            },
            /**
             * @property {Object} nameFromCode
             * @property {String} nameFromCode.8 "BACKSPACE"
             */
            nameFromCode: func.invertObject(keyMap),
            code: keyMap
        };
    })();

    /**
     * @class editing.History
     *
     * Editor History
     *
     */
    var History = function ($editable) {
        var stack = [], stackOffset = -1;
        var editable = $editable[0];

        var makeSnapshot = function () {
            var rng = range.create();
            var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};

            return {
                contents: $editable.html(),
                bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)
            };
        };

        var applySnapshot = function (snapshot) {
            if (snapshot.contents !== null) {
                $editable.html(snapshot.contents);
            }
            if (snapshot.bookmark !== null) {
                range.createFromBookmark(editable, snapshot.bookmark).select();
            }
        };

        /**
         * undo
         */
        this.undo = function () {
            // Create snap shot if not yet recorded
            if ($editable.html() !== stack[stackOffset].contents) {
                this.recordUndo();
            }

            if (0 < stackOffset) {
                stackOffset--;
                applySnapshot(stack[stackOffset]);
            }
        };

        /**
         * redo
         */
        this.redo = function () {
            if (stack.length - 1 > stackOffset) {
                stackOffset++;
                applySnapshot(stack[stackOffset]);
            }
        };

        /**
         * recorded undo
         */
        this.recordUndo = function () {
            stackOffset++;

            // Wash out stack after stackOffset
            if (stack.length > stackOffset) {
                stack = stack.slice(0, stackOffset);
            }

            // Create new snapshot and push it to the end
            stack.push(makeSnapshot());
        };

        // Create first undo stack
        this.recordUndo();
    };

    /**
     * @class editing.Style
     *
     * Style
     *
     */
    var Style = function () {
        /**
         * @method jQueryCSS
         *
         * [workaround] for old jQuery
         * passing an array of style properties to .css()
         * will result in an object of property-value pairs.
         * (compability with version < 1.9)
         *
         * @private
         * @param  {jQuery} $obj
         * @param  {Array} propertyNames - An array of one or more CSS properties.
         * @return {Object}
         */
        var jQueryCSS = function ($obj, propertyNames) {
            if (agent.jqueryVersion < 1.9) {
                var result = {};
                $.each(propertyNames, function (idx, propertyName) {
                    result[propertyName] = $obj.css(propertyName);
                });
                return result;
            }
            return $obj.css.call($obj, propertyNames);
        };

        /**
         * returns style object from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        this.fromNode = function ($node) {
            var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
            var styleInfo = jQueryCSS($node, properties) || {};
            styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
            return styleInfo;
        };

        /**
         * paragraph level style
         *
         * @param {WrappedRange} rng
         * @param {Object} styleInfo
         */
        this.stylePara = function (rng, styleInfo) {
            $.each(rng.nodes(dom.isPara, {
                includeAncestor: true
            }), function (idx, para) {
                $(para).css(styleInfo);
            });
        };

        /**
         * insert and returns styleNodes on range.
         *
         * @param {WrappedRange} rng
         * @param {Object} [options] - options for styleNodes
         * @param {String} [options.nodeName] - default: `SPAN`
         * @param {Boolean} [options.expandClosestSibling] - default: `false`
         * @param {Boolean} [options.onlyPartialContains] - default: `false`
         * @return {Node[]}
         */
        this.styleNodes = function (rng, options) {
            rng = rng.splitText();

            var nodeName = options && options.nodeName || 'SPAN';
            var expandClosestSibling = !!(options && options.expandClosestSibling);
            var onlyPartialContains = !!(options && options.onlyPartialContains);

            if (rng.isCollapsed()) {
                return [rng.insertNode(dom.create(nodeName))];
            }

            var pred = dom.makePredByNodeName(nodeName);
            var nodes = rng.nodes(dom.isText, {
                fullyContains: true
            }).map(function (text) {
                return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
            });

            if (expandClosestSibling) {
                if (onlyPartialContains) {
                    var nodesInRange = rng.nodes();
                    // compose with partial contains predication
                    pred = func.and(pred, function (node) {
                        return list.contains(nodesInRange, node);
                    });
                }

                return nodes.map(function (node) {
                    var siblings = dom.withClosestSiblings(node, pred);
                    var head = list.head(siblings);
                    var tails = list.tail(siblings);
                    $.each(tails, function (idx, elem) {
                        dom.appendChildNodes(head, elem.childNodes);
                        dom.remove(elem);
                    });
                    return list.head(siblings);
                });
            } else {
                return nodes;
            }
        };

        /**
         * get current style on cursor
         *
         * @param {WrappedRange} rng
         * @return {Object} - object contains style properties.
         */
        this.current = function (rng) {
            var $cont = $(dom.isText(rng.sc) ? rng.sc.parentNode : rng.sc);
            var styleInfo = this.fromNode($cont);

            // document.queryCommandState for toggle state
            styleInfo['font-bold'] = document.queryCommandState('bold') ? 'bold' : 'normal';
            styleInfo['font-italic'] = document.queryCommandState('italic') ? 'italic' : 'normal';
            styleInfo['font-underline'] = document.queryCommandState('underline') ? 'underline' : 'normal';
            styleInfo['font-strikethrough'] = document.queryCommandState('strikeThrough') ? 'strikethrough' : 'normal';
            styleInfo['font-superscript'] = document.queryCommandState('superscript') ? 'superscript' : 'normal';
            styleInfo['font-subscript'] = document.queryCommandState('subscript') ? 'subscript' : 'normal';

            // list-style-type to list-style(unordered, ordered)
            if (!rng.isOnList()) {
                styleInfo['list-style'] = 'none';
            } else {
                var aOrderedType = ['circle', 'disc', 'disc-leading-zero', 'square'];
                var isUnordered = $.inArray(styleInfo['list-style-type'], aOrderedType) > -1;
                styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
            }

            var para = dom.ancestor(rng.sc, dom.isPara);
            if (para && para.style['line-height']) {
                styleInfo['line-height'] = para.style.lineHeight;
            } else {
                var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                styleInfo['line-height'] = lineHeight.toFixed(1);
            }

            styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
            styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
            styleInfo.range = rng;

            return styleInfo;
        };
    };


    /**
     * @class editing.Bullet
     *
     * @alternateClassName Bullet
     */
    var Bullet = function () {
        /**
         * @method insertOrderedList
         *
         * toggle ordered list
         *
         * @type command
         */
        this.insertOrderedList = function () {
            this.toggleList('OL');
        };

        /**
         * @method insertUnorderedList
         *
         * toggle unordered list
         *
         * @type command
         */
        this.insertUnorderedList = function () {
            this.toggleList('UL');
        };

        /**
         * @method indent
         *
         * indent
         *
         * @type command
         */
        this.indent = function () {
            var self = this;
            var rng = range.create().wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                if (dom.isLi(head)) {
                    self.wrapList(paras, head.parentNode.nodeName);
                } else {
                    $.each(paras, function (idx, para) {
                        $(para).css('marginLeft', function (idx, val) {
                            return (parseInt(val, 10) || 0) + 25;
                        });
                    });
                }
            });

            rng.select();
        };

        /**
         * @method outdent
         *
         * outdent
         *
         * @type command
         */
        this.outdent = function () {
            var self = this;
            var rng = range.create().wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                if (dom.isLi(head)) {
                    self.releaseList([paras]);
                } else {
                    $.each(paras, function (idx, para) {
                        $(para).css('marginLeft', function (idx, val) {
                            val = (parseInt(val, 10) || 0);
                            return val > 25 ? val - 25 : '';
                        });
                    });
                }
            });

            rng.select();
        };

        /**
         * @method toggleList
         *
         * toggle list
         *
         * @param {String} listName - OL or UL
         */
        this.toggleList = function (listName) {
            var self = this;
            var rng = range.create().wrapBodyInlineWithPara();

            var paras = rng.nodes(dom.isPara, {includeAncestor: true});
            var bookmark = rng.paraBookmark(paras);
            var clustereds = list.clusterBy(paras, func.peq2('parentNode'));

            // paragraph to list
            if (list.find(paras, dom.isPurePara)) {
                var wrappedParas = [];
                $.each(clustereds, function (idx, paras) {
                    wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));
                });
                paras = wrappedParas;
                // list to paragraph or change list style
            } else {
                var diffLists = rng.nodes(dom.isList, {
                    includeAncestor: true
                }).filter(function (listNode) {
                    return !$.nodeName(listNode, listName);
                });

                if (diffLists.length) {
                    $.each(diffLists, function (idx, listNode) {
                        dom.replace(listNode, listName);
                    });
                } else {
                    paras = this.releaseList(clustereds, true);
                }
            }

            range.createFromParaBookmark(bookmark, paras).select();
        };

        /**
         * @method wrapList
         *
         * @param {Node[]} paras
         * @param {String} listName
         * @return {Node[]}
         */
        this.wrapList = function (paras, listName) {
            var head = list.head(paras);
            var last = list.last(paras);

            var prevList = dom.isList(head.previousSibling) && head.previousSibling;
            var nextList = dom.isList(last.nextSibling) && last.nextSibling;

            var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);

            // P to LI
            paras = paras.map(function (para) {
                return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
            });

            // append to list(<ul>, <ol>)
            dom.appendChildNodes(listNode, paras);

            if (nextList) {
                dom.appendChildNodes(listNode, list.from(nextList.childNodes));
                dom.remove(nextList);
            }

            return paras;
        };

        /**
         * @method releaseList
         *
         * @param {Array[]} clustereds
         * @param {Boolean} isEscapseToBody
         * @return {Node[]}
         */
        this.releaseList = function (clustereds, isEscapseToBody) {
            var releasedParas = [];

            $.each(clustereds, function (idx, paras) {
                var head = list.head(paras);
                var last = list.last(paras);

                var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :
                    head.parentNode;
                var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                    node: last.parentNode,
                    offset: dom.position(last) + 1
                }, {
                    isSkipPaddingBlankHTML: true
                }) : null;

                var middleList = dom.splitTree(headList, {
                    node: head.parentNode,
                    offset: dom.position(head)
                }, {
                    isSkipPaddingBlankHTML: true
                });

                paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :
                    list.from(middleList.childNodes).filter(dom.isLi);

                // LI to P
                if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                    paras = paras.map(function (para) {
                        return dom.replace(para, 'P');
                    });
                }

                $.each(list.from(paras).reverse(), function (idx, para) {
                    dom.insertAfter(para, headList);
                });

                // remove empty lists
                var rootLists = list.compact([headList, middleList, lastList]);
                $.each(rootLists, function (idx, rootList) {
                    var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                    $.each(listNodes.reverse(), function (idx, listNode) {
                        if (!dom.nodeLength(listNode)) {
                            dom.remove(listNode, true);
                        }
                    });
                });

                releasedParas = releasedParas.concat(paras);
            });

            return releasedParas;
        };
    };


    /**
     * @class editing.Typing
     *
     * Typing
     *
     */
    var Typing = function () {

        // a Bullet instance to toggle lists off
        var bullet = new Bullet();

        /**
         * insert tab
         *
         * @param {jQuery} $editable
         * @param {WrappedRange} rng
         * @param {Number} tabsize
         */
        this.insertTab = function ($editable, rng, tabsize) {
            var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
            rng = rng.deleteContents();
            rng.insertNode(tab, true);

            rng = range.create(tab, tabsize);
            rng.select();
        };

        /**
         * insert paragraph
         */
        this.insertParagraph = function () {
            var rng = range.create();

            // deleteContents on range.
            rng = rng.deleteContents();

            // Wrap range if it needs to be wrapped by paragraph
            rng = rng.wrapBodyInlineWithPara();

            // finding paragraph
            var splitRoot = dom.ancestor(rng.sc, dom.isPara);

            var nextPara;
            // on paragraph: split paragraph
            if (splitRoot) {
                // if it is an empty line with li
                if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
                    // disable UL/OL and escape!
                    bullet.toggleList(splitRoot.parentNode.nodeName);
                    return;
                    // if new line has content (not a line break)
                } else {
                    nextPara = dom.splitTree(splitRoot, rng.getStartPoint());

                    var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                    emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));

                    $.each(emptyAnchors, function (idx, anchor) {
                        dom.remove(anchor);
                    });
                }
                // no paragraph: insert empty paragraph
            } else {
                var next = rng.sc.childNodes[rng.so];
                nextPara = $(dom.emptyPara)[0];
                if (next) {
                    rng.sc.insertBefore(nextPara, next);
                } else {
                    rng.sc.appendChild(nextPara);
                }
            }

            range.create(nextPara, 0).normalize().select();

        };

    };

    /**
     * @class editing.Table
     *
     * Table
     *
     */
    var Table = function () {
        /**
         * handle tab key
         *
         * @param {WrappedRange} rng
         * @param {Boolean} isShift
         */
        this.tab = function (rng, isShift) {
            var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
            var table = dom.ancestor(cell, dom.isTable);
            var cells = dom.listDescendant(table, dom.isCell);

            var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);
            if (nextCell) {
                range.create(nextCell, 0).select();
            }
        };

        /**
         * create empty table element
         *
         * @param {Number} rowCount
         * @param {Number} colCount
         * @return {Node}
         */
        this.createTable = function (colCount, rowCount) {
            var tds = [], tdHTML;
            for (var idxCol = 0; idxCol < colCount; idxCol++) {
                tds.push('<td>' + dom.blank + '</td>');
            }
            tdHTML = tds.join('');

            var trs = [], trHTML;
            for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                trs.push('<tr>' + tdHTML + '</tr>');
            }
            trHTML = trs.join('');
            return $('<table class="table table-bordered">' + trHTML + '</table>')[0];
        };
    };


    var KEY_BOGUS = 'bogus';

    /**
     * @class editing.Editor
     *
     * Editor
     *
     */
    var Editor = function (handler) {

        var self = this;
        var style = new Style();
        var table = new Table();
        var typing = new Typing();
        var bullet = new Bullet();

        /**
         * @method createRange
         *
         * create range
         *
         * @param {jQuery} $editable
         * @return {WrappedRange}
         */
        this.createRange = function ($editable) {
            this.focus($editable);
            return range.create();
        };

        /**
         * @method saveRange
         *
         * save current range
         *
         * @param {jQuery} $editable
         * @param {Boolean} [thenCollapse=false]
         */
        this.saveRange = function ($editable, thenCollapse) {
            this.focus($editable);
            $editable.data('range', range.create());
            if (thenCollapse) {
                range.create().collapse().select();
            }
        };

        /**
         * @method saveRange
         *
         * save current node list to $editable.data('childNodes')
         *
         * @param {jQuery} $editable
         */
        this.saveNode = function ($editable) {
            // copy child node reference
            var copy = [];
            for (var key = 0, len = $editable[0].childNodes.length; key < len; key++) {
                copy.push($editable[0].childNodes[key]);
            }
            $editable.data('childNodes', copy);
        };

        /**
         * @method restoreRange
         *
         * restore lately range
         *
         * @param {jQuery} $editable
         */
        this.restoreRange = function ($editable) {
            var rng = $editable.data('range');
            if (rng) {
                rng.select();
                this.focus($editable);
            }
        };

        /**
         * @method restoreNode
         *
         * restore lately node list
         *
         * @param {jQuery} $editable
         */
        this.restoreNode = function ($editable) {
            $editable.html('');
            var child = $editable.data('childNodes');
            for (var index = 0, len = child.length; index < len; index++) {
                $editable[0].appendChild(child[index]);
            }
        };

        /**
         * @method currentStyle
         *
         * current style
         *
         * @param {Node} target
         * @return {Object|Boolean} unfocus
         */
        this.currentStyle = function (target) {
            var rng = range.create();
            var styleInfo = rng && rng.isOnEditable() ? style.current(rng.normalize()) : {};
            if (dom.isImg(target)) {
                styleInfo.image = target;
            }
            return styleInfo;
        };

        /**
         * style from node
         *
         * @param {jQuery} $node
         * @return {Object}
         */
        this.styleFromNode = function ($node) {
            return style.fromNode($node);
        };

        var triggerOnBeforeChange = function ($editable) {
            var $holder = dom.makeLayoutInfo($editable).holder();
            handler.bindCustomEvent(
                $holder, $editable.data('callbacks'), 'before.command'
            )($editable.html(), $editable);
        };

        var triggerOnChange = function ($editable) {
            var $holder = dom.makeLayoutInfo($editable).holder();
            handler.bindCustomEvent(
                $holder, $editable.data('callbacks'), 'change'
            )($editable.html(), $editable);
        };

        /**
         * @method undo
         * undo
         * @param {jQuery} $editable
         */
        this.undo = function ($editable) {
            triggerOnBeforeChange($editable);
            $editable.data('NoteHistory').undo();
            triggerOnChange($editable);
        };

        /**
         * @method redo
         * redo
         * @param {jQuery} $editable
         */
        this.redo = function ($editable) {
            triggerOnBeforeChange($editable);
            $editable.data('NoteHistory').redo();
            triggerOnChange($editable);
        };

        /**
         * @method beforeCommand
         * before command
         * @param {jQuery} $editable
         */
        var beforeCommand = this.beforeCommand = function ($editable) {
            triggerOnBeforeChange($editable);
            // keep focus on editable before command execution
            self.focus($editable);
        };

        /**
         * @method afterCommand
         * after command
         * @param {jQuery} $editable
         * @param {Boolean} isPreventTrigger
         */
        var afterCommand = this.afterCommand = function ($editable, isPreventTrigger) {
            $editable.data('NoteHistory').recordUndo();
            if (!isPreventTrigger) {
                triggerOnChange($editable);
            }
        };

        /**
         * @method bold
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method italic
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method underline
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method strikethrough
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method formatBlock
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method superscript
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method subscript
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method justifyLeft
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method justifyCenter
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method justifyRight
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method justifyFull
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method formatBlock
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method removeFormat
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method backColor
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method foreColor
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method insertHorizontalRule
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /**
         * @method fontName
         *
         * change font name
         *
         * @param {jQuery} $editable
         * @param {Mixed} value
         */

        /* jshint ignore:start */
        // native commands(with execCommand), generate function for execCommand
        var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',
            'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',
            'formatBlock', 'removeFormat',
            'backColor', 'foreColor', 'fontName'];

        for (var idx = 0, len = commands.length; idx < len; idx++) {
            this[commands[idx]] = (function (sCmd) {
                return function ($editable, value) {
                    beforeCommand($editable);

                    document.execCommand(sCmd, false, value);

                    afterCommand($editable, true);
                };
            })(commands[idx]);
        }
        /* jshint ignore:end */

        /**
         * @method tab
         *
         * handle tab key
         *
         * @param {jQuery} $editable
         * @param {Object} options
         */
        this.tab = function ($editable, options) {
            var rng = this.createRange($editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                table.tab(rng);
            } else {
                beforeCommand($editable);
                typing.insertTab($editable, rng, options.tabsize);
                afterCommand($editable);
            }
        };

        /**
         * @method untab
         *
         * handle shift+tab key
         *
         */
        this.untab = function ($editable) {
            var rng = this.createRange($editable);
            if (rng.isCollapsed() && rng.isOnCell()) {
                table.tab(rng, true);
            }
        };

        /**
         * @method insertParagraph
         *
         * insert paragraph
         *
         * @param {Node} $editable
         */
        this.insertParagraph = function ($editable) {
            beforeCommand($editable);
            typing.insertParagraph($editable);
            afterCommand($editable);
        };

        /**
         * @method insertOrderedList
         *
         * @param {jQuery} $editable
         */
        this.insertOrderedList = function ($editable) {
            beforeCommand($editable);
            bullet.insertOrderedList($editable);
            afterCommand($editable);
        };

        /**
         * @param {jQuery} $editable
         */
        this.insertUnorderedList = function ($editable) {
            beforeCommand($editable);
            bullet.insertUnorderedList($editable);
            afterCommand($editable);
        };

        /**
         * @param {jQuery} $editable
         */
        this.indent = function ($editable) {
            beforeCommand($editable);
            bullet.indent($editable);
            afterCommand($editable);
        };

        /**
         * @param {jQuery} $editable
         */
        this.outdent = function ($editable) {
            beforeCommand($editable);
            bullet.outdent($editable);
            afterCommand($editable);
        };

        /**
         * insert image
         *
         * @param {jQuery} $editable
         * @param {String} sUrl
         */
        this.insertImage = function ($editable, sUrl, filename) {
            async.createImage(sUrl, filename).then(function ($image) {
                beforeCommand($editable);
                $image.css({
                    display: '',
                    width: Math.min($editable.width(), $image.width())
                });
                range.create().insertNode($image[0]);
                range.createFromNodeAfter($image[0]).select();
                afterCommand($editable);
            }).fail(function () {
                var $holder = dom.makeLayoutInfo($editable).holder();
                handler.bindCustomEvent(
                    $holder, $editable.data('callbacks'), 'image.upload.error'
                )();
            });
        };

        /**
         * @method insertNode
         * insert node
         * @param {Node} $editable
         * @param {Node} node
         */
        this.insertNode = function ($editable, node) {
            beforeCommand($editable);
            range.create().insertNode(node);
            range.createFromNodeAfter(node).select();
            afterCommand($editable);
        };

        /**
         * insert text
         * @param {Node} $editable
         * @param {String} text
         */
        this.insertText = function ($editable, text) {
            beforeCommand($editable);
            var textNode = range.create().insertNode(dom.createText(text));
            range.create(textNode, dom.nodeLength(textNode)).select();
            afterCommand($editable);
        };

        /**
         * paste HTML
         * @param {Node} $editable
         * @param {String} markup
         */
        this.pasteHTML = function ($editable, markup) {
            beforeCommand($editable);
            var contents = range.create().pasteHTML(markup);
            range.createFromNodeAfter(list.last(contents)).select();
            afterCommand($editable);
        };

        /**
         * formatBlock
         *
         * @param {jQuery} $editable
         * @param {String} tagName
         */
        this.formatBlock = function ($editable, tagName) {
            beforeCommand($editable);
            // [workaround] for MSIE, IE need `<`
            tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;
            document.execCommand('FormatBlock', false, tagName);
            afterCommand($editable);
        };

        this.formatPara = function ($editable) {
            beforeCommand($editable);
            this.formatBlock($editable, 'P');
            afterCommand($editable);
        };

        /* jshint ignore:start */
        for (var idx = 1; idx <= 6; idx++) {
            this['formatH' + idx] = function (idx) {
                return function ($editable) {
                    this.formatBlock($editable, 'H' + idx);
                };
            }(idx);
        }
        ;
        /* jshint ignore:end */

        /**
         * fontSize
         *
         * @param {jQuery} $editable
         * @param {String} value - px
         */
        this.fontSize = function ($editable, value) {
            var rng = range.create();

            if (rng.isCollapsed()) {
                var spans = style.styleNodes(rng);
                var firstSpan = list.head(spans);

                $(spans).css({
                    'font-size': value + 'px'
                });

                // [workaround] added styled bogus span for style
                //  - also bogus character needed for cursor position
                if (firstSpan && !dom.nodeLength(firstSpan)) {
                    firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                    range.createFromNodeAfter(firstSpan.firstChild).select();
                    $editable.data(KEY_BOGUS, firstSpan);
                }
            } else {
                beforeCommand($editable);
                $(style.styleNodes(rng)).css({
                    'font-size': value + 'px'
                });
                afterCommand($editable);
            }
        };

        /**
         * insert horizontal rule
         * @param {jQuery} $editable
         */
        this.insertHorizontalRule = function ($editable) {
            beforeCommand($editable);

            var rng = range.create();
            var hrNode = rng.insertNode($('<HR/>')[0]);
            if (hrNode.nextSibling) {
                range.create(hrNode.nextSibling, 0).normalize().select();
            }

            afterCommand($editable);
        };

        /**
         * remove bogus node and character
         */
        this.removeBogus = function ($editable) {
            var bogusNode = $editable.data(KEY_BOGUS);
            if (!bogusNode) {
                return;
            }

            var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);

            var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);
            if (bogusCharIdx !== -1) {
                textNode.deleteData(bogusCharIdx, 1);
            }

            if (dom.isEmpty(bogusNode)) {
                dom.remove(bogusNode);
            }

            $editable.removeData(KEY_BOGUS);
        };

        /**
         * lineHeight
         * @param {jQuery} $editable
         * @param {String} value
         */
        this.lineHeight = function ($editable, value) {
            beforeCommand($editable);
            style.stylePara(range.create(), {
                lineHeight: value
            });
            afterCommand($editable);
        };

        /**
         * unlink
         *
         * @type command
         *
         * @param {jQuery} $editable
         */
        this.unlink = function ($editable) {
            var rng = this.createRange($editable);
            if (rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                rng = range.createFromNode(anchor);
                rng.select();

                beforeCommand($editable);
                document.execCommand('unlink');
                afterCommand($editable);
            }
        };

        /**
         * create link (command)
         *
         * @param {jQuery} $editable
         * @param {Object} linkInfo
         * @param {Object} options
         */
        this.createLink = function ($editable, linkInfo, options) {
            var linkUrl = linkInfo.url;
            var linkText = linkInfo.text;
            var isNewWindow = linkInfo.isNewWindow;
            var rng = linkInfo.range || this.createRange($editable);
            var isTextChanged = rng.toString() !== linkText;

            options = options || dom.makeLayoutInfo($editable).editor().data('options');

            beforeCommand($editable);

            if (options.onCreateLink) {
                linkUrl = options.onCreateLink(linkUrl);
            }

            var anchors = [];
            if (isTextChanged) {
                // Create a new link when text changed.
                var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);
                anchors.push(anchor);
            } else {
                anchors = style.styleNodes(rng, {
                    nodeName: 'A',
                    expandClosestSibling: true,
                    onlyPartialContains: true
                });
            }

            $.each(anchors, function (idx, anchor) {
                $(anchor).attr('href', linkUrl);
                if (isNewWindow) {
                    $(anchor).attr('target', '_blank');
                } else {
                    $(anchor).removeAttr('target');
                }
            });

            var startRange = range.createFromNodeBefore(list.head(anchors));
            var startPoint = startRange.getStartPoint();
            var endRange = range.createFromNodeAfter(list.last(anchors));
            var endPoint = endRange.getEndPoint();

            range.create(
                startPoint.node,
                startPoint.offset,
                endPoint.node,
                endPoint.offset
            ).select();

            afterCommand($editable);
        };

        /**
         * returns link info
         *
         * @return {Object}
         * @return {WrappedRange} return.range
         * @return {String} return.text
         * @return {Boolean} [return.isNewWindow=true]
         * @return {String} [return.url=""]
         */
        this.getLinkInfo = function ($editable) {
            this.focus($editable);

            var rng = range.create().expand(dom.isAnchor);

            // Get the first anchor on range(for edit).
            var $anchor = $(list.head(rng.nodes(dom.isAnchor)));

            return {
                range: rng,
                text: rng.toString(),
                isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,
                url: $anchor.length ? $anchor.attr('href') : ''
            };
        };

        /**
         * setting color
         *
         * @param {Node} $editable
         * @param {Object} sObjColor  color code
         * @param {String} sObjColor.foreColor foreground color
         * @param {String} sObjColor.backColor background color
         */
        this.color = function ($editable, sObjColor) {
            var oColor = JSON.parse(sObjColor);
            var foreColor = oColor.foreColor, backColor = oColor.backColor;

            beforeCommand($editable);

            if (foreColor) {
                document.execCommand('foreColor', false, foreColor);
            }
            if (backColor) {
                document.execCommand('backColor', false, backColor);
            }

            afterCommand($editable);
        };

        /**
         * insert Table
         *
         * @param {Node} $editable
         * @param {String} sDim dimension of table (ex : "5x5")
         */
        this.insertTable = function ($editable, sDim) {
            var dimension = sDim.split('x');
            beforeCommand($editable);

            var rng = range.create().deleteContents();
            rng.insertNode(table.createTable(dimension[0], dimension[1]));
            afterCommand($editable);
        };

        /**
         * float me
         *
         * @param {jQuery} $editable
         * @param {String} value
         * @param {jQuery} $target
         */
        this.floatMe = function ($editable, value, $target) {
            beforeCommand($editable);
            // bootstrap
            $target.removeClass('pull-left pull-right');
            if (value && value !== 'none') {
                $target.addClass('pull-' + value);
            }

            // fallback for non-bootstrap
            $target.css('float', value);
            afterCommand($editable);
        };

        /**
         * change image shape
         *
         * @param {jQuery} $editable
         * @param {String} value css class
         * @param {Node} $target
         */
        this.imageShape = function ($editable, value, $target) {
            beforeCommand($editable);

            $target.removeClass('img-rounded img-circle img-thumbnail');

            if (value) {
                $target.addClass(value);
            }

            afterCommand($editable);
        };

        /**
         * resize overlay element
         * @param {jQuery} $editable
         * @param {String} value
         * @param {jQuery} $target - target element
         */
        this.resize = function ($editable, value, $target) {
            beforeCommand($editable);

            $target.css({
                width: value * 100 + '%',
                height: ''
            });

            afterCommand($editable);
        };

        /**
         * @param {Position} pos
         * @param {jQuery} $target - target element
         * @param {Boolean} [bKeepRatio] - keep ratio
         */
        this.resizeTo = function (pos, $target, bKeepRatio) {
            var imageSize;
            if (bKeepRatio) {
                var newRatio = pos.y / pos.x;
                var ratio = $target.data('ratio');
                imageSize = {
                    width: ratio > newRatio ? pos.x : pos.y / ratio,
                    height: ratio > newRatio ? pos.x * ratio : pos.y
                };
            } else {
                imageSize = {
                    width: pos.x,
                    height: pos.y
                };
            }

            $target.css(imageSize);
        };

        /**
         * remove media object
         *
         * @param {jQuery} $editable
         * @param {String} value - dummy argument (for keep interface)
         * @param {jQuery} $target - target element
         */
        this.removeMedia = function ($editable, value, $target) {
            beforeCommand($editable);
            $target.detach();

            handler.bindCustomEvent(
                $(), $editable.data('callbacks'), 'media.delete'
            )($target, $editable);

            afterCommand($editable);
        };

        /**
         * set focus
         *
         * @param $editable
         */
        this.focus = function ($editable) {
            $editable.focus();

            // [workaround] for firefox bug http://goo.gl/lVfAaI
            if (agent.isFF && !range.create().isOnEditable()) {
                range.createFromNode($editable[0])
                    .normalize()
                    .collapse()
                    .select();
            }
        };

        /**
         * returns whether contents is empty or not.
         *
         * @param {jQuery} $editable
         * @return {Boolean}
         */
        this.isEmpty = function ($editable) {
            return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();
        };
    };

    /**
     * @class module.Button
     *
     * Button
     */
    var Button = function () {
        /**
         * update button status
         *
         * @param {jQuery} $container
         * @param {Object} styleInfo
         */
        this.update = function ($container, styleInfo) {
            /**
             * handle dropdown's check mark (for fontname, fontsize, lineHeight).
             * @param {jQuery} $btn
             * @param {Number} value
             */
            var checkDropdownMenu = function ($btn, value) {
                $btn.find('.dropdown-menu li a').each(function () {
                    // always compare string to avoid creating another func.
                    var isChecked = ($(this).data('value') + '') === (value + '');
                    this.className = isChecked ? 'checked' : '';
                });
            };

            /**
             * update button state(active or not).
             *
             * @private
             * @param {String} selector
             * @param {Function} pred
             */
            var btnState = function (selector, pred) {
                var $btn = $container.find(selector);
                $btn.toggleClass('active', pred());
            };

            if (styleInfo.image) {
                var $img = $(styleInfo.image);

                btnState('button[data-event="imageShape"][data-value="img-rounded"]', function () {
                    return $img.hasClass('img-rounded');
                });
                btnState('button[data-event="imageShape"][data-value="img-circle"]', function () {
                    return $img.hasClass('img-circle');
                });
                btnState('button[data-event="imageShape"][data-value="img-thumbnail"]', function () {
                    return $img.hasClass('img-thumbnail');
                });
                btnState('button[data-event="imageShape"]:not([data-value])', function () {
                    return !$img.is('.img-rounded, .img-circle, .img-thumbnail');
                });

                var imgFloat = $img.css('float');
                btnState('button[data-event="floatMe"][data-value="left"]', function () {
                    return imgFloat === 'left';
                });
                btnState('button[data-event="floatMe"][data-value="right"]', function () {
                    return imgFloat === 'right';
                });
                btnState('button[data-event="floatMe"][data-value="none"]', function () {
                    return imgFloat !== 'left' && imgFloat !== 'right';
                });

                var style = $img.attr('style');
                btnState('button[data-event="resize"][data-value="1"]', function () {
                    return !!/(^|\s)(max-)?width\s*:\s*100%/.test(style);
                });
                btnState('button[data-event="resize"][data-value="0.5"]', function () {
                    return !!/(^|\s)(max-)?width\s*:\s*50%/.test(style);
                });
                btnState('button[data-event="resize"][data-value="0.25"]', function () {
                    return !!/(^|\s)(max-)?width\s*:\s*25%/.test(style);
                });
                return;
            }

            // fontname
            var $fontname = $container.find('.note-fontname');
            if ($fontname.length) {
                var selectedFont = styleInfo['font-family'];
                if (!!selectedFont) {

                    var list = selectedFont.split(',');
                    for (var i = 0, len = list.length; i < len; i++) {
                        selectedFont = list[i].replace(/[\'\"]/g, '').replace(/\s+$/, '').replace(/^\s+/, '');
                        if (agent.isFontInstalled(selectedFont)) {
                            break;
                        }
                    }

                    $fontname.find('.note-current-fontname').text(selectedFont);
                    checkDropdownMenu($fontname, selectedFont);

                }
            }

            // fontsize
            var $fontsize = $container.find('.note-fontsize');
            $fontsize.find('.note-current-fontsize').text(styleInfo['font-size']);
            checkDropdownMenu($fontsize, parseFloat(styleInfo['font-size']));

            // lineheight
            var $lineHeight = $container.find('.note-height');
            checkDropdownMenu($lineHeight, parseFloat(styleInfo['line-height']));

            btnState('button[data-event="bold"]', function () {
                return styleInfo['font-bold'] === 'bold';
            });
            btnState('button[data-event="italic"]', function () {
                return styleInfo['font-italic'] === 'italic';
            });
            btnState('button[data-event="underline"]', function () {
                return styleInfo['font-underline'] === 'underline';
            });
            btnState('button[data-event="strikethrough"]', function () {
                return styleInfo['font-strikethrough'] === 'strikethrough';
            });
            btnState('button[data-event="superscript"]', function () {
                return styleInfo['font-superscript'] === 'superscript';
            });
            btnState('button[data-event="subscript"]', function () {
                return styleInfo['font-subscript'] === 'subscript';
            });
            btnState('button[data-event="justifyLeft"]', function () {
                return styleInfo['text-align'] === 'left' || styleInfo['text-align'] === 'start';
            });
            btnState('button[data-event="justifyCenter"]', function () {
                return styleInfo['text-align'] === 'center';
            });
            btnState('button[data-event="justifyRight"]', function () {
                return styleInfo['text-align'] === 'right';
            });
            btnState('button[data-event="justifyFull"]', function () {
                return styleInfo['text-align'] === 'justify';
            });
            btnState('button[data-event="insertUnorderedList"]', function () {
                return styleInfo['list-style'] === 'unordered';
            });
            btnState('button[data-event="insertOrderedList"]', function () {
                return styleInfo['list-style'] === 'ordered';
            });
        };

        /**
         * update recent color
         *
         * @param {Node} button
         * @param {String} eventName
         * @param {Mixed} value
         */
        this.updateRecentColor = function (button, eventName, value) {
            var $color = $(button).closest('.note-color');
            var $recentColor = $color.find('.note-recent-color');
            var colorInfo = JSON.parse($recentColor.attr('data-value'));
            colorInfo[eventName] = value;
            $recentColor.attr('data-value', JSON.stringify(colorInfo));
            var sKey = eventName === 'backColor' ? 'background-color' : 'color';
            $recentColor.find('i').css(sKey, value);
        };
    };

    /**
     * @class module.Toolbar
     *
     * Toolbar
     */
    var Toolbar = function () {
        var button = new Button();

        this.update = function ($toolbar, styleInfo) {
            button.update($toolbar, styleInfo);
        };

        /**
         * @param {Node} button
         * @param {String} eventName
         * @param {String} value
         */
        this.updateRecentColor = function (buttonNode, eventName, value) {
            button.updateRecentColor(buttonNode, eventName, value);
        };

        /**
         * activate buttons exclude codeview
         * @param {jQuery} $toolbar
         */
        this.activate = function ($toolbar) {
            $toolbar.find('button')
                .not('button[data-event="codeview"]')
                .removeClass('disabled');
        };

        /**
         * deactivate buttons exclude codeview
         * @param {jQuery} $toolbar
         */
        this.deactivate = function ($toolbar) {
            $toolbar.find('button')
                .not('button[data-event="codeview"]')
                .addClass('disabled');
        };

        /**
         * @param {jQuery} $container
         * @param {Boolean} [bFullscreen=false]
         */
        this.updateFullscreen = function ($container, bFullscreen) {
            var $btn = $container.find('button[data-event="fullscreen"]');
            $btn.toggleClass('active', bFullscreen);
        };

        /**
         * @param {jQuery} $container
         * @param {Boolean} [isCodeview=false]
         */
        this.updateCodeview = function ($container, isCodeview) {
            var $btn = $container.find('button[data-event="codeview"]');
            $btn.toggleClass('active', isCodeview);

            if (isCodeview) {
                this.deactivate($container);
            } else {
                this.activate($container);
            }
        };

        /**
         * get button in toolbar
         *
         * @param {jQuery} $editable
         * @param {String} name
         * @return {jQuery}
         */
        this.get = function ($editable, name) {
            var $toolbar = dom.makeLayoutInfo($editable).toolbar();

            return $toolbar.find('[data-name=' + name + ']');
        };

        /**
         * set button state
         * @param {jQuery} $editable
         * @param {String} name
         * @param {Boolean} [isActive=true]
         */
        this.setButtonState = function ($editable, name, isActive) {
            isActive = (isActive === false) ? false : true;

            var $button = this.get($editable, name);
            $button.toggleClass('active', isActive);
        };
    };

    var EDITABLE_PADDING = 24;

    var Statusbar = function () {
        var $document = $(document);

        this.attach = function (layoutInfo, options) {
            if (!options.disableResizeEditor) {
                layoutInfo.statusbar().on('mousedown', hStatusbarMousedown);
            }
        };

        /**
         * `mousedown` event handler on statusbar
         *
         * @param {MouseEvent} event
         */
        var hStatusbarMousedown = function (event) {
            event.preventDefault();
            event.stopPropagation();

            var $editable = dom.makeLayoutInfo(event.target).editable();
            var editableTop = $editable.offset().top - $document.scrollTop();

            var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);
            var options = layoutInfo.editor().data('options');

            $document.on('mousemove', function (event) {
                var nHeight = event.clientY - (editableTop + EDITABLE_PADDING);

                nHeight = (options.minHeight > 0) ? Math.max(nHeight, options.minHeight) : nHeight;
                nHeight = (options.maxHeight > 0) ? Math.min(nHeight, options.maxHeight) : nHeight;

                $editable.height(nHeight);
            }).one('mouseup', function () {
                $document.off('mousemove');
            });
        };
    };

    /**
     * @class module.Popover
     *
     * Popover (http://getbootstrap.com/javascript/#popovers)
     *
     */
    var Popover = function () {
        var button = new Button();

        /**
         * returns position from placeholder
         *
         * @private
         * @param {Node} placeholder
         * @param {Object} options
         * @param {Boolean} options.isAirMode
         * @return {Position}
         */
        var posFromPlaceholder = function (placeholder, options) {
            var isAirMode = options && options.isAirMode;
            var isLeftTop = options && options.isLeftTop;

            var $placeholder = $(placeholder);
            var pos = isAirMode ? $placeholder.offset() : $placeholder.position();
            var height = isLeftTop ? 0 : $placeholder.outerHeight(true); // include margin

            // popover below placeholder.
            return {
                left: pos.left,
                top: pos.top + height
            };
        };

        /**
         * show popover
         *
         * @private
         * @param {jQuery} popover
         * @param {Position} pos
         */
        var showPopover = function ($popover, pos) {
            $popover.css({
                display: 'block',
                left: pos.left,
                top: pos.top
            });
        };

        var PX_POPOVER_ARROW_OFFSET_X = 20;

        /**
         * update current state
         * @param {jQuery} $popover - popover container
         * @param {Object} styleInfo - style object
         * @param {Boolean} isAirMode
         */
        this.update = function ($popover, styleInfo, isAirMode) {
            button.update($popover, styleInfo);

            var $linkPopover = $popover.find('.note-link-popover');
            if (styleInfo.anchor) {
                var $anchor = $linkPopover.find('a');
                var href = $(styleInfo.anchor).attr('href');
                var target = $(styleInfo.anchor).attr('target');
                $anchor.attr('href', href).html(href);
                if (!target) {
                    $anchor.removeAttr('target');
                } else {
                    $anchor.attr('target', '_blank');
                }
                showPopover($linkPopover, posFromPlaceholder(styleInfo.anchor, {
                    isAirMode: isAirMode
                }));
            } else {
                $linkPopover.hide();
            }

            var $imagePopover = $popover.find('.note-image-popover');
            if (styleInfo.image) {
                showPopover($imagePopover, posFromPlaceholder(styleInfo.image, {
                    isAirMode: isAirMode,
                    isLeftTop: true
                }));
            } else {
                $imagePopover.hide();
            }

            var $airPopover = $popover.find('.note-air-popover');
            if (isAirMode && styleInfo.range && !styleInfo.range.isCollapsed()) {
                var rect = list.last(styleInfo.range.getClientRects());
                if (rect) {
                    var bnd = func.rect2bnd(rect);
                    showPopover($airPopover, {
                        left: Math.max(bnd.left + bnd.width / 2 - PX_POPOVER_ARROW_OFFSET_X, 0),
                        top: bnd.top + bnd.height
                    });
                }
            } else {
                $airPopover.hide();
            }
        };

        /**
         * @param {Node} button
         * @param {String} eventName
         * @param {String} value
         */
        this.updateRecentColor = function (button, eventName, value) {
            button.updateRecentColor(button, eventName, value);
        };

        /**
         * hide all popovers
         * @param {jQuery} $popover - popover container
         */
        this.hide = function ($popover) {
            $popover.children().hide();
        };
    };

    /**
     * @class module.Handle
     *
     * Handle
     */
    var Handle = function (handler) {
        var $document = $(document);

        /**
         * `mousedown` event handler on $handle
         *  - controlSizing: resize image
         *
         * @param {MouseEvent} event
         */
        var hHandleMousedown = function (event) {
            if (dom.isControlSizing(event.target)) {
                event.preventDefault();
                event.stopPropagation();

                var layoutInfo = dom.makeLayoutInfo(event.target),
                    $handle = layoutInfo.handle(),
                    $popover = layoutInfo.popover(),
                    $editable = layoutInfo.editable(),
                    $editor = layoutInfo.editor();

                var target = $handle.find('.note-control-selection').data('target'),
                    $target = $(target), posStart = $target.offset(),
                    scrollTop = $document.scrollTop();

                var isAirMode = $editor.data('options').airMode;

                $document.on('mousemove', function (event) {
                    handler.invoke('editor.resizeTo', {
                        x: event.clientX - posStart.left,
                        y: event.clientY - (posStart.top - scrollTop)
                    }, $target, !event.shiftKey);

                    handler.invoke('handle.update', $handle, {image: target}, isAirMode);
                    handler.invoke('popover.update', $popover, {image: target}, isAirMode);
                }).one('mouseup', function () {
                    $document.off('mousemove');
                    handler.invoke('editor.afterCommand', $editable);
                });

                if (!$target.data('ratio')) { // original ratio.
                    $target.data('ratio', $target.height() / $target.width());
                }
            }
        };

        this.attach = function (layoutInfo) {
            layoutInfo.handle().on('mousedown', hHandleMousedown);
        };

        /**
         * update handle
         * @param {jQuery} $handle
         * @param {Object} styleInfo
         * @param {Boolean} isAirMode
         */
        this.update = function ($handle, styleInfo, isAirMode) {
            var $selection = $handle.find('.note-control-selection');
            if (styleInfo.image) {
                var $image = $(styleInfo.image);
                var pos = isAirMode ? $image.offset() : $image.position();

                // include margin
                var imageSize = {
                    w: $image.outerWidth(true),
                    h: $image.outerHeight(true)
                };

                $selection.css({
                    display: 'block',
                    left: pos.left,
                    top: pos.top,
                    width: imageSize.w,
                    height: imageSize.h
                }).data('target', styleInfo.image); // save current image element.
                var sizingText = imageSize.w + 'x' + imageSize.h;
                $selection.find('.note-control-selection-info').text(sizingText);
            } else {
                $selection.hide();
            }
        };

        /**
         * hide
         *
         * @param {jQuery} $handle
         */
        this.hide = function ($handle) {
            $handle.children().hide();
        };
    };

    var Fullscreen = function (handler) {
        var $window = $(window);
        var $scrollbar = $('html, body');

        /**
         * toggle fullscreen
         *
         * @param {Object} layoutInfo
         */
        this.toggle = function (layoutInfo) {

            var $editor = layoutInfo.editor(),
                $toolbar = layoutInfo.toolbar(),
                $editable = layoutInfo.editable(),
                $codable = layoutInfo.codable();

            var resize = function (size) {
                $editable.css('height', size.h);
                $codable.css('height', size.h);
                if ($codable.data('cmeditor')) {
                    $codable.data('cmeditor').setsize(null, size.h);
                }
            };

            $editor.toggleClass('fullscreen');
            var isFullscreen = $editor.hasClass('fullscreen');
            if (isFullscreen) {
                $editable.data('orgheight', $editable.css('height'));

                $window.on('resize', function () {
                    resize({
                        h: $window.height() - $toolbar.outerHeight()
                    });
                }).trigger('resize');

                $scrollbar.css('overflow', 'hidden');
            } else {
                $window.off('resize');
                resize({
                    h: $editable.data('orgheight')
                });
                $scrollbar.css('overflow', 'visible');
            }

            handler.invoke('toolbar.updateFullscreen', $toolbar, isFullscreen);
        };
    };


    var CodeMirror;
    if (agent.hasCodeMirror) {
        if (agent.isSupportAmd) {
            require(['CodeMirror'], function (cm) {
                CodeMirror = cm;
            });
        } else {
            CodeMirror = window.CodeMirror;
        }
    }

    /**
     * @class Codeview
     */
    var Codeview = function (handler) {

        this.sync = function (layoutInfo) {
            var isCodeview = handler.invoke('codeview.isActivated', layoutInfo);
            if (isCodeview && agent.hasCodeMirror) {
                layoutInfo.codable().data('cmEditor').save();
            }
        };

        /**
         * @param {Object} layoutInfo
         * @return {Boolean}
         */
        this.isActivated = function (layoutInfo) {
            var $editor = layoutInfo.editor();
            return $editor.hasClass('codeview');
        };

        /**
         * toggle codeview
         *
         * @param {Object} layoutInfo
         */
        this.toggle = function (layoutInfo) {
            if (this.isActivated(layoutInfo)) {
                this.deactivate(layoutInfo);
            } else {
                this.activate(layoutInfo);
            }
        };

        /**
         * activate code view
         *
         * @param {Object} layoutInfo
         */
        this.activate = function (layoutInfo) {
            var $editor = layoutInfo.editor(),
                $toolbar = layoutInfo.toolbar(),
                $editable = layoutInfo.editable(),
                $codable = layoutInfo.codable(),
                $popover = layoutInfo.popover(),
                $handle = layoutInfo.handle();

            var options = $editor.data('options');

            $codable.val(dom.html($editable, options.prettifyHtml));
            $codable.height($editable.height());

            handler.invoke('toolbar.updateCodeview', $toolbar, true);
            handler.invoke('popover.hide', $popover);
            handler.invoke('handle.hide', $handle);

            $editor.addClass('codeview');

            $codable.focus();

            // activate CodeMirror as codable
            if (agent.hasCodeMirror) {
                var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);

                // CodeMirror TernServer
                if (options.codemirror.tern) {
                    var server = new CodeMirror.TernServer(options.codemirror.tern);
                    cmEditor.ternServer = server;
                    cmEditor.on('cursorActivity', function (cm) {
                        server.updateArgHints(cm);
                    });
                }

                // CodeMirror hasn't Padding.
                cmEditor.setSize(null, $editable.outerHeight());
                $codable.data('cmEditor', cmEditor);
            }
        };

        /**
         * deactivate code view
         *
         * @param {Object} layoutInfo
         */
        this.deactivate = function (layoutInfo) {
            var $holder = layoutInfo.holder(),
                $editor = layoutInfo.editor(),
                $toolbar = layoutInfo.toolbar(),
                $editable = layoutInfo.editable(),
                $codable = layoutInfo.codable();

            var options = $editor.data('options');

            // deactivate CodeMirror as codable
            if (agent.hasCodeMirror) {
                var cmEditor = $codable.data('cmEditor');
                $codable.val(cmEditor.getValue());
                cmEditor.toTextArea();
            }

            var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;
            var isChange = $editable.html() !== value;

            $editable.html(value);
            $editable.height(options.height ? $codable.height() : 'auto');
            $editor.removeClass('codeview');

            if (isChange) {
                handler.bindCustomEvent(
                    $holder, $editable.data('callbacks'), 'change'
                )($editable.html(), $editable);
            }

            $editable.focus();

            handler.invoke('toolbar.updateCodeview', $toolbar, false);
        };
    };

    var DragAndDrop = function (handler) {
        var $document = $(document);

        /**
         * attach Drag and Drop Events
         *
         * @param {Object} layoutInfo - layout Informations
         * @param {Object} options
         */
        this.attach = function (layoutInfo, options) {
            if (options.airMode || options.disableDragAndDrop) {
                // prevent default drop event
                $document.on('drop', function (e) {
                    e.preventDefault();
                });
            } else {
                this.attachDragAndDropEvent(layoutInfo, options);
            }
        };

        /**
         * attach Drag and Drop Events
         *
         * @param {Object} layoutInfo - layout Informations
         * @param {Object} options
         */
        this.attachDragAndDropEvent = function (layoutInfo, options) {
            var collection = $(),
                $editor = layoutInfo.editor(),
                $dropzone = layoutInfo.dropzone(),
                $dropzoneMessage = $dropzone.find('.note-dropzone-message');

            // show dropzone on dragenter when dragging a object to document
            // -but only if the editor is visible, i.e. has a positive width and height
            $document.on('dragenter', function (e) {
                var isCodeview = handler.invoke('codeview.isActivated', layoutInfo);
                var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;
                if (!isCodeview && !collection.length && hasEditorSize) {
                    $editor.addClass('dragover');
                    $dropzone.width($editor.width());
                    $dropzone.height($editor.height());
                    $dropzoneMessage.text(options.langInfo.image.dragImageHere);
                }
                collection = collection.add(e.target);
            }).on('dragleave', function (e) {
                collection = collection.not(e.target);
                if (!collection.length) {
                    $editor.removeClass('dragover');
                }
            }).on('drop', function () {
                collection = $();
                $editor.removeClass('dragover');
            });

            // change dropzone's message on hover.
            $dropzone.on('dragenter', function () {
                $dropzone.addClass('hover');
                $dropzoneMessage.text(options.langInfo.image.dropImage);
            }).on('dragleave', function () {
                $dropzone.removeClass('hover');
                $dropzoneMessage.text(options.langInfo.image.dragImageHere);
            });

            // attach dropImage
            $dropzone.on('drop', function (event) {

                var dataTransfer = event.originalEvent.dataTransfer;
                var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);

                if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                    event.preventDefault();
                    layoutInfo.editable().focus();
                    handler.insertImages(layoutInfo, dataTransfer.files);
                } else {
                    var insertNodefunc = function () {
                        layoutInfo.holder().summernote('insertNode', this);
                    };

                    for (var i = 0, len = dataTransfer.types.length; i < len; i++) {
                        var type = dataTransfer.types[i];
                        var content = dataTransfer.getData(type);

                        if (type.toLowerCase().indexOf('text') > -1) {
                            layoutInfo.holder().summernote('pasteHTML', content);
                        } else {
                            $(content).each(insertNodefunc);
                        }
                    }
                }
            }).on('dragover', false); // prevent default dragover event
        };
    };

    var Clipboard = function (handler) {
        var $paste;

        this.attach = function (layoutInfo) {
            // [workaround] getting image from clipboard
            //  - IE11 and Firefox: CTRL+v hook
            //  - Webkit: event.clipboardData
            if ((agent.isMSIE && agent.browserVersion > 10) || agent.isFF) {
                $paste = $('<div />').attr('contenteditable', true).css({
                    position: 'absolute',
                    left: -100000,
                    opacity: 0
                });

                layoutInfo.editable().on('keydown', function (e) {
                    if (e.ctrlKey && e.keyCode === key.code.V) {
                        handler.invoke('saveRange', layoutInfo.editable());
                        $paste.focus();

                        setTimeout(function () {
                            pasteByHook(layoutInfo);
                        }, 0);
                    }
                });

                layoutInfo.editable().before($paste);
            } else {
                layoutInfo.editable().on('paste', pasteByEvent);
            }
        };

        var pasteByHook = function (layoutInfo) {
            var $editable = layoutInfo.editable();
            var node = $paste[0].firstChild;

            if (dom.isImg(node)) {
                var dataURI = node.src;
                var decodedData = atob(dataURI.split(',')[1]);
                var array = new Uint8Array(decodedData.length);
                for (var i = 0; i < decodedData.length; i++) {
                    array[i] = decodedData.charCodeAt(i);
                }

                var blob = new Blob([array], {type: 'image/png'});
                blob.name = 'clipboard.png';

                handler.invoke('restoreRange', $editable);
                handler.invoke('focus', $editable);
                handler.insertImages(layoutInfo, [blob]);
            } else {
                var pasteContent = $('<div />').html($paste.html()).html();
                handler.invoke('restoreRange', $editable);
                handler.invoke('focus', $editable);

                if (pasteContent) {
                    handler.invoke('pasteHTML', $editable, pasteContent);
                }
            }

            $paste.empty();
        };

        /**
         * paste by clipboard event
         *
         * @param {Event} event
         */
        var pasteByEvent = function (event) {
            var clipboardData = event.originalEvent.clipboardData;
            var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);
            var $editable = layoutInfo.editable();

            if (clipboardData && clipboardData.items && clipboardData.items.length) {
                var item = list.head(clipboardData.items);
                if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                    handler.insertImages(layoutInfo, [item.getAsFile()]);
                }
                handler.invoke('editor.afterCommand', $editable);
            }
        };
    };

    var LinkDialog = function (handler) {

        /**
         * toggle button status
         *
         * @private
         * @param {jQuery} $btn
         * @param {Boolean} isEnable
         */
        var toggleBtn = function ($btn, isEnable) {
            $btn.toggleClass('disabled', !isEnable);
            $btn.attr('disabled', !isEnable);
        };

        /**
         * bind enter key
         *
         * @private
         * @param {jQuery} $input
         * @param {jQuery} $btn
         */
        var bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    $btn.trigger('click');
                }
            });
        };

        /**
         * Show link dialog and set event handlers on dialog controls.
         *
         * @param {jQuery} $editable
         * @param {jQuery} $dialog
         * @param {Object} linkInfo
         * @return {Promise}
         */
        this.showLinkDialog = function ($editable, $dialog, linkInfo) {
            return $.Deferred(function (deferred) {
                var $linkDialog = $dialog.find('.note-link-dialog');

                var $linkText = $linkDialog.find('.note-link-text'),
                    $linkUrl = $linkDialog.find('.note-link-url'),
                    $linkBtn = $linkDialog.find('.note-link-btn'),
                    $openInNewWindow = $linkDialog.find('input[type=checkbox]');

                $linkDialog.one('shown.bs.modal', function () {
                    $linkText.val(linkInfo.text);

                    $linkText.on('input', function () {
                        toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
                        // if linktext was modified by keyup,
                        // stop cloning text from linkUrl
                        linkInfo.text = $linkText.val();
                    });

                    // if no url was given, copy text to url
                    if (!linkInfo.url) {
                        linkInfo.url = linkInfo.text || 'http://';
                        toggleBtn($linkBtn, linkInfo.text);
                    }

                    $linkUrl.on('input', function () {
                        toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
                        // display same link on `Text to display` input
                        // when create a new link
                        if (!linkInfo.text) {
                            $linkText.val($linkUrl.val());
                        }
                    }).val(linkInfo.url).trigger('focus').trigger('select');

                    bindEnterKey($linkUrl, $linkBtn);
                    bindEnterKey($linkText, $linkBtn);

                    $openInNewWindow.prop('checked', linkInfo.isNewWindow);

                    $linkBtn.one('click', function (event) {
                        event.preventDefault();

                        deferred.resolve({
                            range: linkInfo.range,
                            url: $linkUrl.val(),
                            text: $linkText.val(),
                            isNewWindow: $openInNewWindow.is(':checked')
                        });
                        $linkDialog.modal('hide');
                    });
                }).one('hidden.bs.modal', function () {
                    // detach events
                    $linkText.off('input keypress');
                    $linkUrl.off('input keypress');
                    $linkBtn.off('click');

                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                }).modal('show');
            }).promise();
        };

        /**
         * @param {Object} layoutInfo
         */
        this.show = function (layoutInfo) {
            var $editor = layoutInfo.editor(),
                $dialog = layoutInfo.dialog(),
                $editable = layoutInfo.editable(),
                $popover = layoutInfo.popover(),
                linkInfo = handler.invoke('editor.getLinkInfo', $editable);

            var options = $editor.data('options');

            handler.invoke('editor.saveRange', $editable);
            this.showLinkDialog($editable, $dialog, linkInfo).then(function (linkInfo) {
                handler.invoke('editor.restoreRange', $editable);
                handler.invoke('editor.createLink', $editable, linkInfo, options);
                // hide popover after creating link
                handler.invoke('popover.hide', $popover);
            }).fail(function () {
                handler.invoke('editor.restoreRange', $editable);
            });
        };
    };

    var ImageDialog = function (handler) {
        /**
         * toggle button status
         *
         * @private
         * @param {jQuery} $btn
         * @param {Boolean} isEnable
         */
        var toggleBtn = function ($btn, isEnable) {
            $btn.toggleClass('disabled', !isEnable);
            $btn.attr('disabled', !isEnable);
        };

        /**
         * bind enter key
         *
         * @private
         * @param {jQuery} $input
         * @param {jQuery} $btn
         */
        var bindEnterKey = function ($input, $btn) {
            $input.on('keypress', function (event) {
                if (event.keyCode === key.code.ENTER) {
                    $btn.trigger('click');
                }
            });
        };

        this.show = function (layoutInfo) {
            var $dialog = layoutInfo.dialog(),
                $editable = layoutInfo.editable();

            handler.invoke('editor.saveRange', $editable);
            this.showImageDialog($editable, $dialog).then(function (data) {
                handler.invoke('editor.restoreRange', $editable);

                if (typeof data === 'string') {
                    // image url
                    handler.invoke('editor.insertImage', $editable, data);
                } else {
                    // array of files
                    handler.insertImages(layoutInfo, data);
                }
            }).fail(function () {
                handler.invoke('editor.restoreRange', $editable);
            });
        };

        /**
         * show image dialog
         *
         * @param {jQuery} $editable
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        this.showImageDialog = function ($editable, $dialog) {
            return $.Deferred(function (deferred) {
                var $imageDialog = $dialog.find('.note-image-dialog');

                var $imageInput = $dialog.find('.note-image-input'),
                    $imageUrl = $dialog.find('.note-image-url'),
                    $imageBtn = $dialog.find('.note-image-btn');

                $imageDialog.one('shown.bs.modal', function () {
                    // Cloning imageInput to clear element.
                    $imageInput.replaceWith($imageInput.clone()
                        .on('change', function () {
                            deferred.resolve(this.files || this.value);
                            $imageDialog.modal('hide');
                        })
                        .val('')
                    );

                    $imageBtn.click(function (event) {
                        event.preventDefault();

                        deferred.resolve($imageUrl.val());
                        $imageDialog.modal('hide');
                    });

                    $imageUrl.on('keyup paste', function (event) {
                        var url;

                        if (event.type === 'paste') {
                            url = event.originalEvent.clipboardData.getData('text');
                        } else {
                            url = $imageUrl.val();
                        }

                        toggleBtn($imageBtn, url);
                    }).val('').trigger('focus');
                    bindEnterKey($imageUrl, $imageBtn);
                }).one('hidden.bs.modal', function () {
                    $imageInput.off('change');
                    $imageUrl.off('keyup paste keypress');
                    $imageBtn.off('click');

                    if (deferred.state() === 'pending') {
                        deferred.reject();
                    }
                }).modal('show');
            });
        };
    };

    var HelpDialog = function (handler) {
        /**
         * show help dialog
         *
         * @param {jQuery} $editable
         * @param {jQuery} $dialog
         * @return {Promise}
         */
        this.showHelpDialog = function ($editable, $dialog) {
            return $.Deferred(function (deferred) {
                var $helpDialog = $dialog.find('.note-help-dialog');

                $helpDialog.one('hidden.bs.modal', function () {
                    deferred.resolve();
                }).modal('show');
            }).promise();
        };

        /**
         * @param {Object} layoutInfo
         */
        this.show = function (layoutInfo) {
            var $dialog = layoutInfo.dialog(),
                $editable = layoutInfo.editable();

            handler.invoke('editor.saveRange', $editable, true);
            this.showHelpDialog($editable, $dialog).then(function () {
                handler.invoke('editor.restoreRange', $editable);
            });
        };
    };


    /**
     * @class EventHandler
     *
     * EventHandler
     *  - TODO: new instance per a editor
     */
    var EventHandler = function () {
        var self = this;

        /**
         * Modules
         */
        var modules = this.modules = {
            editor: new Editor(this),
            toolbar: new Toolbar(this),
            statusbar: new Statusbar(this),
            popover: new Popover(this),
            handle: new Handle(this),
            fullscreen: new Fullscreen(this),
            codeview: new Codeview(this),
            dragAndDrop: new DragAndDrop(this),
            clipboard: new Clipboard(this),
            linkDialog: new LinkDialog(this),
            imageDialog: new ImageDialog(this),
            helpDialog: new HelpDialog(this)
        };

        /**
         * invoke module's method
         *
         * @param {String} moduleAndMethod - ex) 'editor.redo'
         * @param {...*} arguments - arguments of method
         * @return {*}
         */
        this.invoke = function () {
            var moduleAndMethod = list.head(list.from(arguments));
            var args = list.tail(list.from(arguments));

            var splits = moduleAndMethod.split('.');
            var hasSeparator = splits.length > 1;
            var moduleName = hasSeparator && list.head(splits);
            var methodName = hasSeparator ? list.last(splits) : list.head(splits);

            var module = this.getModule(moduleName);
            var method = module[methodName];

            return method && method.apply(module, args);
        };

        /**
         * returns module
         *
         * @param {String} moduleName - name of module
         * @return {Module} - defaults is editor
         */
        this.getModule = function (moduleName) {
            return this.modules[moduleName] || this.modules.editor;
        };

        /**
         * @param {jQuery} $holder
         * @param {Object} callbacks
         * @param {String} eventNamespace
         * @returns {Function}
         */
        var bindCustomEvent = this.bindCustomEvent = function ($holder, callbacks, eventNamespace) {
            return function () {
                var callback = callbacks[func.namespaceToCamel(eventNamespace, 'on')];
                if (callback) {
                    callback.apply($holder[0], arguments);
                }
                return $holder.trigger('summernote.' + eventNamespace, arguments);
            };
        };

        /**
         * insert Images from file array.
         *
         * @private
         * @param {Object} layoutInfo
         * @param {File[]} files
         */
        this.insertImages = function (layoutInfo, files) {
            var $editor = layoutInfo.editor(),
                $editable = layoutInfo.editable(),
                $holder = layoutInfo.holder();

            var callbacks = $editable.data('callbacks');
            var options = $editor.data('options');

            // If onImageUpload options setted
            if (callbacks.onImageUpload) {
                bindCustomEvent($holder, callbacks, 'image.upload')(files);
                // else insert Image as dataURL
            } else {
                $.each(files, function (idx, file) {
                    var filename = file.name;
                    if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {
                        bindCustomEvent($holder, callbacks, 'image.upload.error')(options.langInfo.image.maximumFileSizeError);
                    } else {
                        async.readFileAsDataURL(file).then(function (sDataURL) {
                            modules.editor.insertImage($editable, sDataURL, filename);
                        }).fail(function () {
                            bindCustomEvent($holder, callbacks, 'image.upload.error')(options.langInfo.image.maximumFileSizeError);
                        });
                    }
                });
            }
        };

        var commands = {
            /**
             * @param {Object} layoutInfo
             */
            showLinkDialog: function (layoutInfo) {
                modules.linkDialog.show(layoutInfo);
            },

            /**
             * @param {Object} layoutInfo
             */
            showImageDialog: function (layoutInfo) {
                modules.imageDialog.show(layoutInfo);
            },

            /**
             * @param {Object} layoutInfo
             */
            showHelpDialog: function (layoutInfo) {
                modules.helpDialog.show(layoutInfo);
            },

            /**
             * @param {Object} layoutInfo
             */
            fullscreen: function (layoutInfo) {
                modules.fullscreen.toggle(layoutInfo);
            },

            /**
             * @param {Object} layoutInfo
             */
            codeview: function (layoutInfo) {
                modules.codeview.toggle(layoutInfo);
            }
        };

        var hMousedown = function (event) {
            //preventDefault Selection for FF, IE8+
            if (dom.isImg(event.target)) {
                event.preventDefault();
            }
        };

        var hKeyupAndMouseup = function (event) {
            var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);
            modules.editor.removeBogus(layoutInfo.editable());
            hToolbarAndPopoverUpdate(event);
        };

        /**
         * update sytle info
         * @param {Object} styleInfo
         * @param {Object} layoutInfo
         */
        this.updateStyleInfo = function (styleInfo, layoutInfo) {
            if (!styleInfo) {
                return;
            }
            var isAirMode = layoutInfo.editor().data('options').airMode;
            if (!isAirMode) {
                modules.toolbar.update(layoutInfo.toolbar(), styleInfo);
            }

            modules.popover.update(layoutInfo.popover(), styleInfo, isAirMode);
            modules.handle.update(layoutInfo.handle(), styleInfo, isAirMode);
        };

        var hToolbarAndPopoverUpdate = function (event) {
            var target = event.target;
            // delay for range after mouseup
            setTimeout(function () {
                var layoutInfo = dom.makeLayoutInfo(target);
                var styleInfo = modules.editor.currentStyle(target);
                self.updateStyleInfo(styleInfo, layoutInfo);
            }, 0);
        };

        var hScroll = function (event) {
            var layoutInfo = dom.makeLayoutInfo(event.currentTarget || event.target);
            //hide popover and handle when scrolled
            modules.popover.hide(layoutInfo.popover());
            modules.handle.hide(layoutInfo.handle());
        };

        var hToolbarAndPopoverMousedown = function (event) {
            // prevent default event when insertTable (FF, Webkit)
            var $btn = $(event.target).closest('[data-event]');
            if ($btn.length) {
                event.preventDefault();
            }
        };

        var hToolbarAndPopoverClick = function (event) {
            var $btn = $(event.target).closest('[data-event]');

            if (!$btn.length) {
                return;
            }

            var eventName = $btn.attr('data-event'),
                value = $btn.attr('data-value'),
                hide = $btn.attr('data-hide');

            var layoutInfo = dom.makeLayoutInfo(event.target);

            // before command: detect control selection element($target)
            var $target;
            if ($.inArray(eventName, ['resize', 'floatMe', 'removeMedia', 'imageShape']) !== -1) {
                var $selection = layoutInfo.handle().find('.note-control-selection');
                $target = $($selection.data('target'));
            }

            // If requested, hide the popover when the button is clicked.
            // Useful for things like showHelpDialog.
            if (hide) {
                $btn.parents('.popover').hide();
            }

            if ($.isFunction($.summernote.pluginEvents[eventName])) {
                $.summernote.pluginEvents[eventName](event, modules.editor, layoutInfo, value);
            } else if (modules.editor[eventName]) { // on command
                var $editable = layoutInfo.editable();
                $editable.focus();
                modules.editor[eventName]($editable, value, $target);
                event.preventDefault();
            } else if (commands[eventName]) {
                commands[eventName].call(this, layoutInfo);
                event.preventDefault();
            }

            // after command
            if ($.inArray(eventName, ['backColor', 'foreColor']) !== -1) {
                var options = layoutInfo.editor().data('options', options);
                var module = options.airMode ? modules.popover : modules.toolbar;
                module.updateRecentColor(list.head($btn), eventName, value);
            }

            hToolbarAndPopoverUpdate(event);
        };

        var PX_PER_EM = 18;
        var hDimensionPickerMove = function (event, options) {
            var $picker = $(event.target.parentNode); // target is mousecatcher
            var $dimensionDisplay = $picker.next();
            var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
            var $highlighted = $picker.find('.note-dimension-picker-highlighted');
            var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');

            var posOffset;
            // HTML5 with jQuery - e.offsetX is undefined in Firefox
            if (event.offsetX === undefined) {
                var posCatcher = $(event.target).offset();
                posOffset = {
                    x: event.pageX - posCatcher.left,
                    y: event.pageY - posCatcher.top
                };
            } else {
                posOffset = {
                    x: event.offsetX,
                    y: event.offsetY
                };
            }

            var dim = {
                c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                r: Math.ceil(posOffset.y / PX_PER_EM) || 1
            };

            $highlighted.css({width: dim.c + 'em', height: dim.r + 'em'});
            $catcher.attr('data-value', dim.c + 'x' + dim.r);

            if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {
                $unhighlighted.css({width: dim.c + 1 + 'em'});
            }

            if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {
                $unhighlighted.css({height: dim.r + 1 + 'em'});
            }

            $dimensionDisplay.html(dim.c + ' x ' + dim.r);
        };

        /**
         * bind KeyMap on keydown
         *
         * @param {Object} layoutInfo
         * @param {Object} keyMap
         */
        this.bindKeyMap = function (layoutInfo, keyMap) {
            var $editor = layoutInfo.editor();
            var $editable = layoutInfo.editable();

            $editable.on('keydown', function (event) {
                var keys = [];

                // modifier
                if (event.metaKey) {
                    keys.push('CMD');
                }
                if (event.ctrlKey && !event.altKey) {
                    keys.push('CTRL');
                }
                if (event.shiftKey) {
                    keys.push('SHIFT');
                }

                // keycode
                var keyName = key.nameFromCode[event.keyCode];
                if (keyName) {
                    keys.push(keyName);
                }

                var pluginEvent;
                var keyString = keys.join('+');
                var eventName = keyMap[keyString];
                if (eventName) {
                    // FIXME Summernote doesn't support event pipeline yet.
                    //  - Plugin -> Base Code
                    pluginEvent = $.summernote.pluginEvents[keyString];
                    if ($.isFunction(pluginEvent)) {
                        if (pluginEvent(event, modules.editor, layoutInfo)) {
                            return false;
                        }
                    }

                    pluginEvent = $.summernote.pluginEvents[eventName];

                    if ($.isFunction(pluginEvent)) {
                        pluginEvent(event, modules.editor, layoutInfo);
                    } else if (modules.editor[eventName]) {
                        modules.editor[eventName]($editable, $editor.data('options'));
                        event.preventDefault();
                    } else if (commands[eventName]) {
                        commands[eventName].call(this, layoutInfo);
                        event.preventDefault();
                    }
                } else if (key.isEdit(event.keyCode)) {
                    modules.editor.afterCommand($editable);
                }
            });
        };

        /**
         * attach eventhandler
         *
         * @param {Object} layoutInfo - layout Informations
         * @param {Object} options - user options include custom event handlers
         */
        this.attach = function (layoutInfo, options) {
            // handlers for editable
            if (options.shortcuts) {
                this.bindKeyMap(layoutInfo, options.keyMap[agent.isMac ? 'mac' : 'pc']);
            }
            layoutInfo.editable().on('mousedown', hMousedown);
            layoutInfo.editable().on('keyup mouseup', hKeyupAndMouseup);
            layoutInfo.editable().on('scroll', hScroll);

            // handler for clipboard
            modules.clipboard.attach(layoutInfo, options);

            // handler for handle and popover
            modules.handle.attach(layoutInfo, options);
            layoutInfo.popover().on('click', hToolbarAndPopoverClick);
            layoutInfo.popover().on('mousedown', hToolbarAndPopoverMousedown);

            // handler for drag and drop
            modules.dragAndDrop.attach(layoutInfo, options);

            // handlers for frame mode (toolbar, statusbar)
            if (!options.airMode) {
                // handler for toolbar
                layoutInfo.toolbar().on('click', hToolbarAndPopoverClick);
                layoutInfo.toolbar().on('mousedown', hToolbarAndPopoverMousedown);

                // handler for statusbar
                modules.statusbar.attach(layoutInfo, options);
            }

            // handler for table dimension
            var $catcherContainer = options.airMode ? layoutInfo.popover() :
                layoutInfo.toolbar();
            var $catcher = $catcherContainer.find('.note-dimension-picker-mousecatcher');
            $catcher.css({
                width: options.insertTableMaxSize.col + 'em',
                height: options.insertTableMaxSize.row + 'em'
            }).on('mousemove', function (event) {
                hDimensionPickerMove(event, options);
            });

            // save options on editor
            layoutInfo.editor().data('options', options);

            // ret styleWithCSS for backColor / foreColor clearing with 'inherit'.
            if (!agent.isMSIE) {
                // [workaround] for Firefox
                //  - protect FF Error: NS_ERROR_FAILURE: Failure
                setTimeout(function () {
                    document.execCommand('styleWithCSS', 0, options.styleWithSpan);
                }, 0);
            }

            // History
            var history = new History(layoutInfo.editable());
            layoutInfo.editable().data('NoteHistory', history);

            // All editor status will be saved on editable with jquery's data
            // for support multiple editor with singleton object.
            layoutInfo.editable().data('callbacks', {
                onInit: options.onInit,
                onFocus: options.onFocus,
                onBlur: options.onBlur,
                onKeydown: options.onKeydown,
                onKeyup: options.onKeyup,
                onMousedown: options.onMousedown,
                onEnter: options.onEnter,
                onPaste: options.onPaste,
                onBeforeCommand: options.onBeforeCommand,
                onChange: options.onChange,
                onImageUpload: options.onImageUpload,
                onImageUploadError: options.onImageUploadError,
                onMediaDelete: options.onMediaDelete,
                onToolbarClick: options.onToolbarClick
            });

            var styleInfo = modules.editor.styleFromNode(layoutInfo.editable());
            this.updateStyleInfo(styleInfo, layoutInfo);
        };

        /**
         * attach jquery custom event
         *
         * @param {Object} layoutInfo - layout Informations
         */
        this.attachCustomEvent = function (layoutInfo, options) {
            var $holder = layoutInfo.holder();
            var $editable = layoutInfo.editable();
            var callbacks = $editable.data('callbacks');

            $editable.focus(bindCustomEvent($holder, callbacks, 'focus'));
            $editable.blur(bindCustomEvent($holder, callbacks, 'blur'));

            $editable.keydown(function (event) {
                if (event.keyCode === key.code.ENTER) {
                    bindCustomEvent($holder, callbacks, 'enter').call(this, event);
                }
                bindCustomEvent($holder, callbacks, 'keydown').call(this, event);
            });
            $editable.keyup(bindCustomEvent($holder, callbacks, 'keyup'));

            $editable.on('mousedown', bindCustomEvent($holder, callbacks, 'mousedown'));
            $editable.on('mouseup', bindCustomEvent($holder, callbacks, 'mouseup'));
            $editable.on('scroll', bindCustomEvent($holder, callbacks, 'scroll'));

            $editable.on('paste', bindCustomEvent($holder, callbacks, 'paste'));

            // [workaround] IE doesn't have input events for contentEditable
            //  - see: https://goo.gl/4bfIvA
            var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
            $editable.on(changeEventName, function () {
                bindCustomEvent($holder, callbacks, 'change')($editable.html(), $editable);
            });

            if (!options.airMode) {
                layoutInfo.toolbar().click(bindCustomEvent($holder, callbacks, 'toolbar.click'));
                layoutInfo.popover().click(bindCustomEvent($holder, callbacks, 'popover.click'));
            }

            // Textarea: auto filling the code before form submit.
            if (dom.isTextarea(list.head($holder))) {
                $holder.closest('form').submit(function (e) {
                    layoutInfo.holder().val(layoutInfo.holder().code());
                    bindCustomEvent($holder, callbacks, 'submit').call(this, e, $holder.code());
                });
            }

            // textarea auto sync
            if (dom.isTextarea(list.head($holder)) && options.textareaAutoSync) {
                $holder.on('summernote.change', function () {
                    layoutInfo.holder().val(layoutInfo.holder().code());
                });
            }

            // fire init event
            bindCustomEvent($holder, callbacks, 'init')(layoutInfo);

            // fire plugin init event
            for (var i = 0, len = $.summernote.plugins.length; i < len; i++) {
                if ($.isFunction($.summernote.plugins[i].init)) {
                    $.summernote.plugins[i].init(layoutInfo);
                }
            }
        };

        this.detach = function (layoutInfo, options) {
            layoutInfo.holder().off();
            layoutInfo.editable().off();

            layoutInfo.popover().off();
            layoutInfo.handle().off();
            layoutInfo.dialog().off();

            if (!options.airMode) {
                layoutInfo.dropzone().off();
                layoutInfo.toolbar().off();
                layoutInfo.statusbar().off();
            }
        };
    };

    /**
     * @class Renderer
     *
     * renderer
     *
     * rendering toolbar and editable
     */
    var Renderer = function () {

        /**
         * bootstrap button template
         * @private
         * @param {String} label button name
         * @param {Object} [options] button options
         * @param {String} [options.event] data-event
         * @param {String} [options.className] button's class name
         * @param {String} [options.value] data-value
         * @param {String} [options.title] button's title for popup
         * @param {String} [options.dropdown] dropdown html
         * @param {String} [options.hide] data-hide
         */
        var tplButton = function (label, options) {
            var event = options.event;
            var value = options.value;
            var title = options.title;
            var className = options.className;
            var dropdown = options.dropdown;
            var hide = options.hide;

            return (dropdown ? '<div class="btn-group' +
                (className ? ' ' + className : '') + '">' : '') +
                '<button type="button"' +
                ' class="btn btn-default btn-sm' +
                ((!dropdown && className) ? ' ' + className : '') +
                (dropdown ? ' dropdown-toggle' : '') +
                '"' +
                (dropdown ? ' data-toggle="dropdown"' : '') +
                (title ? ' title="' + title + '"' : '') +
                (event ? ' data-event="' + event + '"' : '') +
                (value ? ' data-value=\'' + value + '\'' : '') +
                (hide ? ' data-hide=\'' + hide + '\'' : '') +
                ' tabindex="-1">' +
                label +
                (dropdown ? ' <span class="caret"></span>' : '') +
                '</button>' +
                (dropdown || '') +
                (dropdown ? '</div>' : '');
        };

        /**
         * bootstrap icon button template
         * @private
         * @param {String} iconClassName
         * @param {Object} [options]
         * @param {String} [options.event]
         * @param {String} [options.value]
         * @param {String} [options.title]
         * @param {String} [options.dropdown]
         */
        var tplIconButton = function (iconClassName, options) {
            var label = '<i class="' + iconClassName + '"></i>';
            return tplButton(label, options);
        };

        /**
         * bootstrap popover template
         * @private
         * @param {String} className
         * @param {String} content
         */
        var tplPopover = function (className, content) {
            var $popover = $('<div class="' + className + ' popover bottom in" style="display: none;">' +
                '<div class="arrow"></div>' +
                '<div class="popover-content">' +
                '</div>' +
                '</div>');

            $popover.find('.popover-content').append(content);
            return $popover;
        };

        /**
         * bootstrap dialog template
         *
         * @param {String} className
         * @param {String} [title='']
         * @param {String} body
         * @param {String} [footer='']
         */
        var tplDialog = function (className, title, body, footer) {
            return '<div class="' + className + ' modal" aria-hidden="false">' +
                '<div class="modal-dialog">' +
                '<div class="modal-content">' +
                (title ?
                        '<div class="modal-header">' +
                        '<button type="button" class="close" aria-hidden="true" tabindex="-1">&times;</button>' +
                        '<h4 class="modal-title">' + title + '</h4>' +
                        '</div>' : ''
                ) +
                '<div class="modal-body">' + body + '</div>' +
                (footer ?
                        '<div class="modal-footer">' + footer + '</div>' : ''
                ) +
                '</div>' +
                '</div>' +
                '</div>';
        };

        /**
         * bootstrap dropdown template
         *
         * @param {String|String[]} contents
         * @param {String} [className='']
         * @param {String} [nodeName='']
         */
        var tplDropdown = function (contents, className, nodeName) {
            var classes = 'dropdown-menu' + (className ? ' ' + className : '');
            nodeName = nodeName || 'ul';
            if (contents instanceof Array) {
                contents = contents.join('');
            }

            return '<' + nodeName + ' class="' + classes + '">' + contents + '</' + nodeName + '>';
        };

        var tplButtonInfo = {
            picture: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.image.image, {
                    event: 'showImageDialog',
                    title: lang.image.image,
                    hide: true
                });
            },
            link: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.link.link, {
                    event: 'showLinkDialog',
                    title: lang.link.link,
                    hide: true
                });
            },
            table: function (lang, options) {
                var dropdown = [
                    '<div class="note-dimension-picker">',
                    '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>',
                    '<div class="note-dimension-picker-highlighted"></div>',
                    '<div class="note-dimension-picker-unhighlighted"></div>',
                    '</div>',
                    '<div class="note-dimension-display"> 1 x 1 </div>'
                ];

                return tplIconButton(options.iconPrefix + options.icons.table.table, {
                    title: lang.table.table,
                    dropdown: tplDropdown(dropdown, 'note-table')
                });
            },
            style: function (lang, options) {
                var items = options.styleTags.reduce(function (memo, v) {
                    var label = lang.style[v === 'p' ? 'normal' : v];
                    return memo + '<li><a data-event="formatBlock" href="#" data-value="' + v + '">' +
                        (
                            (v === 'p' || v === 'pre') ? label :
                                '<' + v + '>' + label + '</' + v + '>'
                        ) +
                        '</a></li>';
                }, '');

                return tplIconButton(options.iconPrefix + options.icons.style.style, {
                    title: lang.style.style,
                    dropdown: tplDropdown(items)
                });
            },
            fontname: function (lang, options) {
                var realFontList = [];
                var items = options.fontNames.reduce(function (memo, v) {
                    if (!agent.isFontInstalled(v) && !list.contains(options.fontNamesIgnoreCheck, v)) {
                        return memo;
                    }
                    realFontList.push(v);
                    return memo + '<li><a data-event="fontName" href="#" data-value="' + v + '" style="font-family:\'' + v + '\'">' +
                        '<i class="' + options.iconPrefix + options.icons.misc.check + '"></i> ' + v +
                        '</a></li>';
                }, '');

                var hasDefaultFont = agent.isFontInstalled(options.defaultFontName);
                var defaultFontName = (hasDefaultFont) ? options.defaultFontName : realFontList[0];

                var label = '<span class="note-current-fontname">' +
                    defaultFontName +
                    '</span>';
                return tplButton(label, {
                    title: lang.font.name,
                    className: 'note-fontname',
                    dropdown: tplDropdown(items, 'note-check')
                });
            },
            fontsize: function (lang, options) {
                var items = options.fontSizes.reduce(function (memo, v) {
                    return memo + '<li><a data-event="fontSize" href="#" data-value="' + v + '">' +
                        '<i class="' + options.iconPrefix + options.icons.misc.check + '"></i> ' + v +
                        '</a></li>';
                }, '');

                var label = '<span class="note-current-fontsize">11</span>';
                return tplButton(label, {
                    title: lang.font.size,
                    className: 'note-fontsize',
                    dropdown: tplDropdown(items, 'note-check')
                });
            },
            color: function (lang, options) {
                var colorButtonLabel = '<i class="' +
                    options.iconPrefix + options.icons.color.recent +
                    '" style="color:black;background-color:yellow;"></i>';

                var colorButton = tplButton(colorButtonLabel, {
                    className: 'note-recent-color',
                    title: lang.color.recent,
                    event: 'color',
                    value: '{"backColor":"yellow"}'
                });

                var items = [
                    '<li><div class="btn-group">',
                    '<div class="note-palette-title">' + lang.color.background + '</div>',
                    '<div class="note-color-reset" data-event="backColor"',
                    ' data-value="inherit" title="' + lang.color.transparent + '">' + lang.color.setTransparent + '</div>',
                    '<div class="note-color-palette" data-target-event="backColor"></div>',
                    '</div><div class="btn-group">',
                    '<div class="note-palette-title">' + lang.color.foreground + '</div>',
                    '<div class="note-color-reset" data-event="foreColor" data-value="inherit" title="' + lang.color.reset + '">',
                    lang.color.resetToDefault,
                    '</div>',
                    '<div class="note-color-palette" data-target-event="foreColor"></div>',
                    '</div></li>'
                ];

                var moreButton = tplButton('', {
                    title: lang.color.more,
                    dropdown: tplDropdown(items)
                });

                return colorButton + moreButton;
            },
            bold: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.bold, {
                    event: 'bold',
                    title: lang.font.bold
                });
            },
            italic: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.italic, {
                    event: 'italic',
                    title: lang.font.italic
                });
            },
            underline: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.underline, {
                    event: 'underline',
                    title: lang.font.underline
                });
            },
            strikethrough: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.strikethrough, {
                    event: 'strikethrough',
                    title: lang.font.strikethrough
                });
            },
            superscript: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.superscript, {
                    event: 'superscript',
                    title: lang.font.superscript
                });
            },
            subscript: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.subscript, {
                    event: 'subscript',
                    title: lang.font.subscript
                });
            },
            clear: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.font.clear, {
                    event: 'removeFormat',
                    title: lang.font.clear
                });
            },
            ul: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.lists.unordered, {
                    event: 'insertUnorderedList',
                    title: lang.lists.unordered
                });
            },
            ol: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.lists.ordered, {
                    event: 'insertOrderedList',
                    title: lang.lists.ordered
                });
            },
            paragraph: function (lang, options) {
                var leftButton = tplIconButton(options.iconPrefix + options.icons.paragraph.left, {
                    title: lang.paragraph.left,
                    event: 'justifyLeft'
                });
                var centerButton = tplIconButton(options.iconPrefix + options.icons.paragraph.center, {
                    title: lang.paragraph.center,
                    event: 'justifyCenter'
                });
                var rightButton = tplIconButton(options.iconPrefix + options.icons.paragraph.right, {
                    title: lang.paragraph.right,
                    event: 'justifyRight'
                });
                var justifyButton = tplIconButton(options.iconPrefix + options.icons.paragraph.justify, {
                    title: lang.paragraph.justify,
                    event: 'justifyFull'
                });

                var outdentButton = tplIconButton(options.iconPrefix + options.icons.paragraph.outdent, {
                    title: lang.paragraph.outdent,
                    event: 'outdent'
                });
                var indentButton = tplIconButton(options.iconPrefix + options.icons.paragraph.indent, {
                    title: lang.paragraph.indent,
                    event: 'indent'
                });

                var dropdown = [
                    '<div class="note-align btn-group">',
                    leftButton + centerButton + rightButton + justifyButton,
                    '</div><div class="note-list btn-group">',
                    indentButton + outdentButton,
                    '</div>'
                ];

                return tplIconButton(options.iconPrefix + options.icons.paragraph.paragraph, {
                    title: lang.paragraph.paragraph,
                    dropdown: tplDropdown(dropdown, '', 'div')
                });
            },
            height: function (lang, options) {
                var items = options.lineHeights.reduce(function (memo, v) {
                    return memo + '<li><a data-event="lineHeight" href="#" data-value="' + parseFloat(v) + '">' +
                        '<i class="' + options.iconPrefix + options.icons.misc.check + '"></i> ' + v +
                        '</a></li>';
                }, '');

                return tplIconButton(options.iconPrefix + options.icons.font.height, {
                    title: lang.font.height,
                    dropdown: tplDropdown(items, 'note-check')
                });

            },
            help: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.options.help, {
                    event: 'showHelpDialog',
                    title: lang.options.help,
                    hide: true
                });
            },
            fullscreen: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.options.fullscreen, {
                    event: 'fullscreen',
                    title: lang.options.fullscreen
                });
            },
            codeview: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.options.codeview, {
                    event: 'codeview',
                    title: lang.options.codeview
                });
            },
            undo: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.history.undo, {
                    event: 'undo',
                    title: lang.history.undo
                });
            },
            redo: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.history.redo, {
                    event: 'redo',
                    title: lang.history.redo
                });
            },
            hr: function (lang, options) {
                return tplIconButton(options.iconPrefix + options.icons.hr.insert, {
                    event: 'insertHorizontalRule',
                    title: lang.hr.insert
                });
            }
        };

        var tplPopovers = function (lang, options) {
            var tplLinkPopover = function () {
                var linkButton = tplIconButton(options.iconPrefix + options.icons.link.edit, {
                    title: lang.link.edit,
                    event: 'showLinkDialog',
                    hide: true
                });
                var unlinkButton = tplIconButton(options.iconPrefix + options.icons.link.unlink, {
                    title: lang.link.unlink,
                    event: 'unlink'
                });
                var content = '<a href="http://www.google.com" target="_blank">www.google.com</a>&nbsp;&nbsp;' +
                    '<div class="note-insert btn-group">' +
                    linkButton + unlinkButton +
                    '</div>';
                return tplPopover('note-link-popover', content);
            };

            var tplImagePopover = function () {
                var fullButton = tplButton('<span class="note-fontsize-10">100%</span>', {
                    title: lang.image.resizeFull,
                    event: 'resize',
                    value: '1'
                });
                var halfButton = tplButton('<span class="note-fontsize-10">50%</span>', {
                    title: lang.image.resizeHalf,
                    event: 'resize',
                    value: '0.5'
                });
                var quarterButton = tplButton('<span class="note-fontsize-10">25%</span>', {
                    title: lang.image.resizeQuarter,
                    event: 'resize',
                    value: '0.25'
                });

                var leftButton = tplIconButton(options.iconPrefix + options.icons.image.floatLeft, {
                    title: lang.image.floatLeft,
                    event: 'floatMe',
                    value: 'left'
                });
                var rightButton = tplIconButton(options.iconPrefix + options.icons.image.floatRight, {
                    title: lang.image.floatRight,
                    event: 'floatMe',
                    value: 'right'
                });
                var justifyButton = tplIconButton(options.iconPrefix + options.icons.image.floatNone, {
                    title: lang.image.floatNone,
                    event: 'floatMe',
                    value: 'none'
                });

                var roundedButton = tplIconButton(options.iconPrefix + options.icons.image.shapeRounded, {
                    title: lang.image.shapeRounded,
                    event: 'imageShape',
                    value: 'img-rounded'
                });
                var circleButton = tplIconButton(options.iconPrefix + options.icons.image.shapeCircle, {
                    title: lang.image.shapeCircle,
                    event: 'imageShape',
                    value: 'img-circle'
                });
                var thumbnailButton = tplIconButton(options.iconPrefix + options.icons.image.shapeThumbnail, {
                    title: lang.image.shapeThumbnail,
                    event: 'imageShape',
                    value: 'img-thumbnail'
                });
                var noneButton = tplIconButton(options.iconPrefix + options.icons.image.shapeNone, {
                    title: lang.image.shapeNone,
                    event: 'imageShape',
                    value: ''
                });

                var removeButton = tplIconButton(options.iconPrefix + options.icons.image.remove, {
                    title: lang.image.remove,
                    event: 'removeMedia',
                    value: 'none'
                });

                var content = (options.disableResizeImage ? '' : '<div class="btn-group">' + fullButton + halfButton + quarterButton + '</div>') +
                    '<div class="btn-group">' + leftButton + rightButton + justifyButton + '</div><br>' +
                    '<div class="btn-group">' + roundedButton + circleButton + thumbnailButton + noneButton + '</div>' +
                    '<div class="btn-group">' + removeButton + '</div>';
                return tplPopover('note-image-popover', content);
            };

            var tplAirPopover = function () {
                var $content = $('<div />');
                for (var idx = 0, len = options.airPopover.length; idx < len; idx++) {
                    var group = options.airPopover[idx];

                    var $group = $('<div class="note-' + group[0] + ' btn-group">');
                    for (var i = 0, lenGroup = group[1].length; i < lenGroup; i++) {
                        var $button = $(tplButtonInfo[group[1][i]](lang, options));

                        $button.attr('data-name', group[1][i]);

                        $group.append($button);
                    }
                    $content.append($group);
                }

                return tplPopover('note-air-popover', $content.children());
            };

            var $notePopover = $('<div class="note-popover" />');

            $notePopover.append(tplLinkPopover());
            $notePopover.append(tplImagePopover());

            if (options.airMode) {
                $notePopover.append(tplAirPopover());
            }

            return $notePopover;
        };

        var tplHandles = function (options) {
            return '<div class="note-handle">' +
                '<div class="note-control-selection">' +
                '<div class="note-control-selection-bg"></div>' +
                '<div class="note-control-holder note-control-nw"></div>' +
                '<div class="note-control-holder note-control-ne"></div>' +
                '<div class="note-control-holder note-control-sw"></div>' +
                '<div class="' +
                (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing') +
                ' note-control-se"></div>' +
                (options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>') +
                '</div>' +
                '</div>';
        };

        /**
         * shortcut table template
         * @param {String} title
         * @param {String} body
         */
        var tplShortcut = function (title, keys) {
            var keyClass = 'note-shortcut-col col-xs-6 note-shortcut-';
            var body = [];

            for (var i in keys) {
                if (keys.hasOwnProperty(i)) {
                    body.push(
                        '<div class="' + keyClass + 'key">' + keys[i].kbd + '</div>' +
                        '<div class="' + keyClass + 'name">' + keys[i].text + '</div>'
                    );
                }
            }

            return '<div class="note-shortcut-row row"><div class="' + keyClass + 'title col-xs-offset-6">' + title + '</div></div>' +
                '<div class="note-shortcut-row row">' + body.join('</div><div class="note-shortcut-row row">') + '</div>';
        };

        var tplShortcutText = function (lang) {
            var keys = [
                {kbd: ' + B', text: lang.font.bold},
                {kbd: ' + I', text: lang.font.italic},
                {kbd: ' + U', text: lang.font.underline},
                {kbd: ' + \\', text: lang.font.clear}
            ];

            return tplShortcut(lang.shortcut.textFormatting, keys);
        };

        var tplShortcutAction = function (lang) {
            var keys = [
                {kbd: ' + Z', text: lang.history.undo},
                {kbd: ' +  + Z', text: lang.history.redo},
                {kbd: ' + ]', text: lang.paragraph.indent},
                {kbd: ' + [', text: lang.paragraph.outdent},
                {kbd: ' + ENTER', text: lang.hr.insert}
            ];

            return tplShortcut(lang.shortcut.action, keys);
        };

        var tplShortcutPara = function (lang) {
            var keys = [
                {kbd: ' +  + L', text: lang.paragraph.left},
                {kbd: ' +  + E', text: lang.paragraph.center},
                {kbd: ' +  + R', text: lang.paragraph.right},
                {kbd: ' +  + J', text: lang.paragraph.justify},
                {kbd: ' +  + NUM7', text: lang.lists.ordered},
                {kbd: ' +  + NUM8', text: lang.lists.unordered}
            ];

            return tplShortcut(lang.shortcut.paragraphFormatting, keys);
        };

        var tplShortcutStyle = function (lang) {
            var keys = [
                {kbd: ' + NUM0', text: lang.style.normal},
                {kbd: ' + NUM1', text: lang.style.h1},
                {kbd: ' + NUM2', text: lang.style.h2},
                {kbd: ' + NUM3', text: lang.style.h3},
                {kbd: ' + NUM4', text: lang.style.h4},
                {kbd: ' + NUM5', text: lang.style.h5},
                {kbd: ' + NUM6', text: lang.style.h6}
            ];

            return tplShortcut(lang.shortcut.documentStyle, keys);
        };

        var tplExtraShortcuts = function (lang, options) {
            var extraKeys = options.extraKeys;
            var keys = [];

            for (var key in extraKeys) {
                if (extraKeys.hasOwnProperty(key)) {
                    keys.push({kbd: key, text: extraKeys[key]});
                }
            }

            return tplShortcut(lang.shortcut.extraKeys, keys);
        };

        var tplShortcutTable = function (lang, options) {
            var colClass = 'class="note-shortcut note-shortcut-col col-sm-6 col-xs-12"';
            var template = [
                '<div ' + colClass + '>' + tplShortcutAction(lang, options) + '</div>' +
                '<div ' + colClass + '>' + tplShortcutText(lang, options) + '</div>',
                '<div ' + colClass + '>' + tplShortcutStyle(lang, options) + '</div>' +
                '<div ' + colClass + '>' + tplShortcutPara(lang, options) + '</div>'
            ];

            if (options.extraKeys) {
                template.push('<div ' + colClass + '>' + tplExtraShortcuts(lang, options) + '</div>');
            }

            return '<div class="note-shortcut-row row">' +
                template.join('</div><div class="note-shortcut-row row">') +
                '</div>';
        };

        var replaceMacKeys = function (sHtml) {
            return sHtml.replace(//g, 'Ctrl').replace(//g, 'Shift');
        };

        var tplDialogInfo = {
            image: function (lang, options) {
                var imageLimitation = '';
                if (options.maximumImageFileSize) {
                    var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));
                    var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +
                        ' ' + ' KMGTP'[unit] + 'B';
                    imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';
                }

                var body = '<div class="form-group row note-group-select-from-files">' +
                    '<label>' + lang.image.selectFromFiles + '</label>' +
                    '<input class="note-image-input form-control" type="file" name="files" accept="image/*" multiple="multiple" />' +
                    imageLimitation +
                    '</div>' +
                    '<div class="form-group row">' +
                    '<label>' + lang.image.url + '</label>' +
                    '<input class="note-image-url form-control col-md-12" type="text" />' +
                    '</div>';
                var footer = '<button href="#" class="btn btn-primary note-image-btn disabled" disabled>' + lang.image.insert + '</button>';
                return tplDialog('note-image-dialog', lang.image.insert, body, footer);
            },

            link: function (lang, options) {
                var body = '<div class="form-group row">' +
                    '<label>' + lang.link.textToDisplay + '</label>' +
                    '<input class="note-link-text form-control col-md-12" type="text" />' +
                    '</div>' +
                    '<div class="form-group row">' +
                    '<label>' + lang.link.url + '</label>' +
                    '<input class="note-link-url form-control col-md-12" type="text" value="http://" />' +
                    '</div>' +
                    (!options.disableLinkTarget ?
                            '<div class="checkbox">' +
                            '<label>' + '<input type="checkbox" checked> ' +
                            lang.link.openInNewWindow +
                            '</label>' +
                            '</div>' : ''
                    );
                var footer = '<button href="#" class="btn btn-primary note-link-btn disabled" disabled>' + lang.link.insert + '</button>';
                return tplDialog('note-link-dialog', lang.link.insert, body, footer);
            },

            help: function (lang, options) {
                var body = '<a class="modal-close pull-right" aria-hidden="true" tabindex="-1">' + lang.shortcut.close + '</a>' +
                    '<div class="title">' + lang.shortcut.shortcuts + '</div>' +
                    (agent.isMac ? tplShortcutTable(lang, options) : replaceMacKeys(tplShortcutTable(lang, options))) +
                    '<p class="text-center">' +
                    '<a href="//summernote.org/" target="_blank">Summernote 0.6.16</a>  ' +
                    '<a href="//github.com/summernote/summernote" target="_blank">Project</a>  ' +
                    '<a href="//github.com/summernote/summernote/issues" target="_blank">Issues</a>' +
                    '</p>';
                return tplDialog('note-help-dialog', '', body, '');
            }
        };

        var tplDialogs = function (lang, options) {
            var dialogs = '';

            $.each(tplDialogInfo, function (idx, tplDialog) {
                dialogs += tplDialog(lang, options);
            });

            return '<div class="note-dialog">' + dialogs + '</div>';
        };

        var tplStatusbar = function () {
            return '<div class="note-resizebar">' +
                '<div class="note-icon-bar"></div>' +
                '<div class="note-icon-bar"></div>' +
                '<div class="note-icon-bar"></div>' +
                '</div>';
        };

        var representShortcut = function (str) {
            if (agent.isMac) {
                str = str.replace('CMD', '').replace('SHIFT', '');
            }

            return str.replace('BACKSLASH', '\\')
                .replace('SLASH', '/')
                .replace('LEFTBRACKET', '[')
                .replace('RIGHTBRACKET', ']');
        };

        /**
         * createTooltip
         *
         * @param {jQuery} $container
         * @param {Object} keyMap
         * @param {String} [sPlacement]
         */
        var createTooltip = function ($container, keyMap, sPlacement) {
            var invertedKeyMap = func.invertObject(keyMap);
            var $buttons = $container.find('button');

            $buttons.each(function (i, elBtn) {
                var $btn = $(elBtn);
                var sShortcut = invertedKeyMap[$btn.data('event')];
                if (sShortcut) {
                    $btn.attr('title', function (i, v) {
                        return v + ' (' + representShortcut(sShortcut) + ')';
                    });
                }
                // bootstrap tooltip on btn-group bug
                // https://github.com/twbs/bootstrap/issues/5687
            }).tooltip({
                container: 'body',
                trigger: 'hover',
                placement: sPlacement || 'top'
            }).on('click', function () {
                $(this).tooltip('hide');
            });
        };

        // createPalette
        var createPalette = function ($container, options) {
            var colorInfo = options.colors;
            $container.find('.note-color-palette').each(function () {
                var $palette = $(this), eventName = $palette.attr('data-target-event');
                var paletteContents = [];
                for (var row = 0, lenRow = colorInfo.length; row < lenRow; row++) {
                    var colors = colorInfo[row];
                    var buttons = [];
                    for (var col = 0, lenCol = colors.length; col < lenCol; col++) {
                        var color = colors[col];
                        buttons.push(['<button type="button" class="note-color-btn" style="background-color:', color,
                            ';" data-event="', eventName,
                            '" data-value="', color,
                            '" title="', color,
                            '" data-toggle="button" tabindex="-1"></button>'].join(''));
                    }
                    paletteContents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
                }
                $palette.html(paletteContents.join(''));
            });
        };

        /**
         * create summernote layout (air mode)
         *
         * @param {jQuery} $holder
         * @param {Object} options
         */
        this.createLayoutByAirMode = function ($holder, options) {
            var langInfo = options.langInfo;
            var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
            var id = func.uniqueId();

            $holder.addClass('note-air-editor note-editable panel-body');
            $holder.attr({
                'id': 'note-editor-' + id,
                'contentEditable': true
            });

            var body = document.body;

            // create Popover
            var $popover = $(tplPopovers(langInfo, options));
            $popover.addClass('note-air-layout');
            $popover.attr('id', 'note-popover-' + id);
            $popover.appendTo(body);
            createTooltip($popover, keyMap);
            createPalette($popover, options);

            // create Handle
            var $handle = $(tplHandles(options));
            $handle.addClass('note-air-layout');
            $handle.attr('id', 'note-handle-' + id);
            $handle.appendTo(body);

            // create Dialog
            var $dialog = $(tplDialogs(langInfo, options));
            $dialog.addClass('note-air-layout');
            $dialog.attr('id', 'note-dialog-' + id);
            $dialog.find('button.close, a.modal-close').click(function () {
                $(this).closest('.modal').modal('hide');
            });
            $dialog.appendTo(body);
        };

        /**
         * create summernote layout (normal mode)
         *
         * @param {jQuery} $holder
         * @param {Object} options
         */
        this.createLayoutByFrame = function ($holder, options) {
            var langInfo = options.langInfo;

            //01. create Editor
            var $editor = $('<div class="note-editor panel panel-default" />');
            if (options.width) {
                $editor.width(options.width);
            }

            //02. statusbar (resizebar)
            if (options.height > 0) {
                $('<div class="note-statusbar">' + (options.disableResizeEditor ? '' : tplStatusbar()) + '</div>').prependTo($editor);
            }

            //03 editing area
            var $editingArea = $('<div class="note-editing-area" />');
            //03. create editable
            var isContentEditable = !$holder.is(':disabled');
            var $editable = $('<div class="note-editable panel-body" contentEditable="' + isContentEditable + '"></div>').prependTo($editingArea);

            if (options.height) {
                $editable.height(options.height);
            }
            if (options.direction) {
                $editable.attr('dir', options.direction);
            }
            var placeholder = $holder.attr('placeholder') || options.placeholder;
            if (placeholder) {
                $editable.attr('data-placeholder', placeholder);
            }

            $editable.html(dom.html($holder) || dom.emptyPara);

            //031. create codable
            $('<textarea class="note-codable"></textarea>').prependTo($editingArea);

            //04. create Popover
            var $popover = $(tplPopovers(langInfo, options)).prependTo($editingArea);
            createPalette($popover, options);
            createTooltip($popover, keyMap);

            //05. handle(control selection, ...)
            $(tplHandles(options)).prependTo($editingArea);

            $editingArea.prependTo($editor);

            //06. create Toolbar
            var $toolbar = $('<div class="note-toolbar panel-heading" />');
            for (var idx = 0, len = options.toolbar.length; idx < len; idx++) {
                var groupName = options.toolbar[idx][0];
                var groupButtons = options.toolbar[idx][1];

                var $group = $('<div class="note-' + groupName + ' btn-group" />');
                for (var i = 0, btnLength = groupButtons.length; i < btnLength; i++) {
                    var buttonInfo = tplButtonInfo[groupButtons[i]];
                    // continue creating toolbar even if a button doesn't exist
                    if (!$.isFunction(buttonInfo)) {
                        continue;
                    }

                    var $button = $(buttonInfo(langInfo, options));
                    $button.attr('data-name', groupButtons[i]);  // set button's alias, becuase to get button element from $toolbar
                    $group.append($button);
                }
                $toolbar.append($group);
            }

            var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];
            createPalette($toolbar, options);
            createTooltip($toolbar, keyMap, 'bottom');
            $toolbar.prependTo($editor);

            //07. create Dropzone
            $('<div class="note-dropzone"><div class="note-dropzone-message"></div></div>').prependTo($editor);

            //08. create Dialog
            var $dialogContainer = options.dialogsInBody ? $(document.body) : $editor;
            var $dialog = $(tplDialogs(langInfo, options)).prependTo($dialogContainer);
            $dialog.find('button.close, a.modal-close').click(function () {
                $(this).closest('.modal').modal('hide');
            });

            //09. Editor/Holder switch
            $editor.insertAfter($holder);
            $holder.hide();
        };

        this.hasNoteEditor = function ($holder) {
            return this.noteEditorFromHolder($holder).length > 0;
        };

        this.noteEditorFromHolder = function ($holder) {
            if ($holder.hasClass('note-air-editor')) {
                return $holder;
            } else if ($holder.next().hasClass('note-editor')) {
                return $holder.next();
            } else {
                return $();
            }
        };

        /**
         * create summernote layout
         *
         * @param {jQuery} $holder
         * @param {Object} options
         */
        this.createLayout = function ($holder, options) {
            if (options.airMode) {
                this.createLayoutByAirMode($holder, options);
            } else {
                this.createLayoutByFrame($holder, options);
            }
        };

        /**
         * returns layoutInfo from holder
         *
         * @param {jQuery} $holder - placeholder
         * @return {Object}
         */
        this.layoutInfoFromHolder = function ($holder) {
            var $editor = this.noteEditorFromHolder($holder);
            if (!$editor.length) {
                return;
            }

            // connect $holder to $editor
            $editor.data('holder', $holder);

            return dom.buildLayoutInfo($editor);
        };

        /**
         * removeLayout
         *
         * @param {jQuery} $holder - placeholder
         * @param {Object} layoutInfo
         * @param {Object} options
         *
         */
        this.removeLayout = function ($holder, layoutInfo, options) {
            if (options.airMode) {
                $holder.removeClass('note-air-editor note-editable')
                    .removeAttr('id contentEditable');

                layoutInfo.popover().remove();
                layoutInfo.handle().remove();
                layoutInfo.dialog().remove();
            } else {
                $holder.html(layoutInfo.editable().html());

                if (options.dialogsInBody) {
                    layoutInfo.dialog().remove();
                }
                layoutInfo.editor().remove();
                $holder.show();
            }
        };

        /**
         *
         * @return {Object}
         * @return {function(label, options=):string} return.button {@link #tplButton function to make text button}
         * @return {function(iconClass, options=):string} return.iconButton {@link #tplIconButton function to make icon button}
         * @return {function(className, title=, body=, footer=):string} return.dialog {@link #tplDialog function to make dialog}
         */
        this.getTemplate = function () {
            return {
                button: tplButton,
                iconButton: tplIconButton,
                dialog: tplDialog
            };
        };

        /**
         * add button information
         *
         * @param {String} name button name
         * @param {Function} buttonInfo function to make button, reference to {@link #tplButton},{@link #tplIconButton}
         */
        this.addButtonInfo = function (name, buttonInfo) {
            tplButtonInfo[name] = buttonInfo;
        };

        /**
         *
         * @param {String} name
         * @param {Function} dialogInfo function to make dialog, reference to {@link #tplDialog}
         */
        this.addDialogInfo = function (name, dialogInfo) {
            tplDialogInfo[name] = dialogInfo;
        };
    };


    // jQuery namespace for summernote
    /**
     * @class $.summernote
     *
     * summernote attribute
     *
     * @mixin defaults
     * @singleton
     *
     */
    $.summernote = $.summernote || {};

    // extends default settings
    //  - $.summernote.version
    //  - $.summernote.options
    //  - $.summernote.lang
    $.extend($.summernote, defaults);

    var renderer = new Renderer();
    var eventHandler = new EventHandler();

    $.extend($.summernote, {
        /** @property {Renderer} */
        renderer: renderer,
        /** @property {EventHandler} */
        eventHandler: eventHandler,
        /**
         * @property {Object} core
         * @property {core.agent} core.agent
         * @property {core.dom} core.dom
         * @property {core.range} core.range
         */
        core: {
            agent: agent,
            list: list,
            dom: dom,
            range: range
        },
        /**
         * @property {Object}
         * pluginEvents event list for plugins
         * event has name and callback function.
         *
         * ```
         * $.summernote.addPlugin({
     *     events : {
     *          'hello' : function(layoutInfo, value, $target) {
     *              console.log('event name is hello, value is ' + value );
     *          }
     *     }
     * })
         * ```
         *
         * * event name is data-event property.
         * * layoutInfo is a summernote layout information.
         * * value is data-value property.
         */
        pluginEvents: {},

        plugins: []
    });

    /**
     * @method addPlugin
     *
     * add Plugin in Summernote
     *
     * Summernote can make a own plugin.
     *
     * ### Define plugin
     * ```
     * // get template function
     * var tmpl = $.summernote.renderer.getTemplate();
     *
     * // add a button
     * $.summernote.addPlugin({
   *     buttons : {
   *        // "hello"  is button's namespace.
   *        "hello" : function(lang, options) {
   *            // make icon button by template function
   *            return tmpl.iconButton(options.iconPrefix + 'header', {
   *                // callback function name when button clicked
   *                event : 'hello',
   *                // set data-value property
   *                value : 'hello',
   *                hide : true
   *            });
   *        }
   *
   *     },
   *
   *     events : {
   *        "hello" : function(layoutInfo, value) {
   *            // here is event code
   *        }
   *     }
   * });
     * ```
     * ### Use a plugin in toolbar
     *
     * ```
     *    $("#editor").summernote({
   *    ...
   *    toolbar : [
   *        // display hello plugin in toolbar
   *        ['group', [ 'hello' ]]
   *    ]
   *    ...
   *    });
     * ```
     *
     *
     * @param {Object} plugin
     * @param {Object} [plugin.buttons] define plugin button. for detail, see to Renderer.addButtonInfo
     * @param {Object} [plugin.dialogs] define plugin dialog. for detail, see to Renderer.addDialogInfo
     * @param {Object} [plugin.events] add event in $.summernote.pluginEvents
     * @param {Object} [plugin.langs] update $.summernote.lang
     * @param {Object} [plugin.options] update $.summernote.options
     */
    $.summernote.addPlugin = function (plugin) {

        // save plugin list
        $.summernote.plugins.push(plugin);

        if (plugin.buttons) {
            $.each(plugin.buttons, function (name, button) {
                renderer.addButtonInfo(name, button);
            });
        }

        if (plugin.dialogs) {
            $.each(plugin.dialogs, function (name, dialog) {
                renderer.addDialogInfo(name, dialog);
            });
        }

        if (plugin.events) {
            $.each(plugin.events, function (name, event) {
                $.summernote.pluginEvents[name] = event;
            });
        }

        if (plugin.langs) {
            $.each(plugin.langs, function (locale, lang) {
                if ($.summernote.lang[locale]) {
                    $.extend($.summernote.lang[locale], lang);
                }
            });
        }

        if (plugin.options) {
            $.extend($.summernote.options, plugin.options);
        }
    };

    /*
   * extend $.fn
   */
    $.fn.extend({
        /**
         * @method
         * Initialize summernote
         *  - create editor layout and attach Mouse and keyboard events.
         *
         * ```
         * $("#summernote").summernote( { options ..} );
         * ```
         *
         * @member $.fn
         * @param {Object|String} options reference to $.summernote.options
         * @return {this}
         */
        summernote: function () {
            // check first argument's type
            //  - {String}: External API call {{module}}.{{method}}
            //  - {Object}: init options
            var type = $.type(list.head(arguments));
            var isExternalAPICalled = type === 'string';
            var hasInitOptions = type === 'object';

            // extend default options with custom user options
            var options = hasInitOptions ? list.head(arguments) : {};

            options = $.extend({}, $.summernote.options, options);
            options.icons = $.extend({}, $.summernote.options.icons, options.icons);

            // Include langInfo in options for later use, e.g. for image drag-n-drop
            // Setup language info with en-US as default
            options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);

            // override plugin options
            if (!isExternalAPICalled && hasInitOptions) {
                for (var i = 0, len = $.summernote.plugins.length; i < len; i++) {
                    var plugin = $.summernote.plugins[i];

                    if (options.plugin[plugin.name]) {
                        $.summernote.plugins[i] = $.extend(true, plugin, options.plugin[plugin.name]);
                    }
                }
            }

            this.each(function (idx, holder) {
                var $holder = $(holder);

                // if layout isn't created yet, createLayout and attach events
                if (!renderer.hasNoteEditor($holder)) {
                    renderer.createLayout($holder, options);

                    var layoutInfo = renderer.layoutInfoFromHolder($holder);
                    $holder.data('layoutInfo', layoutInfo);

                    eventHandler.attach(layoutInfo, options);
                    eventHandler.attachCustomEvent(layoutInfo, options);
                }
            });

            var $first = this.first();
            if ($first.length) {
                var layoutInfo = renderer.layoutInfoFromHolder($first);

                // external API
                if (isExternalAPICalled) {
                    var moduleAndMethod = list.head(list.from(arguments));
                    var args = list.tail(list.from(arguments));

                    // TODO now external API only works for editor
                    var params = [moduleAndMethod, layoutInfo.editable()].concat(args);
                    return eventHandler.invoke.apply(eventHandler, params);
                } else if (options.focus) {
                    // focus on first editable element for initialize editor
                    layoutInfo.editable().focus();
                }
            }

            return this;
        },

        /**
         * @method
         *
         * get the HTML contents of note or set the HTML contents of note.
         *
         * * get contents
         * ```
         * var content = $("#summernote").code();
         * ```
         * * set contents
         *
         * ```
         * $("#summernote").code(html);
         * ```
         *
         * @member $.fn
         * @param {String} [html] - HTML contents(optional, set)
         * @return {this|String} - context(set) or HTML contents of note(get).
         */
        code: function (html) {
            // get the HTML contents of note
            if (html === undefined) {
                var $holder = this.first();
                if (!$holder.length) {
                    return;
                }

                var layoutInfo = renderer.layoutInfoFromHolder($holder);
                var $editable = layoutInfo && layoutInfo.editable();

                if ($editable && $editable.length) {
                    var isCodeview = eventHandler.invoke('codeview.isActivated', layoutInfo);
                    eventHandler.invoke('codeview.sync', layoutInfo);
                    return isCodeview ? layoutInfo.codable().val() :
                        layoutInfo.editable().html();
                }
                return dom.value($holder);
            }

            // set the HTML contents of note
            this.each(function (i, holder) {
                var layoutInfo = renderer.layoutInfoFromHolder($(holder));
                var $editable = layoutInfo && layoutInfo.editable();
                if ($editable) {
                    $editable.html(html);
                }
            });

            return this;
        },

        /**
         * @method
         *
         * destroy Editor Layout and detach Key and Mouse Event
         *
         * @member $.fn
         * @return {this}
         */
        destroy: function () {
            this.each(function (idx, holder) {
                var $holder = $(holder);

                if (!renderer.hasNoteEditor($holder)) {
                    return;
                }

                var info = renderer.layoutInfoFromHolder($holder);
                var options = info.editor().data('options');

                eventHandler.detach(info, options);
                renderer.removeLayout($holder, info, options);
            });

            return this;
        }
    });
}));

/* @license
morris.js v0.5.0
Copyright 2014 Olly Smith All rights reserved.
Licensed under the BSD-2-Clause License.
*/


(function () {
    var $, Morris, minutesSpecHelper, secondsSpecHelper,
        __slice = [].slice,
        __bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        },
        __hasProp = {}.hasOwnProperty,
        __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
                this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        },
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    Morris = window.Morris = {};

    $ = jQuery;

    Morris.EventEmitter = (function () {
        function EventEmitter() {
        }

        EventEmitter.prototype.on = function (name, handler) {
            if (this.handlers == null) {
                this.handlers = {};
            }
            if (this.handlers[name] == null) {
                this.handlers[name] = [];
            }
            this.handlers[name].push(handler);
            return this;
        };

        EventEmitter.prototype.fire = function () {
            var args, handler, name, _i, _len, _ref, _results;
            name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if ((this.handlers != null) && (this.handlers[name] != null)) {
                _ref = this.handlers[name];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    handler = _ref[_i];
                    _results.push(handler.apply(null, args));
                }
                return _results;
            }
        };

        return EventEmitter;

    })();

    Morris.commas = function (num) {
        var absnum, intnum, ret, strabsnum;
        if (num != null) {
            ret = num < 0 ? "-" : "";
            absnum = Math.abs(num);
            intnum = Math.floor(absnum).toFixed(0);
            ret += intnum.replace(/(?=(?:\d{3})+$)(?!^)/g, ',');
            strabsnum = absnum.toString();
            if (strabsnum.length > intnum.length) {
                ret += strabsnum.slice(intnum.length);
            }
            return ret;
        } else {
            return '-';
        }
    };

    Morris.pad2 = function (number) {
        return (number < 10 ? '0' : '') + number;
    };

    Morris.Grid = (function (_super) {
        __extends(Grid, _super);

        function Grid(options) {
            this.resizeHandler = __bind(this.resizeHandler, this);
            var _this = this;
            if (typeof options.element === 'string') {
                this.el = $(document.getElementById(options.element));
            } else {
                this.el = $(options.element);
            }
            if ((this.el == null) || this.el.length === 0) {
                throw new Error("Graph container element not found");
            }
            if (this.el.css('position') === 'static') {
                this.el.css('position', 'relative');
            }
            this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);
            if (typeof this.options.units === 'string') {
                this.options.postUnits = options.units;
            }
            this.raphael = new Raphael(this.el[0]);
            this.elementWidth = null;
            this.elementHeight = null;
            this.dirty = false;
            this.selectFrom = null;
            if (this.init) {
                this.init();
            }
            this.setData(this.options.data);
            this.el.bind('mousemove', function (evt) {
                var left, offset, right, width, x;
                offset = _this.el.offset();
                x = evt.pageX - offset.left;
                if (_this.selectFrom) {
                    left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;
                    right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;
                    width = right - left;
                    return _this.selectionRect.attr({
                        x: left,
                        width: width
                    });
                } else {
                    return _this.fire('hovermove', x, evt.pageY - offset.top);
                }
            });
            this.el.bind('mouseleave', function (evt) {
                if (_this.selectFrom) {
                    _this.selectionRect.hide();
                    _this.selectFrom = null;
                }
                return _this.fire('hoverout');
            });
            this.el.bind('touchstart touchmove touchend', function (evt) {
                var offset, touch;
                touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
                offset = _this.el.offset();
                return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);
            });
            this.el.bind('click', function (evt) {
                var offset;
                offset = _this.el.offset();
                return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);
            });
            if (this.options.rangeSelect) {
                this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
                    fill: this.options.rangeSelectColor,
                    stroke: false
                }).toBack().hide();
                this.el.bind('mousedown', function (evt) {
                    var offset;
                    offset = _this.el.offset();
                    return _this.startRange(evt.pageX - offset.left);
                });
                this.el.bind('mouseup', function (evt) {
                    var offset;
                    offset = _this.el.offset();
                    _this.endRange(evt.pageX - offset.left);
                    return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);
                });
            }
            if (this.options.resize) {
                $(window).bind('resize', function (evt) {
                    if (_this.timeoutId != null) {
                        window.clearTimeout(_this.timeoutId);
                    }
                    return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
                });
            }
            this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
            if (this.postInit) {
                this.postInit();
            }
        }

        Grid.prototype.gridDefaults = {
            dateFormat: null,
            axes: true,
            grid: true,
            gridLineColor: '#aaa',
            gridStrokeWidth: 0.5,
            gridTextColor: '#888',
            gridTextSize: 12,
            gridTextFamily: 'sans-serif',
            gridTextWeight: 'normal',
            hideHover: false,
            yLabelFormat: null,
            xLabelAngle: 0,
            numLines: 5,
            padding: 25,
            parseTime: true,
            postUnits: '',
            preUnits: '',
            ymax: 'auto',
            ymin: 'auto 0',
            goals: [],
            goalStrokeWidth: 1.0,
            goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],
            events: [],
            eventStrokeWidth: 1.0,
            eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],
            rangeSelect: null,
            rangeSelectColor: '#eef',
            resize: false
        };

        Grid.prototype.setData = function (data, redraw) {
            var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;
            if (redraw == null) {
                redraw = true;
            }
            this.options.data = data;
            if ((data == null) || data.length === 0) {
                this.data = [];
                this.raphael.clear();
                if (this.hover != null) {
                    this.hover.hide();
                }
                return;
            }
            ymax = this.cumulative ? 0 : null;
            ymin = this.cumulative ? 0 : null;
            if (this.options.goals.length > 0) {
                minGoal = Math.min.apply(Math, this.options.goals);
                maxGoal = Math.max.apply(Math, this.options.goals);
                ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;
                ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;
            }
            this.data = (function () {
                var _i, _len, _results;
                _results = [];
                for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
                    row = data[index];
                    ret = {
                        src: row
                    };
                    ret.label = row[this.options.xkey];
                    if (this.options.parseTime) {
                        ret.x = Morris.parseDate(ret.label);
                        if (this.options.dateFormat) {
                            ret.label = this.options.dateFormat(ret.x);
                        } else if (typeof ret.label === 'number') {
                            ret.label = new Date(ret.label).toString();
                        }
                    } else {
                        ret.x = index;
                        if (this.options.xLabelFormat) {
                            ret.label = this.options.xLabelFormat(ret);
                        }
                    }
                    total = 0;
                    ret.y = (function () {
                        var _j, _len1, _ref, _results1;
                        _ref = this.options.ykeys;
                        _results1 = [];
                        for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {
                            ykey = _ref[idx];
                            yval = row[ykey];
                            if (typeof yval === 'string') {
                                yval = parseFloat(yval);
                            }
                            if ((yval != null) && typeof yval !== 'number') {
                                yval = null;
                            }
                            if (yval != null) {
                                if (this.cumulative) {
                                    total += yval;
                                } else {
                                    if (ymax != null) {
                                        ymax = Math.max(yval, ymax);
                                        ymin = Math.min(yval, ymin);
                                    } else {
                                        ymax = ymin = yval;
                                    }
                                }
                            }
                            if (this.cumulative && (total != null)) {
                                ymax = Math.max(total, ymax);
                                ymin = Math.min(total, ymin);
                            }
                            _results1.push(yval);
                        }
                        return _results1;
                    }).call(this);
                    _results.push(ret);
                }
                return _results;
            }).call(this);
            if (this.options.parseTime) {
                this.data = this.data.sort(function (a, b) {
                    return (a.x > b.x) - (b.x > a.x);
                });
            }
            this.xmin = this.data[0].x;
            this.xmax = this.data[this.data.length - 1].x;
            this.events = [];
            if (this.options.events.length > 0) {
                if (this.options.parseTime) {
                    this.events = (function () {
                        var _i, _len, _ref, _results;
                        _ref = this.options.events;
                        _results = [];
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            e = _ref[_i];
                            _results.push(Morris.parseDate(e));
                        }
                        return _results;
                    }).call(this);
                } else {
                    this.events = this.options.events;
                }
                this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));
                this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));
            }
            if (this.xmin === this.xmax) {
                this.xmin -= 1;
                this.xmax += 1;
            }
            this.ymin = this.yboundary('min', ymin);
            this.ymax = this.yboundary('max', ymax);
            if (this.ymin === this.ymax) {
                if (ymin) {
                    this.ymin -= 1;
                }
                this.ymax += 1;
            }
            if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {
                if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {
                    this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);
                    this.ymin = Math.min(this.ymin, this.grid[0]);
                    this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);
                } else {
                    step = (this.ymax - this.ymin) / (this.options.numLines - 1);
                    this.grid = (function () {
                        var _i, _ref1, _ref2, _results;
                        _results = [];
                        for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {
                            _results.push(y);
                        }
                        return _results;
                    }).call(this);
                }
            }
            this.dirty = true;
            if (redraw) {
                return this.redraw();
            }
        };

        Grid.prototype.yboundary = function (boundaryType, currentValue) {
            var boundaryOption, suggestedValue;
            boundaryOption = this.options["y" + boundaryType];
            if (typeof boundaryOption === 'string') {
                if (boundaryOption.slice(0, 4) === 'auto') {
                    if (boundaryOption.length > 5) {
                        suggestedValue = parseInt(boundaryOption.slice(5), 10);
                        if (currentValue == null) {
                            return suggestedValue;
                        }
                        return Math[boundaryType](currentValue, suggestedValue);
                    } else {
                        if (currentValue != null) {
                            return currentValue;
                        } else {
                            return 0;
                        }
                    }
                } else {
                    return parseInt(boundaryOption, 10);
                }
            } else {
                return boundaryOption;
            }
        };

        Grid.prototype.autoGridLines = function (ymin, ymax, nlines) {
            var gmax, gmin, grid, smag, span, step, unit, y, ymag;
            span = ymax - ymin;
            ymag = Math.floor(Math.log(span) / Math.log(10));
            unit = Math.pow(10, ymag);
            gmin = Math.floor(ymin / unit) * unit;
            gmax = Math.ceil(ymax / unit) * unit;
            step = (gmax - gmin) / (nlines - 1);
            if (unit === 1 && step > 1 && Math.ceil(step) !== step) {
                step = Math.ceil(step);
                gmax = gmin + step * (nlines - 1);
            }
            if (gmin < 0 && gmax > 0) {
                gmin = Math.floor(ymin / step) * step;
                gmax = Math.ceil(ymax / step) * step;
            }
            if (step < 1) {
                smag = Math.floor(Math.log(step) / Math.log(10));
                grid = (function () {
                    var _i, _results;
                    _results = [];
                    for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
                        _results.push(parseFloat(y.toFixed(1 - smag)));
                    }
                    return _results;
                })();
            } else {
                grid = (function () {
                    var _i, _results;
                    _results = [];
                    for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
                        _results.push(y);
                    }
                    return _results;
                })();
            }
            return grid;
        };

        Grid.prototype._calc = function () {
            var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;
            w = this.el.width();
            h = this.el.height();
            if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {
                this.elementWidth = w;
                this.elementHeight = h;
                this.dirty = false;
                this.left = this.options.padding;
                this.right = this.elementWidth - this.options.padding;
                this.top = this.options.padding;
                this.bottom = this.elementHeight - this.options.padding;
                if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {
                    yLabelWidths = (function () {
                        var _i, _len, _ref1, _results;
                        _ref1 = this.grid;
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            gridLine = _ref1[_i];
                            _results.push(this.measureText(this.yAxisFormat(gridLine)).width);
                        }
                        return _results;
                    }).call(this);
                    this.left += Math.max.apply(Math, yLabelWidths);
                }
                if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {
                    bottomOffsets = (function () {
                        var _i, _ref2, _results;
                        _results = [];
                        for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                            _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);
                        }
                        return _results;
                    }).call(this);
                    this.bottom -= Math.max.apply(Math, bottomOffsets);
                }
                this.width = Math.max(1, this.right - this.left);
                this.height = Math.max(1, this.bottom - this.top);
                this.dx = this.width / (this.xmax - this.xmin);
                this.dy = this.height / (this.ymax - this.ymin);
                if (this.calc) {
                    return this.calc();
                }
            }
        };

        Grid.prototype.transY = function (y) {
            return this.bottom - (y - this.ymin) * this.dy;
        };

        Grid.prototype.transX = function (x) {
            if (this.data.length === 1) {
                return (this.left + this.right) / 2;
            } else {
                return this.left + (x - this.xmin) * this.dx;
            }
        };

        Grid.prototype.redraw = function () {
            this.raphael.clear();
            this._calc();
            this.drawGrid();
            this.drawGoals();
            this.drawEvents();
            if (this.draw) {
                return this.draw();
            }
        };

        Grid.prototype.measureText = function (text, angle) {
            var ret, tt;
            if (angle == null) {
                angle = 0;
            }
            tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);
            ret = tt.getBBox();
            tt.remove();
            return ret;
        };

        Grid.prototype.yAxisFormat = function (label) {
            return this.yLabelFormat(label);
        };

        Grid.prototype.yLabelFormat = function (label) {
            if (typeof this.options.yLabelFormat === 'function') {
                return this.options.yLabelFormat(label);
            } else {
                return "" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;
            }
        };

        Grid.prototype.drawGrid = function () {
            var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;
            if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {
                return;
            }
            _ref1 = this.grid;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                lineY = _ref1[_i];
                y = this.transY(lineY);
                if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {
                    this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));
                }
                if (this.options.grid) {
                    _results.push(this.drawGridLine("M" + this.left + "," + y + "H" + (this.left + this.width)));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };

        Grid.prototype.drawGoals = function () {
            var color, goal, i, _i, _len, _ref, _results;
            _ref = this.options.goals;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                goal = _ref[i];
                color = this.options.goalLineColors[i % this.options.goalLineColors.length];
                _results.push(this.drawGoal(goal, color));
            }
            return _results;
        };

        Grid.prototype.drawEvents = function () {
            var color, event, i, _i, _len, _ref, _results;
            _ref = this.events;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                event = _ref[i];
                color = this.options.eventLineColors[i % this.options.eventLineColors.length];
                _results.push(this.drawEvent(event, color));
            }
            return _results;
        };

        Grid.prototype.drawGoal = function (goal, color) {
            return this.raphael.path("M" + this.left + "," + (this.transY(goal)) + "H" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);
        };

        Grid.prototype.drawEvent = function (event, color) {
            return this.raphael.path("M" + (this.transX(event)) + "," + this.bottom + "V" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);
        };

        Grid.prototype.drawYAxisLabel = function (xPos, yPos, text) {
            return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');
        };

        Grid.prototype.drawGridLine = function (path) {
            return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);
        };

        Grid.prototype.startRange = function (x) {
            this.hover.hide();
            this.selectFrom = x;
            return this.selectionRect.attr({
                x: x,
                width: 0
            }).show();
        };

        Grid.prototype.endRange = function (x) {
            var end, start;
            if (this.selectFrom) {
                start = Math.min(this.selectFrom, x);
                end = Math.max(this.selectFrom, x);
                this.options.rangeSelect.call(this.el, {
                    start: this.data[this.hitTest(start)].x,
                    end: this.data[this.hitTest(end)].x
                });
                return this.selectFrom = null;
            }
        };

        Grid.prototype.resizeHandler = function () {
            this.timeoutId = null;
            this.raphael.setSize(this.el.width(), this.el.height());
            return this.redraw();
        };

        return Grid;

    })(Morris.EventEmitter);

    Morris.parseDate = function (date) {
        var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;
        if (typeof date === 'number') {
            return date;
        }
        m = date.match(/^(\d+) Q(\d)$/);
        n = date.match(/^(\d+)-(\d+)$/);
        o = date.match(/^(\d+)-(\d+)-(\d+)$/);
        p = date.match(/^(\d+) W(\d+)$/);
        q = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/);
        r = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/);
        if (m) {
            return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();
        } else if (n) {
            return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();
        } else if (o) {
            return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();
        } else if (p) {
            ret = new Date(parseInt(p[1], 10), 0, 1);
            if (ret.getDay() !== 4) {
                ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);
            }
            return ret.getTime() + parseInt(p[2], 10) * 604800000;
        } else if (q) {
            if (!q[6]) {
                return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();
            } else {
                offsetmins = 0;
                if (q[6] !== 'Z') {
                    offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);
                    if (q[7] === '+') {
                        offsetmins = 0 - offsetmins;
                    }
                }
                return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);
            }
        } else if (r) {
            secs = parseFloat(r[6]);
            isecs = Math.floor(secs);
            msecs = Math.round((secs - isecs) * 1000);
            if (!r[8]) {
                return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();
            } else {
                offsetmins = 0;
                if (r[8] !== 'Z') {
                    offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);
                    if (r[9] === '+') {
                        offsetmins = 0 - offsetmins;
                    }
                }
                return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);
            }
        } else {
            return new Date(parseInt(date, 10), 0, 1).getTime();
        }
    };

    Morris.Hover = (function () {
        Hover.defaults = {
            "class": 'morris-hover morris-default-style'
        };

        function Hover(options) {
            if (options == null) {
                options = {};
            }
            this.options = $.extend({}, Morris.Hover.defaults, options);
            this.el = $("<div class='" + this.options["class"] + "'></div>");
            this.el.hide();
            this.options.parent.append(this.el);
        }

        Hover.prototype.update = function (html, x, y) {
            if (!html) {
                return this.hide();
            } else {
                this.html(html);
                this.show();
                return this.moveTo(x, y);
            }
        };

        Hover.prototype.html = function (content) {
            return this.el.html(content);
        };

        Hover.prototype.moveTo = function (x, y) {
            var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;
            parentWidth = this.options.parent.innerWidth();
            parentHeight = this.options.parent.innerHeight();
            hoverWidth = this.el.outerWidth();
            hoverHeight = this.el.outerHeight();
            left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);
            if (y != null) {
                top = y - hoverHeight - 10;
                if (top < 0) {
                    top = y + 10;
                    if (top + hoverHeight > parentHeight) {
                        top = parentHeight / 2 - hoverHeight / 2;
                    }
                }
            } else {
                top = parentHeight / 2 - hoverHeight / 2;
            }
            return this.el.css({
                left: left + "px",
                top: parseInt(top) + "px"
            });
        };

        Hover.prototype.show = function () {
            return this.el.show();
        };

        Hover.prototype.hide = function () {
            return this.el.hide();
        };

        return Hover;

    })();

    Morris.Line = (function (_super) {
        __extends(Line, _super);

        function Line(options) {
            this.hilight = __bind(this.hilight, this);
            this.onHoverOut = __bind(this.onHoverOut, this);
            this.onHoverMove = __bind(this.onHoverMove, this);
            this.onGridClick = __bind(this.onGridClick, this);
            if (!(this instanceof Morris.Line)) {
                return new Morris.Line(options);
            }
            Line.__super__.constructor.call(this, options);
        }

        Line.prototype.init = function () {
            if (this.options.hideHover !== 'always') {
                this.hover = new Morris.Hover({
                    parent: this.el
                });
                this.on('hovermove', this.onHoverMove);
                this.on('hoverout', this.onHoverOut);
                return this.on('gridclick', this.onGridClick);
            }
        };

        Line.prototype.defaults = {
            lineWidth: 3,
            pointSize: 4,
            lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
            pointStrokeWidths: [1],
            pointStrokeColors: ['#ffffff'],
            pointFillColors: [],
            smooth: true,
            xLabels: 'auto',
            xLabelFormat: null,
            xLabelMargin: 24,
            hideHover: false
        };

        Line.prototype.calc = function () {
            this.calcPoints();
            return this.generatePaths();
        };

        Line.prototype.calcPoints = function () {
            var row, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                row._x = this.transX(row.x);
                row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(this.transY(y));
                        } else {
                            _results1.push(y);
                        }
                    }
                    return _results1;
                }).call(this);
                _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row._y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(y);
                        }
                    }
                    return _results1;
                })())));
            }
            return _results;
        };

        Line.prototype.hitTest = function (x) {
            var index, r, _i, _len, _ref;
            if (this.data.length === 0) {
                return null;
            }
            _ref = this.data.slice(1);
            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
                r = _ref[index];
                if (x < (r._x + this.data[index]._x) / 2) {
                    break;
                }
            }
            return index;
        };

        Line.prototype.onGridClick = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.fire('click', index, this.data[index].src, x, y);
        };

        Line.prototype.onHoverMove = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.displayHoverForRow(index);
        };

        Line.prototype.onHoverOut = function () {
            if (this.options.hideHover !== false) {
                return this.displayHoverForRow(null);
            }
        };

        Line.prototype.displayHoverForRow = function (index) {
            var _ref;
            if (index != null) {
                (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
                return this.hilight(index);
            } else {
                this.hover.hide();
                return this.hilight();
            }
        };

        Line.prototype.hoverContentForRow = function (index) {
            var content, j, row, y, _i, _len, _ref;
            row = this.data[index];
            content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
            _ref = row.y;
            for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
                y = _ref[j];
                content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
            }
            if (typeof this.options.hoverCallback === 'function') {
                content = this.options.hoverCallback(index, this.options, content, row.src);
            }
            return [content, row._x, row._ymax];
        };

        Line.prototype.generatePaths = function () {
            var coords, i, r, smooth;
            return this.paths = (function () {
                var _i, _ref, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    smooth = typeof this.options.smooth === "boolean" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);
                    coords = (function () {
                        var _j, _len, _ref2, _results1;
                        _ref2 = this.data;
                        _results1 = [];
                        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                            r = _ref2[_j];
                            if (r._y[i] !== void 0) {
                                _results1.push({
                                    x: r._x,
                                    y: r._y[i]
                                });
                            }
                        }
                        return _results1;
                    }).call(this);
                    if (coords.length > 1) {
                        _results.push(Morris.Line.createPath(coords, smooth, this.bottom));
                    } else {
                        _results.push(null);
                    }
                }
                return _results;
            }).call(this);
        };

        Line.prototype.draw = function () {
            var _ref;
            if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
                this.drawXAxis();
            }
            this.drawSeries();
            if (this.options.hideHover === false) {
                return this.displayHoverForRow(this.data.length - 1);
            }
        };

        Line.prototype.drawXAxis = function () {
            var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,
                _this = this;
            ypos = this.bottom + this.options.padding / 2;
            prevLabelMargin = null;
            prevAngleMargin = null;
            drawLabel = function (labelText, xpos) {
                var label, labelBox, margin, offset, textBox;
                label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);
                textBox = label.getBBox();
                label.transform("r" + (-_this.options.xLabelAngle));
                labelBox = label.getBBox();
                label.transform("t0," + (labelBox.height / 2) + "...");
                if (_this.options.xLabelAngle !== 0) {
                    offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);
                    label.transform("t" + offset + ",0...");
                }
                labelBox = label.getBBox();
                if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {
                    if (_this.options.xLabelAngle !== 0) {
                        margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);
                        prevAngleMargin = labelBox.x - margin;
                    }
                    return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;
                } else {
                    return label.remove();
                }
            };
            if (this.options.parseTime) {
                if (this.data.length === 1 && this.options.xLabels === 'auto') {
                    labels = [[this.data[0].label, this.data[0].x]];
                } else {
                    labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);
                }
            } else {
                labels = (function () {
                    var _i, _len, _ref, _results;
                    _ref = this.data;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        row = _ref[_i];
                        _results.push([row.label, row.x]);
                    }
                    return _results;
                }).call(this);
            }
            labels.reverse();
            _results = [];
            for (_i = 0, _len = labels.length; _i < _len; _i++) {
                l = labels[_i];
                _results.push(drawLabel(l[0], l[1]));
            }
            return _results;
        };

        Line.prototype.drawSeries = function () {
            var i, _i, _j, _ref, _ref1, _results;
            this.seriesPoints = [];
            for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
                this._drawLineFor(i);
            }
            _results = [];
            for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {
                _results.push(this._drawPointFor(i));
            }
            return _results;
        };

        Line.prototype._drawPointFor = function (index) {
            var circle, row, _i, _len, _ref, _results;
            this.seriesPoints[index] = [];
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                circle = null;
                if (row._y[index] != null) {
                    circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);
                }
                _results.push(this.seriesPoints[index].push(circle));
            }
            return _results;
        };

        Line.prototype._drawLineFor = function (index) {
            var path;
            path = this.paths[index];
            if (path !== null) {
                return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);
            }
        };

        Line.createPath = function (coords, smooth, bottom) {
            var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;
            path = "";
            if (smooth) {
                grads = Morris.Line.gradients(coords);
            }
            prevCoord = {
                y: null
            };
            for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
                coord = coords[i];
                if (coord.y != null) {
                    if (prevCoord.y != null) {
                        if (smooth) {
                            g = grads[i];
                            lg = grads[i - 1];
                            ix = (coord.x - prevCoord.x) / 4;
                            x1 = prevCoord.x + ix;
                            y1 = Math.min(bottom, prevCoord.y + ix * lg);
                            x2 = coord.x - ix;
                            y2 = Math.min(bottom, coord.y - ix * g);
                            path += "C" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + coord.x + "," + coord.y;
                        } else {
                            path += "L" + coord.x + "," + coord.y;
                        }
                    } else {
                        if (!smooth || (grads[i] != null)) {
                            path += "M" + coord.x + "," + coord.y;
                        }
                    }
                }
                prevCoord = coord;
            }
            return path;
        };

        Line.gradients = function (coords) {
            var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;
            grad = function (a, b) {
                return (a.y - b.y) / (a.x - b.x);
            };
            _results = [];
            for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
                coord = coords[i];
                if (coord.y != null) {
                    nextCoord = coords[i + 1] || {
                        y: null
                    };
                    prevCoord = coords[i - 1] || {
                        y: null
                    };
                    if ((prevCoord.y != null) && (nextCoord.y != null)) {
                        _results.push(grad(prevCoord, nextCoord));
                    } else if (prevCoord.y != null) {
                        _results.push(grad(prevCoord, coord));
                    } else if (nextCoord.y != null) {
                        _results.push(grad(coord, nextCoord));
                    } else {
                        _results.push(null);
                    }
                } else {
                    _results.push(null);
                }
            }
            return _results;
        };

        Line.prototype.hilight = function (index) {
            var i, _i, _j, _ref, _ref1;
            if (this.prevHilight !== null && this.prevHilight !== index) {
                for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                    if (this.seriesPoints[i][this.prevHilight]) {
                        this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
                    }
                }
            }
            if (index !== null && this.prevHilight !== index) {
                for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                    if (this.seriesPoints[i][index]) {
                        this.seriesPoints[i][index].animate(this.pointGrowSeries(i));
                    }
                }
            }
            return this.prevHilight = index;
        };

        Line.prototype.colorFor = function (row, sidx, type) {
            if (typeof this.options.lineColors === 'function') {
                return this.options.lineColors.call(this, row, sidx, type);
            } else if (type === 'point') {
                return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];
            } else {
                return this.options.lineColors[sidx % this.options.lineColors.length];
            }
        };

        Line.prototype.drawXAxisLabel = function (xPos, yPos, text) {
            return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
        };

        Line.prototype.drawLinePath = function (path, lineColor, lineIndex) {
            return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));
        };

        Line.prototype.drawLinePoint = function (xPos, yPos, pointColor, lineIndex) {
            return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));
        };

        Line.prototype.pointStrokeWidthForSeries = function (index) {
            return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];
        };

        Line.prototype.pointStrokeColorForSeries = function (index) {
            return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];
        };

        Line.prototype.lineWidthForSeries = function (index) {
            if (this.options.lineWidth instanceof Array) {
                return this.options.lineWidth[index % this.options.lineWidth.length];
            } else {
                return this.options.lineWidth;
            }
        };

        Line.prototype.pointSizeForSeries = function (index) {
            if (this.options.pointSize instanceof Array) {
                return this.options.pointSize[index % this.options.pointSize.length];
            } else {
                return this.options.pointSize;
            }
        };

        Line.prototype.pointGrowSeries = function (index) {
            return Raphael.animation({
                r: this.pointSizeForSeries(index) + 3
            }, 25, 'linear');
        };

        Line.prototype.pointShrinkSeries = function (index) {
            return Raphael.animation({
                r: this.pointSizeForSeries(index)
            }, 25, 'linear');
        };

        return Line;

    })(Morris.Grid);

    Morris.labelSeries = function (dmin, dmax, pxwidth, specName, xLabelFormat) {
        var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;
        ddensity = 200 * (dmax - dmin) / pxwidth;
        d0 = new Date(dmin);
        spec = Morris.LABEL_SPECS[specName];
        if (spec === void 0) {
            _ref = Morris.AUTO_LABEL_ORDER;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                name = _ref[_i];
                s = Morris.LABEL_SPECS[name];
                if (ddensity >= s.span) {
                    spec = s;
                    break;
                }
            }
        }
        if (spec === void 0) {
            spec = Morris.LABEL_SPECS["second"];
        }
        if (xLabelFormat) {
            spec = $.extend({}, spec, {
                fmt: xLabelFormat
            });
        }
        d = spec.start(d0);
        ret = [];
        while ((t = d.getTime()) <= dmax) {
            if (t >= dmin) {
                ret.push([spec.fmt(d), t]);
            }
            spec.incr(d);
        }
        return ret;
    };

    minutesSpecHelper = function (interval) {
        return {
            span: interval * 60 * 1000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());
            },
            fmt: function (d) {
                return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes()));
            },
            incr: function (d) {
                return d.setUTCMinutes(d.getUTCMinutes() + interval);
            }
        };
    };

    secondsSpecHelper = function (interval) {
        return {
            span: interval * 1000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
            },
            fmt: function (d) {
                return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes())) + ":" + (Morris.pad2(d.getSeconds()));
            },
            incr: function (d) {
                return d.setUTCSeconds(d.getUTCSeconds() + interval);
            }
        };
    };

    Morris.LABEL_SPECS = {
        "decade": {
            span: 172800000000,
            start: function (d) {
                return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear());
            },
            incr: function (d) {
                return d.setFullYear(d.getFullYear() + 10);
            }
        },
        "year": {
            span: 17280000000,
            start: function (d) {
                return new Date(d.getFullYear(), 0, 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear());
            },
            incr: function (d) {
                return d.setFullYear(d.getFullYear() + 1);
            }
        },
        "month": {
            span: 2419200000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), 1);
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1));
            },
            incr: function (d) {
                return d.setMonth(d.getMonth() + 1);
            }
        },
        "week": {
            span: 604800000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate());
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
            },
            incr: function (d) {
                return d.setDate(d.getDate() + 7);
            }
        },
        "day": {
            span: 86400000,
            start: function (d) {
                return new Date(d.getFullYear(), d.getMonth(), d.getDate());
            },
            fmt: function (d) {
                return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
            },
            incr: function (d) {
                return d.setDate(d.getDate() + 1);
            }
        },
        "hour": minutesSpecHelper(60),
        "30min": minutesSpecHelper(30),
        "15min": minutesSpecHelper(15),
        "10min": minutesSpecHelper(10),
        "5min": minutesSpecHelper(5),
        "minute": minutesSpecHelper(1),
        "30sec": secondsSpecHelper(30),
        "15sec": secondsSpecHelper(15),
        "10sec": secondsSpecHelper(10),
        "5sec": secondsSpecHelper(5),
        "second": secondsSpecHelper(1)
    };

    Morris.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"];

    Morris.Area = (function (_super) {
        var areaDefaults;

        __extends(Area, _super);

        areaDefaults = {
            fillOpacity: 'auto',
            behaveLikeLine: false
        };

        function Area(options) {
            var areaOptions;
            if (!(this instanceof Morris.Area)) {
                return new Morris.Area(options);
            }
            areaOptions = $.extend({}, areaDefaults, options);
            this.cumulative = !areaOptions.behaveLikeLine;
            if (areaOptions.fillOpacity === 'auto') {
                areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;
            }
            Area.__super__.constructor.call(this, areaOptions);
        }

        Area.prototype.calcPoints = function () {
            var row, total, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                row = _ref[_i];
                row._x = this.transX(row.x);
                total = 0;
                row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (this.options.behaveLikeLine) {
                            _results1.push(this.transY(y));
                        } else {
                            total += y || 0;
                            _results1.push(this.transY(total));
                        }
                    }
                    return _results1;
                }).call(this);
                _results.push(row._ymax = Math.max.apply(Math, row._y));
            }
            return _results;
        };

        Area.prototype.drawSeries = function () {
            var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;
            this.seriesPoints = [];
            if (this.options.behaveLikeLine) {
                range = (function () {
                    _results = [];
                    for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
                        _results.push(_i);
                    }
                    return _results;
                }).apply(this);
            } else {
                range = (function () {
                    _results1 = [];
                    for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--) {
                        _results1.push(_j);
                    }
                    return _results1;
                }).apply(this);
            }
            _results2 = [];
            for (_k = 0, _len = range.length; _k < _len; _k++) {
                i = range[_k];
                this._drawFillFor(i);
                this._drawLineFor(i);
                _results2.push(this._drawPointFor(i));
            }
            return _results2;
        };

        Area.prototype._drawFillFor = function (index) {
            var path;
            path = this.paths[index];
            if (path !== null) {
                path = path + ("L" + (this.transX(this.xmax)) + "," + this.bottom + "L" + (this.transX(this.xmin)) + "," + this.bottom + "Z");
                return this.drawFilledPath(path, this.fillForSeries(index));
            }
        };

        Area.prototype.fillForSeries = function (i) {
            var color;
            color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));
            return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));
        };

        Area.prototype.drawFilledPath = function (path, fill) {
            return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');
        };

        return Area;

    })(Morris.Line);

    Morris.Bar = (function (_super) {
        __extends(Bar, _super);

        function Bar(options) {
            this.onHoverOut = __bind(this.onHoverOut, this);
            this.onHoverMove = __bind(this.onHoverMove, this);
            this.onGridClick = __bind(this.onGridClick, this);
            if (!(this instanceof Morris.Bar)) {
                return new Morris.Bar(options);
            }
            Bar.__super__.constructor.call(this, $.extend({}, options, {
                parseTime: false
            }));
        }

        Bar.prototype.init = function () {
            this.cumulative = this.options.stacked;
            if (this.options.hideHover !== 'always') {
                this.hover = new Morris.Hover({
                    parent: this.el
                });
                this.on('hovermove', this.onHoverMove);
                this.on('hoverout', this.onHoverOut);
                return this.on('gridclick', this.onGridClick);
            }
        };

        Bar.prototype.defaults = {
            barSizeRatio: 0.75,
            barGap: 3,
            barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
            barOpacity: 1.0,
            barRadius: [0, 0, 0, 0],
            xLabelMargin: 50
        };

        Bar.prototype.calc = function () {
            var _ref;
            this.calcBars();
            if (this.options.hideHover === false) {
                return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));
            }
        };

        Bar.prototype.calcBars = function () {
            var idx, row, y, _i, _len, _ref, _results;
            _ref = this.data;
            _results = [];
            for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
                row = _ref[idx];
                row._x = this.left + this.width * (idx + 0.5) / this.data.length;
                _results.push(row._y = (function () {
                    var _j, _len1, _ref1, _results1;
                    _ref1 = row.y;
                    _results1 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        y = _ref1[_j];
                        if (y != null) {
                            _results1.push(this.transY(y));
                        } else {
                            _results1.push(null);
                        }
                    }
                    return _results1;
                }).call(this));
            }
            return _results;
        };

        Bar.prototype.draw = function () {
            var _ref;
            if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
                this.drawXAxis();
            }
            return this.drawSeries();
        };

        Bar.prototype.drawXAxis = function () {
            var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref,
                _results;
            ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);
            prevLabelMargin = null;
            prevAngleMargin = null;
            _results = [];
            for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                row = this.data[this.data.length - 1 - i];
                label = this.drawXAxisLabel(row._x, ypos, row.label);
                textBox = label.getBBox();
                label.transform("r" + (-this.options.xLabelAngle));
                labelBox = label.getBBox();
                label.transform("t0," + (labelBox.height / 2) + "...");
                if (this.options.xLabelAngle !== 0) {
                    offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);
                    label.transform("t" + offset + ",0...");
                }
                if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {
                    if (this.options.xLabelAngle !== 0) {
                        margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);
                        prevAngleMargin = labelBox.x - margin;
                    }
                    _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);
                } else {
                    _results.push(label.remove());
                }
            }
            return _results;
        };

        Bar.prototype.drawSeries = function () {
            var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top,
                ypos, zeroPos;
            groupWidth = this.width / this.options.data.length;
            numBars = this.options.stacked ? 1 : this.options.ykeys.length;
            barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;
            if (this.options.barSize) {
                barWidth = Math.min(barWidth, this.options.barSize);
            }
            spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);
            leftPadding = spaceLeft / 2;
            zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;
            return this.bars = (function () {
                var _i, _len, _ref, _results;
                _ref = this.data;
                _results = [];
                for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
                    row = _ref[idx];
                    lastTop = 0;
                    _results.push((function () {
                        var _j, _len1, _ref1, _results1;
                        _ref1 = row._y;
                        _results1 = [];
                        for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {
                            ypos = _ref1[sidx];
                            if (ypos !== null) {
                                if (zeroPos) {
                                    top = Math.min(ypos, zeroPos);
                                    bottom = Math.max(ypos, zeroPos);
                                } else {
                                    top = ypos;
                                    bottom = this.bottom;
                                }
                                left = this.left + idx * groupWidth + leftPadding;
                                if (!this.options.stacked) {
                                    left += sidx * (barWidth + this.options.barGap);
                                }
                                size = bottom - top;
                                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {
                                    this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
                                }
                                if (this.options.stacked) {
                                    top -= lastTop;
                                }
                                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);
                                _results1.push(lastTop += size);
                            } else {
                                _results1.push(null);
                            }
                        }
                        return _results1;
                    }).call(this));
                }
                return _results;
            }).call(this);
        };

        Bar.prototype.colorFor = function (row, sidx, type) {
            var r, s;
            if (typeof this.options.barColors === 'function') {
                r = {
                    x: row.x,
                    y: row.y[sidx],
                    label: row.label
                };
                s = {
                    index: sidx,
                    key: this.options.ykeys[sidx],
                    label: this.options.labels[sidx]
                };
                return this.options.barColors.call(this, r, s, type);
            } else {
                return this.options.barColors[sidx % this.options.barColors.length];
            }
        };

        Bar.prototype.hitTest = function (x) {
            if (this.data.length === 0) {
                return null;
            }
            x = Math.max(Math.min(x, this.right), this.left);
            return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));
        };

        Bar.prototype.onGridClick = function (x, y) {
            var index;
            index = this.hitTest(x);
            return this.fire('click', index, this.data[index].src, x, y);
        };

        Bar.prototype.onHoverMove = function (x, y) {
            var index, _ref;
            index = this.hitTest(x);
            return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
        };

        Bar.prototype.onHoverOut = function () {
            if (this.options.hideHover !== false) {
                return this.hover.hide();
            }
        };

        Bar.prototype.hoverContentForRow = function (index) {
            var content, j, row, x, y, _i, _len, _ref;
            row = this.data[index];
            content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
            _ref = row.y;
            for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
                y = _ref[j];
                content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
            }
            if (typeof this.options.hoverCallback === 'function') {
                content = this.options.hoverCallback(index, this.options, content, row.src);
            }
            x = this.left + (index + 0.5) * this.width / this.data.length;
            return [content, x];
        };

        Bar.prototype.drawXAxisLabel = function (xPos, yPos, text) {
            var label;
            return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
        };

        Bar.prototype.drawBar = function (xPos, yPos, width, height, barColor, opacity, radiusArray) {
            var maxRadius, path;
            maxRadius = Math.max.apply(Math, radiusArray);
            if (maxRadius === 0 || maxRadius > height) {
                path = this.raphael.rect(xPos, yPos, width, height);
            } else {
                path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));
            }
            return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');
        };

        Bar.prototype.roundedRect = function (x, y, w, h, r) {
            if (r == null) {
                r = [0, 0, 0, 0];
            }
            return ["M", x, r[0] + y, "Q", x, y, x + r[0], y, "L", x + w - r[1], y, "Q", x + w, y, x + w, y + r[1], "L", x + w, y + h - r[2], "Q", x + w, y + h, x + w - r[2], y + h, "L", x + r[3], y + h, "Q", x, y + h, x, y + h - r[3], "Z"];
        };

        return Bar;

    })(Morris.Grid);

    Morris.Donut = (function (_super) {
        __extends(Donut, _super);

        Donut.prototype.defaults = {
            colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],
            backgroundColor: '#FFFFFF',
            labelColor: '#000000',
            formatter: Morris.commas,
            resize: false
        };

        function Donut(options) {
            this.resizeHandler = __bind(this.resizeHandler, this);
            this.select = __bind(this.select, this);
            this.click = __bind(this.click, this);
            var _this = this;
            if (!(this instanceof Morris.Donut)) {
                return new Morris.Donut(options);
            }
            this.options = $.extend({}, this.defaults, options);
            if (typeof options.element === 'string') {
                this.el = $(document.getElementById(options.element));
            } else {
                this.el = $(options.element);
            }
            if (this.el === null || this.el.length === 0) {
                throw new Error("Graph placeholder not found.");
            }
            if (options.data === void 0 || options.data.length === 0) {
                return;
            }
            this.raphael = new Raphael(this.el[0]);
            if (this.options.resize) {
                $(window).bind('resize', function (evt) {
                    if (_this.timeoutId != null) {
                        window.clearTimeout(_this.timeoutId);
                    }
                    return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
                });
            }
            this.setData(options.data);
        }

        Donut.prototype.redraw = function () {
            var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2,
                _ref, _ref1, _ref2, _results;
            this.raphael.clear();
            cx = this.el.width() / 2;
            cy = this.el.height() / 2;
            w = (Math.min(cx, cy) - 10) / 3;
            total = 0;
            _ref = this.values;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                value = _ref[_i];
                total += value;
            }
            min = 5 / (2 * w);
            C = 1.9999 * Math.PI - min * this.data.length;
            last = 0;
            idx = 0;
            this.segments = [];
            _ref1 = this.values;
            for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                value = _ref1[i];
                next = last + min + C * (value / total);
                seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);
                seg.render();
                this.segments.push(seg);
                seg.on('hover', this.select);
                seg.on('click', this.click);
                last = next;
                idx += 1;
            }
            this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);
            this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);
            max_value = Math.max.apply(Math, this.values);
            idx = 0;
            _ref2 = this.values;
            _results = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                value = _ref2[_k];
                if (value === max_value) {
                    this.select(idx);
                    break;
                }
                _results.push(idx += 1);
            }
            return _results;
        };

        Donut.prototype.setData = function (data) {
            var row;
            this.data = data;
            this.values = (function () {
                var _i, _len, _ref, _results;
                _ref = this.data;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    row = _ref[_i];
                    _results.push(parseFloat(row.value));
                }
                return _results;
            }).call(this);
            return this.redraw();
        };

        Donut.prototype.click = function (idx) {
            return this.fire('click', idx, this.data[idx]);
        };

        Donut.prototype.select = function (idx) {
            var row, s, segment, _i, _len, _ref;
            _ref = this.segments;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                s = _ref[_i];
                s.deselect();
            }
            segment = this.segments[idx];
            segment.select();
            row = this.data[idx];
            return this.setLabels(row.label, this.options.formatter(row.value, row));
        };

        Donut.prototype.setLabels = function (label1, label2) {
            var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;
            inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;
            maxWidth = 1.8 * inner;
            maxHeightTop = inner / 2;
            maxHeightBottom = inner / 3;
            this.text1.attr({
                text: label1,
                transform: ''
            });
            text1bbox = this.text1.getBBox();
            text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);
            this.text1.attr({
                transform: "S" + text1scale + "," + text1scale + "," + (text1bbox.x + text1bbox.width / 2) + "," + (text1bbox.y + text1bbox.height)
            });
            this.text2.attr({
                text: label2,
                transform: ''
            });
            text2bbox = this.text2.getBBox();
            text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);
            return this.text2.attr({
                transform: "S" + text2scale + "," + text2scale + "," + (text2bbox.x + text2bbox.width / 2) + "," + text2bbox.y
            });
        };

        Donut.prototype.drawEmptyDonutLabel = function (xPos, yPos, color, fontSize, fontWeight) {
            var text;
            text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);
            if (fontWeight != null) {
                text.attr('font-weight', fontWeight);
            }
            return text;
        };

        Donut.prototype.resizeHandler = function () {
            this.timeoutId = null;
            this.raphael.setSize(this.el.width(), this.el.height());
            return this.redraw();
        };

        return Donut;

    })(Morris.EventEmitter);

    Morris.DonutSegment = (function (_super) {
        __extends(DonutSegment, _super);

        function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {
            this.cx = cx;
            this.cy = cy;
            this.inner = inner;
            this.outer = outer;
            this.color = color;
            this.backgroundColor = backgroundColor;
            this.index = index;
            this.raphael = raphael;
            this.deselect = __bind(this.deselect, this);
            this.select = __bind(this.select, this);
            this.sin_p0 = Math.sin(p0);
            this.cos_p0 = Math.cos(p0);
            this.sin_p1 = Math.sin(p1);
            this.cos_p1 = Math.cos(p1);
            this.is_long = (p1 - p0) > Math.PI ? 1 : 0;
            this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);
            this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);
            this.hilight = this.calcArc(this.inner);
        }

        DonutSegment.prototype.calcArcPoints = function (r) {
            return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];
        };

        DonutSegment.prototype.calcSegment = function (r1, r2) {
            var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;
            _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
            _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];
            return ("M" + ix0 + "," + iy0) + ("A" + r1 + "," + r1 + ",0," + this.is_long + ",0," + ix1 + "," + iy1) + ("L" + ox1 + "," + oy1) + ("A" + r2 + "," + r2 + ",0," + this.is_long + ",1," + ox0 + "," + oy0) + "Z";
        };

        DonutSegment.prototype.calcArc = function (r) {
            var ix0, ix1, iy0, iy1, _ref;
            _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
            return ("M" + ix0 + "," + iy0) + ("A" + r + "," + r + ",0," + this.is_long + ",0," + ix1 + "," + iy1);
        };

        DonutSegment.prototype.render = function () {
            var _this = this;
            this.arc = this.drawDonutArc(this.hilight, this.color);
            return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function () {
                return _this.fire('hover', _this.index);
            }, function () {
                return _this.fire('click', _this.index);
            });
        };

        DonutSegment.prototype.drawDonutArc = function (path, color) {
            return this.raphael.path(path).attr({
                stroke: color,
                'stroke-width': 2,
                opacity: 0
            });
        };

        DonutSegment.prototype.drawDonutSegment = function (path, fillColor, strokeColor, hoverFunction, clickFunction) {
            return this.raphael.path(path).attr({
                fill: fillColor,
                stroke: strokeColor,
                'stroke-width': 3
            }).hover(hoverFunction).click(clickFunction);
        };

        DonutSegment.prototype.select = function () {
            if (!this.selected) {
                this.seg.animate({
                    path: this.selectedPath
                }, 150, '<>');
                this.arc.animate({
                    opacity: 1
                }, 150, '<>');
                return this.selected = true;
            }
        };

        DonutSegment.prototype.deselect = function () {
            if (this.selected) {
                this.seg.animate({
                    path: this.path
                }, 150, '<>');
                this.arc.animate({
                    opacity: 0
                }, 150, '<>');
                return this.selected = false;
            }
        };

        return DonutSegment;

    })(Morris.EventEmitter);

}).call(this);

//  \\
//  Raphal 2.2.0 - JavaScript Vector Library                                                              \\
//  \\
//  Copyright  2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                        \\
//  Copyright  2008-2016 Sencha Labs (http://sencha.com)                                                  \\
//  \\
//  Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license. \\
//  \\

(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["Raphael"] = factory();
    else
        root["Raphael"] = factory();
})(this, function () {
    return /******/ (function (modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/
        var installedModules = {};

        /******/ 	// The require function
        /******/
        function __webpack_require__(moduleId) {

            /******/ 		// Check if module is in cache
            /******/
            if (installedModules[moduleId])
            /******/            return installedModules[moduleId].exports;

            /******/ 		// Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/            exports: {},
                /******/            id: moduleId,
                /******/            loaded: false
                /******/
            };

            /******/ 		// Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

            /******/ 		// Flag the module as loaded
            /******/
            module.loaded = true;

            /******/ 		// Return the exports of the module
            /******/
            return module.exports;
            /******/
        }


        /******/ 	// expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;

        /******/ 	// expose the module cache
        /******/
        __webpack_require__.c = installedModules;

        /******/ 	// __webpack_public_path__
        /******/
        __webpack_require__.p = "";

        /******/ 	// Load entry module and return exports
        /******/
        return __webpack_require__(0);
        /******/
    })
    /************************************************************************/
    /******/([
        /* 0 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {

                return R;

            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

            /***/
        },
        /* 1 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {

                /*\
	     * Raphael
	     [ method ]
	     **
	     * Creates a canvas object on which to draw.
	     * You must do this first, as all future calls to drawing methods
	     * from this instance will be bound to this canvas.
	     > Parameters
	     **
	     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
	     - width (number)
	     - height (number)
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - x (number)
	     - y (number)
	     - width (number)
	     - height (number)
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
	     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
	     * or
	     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.
	     = (object) @Paper
	     > Usage
	     | // Each of the following examples create a canvas
	     | // that is 320px wide by 200px high.
	     | // Canvas is created at the viewports 10,50 coordinate.
	     | var paper = Raphael(10, 50, 320, 200);
	     | // Canvas is created at the top left corner of the #notepad element
	     | // (or its top right corner in dir="rtl" elements)
	     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
	     | // Same as above
	     | var paper = Raphael("notepad", 320, 200);
	     | // Image dump
	     | var set = Raphael(["notepad", 320, 200, {
	     |     type: "rect",
	     |     x: 10,
	     |     y: 10,
	     |     width: 25,
	     |     height: 25,
	     |     stroke: "#f00"
	     | }, {
	     |     type: "text",
	     |     x: 30,
	     |     y: 40,
	     |     text: "Dump"
	     | }]);
	    \*/
                function R(first) {
                    if (R.is(first, "function")) {
                        return loaded ? first() : eve.on("raphael.DOMload", first);
                    } else if (R.is(first, array)) {
                        return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
                    } else {
                        var args = Array.prototype.slice.call(arguments, 0);
                        if (R.is(args[args.length - 1], "function")) {
                            var f = args.pop();
                            return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                                f.call(R._engine.create[apply](R, args));
                            });
                        } else {
                            return R._engine.create[apply](R, arguments);
                        }
                    }
                }

                R.version = "2.2.0";
                R.eve = eve;
                var loaded,
                    separator = /[, ]+/,
                    elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
                    formatrg = /\{(\d+)\}/g,
                    proto = "prototype",
                    has = "hasOwnProperty",
                    g = {
                        doc: document,
                        win: window
                    },
                    oldRaphael = {
                        was: Object.prototype[has].call(g.win, "Raphael"),
                        is: g.win.Raphael
                    },
                    Paper = function () {
                        /*\
	             * Paper.ca
	             [ property (object) ]
	             **
	             * Shortcut for @Paper.customAttributes
	            \*/
                        /*\
	             * Paper.customAttributes
	             [ property (object) ]
	             **
	             * If you have a set of attributes that you would like to represent
	             * as a function of some number you can do it easily with custom attributes:
	             > Usage
	             | paper.customAttributes.hue = function (num) {
	             |     num = num % 1;
	             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
	             | };
	             | // Custom attribute hue will change fill
	             | // to be given hue with fixed saturation and brightness.
	             | // Now you can use it like this:
	             | var c = paper.circle(10, 10, 10).attr({hue: .45});
	             | // or even like this:
	             | c.animate({hue: 1}, 1e3);
	             |
	             | // You could also create custom attribute
	             | // with multiple parameters:
	             | paper.customAttributes.hsb = function (h, s, b) {
	             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
	             | };
	             | c.attr({hsb: "0.5 .8 1"});
	             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
	            \*/
                        this.ca = this.customAttributes = {};
                    },
                    paperproto,
                    appendChild = "appendChild",
                    apply = "apply",
                    concat = "concat",
                    supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
                    E = "",
                    S = " ",
                    Str = String,
                    split = "split",
                    events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
                    touchMap = {
                        mousedown: "touchstart",
                        mousemove: "touchmove",
                        mouseup: "touchend"
                    },
                    lowerCase = Str.prototype.toLowerCase,
                    math = Math,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    pow = math.pow,
                    PI = math.PI,
                    nu = "number",
                    string = "string",
                    array = "array",
                    toString = "toString",
                    fillString = "fill",
                    objectToString = Object.prototype.toString,
                    paper = {},
                    push = "push",
                    ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
                    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
                    isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
                    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
                    round = math.round,
                    setAttribute = "setAttribute",
                    toFloat = parseFloat,
                    toInt = parseInt,
                    upperCase = Str.prototype.toUpperCase,
                    availableAttrs = R._availableAttrs = {
                        "arrow-end": "none",
                        "arrow-start": "none",
                        blur: 0,
                        "clip-rect": "0 0 1e9 1e9",
                        cursor: "default",
                        cx: 0,
                        cy: 0,
                        fill: "#fff",
                        "fill-opacity": 1,
                        font: '10px "Arial"',
                        "font-family": '"Arial"',
                        "font-size": "10",
                        "font-style": "normal",
                        "font-weight": 400,
                        gradient: 0,
                        height: 0,
                        href: "http://raphaeljs.com/",
                        "letter-spacing": 0,
                        opacity: 1,
                        path: "M0,0",
                        r: 0,
                        rx: 0,
                        ry: 0,
                        src: "",
                        stroke: "#000",
                        "stroke-dasharray": "",
                        "stroke-linecap": "butt",
                        "stroke-linejoin": "butt",
                        "stroke-miterlimit": 0,
                        "stroke-opacity": 1,
                        "stroke-width": 1,
                        target: "_blank",
                        "text-anchor": "middle",
                        title: "Raphael",
                        transform: "",
                        width: 0,
                        x: 0,
                        y: 0,
                        "class": ""
                    },
                    availableAnimAttrs = R._availableAnimAttrs = {
                        blur: nu,
                        "clip-rect": "csv",
                        cx: nu,
                        cy: nu,
                        fill: "colour",
                        "fill-opacity": nu,
                        "font-size": nu,
                        height: nu,
                        opacity: nu,
                        path: "path",
                        r: nu,
                        rx: nu,
                        ry: nu,
                        stroke: "colour",
                        "stroke-opacity": nu,
                        "stroke-width": nu,
                        transform: "transform",
                        width: nu,
                        x: nu,
                        y: nu
                    },
                    whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
                    commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
                    hsrg = {hs: 1, rg: 1},
                    p2s = /,?([achlmqrstvxz]),?/gi,
                    pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                    tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
                    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
                    radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
                    eldata = {},
                    sortByKey = function (a, b) {
                        return a.key - b.key;
                    },
                    sortByNumber = function (a, b) {
                        return toFloat(a) - toFloat(b);
                    },
                    fun = function () {
                    },
                    pipe = function (x) {
                        return x;
                    },
                    rectPath = R._rectPath = function (x, y, w, h, r) {
                        if (r) {
                            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
                        }
                        return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
                    },
                    ellipsePath = function (x, y, rx, ry) {
                        if (ry == null) {
                            ry = rx;
                        }
                        return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
                    },
                    getPath = R._getPath = {
                        path: function (el) {
                            return el.attr("path");
                        },
                        circle: function (el) {
                            var a = el.attrs;
                            return ellipsePath(a.cx, a.cy, a.r);
                        },
                        ellipse: function (el) {
                            var a = el.attrs;
                            return ellipsePath(a.cx, a.cy, a.rx, a.ry);
                        },
                        rect: function (el) {
                            var a = el.attrs;
                            return rectPath(a.x, a.y, a.width, a.height, a.r);
                        },
                        image: function (el) {
                            var a = el.attrs;
                            return rectPath(a.x, a.y, a.width, a.height);
                        },
                        text: function (el) {
                            var bbox = el._getBBox();
                            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                        },
                        set: function (el) {
                            var bbox = el._getBBox();
                            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
                        }
                    },
                    /*\
	         * Raphael.mapPath
	         [ method ]
	         **
	         * Transform the path string with given matrix.
	         > Parameters
	         - path (string) path string
	         - matrix (object) see @Matrix
	         = (string) transformed path string
	        \*/
                    mapPath = R.mapPath = function (path, matrix) {
                        if (!matrix) {
                            return path;
                        }
                        var x, y, i, j, ii, jj, pathi;
                        path = path2curve(path);
                        for (i = 0, ii = path.length; i < ii; i++) {
                            pathi = path[i];
                            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                                x = matrix.x(pathi[j], pathi[j + 1]);
                                y = matrix.y(pathi[j], pathi[j + 1]);
                                pathi[j] = x;
                                pathi[j + 1] = y;
                            }
                        }
                        return path;
                    };

                R._g = g;
                /*\
	     * Raphael.type
	     [ property (string) ]
	     **
	     * Can be SVG, VML or empty, depending on browser support.
	    \*/
                R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
                if (R.type == "VML") {
                    var d = g.doc.createElement("div"),
                        b;
                    d.innerHTML = '<v:shape adj="1"/>';
                    b = d.firstChild;
                    b.style.behavior = "url(#default#VML)";
                    if (!(b && typeof b.adj == "object")) {
                        return (R.type = E);
                    }
                    d = null;
                }
                /*\
	     * Raphael.svg
	     [ property (boolean) ]
	     **
	     * `true` if browser supports SVG.
	    \*/
                /*\
	     * Raphael.vml
	     [ property (boolean) ]
	     **
	     * `true` if browser supports VML.
	    \*/
                R.svg = !(R.vml = R.type == "VML");
                R._Paper = Paper;
                /*\
	     * Raphael.fn
	     [ property (object) ]
	     **
	     * You can add your own method to the canvas. For example if you want to draw a pie chart,
	     * you can create your own pie chart function and ship it as a Raphal plugin. To do this
	     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
	     * Raphal instance is created, otherwise it will take no effect. Please note that the
	     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
	     * ensure any namespacing ensures proper context.
	     > Usage
	     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
	     |     return this.path( ... );
	     | };
	     | // or create namespace
	     | Raphael.fn.mystuff = {
	     |     arrow: function () {},
	     |     star: function () {},
	     |     // etc
	     | };
	     | var paper = Raphael(10, 10, 630, 480);
	     | // then use it
	     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
	     | paper.mystuff.arrow();
	     | paper.mystuff.star();
	    \*/
                R.fn = paperproto = Paper.prototype = R.prototype;
                R._id = 0;
                /*\
	     * Raphael.is
	     [ method ]
	     **
	     * Handful of replacements for `typeof` operator.
	     > Parameters
	     - o () any object or primitive
	     - type (string) name of the type, i.e. string, function, number, etc.
	     = (boolean) is given value is of given type
	    \*/
                R.is = function (o, type) {
                    type = lowerCase.call(type);
                    if (type == "finite") {
                        return !isnan[has](+o);
                    }
                    if (type == "array") {
                        return o instanceof Array;
                    }
                    return (type == "null" && o === null) ||
                        (type == typeof o && o !== null) ||
                        (type == "object" && o === Object(o)) ||
                        (type == "array" && Array.isArray && Array.isArray(o)) ||
                        objectToString.call(o).slice(8, -1).toLowerCase() == type;
                };

                function clone(obj) {
                    if (typeof obj == "function" || Object(obj) !== obj) {
                        return obj;
                    }
                    var res = new obj.constructor;
                    for (var key in obj) if (obj[has](key)) {
                        res[key] = clone(obj[key]);
                    }
                    return res;
                }

                /*\
	     * Raphael.angle
	     [ method ]
	     **
	     * Returns angle between two or three points
	     > Parameters
	     - x1 (number) x coord of first point
	     - y1 (number) y coord of first point
	     - x2 (number) x coord of second point
	     - y2 (number) y coord of second point
	     - x3 (number) #optional x coord of third point
	     - y3 (number) #optional y coord of third point
	     = (number) angle in degrees.
	    \*/
                R.angle = function (x1, y1, x2, y2, x3, y3) {
                    if (x3 == null) {
                        var x = x1 - x2,
                            y = y1 - y2;
                        if (!x && !y) {
                            return 0;
                        }
                        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
                    } else {
                        return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
                    }
                };
                /*\
	     * Raphael.rad
	     [ method ]
	     **
	     * Transform angle to radians
	     > Parameters
	     - deg (number) angle in degrees
	     = (number) angle in radians.
	    \*/
                R.rad = function (deg) {
                    return deg % 360 * PI / 180;
                };
                /*\
	     * Raphael.deg
	     [ method ]
	     **
	     * Transform angle to degrees
	     > Parameters
	     - rad (number) angle in radians
	     = (number) angle in degrees.
	    \*/
                R.deg = function (rad) {
                    return Math.round((rad * 180 / PI % 360) * 1000) / 1000;
                };
                /*\
	     * Raphael.snapTo
	     [ method ]
	     **
	     * Snaps given value to given grid.
	     > Parameters
	     - values (array|number) given array of values or step of the grid
	     - value (number) value to adjust
	     - tolerance (number) #optional tolerance for snapping. Default is `10`.
	     = (number) adjusted value.
	    \*/
                R.snapTo = function (values, value, tolerance) {
                    tolerance = R.is(tolerance, "finite") ? tolerance : 10;
                    if (R.is(values, array)) {
                        var i = values.length;
                        while (i--) if (abs(values[i] - value) <= tolerance) {
                            return values[i];
                        }
                    } else {
                        values = +values;
                        var rem = value % values;
                        if (rem < tolerance) {
                            return value - rem;
                        }
                        if (rem > values - tolerance) {
                            return value - rem + values;
                        }
                    }
                    return value;
                };

                /*\
	     * Raphael.createUUID
	     [ method ]
	     **
	     * Returns RFC4122, version 4 ID
	    \*/
                var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
                    return function () {
                        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
                    };
                })(/[xy]/g, function (c) {
                    var r = math.random() * 16 | 0,
                        v = c == "x" ? r : (r & 3 | 8);
                    return v.toString(16);
                });

                /*\
	     * Raphael.setWindow
	     [ method ]
	     **
	     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
	     > Parameters
	     - newwin (window) new window object
	    \*/
                R.setWindow = function (newwin) {
                    eve("raphael.setWindow", R, g.win, newwin);
                    g.win = newwin;
                    g.doc = g.win.document;
                    if (R._engine.initWin) {
                        R._engine.initWin(g.win);
                    }
                };
                var toHex = function (color) {
                        if (R.vml) {
                            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                            var trim = /^\s+|\s+$/g;
                            var bod;
                            try {
                                var docum = new ActiveXObject("htmlfile");
                                docum.write("<body>");
                                docum.close();
                                bod = docum.body;
                            } catch (e) {
                                bod = createPopup().document.body;
                            }
                            var range = bod.createTextRange();
                            toHex = cacher(function (color) {
                                try {
                                    bod.style.color = Str(color).replace(trim, E);
                                    var value = range.queryCommandValue("ForeColor");
                                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                                    return "#" + ("000000" + value.toString(16)).slice(-6);
                                } catch (e) {
                                    return "none";
                                }
                            });
                        } else {
                            var i = g.doc.createElement("i");
                            i.title = "Rapha\xebl Colour Picker";
                            i.style.display = "none";
                            g.doc.body.appendChild(i);
                            toHex = cacher(function (color) {
                                i.style.color = color;
                                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                            });
                        }
                        return toHex(color);
                    },
                    hsbtoString = function () {
                        return "hsb(" + [this.h, this.s, this.b] + ")";
                    },
                    hsltoString = function () {
                        return "hsl(" + [this.h, this.s, this.l] + ")";
                    },
                    rgbtoString = function () {
                        return this.hex;
                    },
                    prepareRGB = function (r, g, b) {
                        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                            b = r.b;
                            g = r.g;
                            r = r.r;
                        }
                        if (g == null && R.is(r, string)) {
                            var clr = R.getRGB(r);
                            r = clr.r;
                            g = clr.g;
                            b = clr.b;
                        }
                        if (r > 1 || g > 1 || b > 1) {
                            r /= 255;
                            g /= 255;
                            b /= 255;
                        }

                        return [r, g, b];
                    },
                    packageRGB = function (r, g, b, o) {
                        r *= 255;
                        g *= 255;
                        b *= 255;
                        var rgb = {
                            r: r,
                            g: g,
                            b: b,
                            hex: R.rgb(r, g, b),
                            toString: rgbtoString
                        };
                        R.is(o, "finite") && (rgb.opacity = o);
                        return rgb;
                    };

                /*\
	     * Raphael.color
	     [ method ]
	     **
	     * Parses the color string and returns object with all values for the given color.
	     > Parameters
	     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
	     = (object) Combined RGB & HSB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #,
	     o     error (boolean) `true` if string cant be parsed,
	     o     h (number) hue,
	     o     s (number) saturation,
	     o     v (number) value (brightness),
	     o     l (number) lightness
	     o }
	    \*/
                R.color = function (clr) {
                    var rgb;
                    if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
                        rgb = R.hsb2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.hex = rgb.hex;
                    } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
                        rgb = R.hsl2rgb(clr);
                        clr.r = rgb.r;
                        clr.g = rgb.g;
                        clr.b = rgb.b;
                        clr.hex = rgb.hex;
                    } else {
                        if (R.is(clr, "string")) {
                            clr = R.getRGB(clr);
                        }
                        if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                            rgb = R.rgb2hsl(clr);
                            clr.h = rgb.h;
                            clr.s = rgb.s;
                            clr.l = rgb.l;
                            rgb = R.rgb2hsb(clr);
                            clr.v = rgb.b;
                        } else {
                            clr = {hex: "none"};
                            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                        }
                    }
                    clr.toString = rgbtoString;
                    return clr;
                };
                /*\
	     * Raphael.hsb2rgb
	     [ method ]
	     **
	     * Converts HSB values to RGB object.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - v (number) value or brightness
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #
	     o }
	    \*/
                R.hsb2rgb = function (h, s, v, o) {
                    if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
                        v = h.b;
                        s = h.s;
                        o = h.o;
                        h = h.h;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = v * s;
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = v - C;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
	     * Raphael.hsl2rgb
	     [ method ]
	     **
	     * Converts HSL values to RGB object.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - l (number) luminosity
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue,
	     o     hex (string) color in HTML/CSS format: #
	     o }
	    \*/
                R.hsl2rgb = function (h, s, l, o) {
                    if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
                        l = h.l;
                        s = h.s;
                        h = h.h;
                    }
                    if (h > 1 || s > 1 || l > 1) {
                        h /= 360;
                        s /= 100;
                        l /= 100;
                    }
                    h *= 360;
                    var R, G, B, X, C;
                    h = (h % 360) / 60;
                    C = 2 * s * (l < .5 ? l : 1 - l);
                    X = C * (1 - abs(h % 2 - 1));
                    R = G = B = l - C / 2;

                    h = ~~h;
                    R += [C, X, 0, 0, X, C][h];
                    G += [X, C, C, X, 0, 0][h];
                    B += [0, 0, X, C, C, X][h];
                    return packageRGB(R, G, B, o);
                };
                /*\
	     * Raphael.rgb2hsb
	     [ method ]
	     **
	     * Converts RGB values to HSB object.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (object) HSB object in format:
	     o {
	     o     h (number) hue
	     o     s (number) saturation
	     o     b (number) brightness
	     o }
	    \*/
                R.rgb2hsb = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, V, C;
                    V = mmax(r, g, b);
                    C = V - mmin(r, g, b);
                    H = (C == 0 ? null :
                            V == r ? (g - b) / C :
                                V == g ? (b - r) / C + 2 :
                                    (r - g) / C + 4
                    );
                    H = ((H + 360) % 6) * 60 / 360;
                    S = C == 0 ? 0 : C / V;
                    return {h: H, s: S, b: V, toString: hsbtoString};
                };
                /*\
	     * Raphael.rgb2hsl
	     [ method ]
	     **
	     * Converts RGB values to HSL object.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (object) HSL object in format:
	     o {
	     o     h (number) hue
	     o     s (number) saturation
	     o     l (number) luminosity
	     o }
	    \*/
                R.rgb2hsl = function (r, g, b) {
                    b = prepareRGB(r, g, b);
                    r = b[0];
                    g = b[1];
                    b = b[2];

                    var H, S, L, M, m, C;
                    M = mmax(r, g, b);
                    m = mmin(r, g, b);
                    C = M - m;
                    H = (C == 0 ? null :
                        M == r ? (g - b) / C :
                            M == g ? (b - r) / C + 2 :
                                (r - g) / C + 4);
                    H = ((H + 360) % 6) * 60 / 360;
                    L = (M + m) / 2;
                    S = (C == 0 ? 0 :
                        L < .5 ? C / (2 * L) :
                            C / (2 - 2 * L));
                    return {h: H, s: S, l: L, toString: hsltoString};
                };
                R._path2string = function () {
                    return this.join(",").replace(p2s, "$1");
                };

                function repush(array, item) {
                    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
                        return array.push(array.splice(i, 1)[0]);
                    }
                }

                function cacher(f, scope, postprocessor) {
                    function newf() {
                        var arg = Array.prototype.slice.call(arguments, 0),
                            args = arg.join("\u2400"),
                            cache = newf.cache = newf.cache || {},
                            count = newf.count = newf.count || [];
                        if (cache[has](args)) {
                            repush(count, args);
                            return postprocessor ? postprocessor(cache[args]) : cache[args];
                        }
                        count.length >= 1e3 && delete cache[count.shift()];
                        count.push(args);
                        cache[args] = f[apply](scope, arg);
                        return postprocessor ? postprocessor(cache[args]) : cache[args];
                    }

                    return newf;
                }

                var preload = R._preload = function (src, f) {
                    var img = g.doc.createElement("img");
                    img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
                    img.onload = function () {
                        f.call(this);
                        this.onload = null;
                        g.doc.body.removeChild(this);
                    };
                    img.onerror = function () {
                        g.doc.body.removeChild(this);
                    };
                    g.doc.body.appendChild(img);
                    img.src = src;
                };

                function clrToString() {
                    return this.hex;
                }

                /*\
	     * Raphael.getRGB
	     [ method ]
	     **
	     * Parses colour string as RGB object
	     > Parameters
	     - colour (string) colour string in one of formats:
	     # <ul>
	     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
	     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
	     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
	     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
	     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
	     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
	     #     <li>hsb(%, %, %)  same as above, but in %</li>
	     #     <li>hsl(, , )  same as hsb</li>
	     #     <li>hsl(%, %, %)  same as hsb</li>
	     # </ul>
	     = (object) RGB object in format:
	     o {
	     o     r (number) red,
	     o     g (number) green,
	     o     b (number) blue
	     o     hex (string) color in HTML/CSS format: #,
	     o     error (boolean) true if string cant be parsed
	     o }
	    \*/
                R.getRGB = cacher(function (colour) {
                    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
                        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                    }
                    if (colour == "none") {
                        return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
                    }
                    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
                    var res,
                        red,
                        green,
                        blue,
                        opacity,
                        t,
                        values,
                        rgb = colour.match(colourRegExp);
                    if (rgb) {
                        if (rgb[2]) {
                            blue = toInt(rgb[2].substring(5), 16);
                            green = toInt(rgb[2].substring(3, 5), 16);
                            red = toInt(rgb[2].substring(1, 3), 16);
                        }
                        if (rgb[3]) {
                            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                            green = toInt((t = rgb[3].charAt(2)) + t, 16);
                            red = toInt((t = rgb[3].charAt(1)) + t, 16);
                        }
                        if (rgb[4]) {
                            values = rgb[4][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                        }
                        if (rgb[5]) {
                            values = rgb[5][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return R.hsb2rgb(red, green, blue, opacity);
                        }
                        if (rgb[6]) {
                            values = rgb[6][split](commaSpaces);
                            red = toFloat(values[0]);
                            values[0].slice(-1) == "%" && (red *= 2.55);
                            green = toFloat(values[1]);
                            values[1].slice(-1) == "%" && (green *= 2.55);
                            blue = toFloat(values[2]);
                            values[2].slice(-1) == "%" && (blue *= 2.55);
                            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                            return R.hsl2rgb(red, green, blue, opacity);
                        }
                        rgb = {r: red, g: green, b: blue, toString: clrToString};
                        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
                        R.is(opacity, "finite") && (rgb.opacity = opacity);
                        return rgb;
                    }
                    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
                }, R);
                /*\
	     * Raphael.hsb
	     [ method ]
	     **
	     * Converts HSB values to hex representation of the colour.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - b (number) value or brightness
	     = (string) hex representation of the colour.
	    \*/
                R.hsb = cacher(function (h, s, b) {
                    return R.hsb2rgb(h, s, b).hex;
                });
                /*\
	     * Raphael.hsl
	     [ method ]
	     **
	     * Converts HSL values to hex representation of the colour.
	     > Parameters
	     - h (number) hue
	     - s (number) saturation
	     - l (number) luminosity
	     = (string) hex representation of the colour.
	    \*/
                R.hsl = cacher(function (h, s, l) {
                    return R.hsl2rgb(h, s, l).hex;
                });
                /*\
	     * Raphael.rgb
	     [ method ]
	     **
	     * Converts RGB values to hex representation of the colour.
	     > Parameters
	     - r (number) red
	     - g (number) green
	     - b (number) blue
	     = (string) hex representation of the colour.
	    \*/
                R.rgb = cacher(function (r, g, b) {
                    function round(x) {
                        return (x + 0.5) | 0;
                    }

                    return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
                });
                /*\
	     * Raphael.getColor
	     [ method ]
	     **
	     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
	     > Parameters
	     - value (number) #optional brightness, default is `0.75`
	     = (string) hex representation of the colour.
	    \*/
                R.getColor = function (value) {
                    var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
                        rgb = this.hsb2rgb(start.h, start.s, start.b);
                    start.h += .075;
                    if (start.h > 1) {
                        start.h = 0;
                        start.s -= .2;
                        start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
                    }
                    return rgb.hex;
                };
                /*\
	     * Raphael.getColor.reset
	     [ method ]
	     **
	     * Resets spectrum position for @Raphael.getColor back to red.
	    \*/
                R.getColor.reset = function () {
                    delete this.start;
                };

                // http://schepers.cc/getting-to-the-point
                function catmullRom2bezier(crp, z) {
                    var d = [];
                    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                        var p = [
                            {x: +crp[i - 2], y: +crp[i - 1]},
                            {x: +crp[i], y: +crp[i + 1]},
                            {x: +crp[i + 2], y: +crp[i + 3]},
                            {x: +crp[i + 4], y: +crp[i + 5]}
                        ];
                        if (z) {
                            if (!i) {
                                p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                            } else if (iLen - 4 == i) {
                                p[3] = {x: +crp[0], y: +crp[1]};
                            } else if (iLen - 2 == i) {
                                p[2] = {x: +crp[0], y: +crp[1]};
                                p[3] = {x: +crp[2], y: +crp[3]};
                            }
                        } else {
                            if (iLen - 4 == i) {
                                p[3] = p[2];
                            } else if (!i) {
                                p[0] = {x: +crp[i], y: +crp[i + 1]};
                            }
                        }
                        d.push(["C",
                            (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                            (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                            (p[1].x + 6 * p[2].x - p[3].x) / 6,
                            (p[1].y + 6 * p[2].y - p[3].y) / 6,
                            p[2].x,
                            p[2].y
                        ]);
                    }

                    return d;
                }

                /*\
	     * Raphael.parsePathString
	     [ method ]
	     **
	     * Utility method
	     **
	     * Parses given path string into an array of arrays of path segments.
	     > Parameters
	     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
	     = (array) array of segments.
	    \*/
                R.parsePathString = function (pathString) {
                    if (!pathString) {
                        return null;
                    }
                    var pth = paths(pathString);
                    if (pth.arr) {
                        return pathClone(pth.arr);
                    }

                    var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
                        data = [];
                    if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
                        data = pathClone(pathString);
                    }
                    if (!data.length) {
                        Str(pathString).replace(pathCommand, function (a, b, c) {
                            var params = [],
                                name = b.toLowerCase();
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            if (name == "m" && params.length > 2) {
                                data.push([b][concat](params.splice(0, 2)));
                                name = "l";
                                b = b == "m" ? "l" : "L";
                            }
                            if (name == "r") {
                                data.push([b][concat](params));
                            } else while (params.length >= paramCounts[name]) {
                                data.push([b][concat](params.splice(0, paramCounts[name])));
                                if (!paramCounts[name]) {
                                    break;
                                }
                            }
                        });
                    }
                    data.toString = R._path2string;
                    pth.arr = pathClone(data);
                    return data;
                };
                /*\
	     * Raphael.parseTransformString
	     [ method ]
	     **
	     * Utility method
	     **
	     * Parses given path string into an array of transformations.
	     > Parameters
	     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
	     = (array) array of transformations.
	    \*/
                R.parseTransformString = cacher(function (TString) {
                    if (!TString) {
                        return null;
                    }
                    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
                        data = [];
                    if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
                        data = pathClone(TString);
                    }
                    if (!data.length) {
                        Str(TString).replace(tCommand, function (a, b, c) {
                            var params = [],
                                name = lowerCase.call(b);
                            c.replace(pathValues, function (a, b) {
                                b && params.push(+b);
                            });
                            data.push([b][concat](params));
                        });
                    }
                    data.toString = R._path2string;
                    return data;
                });
                // PATHS
                var paths = function (ps) {
                    var p = paths.ps = paths.ps || {};
                    if (p[ps]) {
                        p[ps].sleep = 100;
                    } else {
                        p[ps] = {
                            sleep: 100
                        };
                    }
                    setTimeout(function () {
                        for (var key in p) if (p[has](key) && key != ps) {
                            p[key].sleep--;
                            !p[key].sleep && delete p[key];
                        }
                    });
                    return p[ps];
                };
                /*\
	     * Raphael.findDotsAtSegment
	     [ method ]
	     **
	     * Utility method
	     **
	     * Find dot coordinates on the given cubic bezier curve at the given t.
	     > Parameters
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     - t (number) position on the curve (0..1)
	     = (object) point information in format:
	     o {
	     o     x: (number) x coordinate of the point
	     o     y: (number) y coordinate of the point
	     o     m: {
	     o         x: (number) x coordinate of the left anchor
	     o         y: (number) y coordinate of the left anchor
	     o     }
	     o     n: {
	     o         x: (number) x coordinate of the right anchor
	     o         y: (number) y coordinate of the right anchor
	     o     }
	     o     start: {
	     o         x: (number) x coordinate of the start of the curve
	     o         y: (number) y coordinate of the start of the curve
	     o     }
	     o     end: {
	     o         x: (number) x coordinate of the end of the curve
	     o         y: (number) y coordinate of the end of the curve
	     o     }
	     o     alpha: (number) angle of the curve derivative at the point
	     o }
	    \*/
                R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                    var t1 = 1 - t,
                        t13 = pow(t1, 3),
                        t12 = pow(t1, 2),
                        t2 = t * t,
                        t3 = t2 * t,
                        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                        ax = t1 * p1x + t * c1x,
                        ay = t1 * p1y + t * c1y,
                        cx = t1 * c2x + t * p2x,
                        cy = t1 * c2y + t * p2y,
                        alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
                    (mx > nx || my < ny) && (alpha += 180);
                    return {
                        x: x,
                        y: y,
                        m: {x: mx, y: my},
                        n: {x: nx, y: ny},
                        start: {x: ax, y: ay},
                        end: {x: cx, y: cy},
                        alpha: alpha
                    };
                };
                /*\
	     * Raphael.bezierBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Return bounding box of a given cubic bezier curve
	     > Parameters
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     * or
	     - bez (array) array of six points for bezier curve
	     = (object) point information in format:
	     o {
	     o     min: {
	     o         x: (number) x coordinate of the left point
	     o         y: (number) y coordinate of the top point
	     o     }
	     o     max: {
	     o         x: (number) x coordinate of the right point
	     o         y: (number) y coordinate of the bottom point
	     o     }
	     o }
	    \*/
                R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                    if (!R.is(p1x, "array")) {
                        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
                    }
                    var bbox = curveDim.apply(null, p1x);
                    return {
                        x: bbox.min.x,
                        y: bbox.min.y,
                        x2: bbox.max.x,
                        y2: bbox.max.y,
                        width: bbox.max.x - bbox.min.x,
                        height: bbox.max.y - bbox.min.y
                    };
                };
                /*\
	     * Raphael.isPointInsideBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside bounding boxes.
	     > Parameters
	     - bbox (string) bounding box
	     - x (string) x coordinate of the point
	     - y (string) y coordinate of the point
	     = (boolean) `true` if point inside
	    \*/
                R.isPointInsideBBox = function (bbox, x, y) {
                    return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
                };
                /*\
	     * Raphael.isBBoxIntersect
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if two bounding boxes intersect
	     > Parameters
	     - bbox1 (string) first bounding box
	     - bbox2 (string) second bounding box
	     = (boolean) `true` if they intersect
	    \*/
                R.isBBoxIntersect = function (bbox1, bbox2) {
                    var i = R.isPointInsideBBox;
                    return i(bbox2, bbox1.x, bbox1.y)
                        || i(bbox2, bbox1.x2, bbox1.y)
                        || i(bbox2, bbox1.x, bbox1.y2)
                        || i(bbox2, bbox1.x2, bbox1.y2)
                        || i(bbox1, bbox2.x, bbox2.y)
                        || i(bbox1, bbox2.x2, bbox2.y)
                        || i(bbox1, bbox2.x, bbox2.y2)
                        || i(bbox1, bbox2.x2, bbox2.y2)
                        || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
                        && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
                };

                function base3(t, p1, p2, p3, p4) {
                    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
                    return t * t2 - 3 * p1 + 3 * p2;
                }

                function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
                    if (z == null) {
                        z = 1;
                    }
                    z = z > 1 ? 1 : z < 0 ? 0 : z;
                    var z2 = z / 2,
                        n = 12,
                        Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
                        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                        sum = 0;
                    for (var i = 0; i < n; i++) {
                        var ct = z2 * Tvalues[i] + z2,
                            xbase = base3(ct, x1, x2, x3, x4),
                            ybase = base3(ct, y1, y2, y3, y4),
                            comb = xbase * xbase + ybase * ybase;
                        sum += Cvalues[i] * math.sqrt(comb);
                    }
                    return z2 * sum;
                }

                function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
                    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                        return;
                    }
                    var t = 1,
                        step = t / 2,
                        t2 = t - step,
                        l,
                        e = .01;
                    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    while (abs(l - ll) > e) {
                        step /= 2;
                        t2 += (l < ll ? 1 : -1) * step;
                        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
                    }
                    return t2;
                }

                function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                    if (
                        mmax(x1, x2) < mmin(x3, x4) ||
                        mmin(x1, x2) > mmax(x3, x4) ||
                        mmax(y1, y2) < mmin(y3, y4) ||
                        mmin(y1, y2) > mmax(y3, y4)
                    ) {
                        return;
                    }
                    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                    if (!denominator) {
                        return;
                    }
                    var px = nx / denominator,
                        py = ny / denominator,
                        px2 = +px.toFixed(2),
                        py2 = +py.toFixed(2);
                    if (
                        px2 < +mmin(x1, x2).toFixed(2) ||
                        px2 > +mmax(x1, x2).toFixed(2) ||
                        px2 < +mmin(x3, x4).toFixed(2) ||
                        px2 > +mmax(x3, x4).toFixed(2) ||
                        py2 < +mmin(y1, y2).toFixed(2) ||
                        py2 > +mmax(y1, y2).toFixed(2) ||
                        py2 < +mmin(y3, y4).toFixed(2) ||
                        py2 > +mmax(y3, y4).toFixed(2)
                    ) {
                        return;
                    }
                    return {x: px, y: py};
                }

                function inter(bez1, bez2) {
                    return interHelper(bez1, bez2);
                }

                function interCount(bez1, bez2) {
                    return interHelper(bez1, bez2, 1);
                }

                function interHelper(bez1, bez2, justCount) {
                    var bbox1 = R.bezierBBox(bez1),
                        bbox2 = R.bezierBBox(bez2);
                    if (!R.isBBoxIntersect(bbox1, bbox2)) {
                        return justCount ? 0 : [];
                    }
                    var l1 = bezlen.apply(0, bez1),
                        l2 = bezlen.apply(0, bez2),
                        n1 = mmax(~~(l1 / 5), 1),
                        n2 = mmax(~~(l2 / 5), 1),
                        dots1 = [],
                        dots2 = [],
                        xy = {},
                        res = justCount ? 0 : [];
                    for (var i = 0; i < n1 + 1; i++) {
                        var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
                        dots1.push({x: p.x, y: p.y, t: i / n1});
                    }
                    for (i = 0; i < n2 + 1; i++) {
                        p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
                        dots2.push({x: p.x, y: p.y, t: i / n2});
                    }
                    for (i = 0; i < n1; i++) {
                        for (var j = 0; j < n2; j++) {
                            var di = dots1[i],
                                di1 = dots1[i + 1],
                                dj = dots2[j],
                                dj1 = dots2[j + 1],
                                ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                                cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                                is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                            if (is) {
                                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                                    continue;
                                }
                                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                                var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                                    t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                                    if (justCount) {
                                        res++;
                                    } else {
                                        res.push({
                                            x: is.x,
                                            y: is.y,
                                            t1: mmin(t1, 1),
                                            t2: mmin(t2, 1)
                                        });
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                /*\
	     * Raphael.pathIntersection
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds intersections of two paths
	     > Parameters
	     - path1 (string) path string
	     - path2 (string) path string
	     = (array) dots of intersection
	     o [
	     o     {
	     o         x: (number) x coordinate of the point
	     o         y: (number) y coordinate of the point
	     o         t1: (number) t value for segment of path1
	     o         t2: (number) t value for segment of path2
	     o         segment1: (number) order number for segment of path1
	     o         segment2: (number) order number for segment of path2
	     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1
	     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
	     o     }
	     o ]
	    \*/
                R.pathIntersection = function (path1, path2) {
                    return interPathHelper(path1, path2);
                };
                R.pathIntersectionNumber = function (path1, path2) {
                    return interPathHelper(path1, path2, 1);
                };

                function interPathHelper(path1, path2, justCount) {
                    path1 = R._path2curve(path1);
                    path2 = R._path2curve(path2);
                    var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
                        res = justCount ? 0 : [];
                    for (var i = 0, ii = path1.length; i < ii; i++) {
                        var pi = path1[i];
                        if (pi[0] == "M") {
                            x1 = x1m = pi[1];
                            y1 = y1m = pi[2];
                        } else {
                            if (pi[0] == "C") {
                                bez1 = [x1, y1].concat(pi.slice(1));
                                x1 = bez1[6];
                                y1 = bez1[7];
                            } else {
                                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                                x1 = x1m;
                                y1 = y1m;
                            }
                            for (var j = 0, jj = path2.length; j < jj; j++) {
                                var pj = path2[j];
                                if (pj[0] == "M") {
                                    x2 = x2m = pj[1];
                                    y2 = y2m = pj[2];
                                } else {
                                    if (pj[0] == "C") {
                                        bez2 = [x2, y2].concat(pj.slice(1));
                                        x2 = bez2[6];
                                        y2 = bez2[7];
                                    } else {
                                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                        x2 = x2m;
                                        y2 = y2m;
                                    }
                                    var intr = interHelper(bez1, bez2, justCount);
                                    if (justCount) {
                                        res += intr;
                                    } else {
                                        for (var k = 0, kk = intr.length; k < kk; k++) {
                                            intr[k].segment1 = i;
                                            intr[k].segment2 = j;
                                            intr[k].bez1 = bez1;
                                            intr[k].bez2 = bez2;
                                        }
                                        res = res.concat(intr);
                                    }
                                }
                            }
                        }
                    }
                    return res;
                }

                /*\
	     * Raphael.isPointInsidePath
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside a given closed path.
	     > Parameters
	     - path (string) path string
	     - x (number) x of the point
	     - y (number) y of the point
	     = (boolean) true, if point is inside the path
	    \*/
                R.isPointInsidePath = function (path, x, y) {
                    var bbox = R.pathBBox(path);
                    return R.isPointInsideBBox(bbox, x, y) &&
                        interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
                };
                R._removedFactory = function (methodname) {
                    return function () {
                        eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
                    };
                };
                /*\
	     * Raphael.pathBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Return bounding box of a given path
	     > Parameters
	     - path (string) path string
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box
	     o     y: (number) y coordinate of the left top point of the box
	     o     x2: (number) x coordinate of the right bottom point of the box
	     o     y2: (number) y coordinate of the right bottom point of the box
	     o     width: (number) width of the box
	     o     height: (number) height of the box
	     o     cx: (number) x coordinate of the center of the box
	     o     cy: (number) y coordinate of the center of the box
	     o }
	    \*/
                var pathDimensions = R.pathBBox = function (path) {
                        var pth = paths(path);
                        if (pth.bbox) {
                            return clone(pth.bbox);
                        }
                        if (!path) {
                            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
                        }
                        path = path2curve(path);
                        var x = 0,
                            y = 0,
                            X = [],
                            Y = [],
                            p;
                        for (var i = 0, ii = path.length; i < ii; i++) {
                            p = path[i];
                            if (p[0] == "M") {
                                x = p[1];
                                y = p[2];
                                X.push(x);
                                Y.push(y);
                            } else {
                                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                X = X[concat](dim.min.x, dim.max.x);
                                Y = Y[concat](dim.min.y, dim.max.y);
                                x = p[5];
                                y = p[6];
                            }
                        }
                        var xmin = mmin[apply](0, X),
                            ymin = mmin[apply](0, Y),
                            xmax = mmax[apply](0, X),
                            ymax = mmax[apply](0, Y),
                            width = xmax - xmin,
                            height = ymax - ymin,
                            bb = {
                                x: xmin,
                                y: ymin,
                                x2: xmax,
                                y2: ymax,
                                width: width,
                                height: height,
                                cx: xmin + width / 2,
                                cy: ymin + height / 2
                            };
                        pth.bbox = clone(bb);
                        return bb;
                    },
                    pathClone = function (pathArray) {
                        var res = clone(pathArray);
                        res.toString = R._path2string;
                        return res;
                    },
                    pathToRelative = R._pathToRelative = function (pathArray) {
                        var pth = paths(pathArray);
                        if (pth.rel) {
                            return pathClone(pth.rel);
                        }
                        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                            pathArray = R.parsePathString(pathArray);
                        }
                        var res = [],
                            x = 0,
                            y = 0,
                            mx = 0,
                            my = 0,
                            start = 0;
                        if (pathArray[0][0] == "M") {
                            x = pathArray[0][1];
                            y = pathArray[0][2];
                            mx = x;
                            my = y;
                            start++;
                            res.push(["M", x, y]);
                        }
                        for (var i = start, ii = pathArray.length; i < ii; i++) {
                            var r = res[i] = [],
                                pa = pathArray[i];
                            if (pa[0] != lowerCase.call(pa[0])) {
                                r[0] = lowerCase.call(pa[0]);
                                switch (r[0]) {
                                    case "a":
                                        r[1] = pa[1];
                                        r[2] = pa[2];
                                        r[3] = pa[3];
                                        r[4] = pa[4];
                                        r[5] = pa[5];
                                        r[6] = +(pa[6] - x).toFixed(3);
                                        r[7] = +(pa[7] - y).toFixed(3);
                                        break;
                                    case "v":
                                        r[1] = +(pa[1] - y).toFixed(3);
                                        break;
                                    case "m":
                                        mx = pa[1];
                                        my = pa[2];
                                    default:
                                        for (var j = 1, jj = pa.length; j < jj; j++) {
                                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                                        }
                                }
                            } else {
                                r = res[i] = [];
                                if (pa[0] == "m") {
                                    mx = pa[1] + x;
                                    my = pa[2] + y;
                                }
                                for (var k = 0, kk = pa.length; k < kk; k++) {
                                    res[i][k] = pa[k];
                                }
                            }
                            var len = res[i].length;
                            switch (res[i][0]) {
                                case "z":
                                    x = mx;
                                    y = my;
                                    break;
                                case "h":
                                    x += +res[i][len - 1];
                                    break;
                                case "v":
                                    y += +res[i][len - 1];
                                    break;
                                default:
                                    x += +res[i][len - 2];
                                    y += +res[i][len - 1];
                            }
                        }
                        res.toString = R._path2string;
                        pth.rel = pathClone(res);
                        return res;
                    },
                    pathToAbsolute = R._pathToAbsolute = function (pathArray) {
                        var pth = paths(pathArray);
                        if (pth.abs) {
                            return pathClone(pth.abs);
                        }
                        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                            pathArray = R.parsePathString(pathArray);
                        }
                        if (!pathArray || !pathArray.length) {
                            return [["M", 0, 0]];
                        }
                        var res = [],
                            x = 0,
                            y = 0,
                            mx = 0,
                            my = 0,
                            start = 0;
                        if (pathArray[0][0] == "M") {
                            x = +pathArray[0][1];
                            y = +pathArray[0][2];
                            mx = x;
                            my = y;
                            start++;
                            res[0] = ["M", x, y];
                        }
                        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
                        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                            res.push(r = []);
                            pa = pathArray[i];
                            if (pa[0] != upperCase.call(pa[0])) {
                                r[0] = upperCase.call(pa[0]);
                                switch (r[0]) {
                                    case "A":
                                        r[1] = pa[1];
                                        r[2] = pa[2];
                                        r[3] = pa[3];
                                        r[4] = pa[4];
                                        r[5] = pa[5];
                                        r[6] = +(pa[6] + x);
                                        r[7] = +(pa[7] + y);
                                        break;
                                    case "V":
                                        r[1] = +pa[1] + y;
                                        break;
                                    case "H":
                                        r[1] = +pa[1] + x;
                                        break;
                                    case "R":
                                        var dots = [x, y][concat](pa.slice(1));
                                        for (var j = 2, jj = dots.length; j < jj; j++) {
                                            dots[j] = +dots[j] + x;
                                            dots[++j] = +dots[j] + y;
                                        }
                                        res.pop();
                                        res = res[concat](catmullRom2bezier(dots, crz));
                                        break;
                                    case "M":
                                        mx = +pa[1] + x;
                                        my = +pa[2] + y;
                                    default:
                                        for (j = 1, jj = pa.length; j < jj; j++) {
                                            r[j] = +pa[j] + ((j % 2) ? x : y);
                                        }
                                }
                            } else if (pa[0] == "R") {
                                dots = [x, y][concat](pa.slice(1));
                                res.pop();
                                res = res[concat](catmullRom2bezier(dots, crz));
                                r = ["R"][concat](pa.slice(-2));
                            } else {
                                for (var k = 0, kk = pa.length; k < kk; k++) {
                                    r[k] = pa[k];
                                }
                            }
                            switch (r[0]) {
                                case "Z":
                                    x = mx;
                                    y = my;
                                    break;
                                case "H":
                                    x = r[1];
                                    break;
                                case "V":
                                    y = r[1];
                                    break;
                                case "M":
                                    mx = r[r.length - 2];
                                    my = r[r.length - 1];
                                default:
                                    x = r[r.length - 2];
                                    y = r[r.length - 1];
                            }
                        }
                        res.toString = R._path2string;
                        pth.abs = pathClone(res);
                        return res;
                    },
                    l2c = function (x1, y1, x2, y2) {
                        return [x1, y1, x2, y2, x2, y2];
                    },
                    q2c = function (x1, y1, ax, ay, x2, y2) {
                        var _13 = 1 / 3,
                            _23 = 2 / 3;
                        return [
                            _13 * x1 + _23 * ax,
                            _13 * y1 + _23 * ay,
                            _13 * x2 + _23 * ax,
                            _13 * y2 + _23 * ay,
                            x2,
                            y2
                        ];
                    },
                    a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
                        // for more information of where this math came from visit:
                        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                        var _120 = PI * 120 / 180,
                            rad = PI / 180 * (+angle || 0),
                            res = [],
                            xy,
                            rotate = cacher(function (x, y, rad) {
                                var X = x * math.cos(rad) - y * math.sin(rad),
                                    Y = x * math.sin(rad) + y * math.cos(rad);
                                return {x: X, y: Y};
                            });
                        if (!recursive) {
                            xy = rotate(x1, y1, -rad);
                            x1 = xy.x;
                            y1 = xy.y;
                            xy = rotate(x2, y2, -rad);
                            x2 = xy.x;
                            y2 = xy.y;
                            var cos = math.cos(PI / 180 * angle),
                                sin = math.sin(PI / 180 * angle),
                                x = (x1 - x2) / 2,
                                y = (y1 - y2) / 2;
                            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                            if (h > 1) {
                                h = math.sqrt(h);
                                rx = h * rx;
                                ry = h * ry;
                            }
                            var rx2 = rx * rx,
                                ry2 = ry * ry,
                                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                                cx = k * rx * y / ry + (x1 + x2) / 2,
                                cy = k * -ry * x / rx + (y1 + y2) / 2,
                                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                            f1 = x1 < cx ? PI - f1 : f1;
                            f2 = x2 < cx ? PI - f2 : f2;
                            f1 < 0 && (f1 = PI * 2 + f1);
                            f2 < 0 && (f2 = PI * 2 + f2);
                            if (sweep_flag && f1 > f2) {
                                f1 = f1 - PI * 2;
                            }
                            if (!sweep_flag && f2 > f1) {
                                f2 = f2 - PI * 2;
                            }
                        } else {
                            f1 = recursive[0];
                            f2 = recursive[1];
                            cx = recursive[2];
                            cy = recursive[3];
                        }
                        var df = f2 - f1;
                        if (abs(df) > _120) {
                            var f2old = f2,
                                x2old = x2,
                                y2old = y2;
                            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                            x2 = cx + rx * math.cos(f2);
                            y2 = cy + ry * math.sin(f2);
                            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
                        }
                        df = f2 - f1;
                        var c1 = math.cos(f1),
                            s1 = math.sin(f1),
                            c2 = math.cos(f2),
                            s2 = math.sin(f2),
                            t = math.tan(df / 4),
                            hx = 4 / 3 * rx * t,
                            hy = 4 / 3 * ry * t,
                            m1 = [x1, y1],
                            m2 = [x1 + hx * s1, y1 - hy * c1],
                            m3 = [x2 + hx * s2, y2 - hy * c2],
                            m4 = [x2, y2];
                        m2[0] = 2 * m1[0] - m2[0];
                        m2[1] = 2 * m1[1] - m2[1];
                        if (recursive) {
                            return [m2, m3, m4][concat](res);
                        } else {
                            res = [m2, m3, m4][concat](res).join()[split](",");
                            var newres = [];
                            for (var i = 0, ii = res.length; i < ii; i++) {
                                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                            }
                            return newres;
                        }
                    },
                    findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
                        var t1 = 1 - t;
                        return {
                            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
                        };
                    },
                    curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                        var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                            b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                            c = p1x - c1x,
                            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                            y = [p1y, p2y],
                            x = [p1x, p2x],
                            dot;
                        abs(t1) > "1e12" && (t1 = .5);
                        abs(t2) > "1e12" && (t2 = .5);
                        if (t1 > 0 && t1 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        if (t2 > 0 && t2 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
                        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
                        c = p1y - c1y;
                        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
                        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
                        abs(t1) > "1e12" && (t1 = .5);
                        abs(t2) > "1e12" && (t2 = .5);
                        if (t1 > 0 && t1 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        if (t2 > 0 && t2 < 1) {
                            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                            x.push(dot.x);
                            y.push(dot.y);
                        }
                        return {
                            min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                            max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
                        };
                    }),
                    path2curve = R._path2curve = cacher(function (path, path2) {
                        var pth = !path2 && paths(path);
                        if (!path2 && pth.curve) {
                            return pathClone(pth.curve);
                        }
                        var p = pathToAbsolute(path),
                            p2 = path2 && pathToAbsolute(path2),
                            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                            processPath = function (path, d, pcom) {
                                var nx, ny, tq = {T: 1, Q: 1};
                                if (!path) {
                                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                                }
                                !(path[0] in tq) && (d.qx = d.qy = null);
                                switch (path[0]) {
                                    case "M":
                                        d.X = path[1];
                                        d.Y = path[2];
                                        break;
                                    case "A":
                                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                                        break;
                                    case "S":
                                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                            nx = d.x * 2 - d.bx;          // And reflect the previous
                                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                                        }
                                        else {                            // or some else or nothing
                                            nx = d.x;
                                            ny = d.y;
                                        }
                                        path = ["C", nx, ny][concat](path.slice(1));
                                        break;
                                    case "T":
                                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                            d.qy = d.y * 2 - d.qy;        // to case "S".
                                        }
                                        else {                            // or something else or nothing
                                            d.qx = d.x;
                                            d.qy = d.y;
                                        }
                                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                                        break;
                                    case "Q":
                                        d.qx = path[1];
                                        d.qy = path[2];
                                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                                        break;
                                    case "L":
                                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                                        break;
                                    case "H":
                                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                                        break;
                                    case "V":
                                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                                        break;
                                    case "Z":
                                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                                        break;
                                }
                                return path;
                            },
                            fixArc = function (pp, i) {
                                if (pp[i].length > 7) {
                                    pp[i].shift();
                                    var pi = pp[i];
                                    while (pi.length) {
                                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                                        p2 && (pcoms2[i] = "A"); // the same as above
                                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                                    }
                                    pp.splice(i, 1);
                                    ii = mmax(p.length, p2 && p2.length || 0);
                                }
                            },
                            fixM = function (path1, path2, a1, a2, i) {
                                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                                    a1.bx = 0;
                                    a1.by = 0;
                                    a1.x = path1[i][1];
                                    a1.y = path1[i][2];
                                    ii = mmax(p.length, p2 && p2.length || 0);
                                }
                            },
                            pcoms1 = [], // path commands of original path p
                            pcoms2 = [], // path commands of original path p2
                            pfirst = "", // temporary holder for original path command
                            pcom = ""; // holder for previous path command of original path
                        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                            p[i] && (pfirst = p[i][0]); // save current path command

                            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                            {
                                pcoms1[i] = pfirst; // Save current path command
                                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
                            }
                            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                            // which may produce multiple C:s
                            // so we have to make sure that C is also C in original path

                            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                            if (p2) { // the same procedures is done to p2
                                p2[i] && (pfirst = p2[i][0]);
                                if (pfirst != "C") {
                                    pcoms2[i] = pfirst;
                                    i && (pcom = pcoms2[i - 1]);
                                }
                                p2[i] = processPath(p2[i], attrs2, pcom);

                                if (pcoms2[i] != "A" && pfirst == "C") pcoms2[i] = "C";

                                fixArc(p2, i);
                            }
                            fixM(p, p2, attrs, attrs2, i);
                            fixM(p2, p, attrs2, attrs, i);
                            var seg = p[i],
                                seg2 = p2 && p2[i],
                                seglen = seg.length,
                                seg2len = p2 && seg2.length;
                            attrs.x = seg[seglen - 2];
                            attrs.y = seg[seglen - 1];
                            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                            attrs2.x = p2 && seg2[seg2len - 2];
                            attrs2.y = p2 && seg2[seg2len - 1];
                        }
                        if (!p2) {
                            pth.curve = pathClone(p);
                        }
                        return p2 ? [p, p2] : p;
                    }, null, pathClone),
                    parseDots = R._parseDots = cacher(function (gradient) {
                        var dots = [];
                        for (var i = 0, ii = gradient.length; i < ii; i++) {
                            var dot = {},
                                par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                            dot.color = R.getRGB(par[1]);
                            if (dot.color.error) {
                                return null;
                            }
                            dot.opacity = dot.color.opacity;
                            dot.color = dot.color.hex;
                            par[2] && (dot.offset = par[2] + "%");
                            dots.push(dot);
                        }
                        for (i = 1, ii = dots.length - 1; i < ii; i++) {
                            if (!dots[i].offset) {
                                var start = toFloat(dots[i - 1].offset || 0),
                                    end = 0;
                                for (var j = i + 1; j < ii; j++) {
                                    if (dots[j].offset) {
                                        end = dots[j].offset;
                                        break;
                                    }
                                }
                                if (!end) {
                                    end = 100;
                                    j = ii;
                                }
                                end = toFloat(end);
                                var d = (end - start) / (j - i + 1);
                                for (; i < j; i++) {
                                    start += d;
                                    dots[i].offset = start + "%";
                                }
                            }
                        }
                        return dots;
                    }),
                    tear = R._tear = function (el, paper) {
                        el == paper.top && (paper.top = el.prev);
                        el == paper.bottom && (paper.bottom = el.next);
                        el.next && (el.next.prev = el.prev);
                        el.prev && (el.prev.next = el.next);
                    },
                    tofront = R._tofront = function (el, paper) {
                        if (paper.top === el) {
                            return;
                        }
                        tear(el, paper);
                        el.next = null;
                        el.prev = paper.top;
                        paper.top.next = el;
                        paper.top = el;
                    },
                    toback = R._toback = function (el, paper) {
                        if (paper.bottom === el) {
                            return;
                        }
                        tear(el, paper);
                        el.next = paper.bottom;
                        el.prev = null;
                        paper.bottom.prev = el;
                        paper.bottom = el;
                    },
                    insertafter = R._insertafter = function (el, el2, paper) {
                        tear(el, paper);
                        el2 == paper.top && (paper.top = el);
                        el2.next && (el2.next.prev = el);
                        el.next = el2.next;
                        el.prev = el2;
                        el2.next = el;
                    },
                    insertbefore = R._insertbefore = function (el, el2, paper) {
                        tear(el, paper);
                        el2 == paper.bottom && (paper.bottom = el);
                        el2.prev && (el2.prev.next = el);
                        el.prev = el2.prev;
                        el2.prev = el;
                        el.next = el2;
                    },
                    /*\
	         * Raphael.toMatrix
	         [ method ]
	         **
	         * Utility method
	         **
	         * Returns matrix of transformations applied to a given path
	         > Parameters
	         - path (string) path string
	         - transform (string|array) transformation string
	         = (object) @Matrix
	        \*/
                    toMatrix = R.toMatrix = function (path, transform) {
                        var bb = pathDimensions(path),
                            el = {
                                _: {
                                    transform: E
                                },
                                getBBox: function () {
                                    return bb;
                                }
                            };
                        extractTransform(el, transform);
                        return el.matrix;
                    },
                    /*\
	         * Raphael.transformPath
	         [ method ]
	         **
	         * Utility method
	         **
	         * Returns path transformed by a given transformation
	         > Parameters
	         - path (string) path string
	         - transform (string|array) transformation string
	         = (string) path
	        \*/
                    transformPath = R.transformPath = function (path, transform) {
                        return mapPath(path, toMatrix(path, transform));
                    },
                    extractTransform = R._extractTransform = function (el, tstr) {
                        if (tstr == null) {
                            return el._.transform;
                        }
                        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
                        var tdata = R.parseTransformString(tstr),
                            deg = 0,
                            dx = 0,
                            dy = 0,
                            sx = 1,
                            sy = 1,
                            _ = el._,
                            m = new Matrix;
                        _.transform = tdata || [];
                        if (tdata) {
                            for (var i = 0, ii = tdata.length; i < ii; i++) {
                                var t = tdata[i],
                                    tlen = t.length,
                                    command = Str(t[0]).toLowerCase(),
                                    absolute = t[0] != command,
                                    inver = absolute ? m.invert() : 0,
                                    x1,
                                    y1,
                                    x2,
                                    y2,
                                    bb;
                                if (command == "t" && tlen == 3) {
                                    if (absolute) {
                                        x1 = inver.x(0, 0);
                                        y1 = inver.y(0, 0);
                                        x2 = inver.x(t[1], t[2]);
                                        y2 = inver.y(t[1], t[2]);
                                        m.translate(x2 - x1, y2 - y1);
                                    } else {
                                        m.translate(t[1], t[2]);
                                    }
                                } else if (command == "r") {
                                    if (tlen == 2) {
                                        bb = bb || el.getBBox(1);
                                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                        deg += t[1];
                                    } else if (tlen == 4) {
                                        if (absolute) {
                                            x2 = inver.x(t[2], t[3]);
                                            y2 = inver.y(t[2], t[3]);
                                            m.rotate(t[1], x2, y2);
                                        } else {
                                            m.rotate(t[1], t[2], t[3]);
                                        }
                                        deg += t[1];
                                    }
                                } else if (command == "s") {
                                    if (tlen == 2 || tlen == 3) {
                                        bb = bb || el.getBBox(1);
                                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                                        sx *= t[1];
                                        sy *= t[tlen - 1];
                                    } else if (tlen == 5) {
                                        if (absolute) {
                                            x2 = inver.x(t[3], t[4]);
                                            y2 = inver.y(t[3], t[4]);
                                            m.scale(t[1], t[2], x2, y2);
                                        } else {
                                            m.scale(t[1], t[2], t[3], t[4]);
                                        }
                                        sx *= t[1];
                                        sy *= t[2];
                                    }
                                } else if (command == "m" && tlen == 7) {
                                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                                }
                                _.dirtyT = 1;
                                el.matrix = m;
                            }
                        }

                        /*\
	             * Element.matrix
	             [ property (object) ]
	             **
	             * Keeps @Matrix object, which represents element transformation
	            \*/
                        el.matrix = m;

                        _.sx = sx;
                        _.sy = sy;
                        _.deg = deg;
                        _.dx = dx = m.e;
                        _.dy = dy = m.f;

                        if (sx == 1 && sy == 1 && !deg && _.bbox) {
                            _.bbox.x += +dx;
                            _.bbox.y += +dy;
                        } else {
                            _.dirtyT = 1;
                        }
                    },
                    getEmpty = function (item) {
                        var l = item[0];
                        switch (l.toLowerCase()) {
                            case "t":
                                return [l, 0, 0];
                            case "m":
                                return [l, 1, 0, 0, 1, 0, 0];
                            case "r":
                                if (item.length == 4) {
                                    return [l, 0, item[2], item[3]];
                                } else {
                                    return [l, 0];
                                }
                            case "s":
                                if (item.length == 5) {
                                    return [l, 1, 1, item[3], item[4]];
                                } else if (item.length == 3) {
                                    return [l, 1, 1];
                                } else {
                                    return [l, 1];
                                }
                        }
                    },
                    equaliseTransform = R._equaliseTransform = function (t1, t2) {
                        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
                        t1 = R.parseTransformString(t1) || [];
                        t2 = R.parseTransformString(t2) || [];
                        var maxlength = mmax(t1.length, t2.length),
                            from = [],
                            to = [],
                            i = 0, j, jj,
                            tt1, tt2;
                        for (; i < maxlength; i++) {
                            tt1 = t1[i] || getEmpty(t2[i]);
                            tt2 = t2[i] || getEmpty(tt1);
                            if ((tt1[0] != tt2[0]) ||
                                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                            ) {
                                return;
                            }
                            from[i] = [];
                            to[i] = [];
                            for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                                j in tt1 && (from[i][j] = tt1[j]);
                                j in tt2 && (to[i][j] = tt2[j]);
                            }
                        }
                        return {
                            from: from,
                            to: to
                        };
                    };
                R._getContainer = function (x, y, w, h) {
                    var container;
                    container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
                    if (container == null) {
                        return;
                    }
                    if (container.tagName) {
                        if (y == null) {
                            return {
                                container: container,
                                width: container.style.pixelWidth || container.offsetWidth,
                                height: container.style.pixelHeight || container.offsetHeight
                            };
                        } else {
                            return {
                                container: container,
                                width: y,
                                height: w
                            };
                        }
                    }
                    return {
                        container: 1,
                        x: x,
                        y: y,
                        width: w,
                        height: h
                    };
                };
                /*\
	     * Raphael.pathToRelative
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to relative form
	     > Parameters
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments.
	    \*/
                R.pathToRelative = pathToRelative;
                R._engine = {};
                /*\
	     * Raphael.path2curve
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to a new path where all segments are cubic bezier curves.
	     > Parameters
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments.
	    \*/
                R.path2curve = path2curve;
                /*\
	     * Raphael.matrix
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns matrix based on given parameters.
	     > Parameters
	     - a (number)
	     - b (number)
	     - c (number)
	     - d (number)
	     - e (number)
	     - f (number)
	     = (object) @Matrix
	    \*/
                R.matrix = function (a, b, c, d, e, f) {
                    return new Matrix(a, b, c, d, e, f);
                };

                function Matrix(a, b, c, d, e, f) {
                    if (a != null) {
                        this.a = +a;
                        this.b = +b;
                        this.c = +c;
                        this.d = +d;
                        this.e = +e;
                        this.f = +f;
                    } else {
                        this.a = 1;
                        this.b = 0;
                        this.c = 0;
                        this.d = 1;
                        this.e = 0;
                        this.f = 0;
                    }
                }

                (function (matrixproto) {
                    /*\
	         * Matrix.add
	         [ method ]
	         **
	         * Adds given matrix to existing one.
	         > Parameters
	         - a (number)
	         - b (number)
	         - c (number)
	         - d (number)
	         - e (number)
	         - f (number)
	         or
	         - matrix (object) @Matrix
	        \*/
                    matrixproto.add = function (a, b, c, d, e, f) {
                        var out = [[], [], []],
                            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                            x, y, z, res;

                        if (a && a instanceof Matrix) {
                            matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
                        }

                        for (x = 0; x < 3; x++) {
                            for (y = 0; y < 3; y++) {
                                res = 0;
                                for (z = 0; z < 3; z++) {
                                    res += m[x][z] * matrix[z][y];
                                }
                                out[x][y] = res;
                            }
                        }
                        this.a = out[0][0];
                        this.b = out[1][0];
                        this.c = out[0][1];
                        this.d = out[1][1];
                        this.e = out[0][2];
                        this.f = out[1][2];
                    };
                    /*\
	         * Matrix.invert
	         [ method ]
	         **
	         * Returns inverted version of the matrix
	         = (object) @Matrix
	        \*/
                    matrixproto.invert = function () {
                        var me = this,
                            x = me.a * me.d - me.b * me.c;
                        return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
                    };
                    /*\
	         * Matrix.clone
	         [ method ]
	         **
	         * Returns copy of the matrix
	         = (object) @Matrix
	        \*/
                    matrixproto.clone = function () {
                        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
                    };
                    /*\
	         * Matrix.translate
	         [ method ]
	         **
	         * Translate the matrix
	         > Parameters
	         - x (number)
	         - y (number)
	        \*/
                    matrixproto.translate = function (x, y) {
                        this.add(1, 0, 0, 1, x, y);
                    };
                    /*\
	         * Matrix.scale
	         [ method ]
	         **
	         * Scales the matrix
	         > Parameters
	         - x (number)
	         - y (number) #optional
	         - cx (number) #optional
	         - cy (number) #optional
	        \*/
                    matrixproto.scale = function (x, y, cx, cy) {
                        y == null && (y = x);
                        (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
                        this.add(x, 0, 0, y, 0, 0);
                        (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
                    };
                    /*\
	         * Matrix.rotate
	         [ method ]
	         **
	         * Rotates the matrix
	         > Parameters
	         - a (number)
	         - x (number)
	         - y (number)
	        \*/
                    matrixproto.rotate = function (a, x, y) {
                        a = R.rad(a);
                        x = x || 0;
                        y = y || 0;
                        var cos = +math.cos(a).toFixed(9),
                            sin = +math.sin(a).toFixed(9);
                        this.add(cos, sin, -sin, cos, x, y);
                        this.add(1, 0, 0, 1, -x, -y);
                    };
                    /*\
	         * Matrix.x
	         [ method ]
	         **
	         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
	         > Parameters
	         - x (number)
	         - y (number)
	         = (number) x
	        \*/
                    matrixproto.x = function (x, y) {
                        return x * this.a + y * this.c + this.e;
                    };
                    /*\
	         * Matrix.y
	         [ method ]
	         **
	         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
	         > Parameters
	         - x (number)
	         - y (number)
	         = (number) y
	        \*/
                    matrixproto.y = function (x, y) {
                        return x * this.b + y * this.d + this.f;
                    };
                    matrixproto.get = function (i) {
                        return +this[Str.fromCharCode(97 + i)].toFixed(4);
                    };
                    matrixproto.toString = function () {
                        return R.svg ?
                            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                            [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
                    };
                    matrixproto.toFilter = function () {
                        return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                            ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                            ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
                    };
                    matrixproto.offset = function () {
                        return [this.e.toFixed(4), this.f.toFixed(4)];
                    };

                    function norm(a) {
                        return a[0] * a[0] + a[1] * a[1];
                    }

                    function normalize(a) {
                        var mag = math.sqrt(norm(a));
                        a[0] && (a[0] /= mag);
                        a[1] && (a[1] /= mag);
                    }

                    /*\
	         * Matrix.split
	         [ method ]
	         **
	         * Splits matrix into primitive transformations
	         = (object) in format:
	         o dx (number) translation by x
	         o dy (number) translation by y
	         o scalex (number) scale by x
	         o scaley (number) scale by y
	         o shear (number) shear
	         o rotate (number) rotation in deg
	         o isSimple (boolean) could it be represented via simple transformations
	        \*/
                    matrixproto.split = function () {
                        var out = {};
                        // translation
                        out.dx = this.e;
                        out.dy = this.f;

                        // scale and shear
                        var row = [[this.a, this.c], [this.b, this.d]];
                        out.scalex = math.sqrt(norm(row[0]));
                        normalize(row[0]);

                        out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
                        row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

                        out.scaley = math.sqrt(norm(row[1]));
                        normalize(row[1]);
                        out.shear /= out.scaley;

                        // rotation
                        var sin = -row[0][1],
                            cos = row[1][1];
                        if (cos < 0) {
                            out.rotate = R.deg(math.acos(cos));
                            if (sin < 0) {
                                out.rotate = 360 - out.rotate;
                            }
                        } else {
                            out.rotate = R.deg(math.asin(sin));
                        }

                        out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
                        out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
                        out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
                        return out;
                    };
                    /*\
	         * Matrix.toTransformString
	         [ method ]
	         **
	         * Return transform string that represents given matrix
	         = (string) transform string
	        \*/
                    matrixproto.toTransformString = function (shorter) {
                        var s = shorter || this[split]();
                        if (s.isSimple) {
                            s.scalex = +s.scalex.toFixed(4);
                            s.scaley = +s.scaley.toFixed(4);
                            s.rotate = +s.rotate.toFixed(4);
                            return (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                                (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                                (s.rotate ? "r" + [s.rotate, 0, 0] : E);
                        } else {
                            return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
                        }
                    };
                })(Matrix.prototype);

                var preventDefault = function () {
                        this.returnValue = false;
                    },
                    preventTouch = function () {
                        return this.originalEvent.preventDefault();
                    },
                    stopPropagation = function () {
                        this.cancelBubble = true;
                    },
                    stopTouch = function () {
                        return this.originalEvent.stopPropagation();
                    },
                    getEventPosition = function (e) {
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

                        return {
                            x: e.clientX + scrollX,
                            y: e.clientY + scrollY
                        };
                    },
                    addEvent = (function () {
                        if (g.doc.addEventListener) {
                            return function (obj, type, fn, element) {
                                var f = function (e) {
                                    var pos = getEventPosition(e);
                                    return fn.call(element, e, pos.x, pos.y);
                                };
                                obj.addEventListener(type, f, false);

                                if (supportsTouch && touchMap[type]) {
                                    var _f = function (e) {
                                        var pos = getEventPosition(e),
                                            olde = e;

                                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                            if (e.targetTouches[i].target == obj) {
                                                e = e.targetTouches[i];
                                                e.originalEvent = olde;
                                                e.preventDefault = preventTouch;
                                                e.stopPropagation = stopTouch;
                                                break;
                                            }
                                        }

                                        return fn.call(element, e, pos.x, pos.y);
                                    };
                                    obj.addEventListener(touchMap[type], _f, false);
                                }

                                return function () {
                                    obj.removeEventListener(type, f, false);

                                    if (supportsTouch && touchMap[type])
                                        obj.removeEventListener(touchMap[type], _f, false);

                                    return true;
                                };
                            };
                        } else if (g.doc.attachEvent) {
                            return function (obj, type, fn, element) {
                                var f = function (e) {
                                    e = e || g.win.event;
                                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                                        x = e.clientX + scrollX,
                                        y = e.clientY + scrollY;
                                    e.preventDefault = e.preventDefault || preventDefault;
                                    e.stopPropagation = e.stopPropagation || stopPropagation;
                                    return fn.call(element, e, x, y);
                                };
                                obj.attachEvent("on" + type, f);
                                var detacher = function () {
                                    obj.detachEvent("on" + type, f);
                                    return true;
                                };
                                return detacher;
                            };
                        }
                    })(),
                    drag = [],
                    dragMove = function (e) {
                        var x = e.clientX,
                            y = e.clientY,
                            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            dragi,
                            j = drag.length;
                        while (j--) {
                            dragi = drag[j];
                            if (supportsTouch && e.touches) {
                                var i = e.touches.length,
                                    touch;
                                while (i--) {
                                    touch = e.touches[i];
                                    if (touch.identifier == dragi.el._drag.id) {
                                        x = touch.clientX;
                                        y = touch.clientY;
                                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                                        break;
                                    }
                                }
                            } else {
                                e.preventDefault();
                            }
                            var node = dragi.el.node,
                                o,
                                next = node.nextSibling,
                                parent = node.parentNode,
                                display = node.style.display;
                            g.win.opera && parent.removeChild(node);
                            node.style.display = "none";
                            o = dragi.el.paper.getElementByPoint(x, y);
                            node.style.display = display;
                            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                            x += scrollX;
                            y += scrollY;
                            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
                        }
                    },
                    dragUp = function (e) {
                        R.unmousemove(dragMove).unmouseup(dragUp);
                        var i = drag.length,
                            dragi;
                        while (i--) {
                            dragi = drag[i];
                            dragi.el._drag = {};
                            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
                        }
                        drag = [];
                    },
                    /*\
	     * Raphael.el
	     [ property (object) ]
	     **
	     * You can add your own method to elements. This is useful when you want to hack default functionality or
	     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
	     * you can redefine element method at any time. Expending element methods wouldnt affect set.
	     > Usage
	     | Raphael.el.red = function () {
	     |     this.attr({fill: "#f00"});
	     | };
	     | // then use it
	     | paper.circle(100, 100, 20).red();
	    \*/
                    elproto = R.el = {};
                /*\
	     * Element.click
	     [ method ]
	     **
	     * Adds event handler for click for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unclick
	     [ method ]
	     **
	     * Removes event handler for click for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.dblclick
	     [ method ]
	     **
	     * Adds event handler for double click for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.undblclick
	     [ method ]
	     **
	     * Removes event handler for double click for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mousedown
	     [ method ]
	     **
	     * Adds event handler for mousedown for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmousedown
	     [ method ]
	     **
	     * Removes event handler for mousedown for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mousemove
	     [ method ]
	     **
	     * Adds event handler for mousemove for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmousemove
	     [ method ]
	     **
	     * Removes event handler for mousemove for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseout
	     [ method ]
	     **
	     * Adds event handler for mouseout for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseout
	     [ method ]
	     **
	     * Removes event handler for mouseout for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseover
	     [ method ]
	     **
	     * Adds event handler for mouseover for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseover
	     [ method ]
	     **
	     * Removes event handler for mouseover for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.mouseup
	     [ method ]
	     **
	     * Adds event handler for mouseup for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.unmouseup
	     [ method ]
	     **
	     * Removes event handler for mouseup for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchstart
	     [ method ]
	     **
	     * Adds event handler for touchstart for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchstart
	     [ method ]
	     **
	     * Removes event handler for touchstart for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchmove
	     [ method ]
	     **
	     * Adds event handler for touchmove for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchmove
	     [ method ]
	     **
	     * Removes event handler for touchmove for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchend
	     [ method ]
	     **
	     * Adds event handler for touchend for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchend
	     [ method ]
	     **
	     * Removes event handler for touchend for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/

                /*\
	     * Element.touchcancel
	     [ method ]
	     **
	     * Adds event handler for touchcancel for the element.
	     > Parameters
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
                /*\
	     * Element.untouchcancel
	     [ method ]
	     **
	     * Removes event handler for touchcancel for the element.
	     > Parameters
	     - handler (function) #optional handler for the event
	     = (object) @Element
	    \*/
                for (var i = events.length; i--;) {
                    (function (eventName) {
                        R[eventName] = elproto[eventName] = function (fn, scope) {
                            if (R.is(fn, "function")) {
                                this.events = this.events || [];
                                this.events.push({
                                    name: eventName,
                                    f: fn,
                                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                                });
                            }
                            return this;
                        };
                        R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                            var events = this.events || [],
                                l = events.length;
                            while (l--) {
                                if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                                    events[l].unbind();
                                    events.splice(l, 1);
                                    !events.length && delete this.events;
                                }
                            }
                            return this;
                        };
                    })(events[i]);
                }

                /*\
	     * Element.data
	     [ method ]
	     **
	     * Adds or retrieves given value associated with given key.
	     **
	     * See also @Element.removeData
	     > Parameters
	     - key (string) key to store data
	     - value (any) #optional value to store
	     = (object) @Element
	     * or, if value is not specified:
	     = (any) value
	     * or, if key and value are not specified:
	     = (object) Key/value pairs for all the data associated with the element.
	     > Usage
	     | for (var i = 0, i < 5, i++) {
	     |     paper.circle(10 + 15 * i, 10, 10)
	     |          .attr({fill: "#000"})
	     |          .data("i", i)
	     |          .click(function () {
	     |             alert(this.data("i"));
	     |          });
	     | }
	    \*/
                elproto.data = function (key, value) {
                    var data = eldata[this.id] = eldata[this.id] || {};
                    if (arguments.length == 0) {
                        return data;
                    }
                    if (arguments.length == 1) {
                        if (R.is(key, "object")) {
                            for (var i in key) if (key[has](i)) {
                                this.data(i, key[i]);
                            }
                            return this;
                        }
                        eve("raphael.data.get." + this.id, this, data[key], key);
                        return data[key];
                    }
                    data[key] = value;
                    eve("raphael.data.set." + this.id, this, value, key);
                    return this;
                };
                /*\
	     * Element.removeData
	     [ method ]
	     **
	     * Removes value associated with an element by given key.
	     * If key is not provided, removes all the data of the element.
	     > Parameters
	     - key (string) #optional key
	     = (object) @Element
	    \*/
                elproto.removeData = function (key) {
                    if (key == null) {
                        eldata[this.id] = {};
                    } else {
                        eldata[this.id] && delete eldata[this.id][key];
                    }
                    return this;
                };
                /*\
	     * Element.getData
	     [ method ]
	     **
	     * Retrieves the element data
	     = (object) data
	    \*/
                elproto.getData = function () {
                    return clone(eldata[this.id] || {});
                };
                /*\
	     * Element.hover
	     [ method ]
	     **
	     * Adds event handlers for hover for the element.
	     > Parameters
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     - icontext (object) #optional context for hover in handler
	     - ocontext (object) #optional context for hover out handler
	     = (object) @Element
	    \*/
                elproto.hover = function (f_in, f_out, scope_in, scope_out) {
                    return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
                };
                /*\
	     * Element.unhover
	     [ method ]
	     **
	     * Removes event handlers for hover for the element.
	     > Parameters
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     = (object) @Element
	    \*/
                elproto.unhover = function (f_in, f_out) {
                    return this.unmouseover(f_in).unmouseout(f_out);
                };
                var draggable = [];
                /*\
	     * Element.drag
	     [ method ]
	     **
	     * Adds event handlers for drag of the element.
	     > Parameters
	     - onmove (function) handler for moving
	     - onstart (function) handler for drag start
	     - onend (function) handler for drag end
	     - mcontext (object) #optional context for moving handler
	     - scontext (object) #optional context for drag start handler
	     - econtext (object) #optional context for drag end handler
	     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
	     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
	     * `drag.over.<id>` will be fired as well.
	     *
	     * Start event and start handler will be called in specified context or in context of the element with following parameters:
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * Move event and move handler will be called in specified context or in context of the element with following parameters:
	     o dx (number) shift by x from the start point
	     o dy (number) shift by y from the start point
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * End event and end handler will be called in specified context or in context of the element with following parameters:
	     o event (object) DOM event object
	     = (object) @Element
	    \*/
                elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
                    function start(e) {
                        (e.originalEvent || e).preventDefault();
                        var x = e.clientX,
                            y = e.clientY,
                            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                        this._drag.id = e.identifier;
                        if (supportsTouch && e.touches) {
                            var i = e.touches.length, touch;
                            while (i--) {
                                touch = e.touches[i];
                                this._drag.id = touch.identifier;
                                if (touch.identifier == this._drag.id) {
                                    x = touch.clientX;
                                    y = touch.clientY;
                                    break;
                                }
                            }
                        }
                        this._drag.x = x + scrollX;
                        this._drag.y = y + scrollY;
                        !drag.length && R.mousemove(dragMove).mouseup(dragUp);
                        drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
                        onstart && eve.on("raphael.drag.start." + this.id, onstart);
                        onmove && eve.on("raphael.drag.move." + this.id, onmove);
                        onend && eve.on("raphael.drag.end." + this.id, onend);
                        eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
                    }

                    this._drag = {};
                    draggable.push({el: this, start: start});
                    this.mousedown(start);
                    return this;
                };
                /*\
	     * Element.onDragOver
	     [ method ]
	     **
	     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
	     > Parameters
	     - f (function) handler for event, first argument would be the element you are dragging over
	    \*/
                elproto.onDragOver = function (f) {
                    f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
                };
                /*\
	     * Element.undrag
	     [ method ]
	     **
	     * Removes all drag event handlers from given element.
	    \*/
                elproto.undrag = function () {
                    var i = draggable.length;
                    while (i--) if (draggable[i].el == this) {
                        this.unmousedown(draggable[i].start);
                        draggable.splice(i, 1);
                        eve.unbind("raphael.drag.*." + this.id);
                    }
                    !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
                    drag = [];
                };
                /*\
	     * Paper.circle
	     [ method ]
	     **
	     * Draws a circle.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - r (number) radius
	     = (object) Raphal element object with type circle
	     **
	     > Usage
	     | var c = paper.circle(50, 50, 40);
	    \*/
                paperproto.circle = function (x, y, r) {
                    var out = R._engine.circle(this, x || 0, y || 0, r || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.rect
	     [ method ]
	     *
	     * Draws a rectangle.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the top left corner
	     - y (number) y coordinate of the top left corner
	     - width (number) width
	     - height (number) height
	     - r (number) #optional radius for rounded corners, default is 0
	     = (object) Raphal element object with type rect
	     **
	     > Usage
	     | // regular rectangle
	     | var c = paper.rect(10, 10, 50, 50);
	     | // rectangle with rounded corners
	     | var c = paper.rect(40, 40, 50, 50, 10);
	    \*/
                paperproto.rect = function (x, y, w, h, r) {
                    var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.ellipse
	     [ method ]
	     **
	     * Draws an ellipse.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - rx (number) horizontal radius
	     - ry (number) vertical radius
	     = (object) Raphal element object with type ellipse
	     **
	     > Usage
	     | var c = paper.ellipse(50, 50, 40, 20);
	    \*/
                paperproto.ellipse = function (x, y, rx, ry) {
                    var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.path
	     [ method ]
	     **
	     * Creates a path element by given path data string.
	     > Parameters
	     - pathString (string) #optional path string in SVG format.
	     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
	     | "M10,20L30,40"
	     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.
	     *
	     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
	     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
	     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
	     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
	     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
	     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
	     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
	     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
	     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
	     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
	     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
	     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
	     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
	     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.
	     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.
	     > Usage
	     | var c = paper.path("M10 10L90 90");
	     | // draw a diagonal line:
	     | // move to 10,10, line to 90,90
	     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
	    \*/
                paperproto.path = function (pathString) {
                    pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
                    var out = R._engine.path(R.format[apply](R, arguments), this);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.image
	     [ method ]
	     **
	     * Embeds an image into the surface.
	     **
	     > Parameters
	     **
	     - src (string) URI of the source image
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - width (number) width of the image
	     - height (number) height of the image
	     = (object) Raphal element object with type image
	     **
	     > Usage
	     | var c = paper.image("apple.png", 10, 10, 80, 80);
	    \*/
                paperproto.image = function (src, x, y, w, h) {
                    var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.text
	     [ method ]
	     **
	     * Draws a text string. If you need line breaks, put \n in the string.
	     **
	     > Parameters
	     **
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - text (string) The text string to draw
	     = (object) Raphal element object with type text
	     **
	     > Usage
	     | var t = paper.text(50, 50, "Raphal\nkicks\nbutt!");
	    \*/
                paperproto.text = function (x, y, text) {
                    var out = R._engine.text(this, x || 0, y || 0, Str(text));
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Paper.set
	     [ method ]
	     **
	     * Creates array-like object to keep and operate several elements at once.
	     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.
	     * Sets act as pseudo elements  all methods available to an element can be used on a set.
	     = (object) array-like object that represents set of elements
	     **
	     > Usage
	     | var st = paper.set();
	     | st.push(
	     |     paper.circle(10, 10, 5),
	     |     paper.circle(30, 10, 5)
	     | );
	     | st.attr({fill: "red"}); // changes the fill of both circles
	    \*/
                paperproto.set = function (itemsArray) {
                    !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
                    var out = new Set(itemsArray);
                    this.__set__ && this.__set__.push(out);
                    out["paper"] = this;
                    out["type"] = "set";
                    return out;
                };
                /*\
	     * Paper.setStart
	     [ method ]
	     **
	     * Creates @Paper.set. All elements that will be created after calling this method and before calling
	     * @Paper.setFinish will be added to the set.
	     **
	     > Usage
	     | paper.setStart();
	     | paper.circle(10, 10, 5),
	     | paper.circle(30, 10, 5)
	     | var st = paper.setFinish();
	     | st.attr({fill: "red"}); // changes the fill of both circles
	    \*/
                paperproto.setStart = function (set) {
                    this.__set__ = set || this.set();
                };
                /*\
	     * Paper.setFinish
	     [ method ]
	     **
	     * See @Paper.setStart. This method finishes catching and returns resulting set.
	     **
	     = (object) set
	    \*/
                paperproto.setFinish = function (set) {
                    var out = this.__set__;
                    delete this.__set__;
                    return out;
                };
                /*\
	     * Paper.getSize
	     [ method ]
	     **
	     * Obtains current paper actual size.
	     **
	     = (object)
	     \*/
                paperproto.getSize = function () {
                    var container = this.canvas.parentNode;
                    return {
                        width: container.offsetWidth,
                        height: container.offsetHeight
                    };
                };
                /*\
	     * Paper.setSize
	     [ method ]
	     **
	     * If you need to change dimensions of the canvas call this method
	     **
	     > Parameters
	     **
	     - width (number) new width of the canvas
	     - height (number) new height of the canvas
	    \*/
                paperproto.setSize = function (width, height) {
                    return R._engine.setSize.call(this, width, height);
                };
                /*\
	     * Paper.setViewBox
	     [ method ]
	     **
	     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
	     * specifying new boundaries.
	     **
	     > Parameters
	     **
	     - x (number) new x position, default is `0`
	     - y (number) new y position, default is `0`
	     - w (number) new width of the canvas
	     - h (number) new height of the canvas
	     - fit (boolean) `true` if you want graphics to fit into new boundary box
	    \*/
                paperproto.setViewBox = function (x, y, w, h, fit) {
                    return R._engine.setViewBox.call(this, x, y, w, h, fit);
                };
                /*\
	     * Paper.top
	     [ property ]
	     **
	     * Points to the topmost element on the paper
	    \*/
                /*\
	     * Paper.bottom
	     [ property ]
	     **
	     * Points to the bottom element on the paper
	    \*/
                paperproto.top = paperproto.bottom = null;
                /*\
	     * Paper.raphael
	     [ property ]
	     **
	     * Points to the @Raphael object/function
	    \*/
                paperproto.raphael = R;
                var getOffset = function (elem) {
                    var box = elem.getBoundingClientRect(),
                        doc = elem.ownerDocument,
                        body = doc.body,
                        docElem = doc.documentElement,
                        clientTop = docElem.clientTop || body.clientTop || 0,
                        clientLeft = docElem.clientLeft || body.clientLeft || 0,
                        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
                        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
                    return {
                        y: top,
                        x: left
                    };
                };
                /*\
	     * Paper.getElementByPoint
	     [ method ]
	     **
	     * Returns you topmost element under given point.
	     **
	     = (object) Raphal element object
	     > Parameters
	     **
	     - x (number) x coordinate from the top left corner of the window
	     - y (number) y coordinate from the top left corner of the window
	     > Usage
	     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
	    \*/
                paperproto.getElementByPoint = function (x, y) {
                    var paper = this,
                        svg = paper.canvas,
                        target = g.doc.elementFromPoint(x, y);
                    if (g.win.opera && target.tagName == "svg") {
                        var so = getOffset(svg),
                            sr = svg.createSVGRect();
                        sr.x = x - so.x;
                        sr.y = y - so.y;
                        sr.width = sr.height = 1;
                        var hits = svg.getIntersectionList(sr, null);
                        if (hits.length) {
                            target = hits[hits.length - 1];
                        }
                    }
                    if (!target) {
                        return null;
                    }
                    while (target.parentNode && target != svg.parentNode && !target.raphael) {
                        target = target.parentNode;
                    }
                    target == paper.canvas.parentNode && (target = svg);
                    target = target && target.raphael ? paper.getById(target.raphaelid) : null;
                    return target;
                };

                /*\
	     * Paper.getElementsByBBox
	     [ method ]
	     **
	     * Returns set of elements that have an intersecting bounding box
	     **
	     > Parameters
	     **
	     - bbox (object) bbox to check with
	     = (object) @Set
	     \*/
                paperproto.getElementsByBBox = function (bbox) {
                    var set = this.set();
                    this.forEach(function (el) {
                        if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                            set.push(el);
                        }
                    });
                    return set;
                };

                /*\
	     * Paper.getById
	     [ method ]
	     **
	     * Returns you element by its internal ID.
	     **
	     > Parameters
	     **
	     - id (number) id
	     = (object) Raphal element object
	    \*/
                paperproto.getById = function (id) {
                    var bot = this.bottom;
                    while (bot) {
                        if (bot.id == id) {
                            return bot;
                        }
                        bot = bot.next;
                    }
                    return null;
                };
                /*\
	     * Paper.forEach
	     [ method ]
	     **
	     * Executes given function for each element on the paper
	     *
	     * If callback function returns `false` it will stop loop running.
	     **
	     > Parameters
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Paper object
	     > Usage
	     | paper.forEach(function (el) {
	     |     el.attr({ stroke: "blue" });
	     | });
	    \*/
                paperproto.forEach = function (callback, thisArg) {
                    var bot = this.bottom;
                    while (bot) {
                        if (callback.call(thisArg, bot) === false) {
                            return this;
                        }
                        bot = bot.next;
                    }
                    return this;
                };
                /*\
	     * Paper.getElementsByPoint
	     [ method ]
	     **
	     * Returns set of elements that have common point inside
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (object) @Set
	    \*/
                paperproto.getElementsByPoint = function (x, y) {
                    var set = this.set();
                    this.forEach(function (el) {
                        if (el.isPointInside(x, y)) {
                            set.push(el);
                        }
                    });
                    return set;
                };

                function x_y() {
                    return this.x + S + this.y;
                }

                function x_y_w_h() {
                    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
                }

                /*\
	     * Element.isPointInside
	     [ method ]
	     **
	     * Determine if given point is inside this elements shape
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (boolean) `true` if point inside the shape
	    \*/
                elproto.isPointInside = function (x, y) {
                    var rp = this.realPath = getPath[this.type](this);
                    if (this.attr('transform') && this.attr('transform').length) {
                        rp = R.transformPath(rp, this.attr('transform'));
                    }
                    return R.isPointInsidePath(rp, x, y);
                };
                /*\
	     * Element.getBBox
	     [ method ]
	     **
	     * Return bounding box for a given element
	     **
	     > Parameters
	     **
	     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
	     = (object) Bounding box object:
	     o {
	     o     x: (number) top left corner x
	     o     y: (number) top left corner y
	     o     x2: (number) bottom right corner x
	     o     y2: (number) bottom right corner y
	     o     width: (number) width
	     o     height: (number) height
	     o }
	    \*/
                elproto.getBBox = function (isWithoutTransform) {
                    if (this.removed) {
                        return {};
                    }
                    var _ = this._;
                    if (isWithoutTransform) {
                        if (_.dirty || !_.bboxwt) {
                            this.realPath = getPath[this.type](this);
                            _.bboxwt = pathDimensions(this.realPath);
                            _.bboxwt.toString = x_y_w_h;
                            _.dirty = 0;
                        }
                        return _.bboxwt;
                    }
                    if (_.dirty || _.dirtyT || !_.bbox) {
                        if (_.dirty || !this.realPath) {
                            _.bboxwt = 0;
                            this.realPath = getPath[this.type](this);
                        }
                        _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
                        _.bbox.toString = x_y_w_h;
                        _.dirty = _.dirtyT = 0;
                    }
                    return _.bbox;
                };
                /*\
	     * Element.clone
	     [ method ]
	     **
	     = (object) clone of a given element
	     **
	    \*/
                elproto.clone = function () {
                    if (this.removed) {
                        return null;
                    }
                    var out = this.paper[this.type]().attr(this.attr());
                    this.__set__ && this.__set__.push(out);
                    return out;
                };
                /*\
	     * Element.glow
	     [ method ]
	     **
	     * Return set of elements that create glow-like effect around given element. See @Paper.set.
	     *
	     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.
	     **
	     > Parameters
	     **
	     - glow (object) #optional parameters object with all properties optional:
	     o {
	     o     width (number) size of the glow, default is `10`
	     o     fill (boolean) will it be filled, default is `false`
	     o     opacity (number) opacity, default is `0.5`
	     o     offsetx (number) horizontal offset, default is `0`
	     o     offsety (number) vertical offset, default is `0`
	     o     color (string) glow colour, default is `black`
	     o }
	     = (object) @Paper.set of elements that represents glow
	    \*/
                elproto.glow = function (glow) {
                    if (this.type == "text") {
                        return null;
                    }
                    glow = glow || {};
                    var s = {
                            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                            fill: glow.fill || false,
                            opacity: glow.opacity == null ? .5 : glow.opacity,
                            offsetx: glow.offsetx || 0,
                            offsety: glow.offsety || 0,
                            color: glow.color || "#000"
                        },
                        c = s.width / 2,
                        r = this.paper,
                        out = r.set(),
                        path = this.realPath || getPath[this.type](this);
                    path = this.matrix ? mapPath(path, this.matrix) : path;
                    for (var i = 1; i < c + 1; i++) {
                        out.push(r.path(path).attr({
                            stroke: s.color,
                            fill: s.fill ? s.color : "none",
                            "stroke-linejoin": "round",
                            "stroke-linecap": "round",
                            "stroke-width": +(s.width / c * i).toFixed(3),
                            opacity: +(s.opacity / c).toFixed(3)
                        }));
                    }
                    return out.insertBefore(this).translate(s.offsetx, s.offsety);
                };
                var curveslengths = {},
                    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
                        if (length == null) {
                            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
                        } else {
                            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
                        }
                    },
                    getLengthFactory = function (istotal, subpath) {
                        return function (path, length, onlystart) {
                            path = path2curve(path);
                            var x, y, p, l, sp = "", subpaths = {}, point,
                                len = 0;
                            for (var i = 0, ii = path.length; i < ii; i++) {
                                p = path[i];
                                if (p[0] == "M") {
                                    x = +p[1];
                                    y = +p[2];
                                } else {
                                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                                    if (len + l > length) {
                                        if (subpath && !subpaths.start) {
                                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                            if (onlystart) {
                                                return sp;
                                            }
                                            subpaths.start = sp;
                                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                            len += l;
                                            x = +p[5];
                                            y = +p[6];
                                            continue;
                                        }
                                        if (!istotal && !subpath) {
                                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                            return {x: point.x, y: point.y, alpha: point.alpha};
                                        }
                                    }
                                    len += l;
                                    x = +p[5];
                                    y = +p[6];
                                }
                                sp += p.shift() + p;
                            }
                            subpaths.end = sp;
                            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
                            return point;
                        };
                    };
                var getTotalLength = getLengthFactory(1),
                    getPointAtLength = getLengthFactory(),
                    getSubpathsAtLength = getLengthFactory(0, 1);
                /*\
	     * Raphael.getTotalLength
	     [ method ]
	     **
	     * Returns length of the given path in pixels.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string.
	     **
	     = (number) length.
	    \*/
                R.getTotalLength = getTotalLength;
                /*\
	     * Raphael.getPointAtLength
	     [ method ]
	     **
	     * Return coordinates of the point located at the given length on the given path.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string
	     - length (number)
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate
	     o     y: (number) y coordinate
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
                R.getPointAtLength = getPointAtLength;
                /*\
	     * Raphael.getSubpath
	     [ method ]
	     **
	     * Return subpath of a given path from given length to given length.
	     **
	     > Parameters
	     **
	     - path (string) SVG path string
	     - from (number) position of the start of the segment
	     - to (number) position of the end of the segment
	     **
	     = (string) pathstring for the segment
	    \*/
                R.getSubpath = function (path, from, to) {
                    if (this.getTotalLength(path) - to < 1e-6) {
                        return getSubpathsAtLength(path, from).end;
                    }
                    var a = getSubpathsAtLength(path, to, 1);
                    return from ? getSubpathsAtLength(a, from).end : a;
                };
                /*\
	     * Element.getTotalLength
	     [ method ]
	     **
	     * Returns length of the path in pixels. Only works for element of path type.
	     = (number) length.
	    \*/
                elproto.getTotalLength = function () {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    if (this.node.getTotalLength) {
                        return this.node.getTotalLength();
                    }

                    return getTotalLength(path);
                };
                /*\
	     * Element.getPointAtLength
	     [ method ]
	     **
	     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.
	     **
	     > Parameters
	     **
	     - length (number)
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate
	     o     y: (number) y coordinate
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
                elproto.getPointAtLength = function (length) {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    return getPointAtLength(path, length);
                };
                /*\
	     * Element.getPath
	     [ method ]
	     **
	     * Returns path of the element. Only works for elements of path type and simple elements like circle.
	     = (object) path
	     **
	    \*/
                elproto.getPath = function () {
                    var path,
                        getPath = R._getPath[this.type];

                    if (this.type == "text" || this.type == "set") {
                        return;
                    }

                    if (getPath) {
                        path = getPath(this);
                    }

                    return path;
                };
                /*\
	     * Element.getSubpath
	     [ method ]
	     **
	     * Return subpath of a given element from given length to given length. Only works for element of path type.
	     **
	     > Parameters
	     **
	     - from (number) position of the start of the segment
	     - to (number) position of the end of the segment
	     **
	     = (string) pathstring for the segment
	    \*/
                elproto.getSubpath = function (from, to) {
                    var path = this.getPath();
                    if (!path) {
                        return;
                    }

                    return R.getSubpath(path, from, to);
                };
                /*\
	     * Raphael.easing_formulas
	     [ property ]
	     **
	     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
	     # <ul>
	     #     <li>linear</li>
	     #     <li>&lt; or easeIn or ease-in</li>
	     #     <li>> or easeOut or ease-out</li>
	     #     <li>&lt;> or easeInOut or ease-in-out</li>
	     #     <li>backIn or back-in</li>
	     #     <li>backOut or back-out</li>
	     #     <li>elastic</li>
	     #     <li>bounce</li>
	     # </ul>
	     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
	    \*/
                var ef = R.easing_formulas = {
                    linear: function (n) {
                        return n;
                    },
                    "<": function (n) {
                        return pow(n, 1.7);
                    },
                    ">": function (n) {
                        return pow(n, .48);
                    },
                    "<>": function (n) {
                        var q = .48 - n / 1.04,
                            Q = math.sqrt(.1734 + q * q),
                            x = Q - q,
                            X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                            y = -Q - q,
                            Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                            t = X + Y + .5;
                        return (1 - t) * 3 * t * t + t * t * t;
                    },
                    backIn: function (n) {
                        var s = 1.70158;
                        return n * n * ((s + 1) * n - s);
                    },
                    backOut: function (n) {
                        n = n - 1;
                        var s = 1.70158;
                        return n * n * ((s + 1) * n + s) + 1;
                    },
                    elastic: function (n) {
                        if (n == !!n) {
                            return n;
                        }
                        return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
                    },
                    bounce: function (n) {
                        var s = 7.5625,
                            p = 2.75,
                            l;
                        if (n < (1 / p)) {
                            l = s * n * n;
                        } else {
                            if (n < (2 / p)) {
                                n -= (1.5 / p);
                                l = s * n * n + .75;
                            } else {
                                if (n < (2.5 / p)) {
                                    n -= (2.25 / p);
                                    l = s * n * n + .9375;
                                } else {
                                    n -= (2.625 / p);
                                    l = s * n * n + .984375;
                                }
                            }
                        }
                        return l;
                    }
                };
                ef.easeIn = ef["ease-in"] = ef["<"];
                ef.easeOut = ef["ease-out"] = ef[">"];
                ef.easeInOut = ef["ease-in-out"] = ef["<>"];
                ef["back-in"] = ef.backIn;
                ef["back-out"] = ef.backOut;

                var animationElements = [],
                    requestAnimFrame = window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (callback) {
                            setTimeout(callback, 16);
                        },
                    animation = function () {
                        var Now = +new Date,
                            l = 0;
                        for (; l < animationElements.length; l++) {
                            var e = animationElements[l];
                            if (e.el.removed || e.paused) {
                                continue;
                            }
                            var time = Now - e.start,
                                ms = e.ms,
                                easing = e.easing,
                                from = e.from,
                                diff = e.diff,
                                to = e.to,
                                t = e.t,
                                that = e.el,
                                set = {},
                                now,
                                init = {},
                                key;
                            if (e.initstatus) {
                                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                                e.status = e.initstatus;
                                delete e.initstatus;
                                e.stop && animationElements.splice(l--, 1);
                            } else {
                                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                            }
                            if (time < 0) {
                                continue;
                            }
                            if (time < ms) {
                                var pos = easing(time / ms);
                                for (var attr in from) if (from[has](attr)) {
                                    switch (availableAnimAttrs[attr]) {
                                        case nu:
                                            now = +from[attr] + pos * ms * diff[attr];
                                            break;
                                        case "colour":
                                            now = "rgb(" + [
                                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                            ].join(",") + ")";
                                            break;
                                        case "path":
                                            now = [];
                                            for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                                now[i] = [from[attr][i][0]];
                                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                    now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                }
                                                now[i] = now[i].join(S);
                                            }
                                            now = now.join(S);
                                            break;
                                        case "transform":
                                            if (diff[attr].real) {
                                                now = [];
                                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                    now[i] = [from[attr][i][0]];
                                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                        now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                                    }
                                                }
                                            } else {
                                                var get = function (i) {
                                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                                };
                                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                                now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                            }
                                            break;
                                        case "csv":
                                            if (attr == "clip-rect") {
                                                now = [];
                                                i = 4;
                                                while (i--) {
                                                    now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                                }
                                            }
                                            break;
                                        default:
                                            var from2 = [][concat](from[attr]);
                                            now = [];
                                            i = that.paper.customAttributes[attr].length;
                                            while (i--) {
                                                now[i] = +from2[i] + pos * ms * diff[attr][i];
                                            }
                                            break;
                                    }
                                    set[attr] = now;
                                }
                                that.attr(set);
                                (function (id, that, anim) {
                                    setTimeout(function () {
                                        eve("raphael.anim.frame." + id, that, anim);
                                    });
                                })(that.id, that, e.anim);
                            } else {
                                (function (f, el, a) {
                                    setTimeout(function () {
                                        eve("raphael.anim.frame." + el.id, el, a);
                                        eve("raphael.anim.finish." + el.id, el, a);
                                        R.is(f, "function") && f.call(el);
                                    });
                                })(e.callback, that, e.anim);
                                that.attr(to);
                                animationElements.splice(l--, 1);
                                if (e.repeat > 1 && !e.next) {
                                    for (key in to) if (to[has](key)) {
                                        init[key] = e.totalOrigin[key];
                                    }
                                    e.el.attr(init);
                                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                                }
                                if (e.next && !e.stop) {
                                    runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                                }
                            }
                        }
                        animationElements.length && requestAnimFrame(animation);
                    },
                    upto255 = function (color) {
                        return color > 255 ? 255 : color < 0 ? 0 : color;
                    };
                /*\
	     * Element.animateWith
	     [ method ]
	     **
	     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
	     **
	     > Parameters
	     **
	     - el (object) element to sync with
	     - anim (object) animation to sync with
	     - params (object) #optional final attributes for the element, see also @Element.attr
	     - ms (number) #optional number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     * or
	     - element (object) element to sync with
	     - anim (object) animation to sync with
	     - animation (object) #optional animation object, see @Raphael.animation
	     **
	     = (object) original element
	    \*/
                elproto.animateWith = function (el, anim, params, ms, easing, callback) {
                    var element = this;
                    if (element.removed) {
                        callback && callback.call(element);
                        return element;
                    }
                    var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
                        x, y;
                    runAnimation(a, element, a.percents[0], null, element.attr());
                    for (var i = 0, ii = animationElements.length; i < ii; i++) {
                        if (animationElements[i].anim == anim && animationElements[i].el == el) {
                            animationElements[ii - 1].start = animationElements[i].start;
                            break;
                        }
                    }
                    return element;
                    //
                    //
                    // var a = params ? R.animation(params, ms, easing, callback) : anim,
                    //     status = element.status(anim);
                    // return this.animate(a).status(a, status * anim.ms / a.ms);
                };

                function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
                    var cx = 3 * p1x,
                        bx = 3 * (p2x - p1x) - cx,
                        ax = 1 - cx - bx,
                        cy = 3 * p1y,
                        by = 3 * (p2y - p1y) - cy,
                        ay = 1 - cy - by;

                    function sampleCurveX(t) {
                        return ((ax * t + bx) * t + cx) * t;
                    }

                    function solve(x, epsilon) {
                        var t = solveCurveX(x, epsilon);
                        return ((ay * t + by) * t + cy) * t;
                    }

                    function solveCurveX(x, epsilon) {
                        var t0, t1, t2, x2, d2, i;
                        for (t2 = x, i = 0; i < 8; i++) {
                            x2 = sampleCurveX(t2) - x;
                            if (abs(x2) < epsilon) {
                                return t2;
                            }
                            d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                            if (abs(d2) < 1e-6) {
                                break;
                            }
                            t2 = t2 - x2 / d2;
                        }
                        t0 = 0;
                        t1 = 1;
                        t2 = x;
                        if (t2 < t0) {
                            return t0;
                        }
                        if (t2 > t1) {
                            return t1;
                        }
                        while (t0 < t1) {
                            x2 = sampleCurveX(t2);
                            if (abs(x2 - x) < epsilon) {
                                return t2;
                            }
                            if (x > x2) {
                                t0 = t2;
                            } else {
                                t1 = t2;
                            }
                            t2 = (t1 - t0) / 2 + t0;
                        }
                        return t2;
                    }

                    return solve(t, 1 / (200 * duration));
                }

                elproto.onAnimation = function (f) {
                    f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
                    return this;
                };

                function Animation(anim, ms) {
                    var percents = [],
                        newAnim = {};
                    this.ms = ms;
                    this.times = 1;
                    if (anim) {
                        for (var attr in anim) if (anim[has](attr)) {
                            newAnim[toFloat(attr)] = anim[attr];
                            percents.push(toFloat(attr));
                        }
                        percents.sort(sortByNumber);
                    }
                    this.anim = newAnim;
                    this.top = percents[percents.length - 1];
                    this.percents = percents;
                }

                /*\
	     * Animation.delay
	     [ method ]
	     **
	     * Creates a copy of existing animation object with given delay.
	     **
	     > Parameters
	     **
	     - delay (number) number of ms to pass between animation start and actual animation
	     **
	     = (object) new altered Animation object
	     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
	     | circle1.animate(anim); // run the given animation immediately
	     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
	    \*/
                Animation.prototype.delay = function (delay) {
                    var a = new Animation(this.anim, this.ms);
                    a.times = this.times;
                    a.del = +delay || 0;
                    return a;
                };
                /*\
	     * Animation.repeat
	     [ method ]
	     **
	     * Creates a copy of existing animation object with given repetition.
	     **
	     > Parameters
	     **
	     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
	     **
	     = (object) new altered Animation object
	    \*/
                Animation.prototype.repeat = function (times) {
                    var a = new Animation(this.anim, this.ms);
                    a.del = this.del;
                    a.times = math.floor(mmax(times, 0)) || 1;
                    return a;
                };

                function runAnimation(anim, element, percent, status, totalOrigin, times) {
                    percent = toFloat(percent);
                    var params,
                        isInAnim,
                        isInAnimSet,
                        percents = [],
                        next,
                        prev,
                        timestamp,
                        ms = anim.ms,
                        from = {},
                        to = {},
                        diff = {};
                    if (status) {
                        for (i = 0, ii = animationElements.length; i < ii; i++) {
                            var e = animationElements[i];
                            if (e.el.id == element.id && e.anim == anim) {
                                if (e.percent != percent) {
                                    animationElements.splice(i, 1);
                                    isInAnimSet = 1;
                                } else {
                                    isInAnim = e;
                                }
                                element.attr(e.totalOrigin);
                                break;
                            }
                        }
                    } else {
                        status = +to; // NaN
                    }
                    for (var i = 0, ii = anim.percents.length; i < ii; i++) {
                        if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                            percent = anim.percents[i];
                            prev = anim.percents[i - 1] || 0;
                            ms = ms / anim.top * (percent - prev);
                            next = anim.percents[i + 1];
                            params = anim.anim[percent];
                            break;
                        } else if (status) {
                            element.attr(anim.anim[anim.percents[i]]);
                        }
                    }
                    if (!params) {
                        return;
                    }
                    if (!isInAnim) {
                        for (var attr in params) if (params[has](attr)) {
                            if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                                from[attr] = element.attr(attr);
                                (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                                to[attr] = params[attr];
                                switch (availableAnimAttrs[attr]) {
                                    case nu:
                                        diff[attr] = (to[attr] - from[attr]) / ms;
                                        break;
                                    case "colour":
                                        from[attr] = R.getRGB(from[attr]);
                                        var toColour = R.getRGB(to[attr]);
                                        diff[attr] = {
                                            r: (toColour.r - from[attr].r) / ms,
                                            g: (toColour.g - from[attr].g) / ms,
                                            b: (toColour.b - from[attr].b) / ms
                                        };
                                        break;
                                    case "path":
                                        var pathes = path2curve(from[attr], to[attr]),
                                            toPath = pathes[1];
                                        from[attr] = pathes[0];
                                        diff[attr] = [];
                                        for (i = 0, ii = from[attr].length; i < ii; i++) {
                                            diff[attr][i] = [0];
                                            for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                            }
                                        }
                                        break;
                                    case "transform":
                                        var _ = element._,
                                            eq = equaliseTransform(_[attr], to[attr]);
                                        if (eq) {
                                            from[attr] = eq.from;
                                            to[attr] = eq.to;
                                            diff[attr] = [];
                                            diff[attr].real = true;
                                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                                diff[attr][i] = [from[attr][i][0]];
                                                for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                                    diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                                }
                                            }
                                        } else {
                                            var m = (element.matrix || new Matrix),
                                                to2 = {
                                                    _: {transform: _.transform},
                                                    getBBox: function () {
                                                        return element.getBBox(1);
                                                    }
                                                };
                                            from[attr] = [
                                                m.a,
                                                m.b,
                                                m.c,
                                                m.d,
                                                m.e,
                                                m.f
                                            ];
                                            extractTransform(to2, to[attr]);
                                            to[attr] = to2._.transform;
                                            diff[attr] = [
                                                (to2.matrix.a - m.a) / ms,
                                                (to2.matrix.b - m.b) / ms,
                                                (to2.matrix.c - m.c) / ms,
                                                (to2.matrix.d - m.d) / ms,
                                                (to2.matrix.e - m.e) / ms,
                                                (to2.matrix.f - m.f) / ms
                                            ];
                                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                            // extractTransform(to2, to[attr]);
                                            // diff[attr] = [
                                            //     (to2._.sx - _.sx) / ms,
                                            //     (to2._.sy - _.sy) / ms,
                                            //     (to2._.deg - _.deg) / ms,
                                            //     (to2._.dx - _.dx) / ms,
                                            //     (to2._.dy - _.dy) / ms
                                            // ];
                                        }
                                        break;
                                    case "csv":
                                        var values = Str(params[attr])[split](separator),
                                            from2 = Str(from[attr])[split](separator);
                                        if (attr == "clip-rect") {
                                            from[attr] = from2;
                                            diff[attr] = [];
                                            i = from2.length;
                                            while (i--) {
                                                diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                            }
                                        }
                                        to[attr] = values;
                                        break;
                                    default:
                                        values = [][concat](params[attr]);
                                        from2 = [][concat](from[attr]);
                                        diff[attr] = [];
                                        i = element.paper.customAttributes[attr].length;
                                        while (i--) {
                                            diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                        }
                                        break;
                                }
                            }
                        }
                        var easing = params.easing,
                            easyeasy = R.easing_formulas[easing];
                        if (!easyeasy) {
                            easyeasy = Str(easing).match(bezierrg);
                            if (easyeasy && easyeasy.length == 5) {
                                var curve = easyeasy;
                                easyeasy = function (t) {
                                    return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                                };
                            } else {
                                easyeasy = pipe;
                            }
                        }
                        timestamp = params.start || anim.start || +new Date;
                        e = {
                            anim: anim,
                            percent: percent,
                            timestamp: timestamp,
                            start: timestamp + (anim.del || 0),
                            status: 0,
                            initstatus: status || 0,
                            stop: false,
                            ms: ms,
                            easing: easyeasy,
                            from: from,
                            diff: diff,
                            to: to,
                            el: element,
                            callback: params.callback,
                            prev: prev,
                            next: next,
                            repeat: times || anim.times,
                            origin: element.attr(),
                            totalOrigin: totalOrigin
                        };
                        animationElements.push(e);
                        if (status && !isInAnim && !isInAnimSet) {
                            e.stop = true;
                            e.start = new Date - ms * status;
                            if (animationElements.length == 1) {
                                return animation();
                            }
                        }
                        if (isInAnimSet) {
                            e.start = new Date - e.ms * status;
                        }
                        animationElements.length == 1 && requestAnimFrame(animation);
                    } else {
                        isInAnim.initstatus = status;
                        isInAnim.start = new Date - isInAnim.ms * status;
                    }
                    eve("raphael.anim.start." + element.id, element, anim);
                }

                /*\
	     * Raphael.animation
	     [ method ]
	     **
	     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
	     * See also @Animation.delay and @Animation.repeat methods.
	     **
	     > Parameters
	     **
	     - params (object) final attributes for the element, see also @Element.attr
	     - ms (number) number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     **
	     = (object) @Animation
	    \*/
                R.animation = function (params, ms, easing, callback) {
                    if (params instanceof Animation) {
                        return params;
                    }
                    if (R.is(easing, "function") || !easing) {
                        callback = callback || easing || null;
                        easing = null;
                    }
                    params = Object(params);
                    ms = +ms || 0;
                    var p = {},
                        json,
                        attr;
                    for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                        json = true;
                        p[attr] = params[attr];
                    }
                    if (!json) {
                        // if percent-like syntax is used and end-of-all animation callback used
                        if (callback) {
                            // find the last one
                            var lastKey = 0;
                            for (var i in params) {
                                var percent = toInt(i);
                                if (params[has](i) && percent > lastKey) {
                                    lastKey = percent;
                                }
                            }
                            lastKey += '%';
                            // if already defined callback in the last keyframe, skip
                            !params[lastKey].callback && (params[lastKey].callback = callback);
                        }
                        return new Animation(params, ms);
                    } else {
                        easing && (p.easing = easing);
                        callback && (p.callback = callback);
                        return new Animation({100: p}, ms);
                    }
                };
                /*\
	     * Element.animate
	     [ method ]
	     **
	     * Creates and starts animation for given element.
	     **
	     > Parameters
	     **
	     - params (object) final attributes for the element, see also @Element.attr
	     - ms (number) number of milliseconds for animation to run
	     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
	     - callback (function) #optional callback function. Will be called at the end of animation.
	     * or
	     - animation (object) animation object, see @Raphael.animation
	     **
	     = (object) original element
	    \*/
                elproto.animate = function (params, ms, easing, callback) {
                    var element = this;
                    if (element.removed) {
                        callback && callback.call(element);
                        return element;
                    }
                    var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
                    runAnimation(anim, element, anim.percents[0], null, element.attr());
                    return element;
                };
                /*\
	     * Element.setTime
	     [ method ]
	     **
	     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
	     **
	     > Parameters
	     **
	     - anim (object) animation object
	     - value (number) number of milliseconds from the beginning of the animation
	     **
	     = (object) original element if `value` is specified
	     * Note, that during animation following events are triggered:
	     *
	     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
	    \*/
                elproto.setTime = function (anim, value) {
                    if (anim && value != null) {
                        this.status(anim, mmin(value, anim.ms) / anim.ms);
                    }
                    return this;
                };
                /*\
	     * Element.status
	     [ method ]
	     **
	     * Gets or sets the status of animation of the element.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
	     **
	     = (number) status
	     * or
	     = (array) status if `anim` is not specified. Array of objects in format:
	     o {
	     o     anim: (object) animation object
	     o     status: (number) status
	     o }
	     * or
	     = (object) original element if `value` is specified
	    \*/
                elproto.status = function (anim, value) {
                    var out = [],
                        i = 0,
                        len,
                        e;
                    if (value != null) {
                        runAnimation(anim, this, -1, mmin(value, 1));
                        return this;
                    } else {
                        len = animationElements.length;
                        for (; i < len; i++) {
                            e = animationElements[i];
                            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                                if (anim) {
                                    return e.status;
                                }
                                out.push({
                                    anim: e.anim,
                                    status: e.status
                                });
                            }
                        }
                        if (anim) {
                            return 0;
                        }
                        return out;
                    }
                };
                /*\
	     * Element.pause
	     [ method ]
	     **
	     * Stops animation of the element with ability to resume it later on.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.pause = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                            animationElements[i].paused = true;
                        }
                    }
                    return this;
                };
                /*\
	     * Element.resume
	     [ method ]
	     **
	     * Resumes animation if it was paused with @Element.pause method.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.resume = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        var e = animationElements[i];
                        if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                            delete e.paused;
                            this.status(e.anim, e.status);
                        }
                    }
                    return this;
                };
                /*\
	     * Element.stop
	     [ method ]
	     **
	     * Stops animation of the element.
	     **
	     > Parameters
	     **
	     - anim (object) #optional animation object
	     **
	     = (object) original element
	    \*/
                elproto.stop = function (anim) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                        if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                            animationElements.splice(i--, 1);
                        }
                    }
                    return this;
                };

                function stopAnimation(paper) {
                    for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
                        animationElements.splice(i--, 1);
                    }
                }

                eve.on("raphael.remove", stopAnimation);
                eve.on("raphael.clear", stopAnimation);
                elproto.toString = function () {
                    return "Rapha\xebl\u2019s object";
                };

                // Set
                var Set = function (items) {
                        this.items = [];
                        this.length = 0;
                        this.type = "set";
                        if (items) {
                            for (var i = 0, ii = items.length; i < ii; i++) {
                                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                                    this[this.items.length] = this.items[this.items.length] = items[i];
                                    this.length++;
                                }
                            }
                        }
                    },
                    setproto = Set.prototype;
                /*\
	     * Set.push
	     [ method ]
	     **
	     * Adds each argument to the current set.
	     = (object) original element
	    \*/
                setproto.push = function () {
                    var item,
                        len;
                    for (var i = 0, ii = arguments.length; i < ii; i++) {
                        item = arguments[i];
                        if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                            len = this.items.length;
                            this[len] = this.items[len] = item;
                            this.length++;
                        }
                    }
                    return this;
                };
                /*\
	     * Set.pop
	     [ method ]
	     **
	     * Removes last element and returns it.
	     = (object) element
	    \*/
                setproto.pop = function () {
                    this.length && delete this[this.length--];
                    return this.items.pop();
                };
                /*\
	     * Set.forEach
	     [ method ]
	     **
	     * Executes given function for each element in the set.
	     *
	     * If function returns `false` it will stop loop running.
	     **
	     > Parameters
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Set object
	    \*/
                setproto.forEach = function (callback, thisArg) {
                    for (var i = 0, ii = this.items.length; i < ii; i++) {
                        if (callback.call(thisArg, this.items[i], i) === false) {
                            return this;
                        }
                    }
                    return this;
                };
                for (var method in elproto) if (elproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname][apply](el, arg);
                            });
                        };
                    })(method);
                }
                setproto.attr = function (name, value) {
                    if (name && R.is(name, array) && R.is(name[0], "object")) {
                        for (var j = 0, jj = name.length; j < jj; j++) {
                            this.items[j].attr(name[j]);
                        }
                    } else {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            this.items[i].attr(name, value);
                        }
                    }
                    return this;
                };
                /*\
	     * Set.clear
	     [ method ]
	     **
	     * Removes all elements from the set
	    \*/
                setproto.clear = function () {
                    while (this.length) {
                        this.pop();
                    }
                };
                /*\
	     * Set.splice
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     > Parameters
	     **
	     - index (number) position of the deletion
	     - count (number) number of element to remove
	     - insertion (object) #optional elements to insert
	     = (object) set elements that were deleted
	    \*/
                setproto.splice = function (index, count, insertion) {
                    index = index < 0 ? mmax(this.length + index, 0) : index;
                    count = mmax(0, mmin(this.length - index, count));
                    var tail = [],
                        todel = [],
                        args = [],
                        i;
                    for (i = 2; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    for (i = 0; i < count; i++) {
                        todel.push(this[index + i]);
                    }
                    for (; i < this.length - index; i++) {
                        tail.push(this[index + i]);
                    }
                    var arglen = args.length;
                    for (i = 0; i < arglen + tail.length; i++) {
                        this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
                    }
                    i = this.items.length = this.length -= count - arglen;
                    while (this[i]) {
                        delete this[i++];
                    }
                    return new Set(todel);
                };
                /*\
	     * Set.exclude
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     > Parameters
	     **
	     - element (object) element to remove
	     = (boolean) `true` if object was found & removed from the set
	    \*/
                setproto.exclude = function (el) {
                    for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
                        this.splice(i, 1);
                        return true;
                    }
                };
                setproto.animate = function (params, ms, easing, callback) {
                    (R.is(easing, "function") || !easing) && (callback = easing || null);
                    var len = this.items.length,
                        i = len,
                        item,
                        set = this,
                        collector;
                    if (!len) {
                        return this;
                    }
                    callback && (collector = function () {
                        !--len && callback.call(set);
                    });
                    easing = R.is(easing, string) ? easing : collector;
                    var anim = R.animation(params, ms, easing, collector);
                    item = this.items[--i].animate(anim);
                    while (i--) {
                        this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
                        (this.items[i] && !this.items[i].removed) || len--;
                    }
                    return this;
                };
                setproto.insertAfter = function (el) {
                    var i = this.items.length;
                    while (i--) {
                        this.items[i].insertAfter(el);
                    }
                    return this;
                };
                setproto.getBBox = function () {
                    var x = [],
                        y = [],
                        x2 = [],
                        y2 = [];
                    for (var i = this.items.length; i--;) if (!this.items[i].removed) {
                        var box = this.items[i].getBBox();
                        x.push(box.x);
                        y.push(box.y);
                        x2.push(box.x + box.width);
                        y2.push(box.y + box.height);
                    }
                    x = mmin[apply](0, x);
                    y = mmin[apply](0, y);
                    x2 = mmax[apply](0, x2);
                    y2 = mmax[apply](0, y2);
                    return {
                        x: x,
                        y: y,
                        x2: x2,
                        y2: y2,
                        width: x2 - x,
                        height: y2 - y
                    };
                };
                setproto.clone = function (s) {
                    s = this.paper.set();
                    for (var i = 0, ii = this.items.length; i < ii; i++) {
                        s.push(this.items[i].clone());
                    }
                    return s;
                };
                setproto.toString = function () {
                    return "Rapha\xebl\u2018s set";
                };

                setproto.glow = function (glowConfig) {
                    var ret = this.paper.set();
                    this.forEach(function (shape, index) {
                        var g = shape.glow(glowConfig);
                        if (g != null) {
                            g.forEach(function (shape2, index2) {
                                ret.push(shape2);
                            });
                        }
                    });
                    return ret;
                };


                /*\
	     * Set.isPointInside
	     [ method ]
	     **
	     * Determine if given point is inside this sets elements
	     **
	     > Parameters
	     **
	     - x (number) x coordinate of the point
	     - y (number) y coordinate of the point
	     = (boolean) `true` if point is inside any of the set's elements
	     \*/
                setproto.isPointInside = function (x, y) {
                    var isPointInside = false;
                    this.forEach(function (el) {
                        if (el.isPointInside(x, y)) {
                            isPointInside = true;
                            return false; // stop loop
                        }
                    });
                    return isPointInside;
                };

                /*\
	     * Raphael.registerFont
	     [ method ]
	     **
	     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.
	     * Returns original parameter, so it could be used with chaining.
	     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
	     **
	     > Parameters
	     **
	     - font (object) the font to register
	     = (object) the font you passed in
	     > Usage
	     | Cufon.registerFont(Raphael.registerFont({}));
	    \*/
                R.registerFont = function (font) {
                    if (!font.face) {
                        return font;
                    }
                    this.fonts = this.fonts || {};
                    var fontcopy = {
                            w: font.w,
                            face: {},
                            glyphs: {}
                        },
                        family = font.face["font-family"];
                    for (var prop in font.face) if (font.face[has](prop)) {
                        fontcopy.face[prop] = font.face[prop];
                    }
                    if (this.fonts[family]) {
                        this.fonts[family].push(fontcopy);
                    } else {
                        this.fonts[family] = [fontcopy];
                    }
                    if (!font.svg) {
                        fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
                        for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                            var path = font.glyphs[glyph];
                            fontcopy.glyphs[glyph] = {
                                w: path.w,
                                k: {},
                                d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                                    return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                                }) + "z"
                            };
                            if (path.k) {
                                for (var k in path.k) if (path[has](k)) {
                                    fontcopy.glyphs[glyph].k[k] = path.k[k];
                                }
                            }
                        }
                    }
                    return font;
                };
                /*\
	     * Paper.getFont
	     [ method ]
	     **
	     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.
	     **
	     > Parameters
	     **
	     - family (string) font family name or any word from it
	     - weight (string) #optional font weight
	     - style (string) #optional font style
	     - stretch (string) #optional font stretch
	     = (object) the font object
	     > Usage
	     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
	    \*/
                paperproto.getFont = function (family, weight, style, stretch) {
                    stretch = stretch || "normal";
                    style = style || "normal";
                    weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
                    if (!R.fonts) {
                        return;
                    }
                    var font = R.fonts[family];
                    if (!font) {
                        var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
                        for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                            if (name.test(fontName)) {
                                font = R.fonts[fontName];
                                break;
                            }
                        }
                    }
                    var thefont;
                    if (font) {
                        for (var i = 0, ii = font.length; i < ii; i++) {
                            thefont = font[i];
                            if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                                break;
                            }
                        }
                    }
                    return thefont;
                };
                /*\
	     * Paper.print
	     [ method ]
	     **
	     * Creates path that represent given text written using given font at given position with given size.
	     * Result of the method is path element that contains whole text as a separate path.
	     **
	     > Parameters
	     **
	     - x (number) x position of the text
	     - y (number) y position of the text
	     - string (string) text to print
	     - font (object) font object, see @Paper.getFont
	     - size (number) #optional size of the font, default is `16`
	     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
	     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
	     - line_spacing (number) #optional number in range `1..3`, default is `1`
	     = (object) resulting path element, which consist of all letters
	     > Usage
	     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
	    \*/
                paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
                    origin = origin || "middle"; // baseline|middle
                    letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
                    line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
                    var letters = Str(string)[split](E),
                        shift = 0,
                        notfirst = 0,
                        path = E,
                        scale;
                    R.is(font, "string") && (font = this.getFont(font));
                    if (font) {
                        scale = (size || 16) / font.face["units-per-em"];
                        var bb = font.face.bbox[split](separator),
                            top = +bb[0],
                            lineHeight = bb[3] - bb[1],
                            shifty = 0,
                            height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
                        for (var i = 0, ii = letters.length; i < ii; i++) {
                            if (letters[i] == "\n") {
                                shift = 0;
                                curr = 0;
                                notfirst = 0;
                                shifty += lineHeight * line_spacing;
                            } else {
                                var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                                    curr = font.glyphs[letters[i]];
                                shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                                notfirst = 1;
                            }
                            if (curr && curr.d) {
                                path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                            }
                        }
                    }
                    return this.path(path).attr({
                        fill: "#000",
                        stroke: "none"
                    });
                };

                /*\
	     * Paper.add
	     [ method ]
	     **
	     * Imports elements in JSON array in format `{type: type, <attributes>}`
	     **
	     > Parameters
	     **
	     - json (array)
	     = (object) resulting set of imported elements
	     > Usage
	     | paper.add([
	     |     {
	     |         type: "circle",
	     |         cx: 10,
	     |         cy: 10,
	     |         r: 5
	     |     },
	     |     {
	     |         type: "rect",
	     |         x: 10,
	     |         y: 10,
	     |         width: 10,
	     |         height: 10,
	     |         fill: "#fc0"
	     |     }
	     | ]);
	    \*/
                paperproto.add = function (json) {
                    if (R.is(json, "array")) {
                        var res = this.set(),
                            i = 0,
                            ii = json.length,
                            j;
                        for (; i < ii; i++) {
                            j = json[i] || {};
                            elements[has](j.type) && res.push(this[j.type]().attr(j));
                        }
                    }
                    return res;
                };

                /*\
	     * Raphael.format
	     [ method ]
	     **
	     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.
	     **
	     > Parameters
	     **
	     - token (string) string to format
	     -  (string) rest of arguments will be treated as parameters for replacement
	     = (string) formated string
	     > Usage
	     | var x = 10,
	     |     y = 20,
	     |     width = 40,
	     |     height = 50;
	     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
	     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
	    \*/
                R.format = function (token, params) {
                    var args = R.is(params, array) ? [0][concat](params) : arguments;
                    token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
                        return args[++i] == null ? E : args[i];
                    }));
                    return token || E;
                };
                /*\
	     * Raphael.fullfill
	     [ method ]
	     **
	     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.
	     **
	     > Parameters
	     **
	     - token (string) string to format
	     - json (object) object which properties will be used as a replacement
	     = (string) formated string
	     > Usage
	     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
	     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
	     |     x: 10,
	     |     y: 20,
	     |     dim: {
	     |         width: 40,
	     |         height: 50,
	     |         "negative width": -40
	     |     }
	     | }));
	    \*/
                R.fullfill = (function () {
                    var tokenRegex = /\{([^\}]+)\}/g,
                        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
                        replacer = function (all, key, obj) {
                            var res = obj;
                            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                                name = name || quotedName;
                                if (res) {
                                    if (name in res) {
                                        res = res[name];
                                    }
                                    typeof res == "function" && isFunc && (res = res());
                                }
                            });
                            res = (res == null || res == obj ? all : res) + "";
                            return res;
                        };
                    return function (str, obj) {
                        return String(str).replace(tokenRegex, function (all, key) {
                            return replacer(all, key, obj);
                        });
                    };
                })();
                /*\
	     * Raphael.ninja
	     [ method ]
	     **
	     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
	     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
	     **
	     = (object) Raphael object
	     > Usage
	     | (function (local_raphael) {
	     |     var paper = local_raphael(10, 10, 320, 200);
	     |     
	     | })(Raphael.ninja());
	    \*/
                R.ninja = function () {
                    if (oldRaphael.was) {
                        g.win.Raphael = oldRaphael.is;
                    } else {
                        // IE8 raises an error when deleting window property
                        window.Raphael = undefined;
                        try {
                            delete window.Raphael;
                        } catch (e) {
                        }
                    }
                    return R;
                };
                /*\
	     * Raphael.st
	     [ property (object) ]
	     **
	     * You can add your own method to elements and sets. It is wise to add a set method for each element method
	     * you added, so you will be able to call the same method on sets too.
	     **
	     * See also @Raphael.el.
	     > Usage
	     | Raphael.el.red = function () {
	     |     this.attr({fill: "#f00"});
	     | };
	     | Raphael.st.red = function () {
	     |     this.forEach(function (el) {
	     |         el.red();
	     |     });
	     | };
	     | // then use it
	     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
	    \*/
                R.st = setproto;

                eve.on("raphael.DOMload", function () {
                    loaded = true;
                });

                // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
                (function (doc, loaded, f) {
                    if (doc.readyState == null && doc.addEventListener) {
                        doc.addEventListener(loaded, f = function () {
                            doc.removeEventListener(loaded, f, false);
                            doc.readyState = "complete";
                        }, false);
                        doc.readyState = "loading";
                    }

                    function isLoaded() {
                        (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
                    }

                    isLoaded();
                })(document, "DOMContentLoaded");

                return R;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        },
        /* 2 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
            //
            // Licensed under the Apache License, Version 2.0 (the "License");
            // you may not use this file except in compliance with the License.
            // You may obtain a copy of the License at
            //
            // http://www.apache.org/licenses/LICENSE-2.0
            //
            // Unless required by applicable law or agreed to in writing, software
            // distributed under the License is distributed on an "AS IS" BASIS,
            // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            // See the License for the specific language governing permissions and
            // limitations under the License.
            //  \\
            //  Eve 0.5.0 - JavaScript Events Library                       \\
            //  \\
            //  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
            //  \\

            (function (glob) {
                var version = "0.5.0",
                    has = "hasOwnProperty",
                    separator = /[\.\/]/,
                    comaseparator = /\s*,\s*/,
                    wildcard = "*",
                    fun = function () {
                    },
                    numsort = function (a, b) {
                        return a - b;
                    },
                    current_event,
                    stop,
                    events = {n: {}},
                    firstDefined = function () {
                        for (var i = 0, ii = this.length; i < ii; i++) {
                            if (typeof this[i] != "undefined") {
                                return this[i];
                            }
                        }
                    },
                    lastDefined = function () {
                        var i = this.length;
                        while (--i) {
                            if (typeof this[i] != "undefined") {
                                return this[i];
                            }
                        }
                    },
                    objtos = Object.prototype.toString,
                    Str = String,
                    isArray = Array.isArray || function (ar) {
                        return ar instanceof Array || objtos.call(ar) == "[object Array]";
                    };
                /*\
	     * eve
	     [ method ]

	     * Fires event with given `name`, given scope and other parameters.

	     > Arguments

	     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
	     - scope (object) context for the event handlers
	     - varargs (...) the rest of arguments will be sent to event handlers

	     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
	    \*/
                eve = function (name, scope) {
                    var e = events,
                        oldstop = stop,
                        args = Array.prototype.slice.call(arguments, 2),
                        listeners = eve.listeners(name),
                        z = 0,
                        f = false,
                        l,
                        indexed = [],
                        queue = {},
                        out = [],
                        ce = current_event,
                        errors = [];
                    out.firstDefined = firstDefined;
                    out.lastDefined = lastDefined;
                    current_event = name;
                    stop = 0;
                    for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                        indexed.push(listeners[i].zIndex);
                        if (listeners[i].zIndex < 0) {
                            queue[listeners[i].zIndex] = listeners[i];
                        }
                    }
                    indexed.sort(numsort);
                    while (indexed[z] < 0) {
                        l = queue[indexed[z++]];
                        out.push(l.apply(scope, args));
                        if (stop) {
                            stop = oldstop;
                            return out;
                        }
                    }
                    for (i = 0; i < ii; i++) {
                        l = listeners[i];
                        if ("zIndex" in l) {
                            if (l.zIndex == indexed[z]) {
                                out.push(l.apply(scope, args));
                                if (stop) {
                                    break;
                                }
                                do {
                                    z++;
                                    l = queue[indexed[z]];
                                    l && out.push(l.apply(scope, args));
                                    if (stop) {
                                        break;
                                    }
                                } while (l)
                            } else {
                                queue[l.zIndex] = l;
                            }
                        } else {
                            out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        }
                    }
                    stop = oldstop;
                    current_event = ce;
                    return out;
                };
                // Undocumented. Debug only.
                eve._events = events;
                /*\
	     * eve.listeners
	     [ method ]

	     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

	     > Arguments

	     - name (string) name of the event, dot (`.`) or slash (`/`) separated

	     = (array) array of event handlers
	    \*/
                eve.listeners = function (name) {
                    var names = isArray(name) ? name : name.split(separator),
                        e = events,
                        item,
                        items,
                        k,
                        i,
                        ii,
                        j,
                        jj,
                        nes,
                        es = [e],
                        out = [];
                    for (i = 0, ii = names.length; i < ii; i++) {
                        nes = [];
                        for (j = 0, jj = es.length; j < jj; j++) {
                            e = es[j].n;
                            items = [e[names[i]], e[wildcard]];
                            k = 2;
                            while (k--) {
                                item = items[k];
                                if (item) {
                                    nes.push(item);
                                    out = out.concat(item.f || []);
                                }
                            }
                        }
                        es = nes;
                    }
                    return out;
                };
                /*\
	     * eve.separator
	     [ method ]

	     * If for some reasons you dont like default separators (`.` or `/`) you can specify yours
	     * here. Be aware that if you pass a string longer than one character it will be treated as
	     * a list of characters.

	     - separator (string) new separator. Empty string resets to default: `.` or `/`.
	    \*/
                eve.separator = function (sep) {
                    if (sep) {
                        sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
                        sep = "[" + sep + "]";
                        separator = new RegExp(sep);
                    } else {
                        separator = /[\.\/]/;
                    }
                };
                /*\
	     * eve.on
	     [ method ]
	     **
	     * Binds given event handler with a given name. You can use wildcards `*` for the names:
	     | eve.on("*.under.*", f);
	     | eve("mouse.under.floor"); // triggers f
	     * Use @eve to trigger the listener.
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     - name (array) if you dont want to use separators, you can use array of strings
	     - f (function) event handler function
	     **
	     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
	     > Example:
	     | eve.on("mouse", eatIt)(2);
	     | eve.on("mouse", scream);
	     | eve.on("mouse", catchIt)(1);
	     * This will ensure that `catchIt` function will be called before `eatIt`.
	     *
	     * If you want to put your handler before non-indexed handlers, specify a negative value.
	     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
	    \*/
                eve.on = function (name, f) {
                    if (typeof f != "function") {
                        return function () {
                        };
                    }
                    var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                    for (var i = 0, ii = names.length; i < ii; i++) {
                        (function (name) {
                            var names = isArray(name) ? name : Str(name).split(separator),
                                e = events,
                                exist;
                            for (var i = 0, ii = names.length; i < ii; i++) {
                                e = e.n;
                                e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                            }
                            e.f = e.f || [];
                            for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                                exist = true;
                                break;
                            }
                            !exist && e.f.push(f);
                        }(names[i]));
                    }
                    return function (zIndex) {
                        if (+zIndex == +zIndex) {
                            f.zIndex = +zIndex;
                        }
                    };
                };
                /*\
	     * eve.f
	     [ method ]
	     **
	     * Returns function that will fire given event with optional arguments.
	     * Arguments that will be passed to the result function will be also
	     * concated to the list of final arguments.
	     | el.onclick = eve.f("click", 1, 2);
	     | eve.on("click", function (a, b, c) {
	     |     console.log(a, b, c); // 1, 2, [event object]
	     | });
	     > Arguments
	     - event (string) event name
	     - varargs () and any other arguments
	     = (function) possible event handler function
	    \*/
                eve.f = function (event) {
                    var attrs = [].slice.call(arguments, 1);
                    return function () {
                        eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
                    };
                };
                /*\
	     * eve.stop
	     [ method ]
	     **
	     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
	    \*/
                eve.stop = function () {
                    stop = 1;
                };
                /*\
	     * eve.nt
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     > Arguments
	     **
	     - subname (string) #optional subname of the event
	     **
	     = (string) name of the event, if `subname` is not specified
	     * or
	     = (boolean) `true`, if current events name contains `subname`
	    \*/
                eve.nt = function (subname) {
                    var cur = isArray(current_event) ? current_event.join(".") : current_event;
                    if (subname) {
                        return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
                    }
                    return cur;
                };
                /*\
	     * eve.nts
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     **
	     = (array) names of the event
	    \*/
                eve.nts = function () {
                    return isArray(current_event) ? current_event : current_event.split(separator);
                };
                /*\
	     * eve.off
	     [ method ]
	     **
	     * Removes given function from the list of event listeners assigned to given name.
	     * If no arguments specified all the events will be cleared.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	    \*/
                /*\
	     * eve.unbind
	     [ method ]
	     **
	     * See @eve.off
	    \*/
                eve.off = eve.unbind = function (name, f) {
                    if (!name) {
                        eve._events = events = {n: {}};
                        return;
                    }
                    var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
                    if (names.length > 1) {
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            eve.off(names[i], f);
                        }
                        return;
                    }
                    names = isArray(name) ? name : Str(name).split(separator);
                    var e,
                        key,
                        splice,
                        i, ii, j, jj,
                        cur = [events];
                    for (i = 0, ii = names.length; i < ii; i++) {
                        for (j = 0; j < cur.length; j += splice.length - 2) {
                            splice = [j, 1];
                            e = cur[j].n;
                            if (names[i] != wildcard) {
                                if (e[names[i]]) {
                                    splice.push(e[names[i]]);
                                }
                            } else {
                                for (key in e) if (e[has](key)) {
                                    splice.push(e[key]);
                                }
                            }
                            cur.splice.apply(cur, splice);
                        }
                    }
                    for (i = 0, ii = cur.length; i < ii; i++) {
                        e = cur[i];
                        while (e.n) {
                            if (f) {
                                if (e.f) {
                                    for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                                        e.f.splice(j, 1);
                                        break;
                                    }
                                    !e.f.length && delete e.f;
                                }
                                for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                    var funcs = e.n[key].f;
                                    for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                                        funcs.splice(j, 1);
                                        break;
                                    }
                                    !funcs.length && delete e.n[key].f;
                                }
                            } else {
                                delete e.f;
                                for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                                    delete e.n[key].f;
                                }
                            }
                            e = e.n;
                        }
                    }
                };
                /*\
	     * eve.once
	     [ method ]
	     **
	     * Binds given event handler with a given name to only run once then unbind itself.
	     | eve.once("login", f);
	     | eve("login"); // triggers f
	     | eve("login"); // no listeners
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) same return function as @eve.on
	    \*/
                eve.once = function (name, f) {
                    var f2 = function () {
                        eve.off(name, f2);
                        return f.apply(this, arguments);
                    };
                    return eve.on(name, f2);
                };
                /*\
	     * eve.version
	     [ property (string) ]
	     **
	     * Current version of the library.
	    \*/
                eve.version = version;
                eve.toString = function () {
                    return "You are running Eve " + version;
                };
                (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
                    return eve;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
            })(this);


            /***/
        },
        /* 3 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {
                if (R && !R.svg) {
                    return;
                }

                var has = "hasOwnProperty",
                    Str = String,
                    toFloat = parseFloat,
                    toInt = parseInt,
                    math = Math,
                    mmax = math.max,
                    abs = math.abs,
                    pow = math.pow,
                    separator = /[, ]+/,
                    eve = R.eve,
                    E = "",
                    S = " ";
                var xlink = "http://www.w3.org/1999/xlink",
                    markers = {
                        block: "M5,0 0,2.5 5,5z",
                        classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
                        diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
                        open: "M6,1 1,3.5 6,6",
                        oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
                    },
                    markerCounter = {};
                R.toString = function () {
                    return "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
                };
                var $ = function (el, attr) {
                        if (attr) {
                            if (typeof el == "string") {
                                el = $(el);
                            }
                            for (var key in attr) if (attr[has](key)) {
                                if (key.substring(0, 6) == "xlink:") {
                                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                                } else {
                                    el.setAttribute(key, Str(attr[key]));
                                }
                            }
                        } else {
                            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
                        }
                        return el;
                    },
                    addGradientFill = function (element, gradient) {
                        var type = "linear",
                            id = element.id + gradient,
                            fx = .5, fy = .5,
                            o = element.node,
                            SVG = element.paper,
                            s = o.style,
                            el = R._g.doc.getElementById(id);
                        if (!el) {
                            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                                type = "radial";
                                if (_fx && _fy) {
                                    fx = toFloat(_fx);
                                    fy = toFloat(_fy);
                                    var dir = ((fy > .5) * 2 - 1);
                                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                                    (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                                    fy != .5 &&
                                    (fy = fy.toFixed(5) - 1e-5 * dir);
                                }
                                return E;
                            });
                            gradient = gradient.split(/\s*\-\s*/);
                            if (type == "linear") {
                                var angle = gradient.shift();
                                angle = -toFloat(angle);
                                if (isNaN(angle)) {
                                    return null;
                                }
                                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                                vector[2] *= max;
                                vector[3] *= max;
                                if (vector[2] < 0) {
                                    vector[0] = -vector[2];
                                    vector[2] = 0;
                                }
                                if (vector[3] < 0) {
                                    vector[1] = -vector[3];
                                    vector[3] = 0;
                                }
                            }
                            var dots = R._parseDots(gradient);
                            if (!dots) {
                                return null;
                            }
                            id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                            if (element.gradient && id != element.gradient.id) {
                                SVG.defs.removeChild(element.gradient);
                                delete element.gradient;
                            }

                            if (!element.gradient) {
                                el = $(type + "Gradient", {id: id});
                                element.gradient = el;
                                $(el, type == "radial" ? {
                                    fx: fx,
                                    fy: fy
                                } : {
                                    x1: vector[0],
                                    y1: vector[1],
                                    x2: vector[2],
                                    y2: vector[3],
                                    gradientTransform: element.matrix.invert()
                                });
                                SVG.defs.appendChild(el);
                                for (var i = 0, ii = dots.length; i < ii; i++) {
                                    el.appendChild($("stop", {
                                        offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                                        "stop-color": dots[i].color || "#fff",
                                        "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                                    }));
                                }
                            }
                        }
                        $(o, {
                            fill: fillurl(id),
                            opacity: 1,
                            "fill-opacity": 1
                        });
                        s.fill = E;
                        s.opacity = 1;
                        s.fillOpacity = 1;
                        return 1;
                    },
                    isIE9or10 = function () {
                        var mode = document.documentMode;
                        return mode && (mode === 9 || mode === 10);
                    },
                    fillurl = function (id) {
                        if (isIE9or10()) {
                            return "url('#" + id + "')";
                        }
                        var location = document.location;
                        var locationString = (
                            location.protocol + '//' +
                            location.host +
                            location.pathname +
                            location.search
                        );
                        return "url('" + locationString + "#" + id + "')";
                    },
                    updatePosition = function (o) {
                        var bbox = o.getBBox(1);
                        $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
                    },
                    addArrow = function (o, value, isEnd) {
                        if (o.type == "path") {
                            var values = Str(value).toLowerCase().split("-"),
                                p = o.paper,
                                se = isEnd ? "end" : "start",
                                node = o.node,
                                attrs = o.attrs,
                                stroke = attrs["stroke-width"],
                                i = values.length,
                                type = "classic",
                                from,
                                to,
                                dx,
                                refX,
                                attr,
                                w = 3,
                                h = 3,
                                t = 5;
                            while (i--) {
                                switch (values[i]) {
                                    case "block":
                                    case "classic":
                                    case "oval":
                                    case "diamond":
                                    case "open":
                                    case "none":
                                        type = values[i];
                                        break;
                                    case "wide":
                                        h = 5;
                                        break;
                                    case "narrow":
                                        h = 2;
                                        break;
                                    case "long":
                                        w = 5;
                                        break;
                                    case "short":
                                        w = 2;
                                        break;
                                }
                            }
                            if (type == "open") {
                                w += 2;
                                h += 2;
                                t += 2;
                                dx = 1;
                                refX = isEnd ? 4 : 1;
                                attr = {
                                    fill: "none",
                                    stroke: attrs.stroke
                                };
                            } else {
                                refX = dx = w / 2;
                                attr = {
                                    fill: attrs.stroke,
                                    stroke: "none"
                                };
                            }
                            if (o._.arrows) {
                                if (isEnd) {
                                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                                } else {
                                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                                }
                            } else {
                                o._.arrows = {};
                            }
                            if (type != "none") {
                                var pathId = "raphael-marker-" + type,
                                    markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                                if (!R._g.doc.getElementById(pathId)) {
                                    p.defs.appendChild($($("path"), {
                                        "stroke-linecap": "round",
                                        d: markers[type],
                                        id: pathId
                                    }));
                                    markerCounter[pathId] = 1;
                                } else {
                                    markerCounter[pathId]++;
                                }
                                var marker = R._g.doc.getElementById(markerId),
                                    use;
                                if (!marker) {
                                    marker = $($("marker"), {
                                        id: markerId,
                                        markerHeight: h,
                                        markerWidth: w,
                                        orient: "auto",
                                        refX: refX,
                                        refY: h / 2
                                    });
                                    use = $($("use"), {
                                        "xlink:href": "#" + pathId,
                                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                                    });
                                    marker.appendChild(use);
                                    p.defs.appendChild(marker);
                                    markerCounter[markerId] = 1;
                                } else {
                                    markerCounter[markerId]++;
                                    use = marker.getElementsByTagName("use")[0];
                                }
                                $(use, attr);
                                var delta = dx * (type != "diamond" && type != "oval");
                                if (isEnd) {
                                    from = o._.arrows.startdx * stroke || 0;
                                    to = R.getTotalLength(attrs.path) - delta * stroke;
                                } else {
                                    from = delta * stroke;
                                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                }
                                attr = {};
                                attr["marker-" + se] = "url(#" + markerId + ")";
                                if (to || from) {
                                    attr.d = R.getSubpath(attrs.path, from, to);
                                }
                                $(node, attr);
                                o._.arrows[se + "Path"] = pathId;
                                o._.arrows[se + "Marker"] = markerId;
                                o._.arrows[se + "dx"] = delta;
                                o._.arrows[se + "Type"] = type;
                                o._.arrows[se + "String"] = value;
                            } else {
                                if (isEnd) {
                                    from = o._.arrows.startdx * stroke || 0;
                                    to = R.getTotalLength(attrs.path) - from;
                                } else {
                                    from = 0;
                                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                                }
                                o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                                delete o._.arrows[se + "Path"];
                                delete o._.arrows[se + "Marker"];
                                delete o._.arrows[se + "dx"];
                                delete o._.arrows[se + "Type"];
                                delete o._.arrows[se + "String"];
                            }
                            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                                var item = R._g.doc.getElementById(attr);
                                item && item.parentNode.removeChild(item);
                            }
                        }
                    },
                    dasharray = {
                        "-": [3, 1],
                        ".": [1, 1],
                        "-.": [3, 1, 1, 1],
                        "-..": [3, 1, 1, 1, 1, 1],
                        ". ": [1, 3],
                        "- ": [4, 3],
                        "--": [8, 3],
                        "- .": [4, 3, 1, 3],
                        "--.": [8, 3, 1, 3],
                        "--..": [8, 3, 1, 3, 1, 3]
                    },
                    addDashes = function (o, value, params) {
                        value = dasharray[Str(value).toLowerCase()];
                        if (value) {
                            var width = o.attrs["stroke-width"] || "1",
                                butt = {
                                    round: width,
                                    square: width,
                                    butt: 0
                                }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                                dashes = [],
                                i = value.length;
                            while (i--) {
                                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                            }
                            $(o.node, {"stroke-dasharray": dashes.join(",")});
                        }
                        else {
                            $(o.node, {"stroke-dasharray": "none"});
                        }
                    },
                    setFillAndStroke = function (o, params) {
                        var node = o.node,
                            attrs = o.attrs,
                            vis = node.style.visibility;
                        node.style.visibility = "hidden";
                        for (var att in params) {
                            if (params[has](att)) {
                                if (!R._availableAttrs[has](att)) {
                                    continue;
                                }
                                var value = params[att];
                                attrs[att] = value;
                                switch (att) {
                                    case "blur":
                                        o.blur(value);
                                        break;
                                    case "title":
                                        var title = node.getElementsByTagName("title");

                                        // Use the existing <title>.
                                        if (title.length && (title = title[0])) {
                                            title.firstChild.nodeValue = value;
                                        } else {
                                            title = $("title");
                                            var val = R._g.doc.createTextNode(value);
                                            title.appendChild(val);
                                            node.appendChild(title);
                                        }
                                        break;
                                    case "href":
                                    case "target":
                                        var pn = node.parentNode;
                                        if (pn.tagName.toLowerCase() != "a") {
                                            var hl = $("a");
                                            pn.insertBefore(hl, node);
                                            hl.appendChild(node);
                                            pn = hl;
                                        }
                                        if (att == "target") {
                                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                                        } else {
                                            pn.setAttributeNS(xlink, att, value);
                                        }
                                        break;
                                    case "cursor":
                                        node.style.cursor = value;
                                        break;
                                    case "transform":
                                        o.transform(value);
                                        break;
                                    case "arrow-start":
                                        addArrow(o, value);
                                        break;
                                    case "arrow-end":
                                        addArrow(o, value, 1);
                                        break;
                                    case "clip-rect":
                                        var rect = Str(value).split(separator);
                                        if (rect.length == 4) {
                                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                            var el = $("clipPath"),
                                                rc = $("rect");
                                            el.id = R.createUUID();
                                            $(rc, {
                                                x: rect[0],
                                                y: rect[1],
                                                width: rect[2],
                                                height: rect[3]
                                            });
                                            el.appendChild(rc);
                                            o.paper.defs.appendChild(el);
                                            $(node, {"clip-path": "url(#" + el.id + ")"});
                                            o.clip = rc;
                                        }
                                        if (!value) {
                                            var path = node.getAttribute("clip-path");
                                            if (path) {
                                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                                clip && clip.parentNode.removeChild(clip);
                                                $(node, {"clip-path": E});
                                                delete o.clip;
                                            }
                                        }
                                        break;
                                    case "path":
                                        if (o.type == "path") {
                                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                                            o._.dirty = 1;
                                            if (o._.arrows) {
                                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                            }
                                        }
                                        break;
                                    case "width":
                                        node.setAttribute(att, value);
                                        o._.dirty = 1;
                                        if (attrs.fx) {
                                            att = "x";
                                            value = attrs.x;
                                        } else {
                                            break;
                                        }
                                    case "x":
                                        if (attrs.fx) {
                                            value = -attrs.x - (attrs.width || 0);
                                        }
                                    case "rx":
                                        if (att == "rx" && o.type == "rect") {
                                            break;
                                        }
                                    case "cx":
                                        node.setAttribute(att, value);
                                        o.pattern && updatePosition(o);
                                        o._.dirty = 1;
                                        break;
                                    case "height":
                                        node.setAttribute(att, value);
                                        o._.dirty = 1;
                                        if (attrs.fy) {
                                            att = "y";
                                            value = attrs.y;
                                        } else {
                                            break;
                                        }
                                    case "y":
                                        if (attrs.fy) {
                                            value = -attrs.y - (attrs.height || 0);
                                        }
                                    case "ry":
                                        if (att == "ry" && o.type == "rect") {
                                            break;
                                        }
                                    case "cy":
                                        node.setAttribute(att, value);
                                        o.pattern && updatePosition(o);
                                        o._.dirty = 1;
                                        break;
                                    case "r":
                                        if (o.type == "rect") {
                                            $(node, {rx: value, ry: value});
                                        } else {
                                            node.setAttribute(att, value);
                                        }
                                        o._.dirty = 1;
                                        break;
                                    case "src":
                                        if (o.type == "image") {
                                            node.setAttributeNS(xlink, "href", value);
                                        }
                                        break;
                                    case "stroke-width":
                                        if (o._.sx != 1 || o._.sy != 1) {
                                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                                        }
                                        node.setAttribute(att, value);
                                        if (attrs["stroke-dasharray"]) {
                                            addDashes(o, attrs["stroke-dasharray"], params);
                                        }
                                        if (o._.arrows) {
                                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                        }
                                        break;
                                    case "stroke-dasharray":
                                        addDashes(o, value, params);
                                        break;
                                    case "fill":
                                        var isURL = Str(value).match(R._ISURL);
                                        if (isURL) {
                                            el = $("pattern");
                                            var ig = $("image");
                                            el.id = R.createUUID();
                                            $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                            $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                                            el.appendChild(ig);

                                            (function (el) {
                                                R._preload(isURL[1], function () {
                                                    var w = this.offsetWidth,
                                                        h = this.offsetHeight;
                                                    $(el, {width: w, height: h});
                                                    $(ig, {width: w, height: h});
                                                });
                                            })(el);
                                            o.paper.defs.appendChild(el);
                                            $(node, {fill: "url(#" + el.id + ")"});
                                            o.pattern = el;
                                            o.pattern && updatePosition(o);
                                            break;
                                        }
                                        var clr = R.getRGB(value);
                                        if (!clr.error) {
                                            delete params.gradient;
                                            delete attrs.gradient;
                                            !R.is(attrs.opacity, "undefined") &&
                                            R.is(params.opacity, "undefined") &&
                                            $(node, {opacity: attrs.opacity});
                                            !R.is(attrs["fill-opacity"], "undefined") &&
                                            R.is(params["fill-opacity"], "undefined") &&
                                            $(node, {"fill-opacity": attrs["fill-opacity"]});
                                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                                if (gradient) {
                                                    var stops = gradient.getElementsByTagName("stop");
                                                    $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                                }
                                            }
                                            attrs.gradient = value;
                                            attrs.fill = "none";
                                            break;
                                        }
                                        clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                    case "stroke":
                                        clr = R.getRGB(value);
                                        node.setAttribute(att, clr.hex);
                                        att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                                        if (att == "stroke" && o._.arrows) {
                                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                        }
                                        break;
                                    case "gradient":
                                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                                        break;
                                    case "opacity":
                                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                            $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                                        }
                                    // fall
                                    case "fill-opacity":
                                        if (attrs.gradient) {
                                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                            if (gradient) {
                                                stops = gradient.getElementsByTagName("stop");
                                                $(stops[stops.length - 1], {"stop-opacity": value});
                                            }
                                            break;
                                        }
                                    default:
                                        att == "font-size" && (value = toInt(value, 10) + "px");
                                        var cssrule = att.replace(/(\-.)/g, function (w) {
                                            return w.substring(1).toUpperCase();
                                        });
                                        node.style[cssrule] = value;
                                        o._.dirty = 1;
                                        node.setAttribute(att, value);
                                        break;
                                }
                            }
                        }

                        tuneText(o, params);
                        node.style.visibility = vis;
                    },
                    leading = 1.2,
                    tuneText = function (el, params) {
                        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                            return;
                        }
                        var a = el.attrs,
                            node = el.node,
                            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

                        if (params[has]("text")) {
                            a.text = params.text;
                            while (node.firstChild) {
                                node.removeChild(node.firstChild);
                            }
                            var texts = Str(params.text).split("\n"),
                                tspans = [],
                                tspan;
                            for (var i = 0, ii = texts.length; i < ii; i++) {
                                tspan = $("tspan");
                                i && $(tspan, {dy: fontSize * leading, x: a.x});
                                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                                node.appendChild(tspan);
                                tspans[i] = tspan;
                            }
                        } else {
                            tspans = node.getElementsByTagName("tspan");
                            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                                $(tspans[i], {dy: fontSize * leading, x: a.x});
                            } else {
                                $(tspans[0], {dy: 0});
                            }
                        }
                        $(node, {x: a.x, y: a.y});
                        el._.dirty = 1;
                        var bb = el._getBBox(),
                            dif = a.y - (bb.y + bb.height / 2);
                        dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
                    },
                    getRealNode = function (node) {
                        if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
                            return node.parentNode;
                        } else {
                            return node;
                        }
                    },
                    Element = function (node, svg) {
                        var X = 0,
                            Y = 0;
                        /*\
	         * Element.node
	         [ property (object) ]
	         **
	         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
	         **
	         * Note: Dont mess with it.
	         > Usage
	         | // draw a circle at coordinate 10,10 with radius of 10
	         | var c = paper.circle(10, 10, 10);
	         | c.node.onclick = function () {
	         |     c.attr("fill", "red");
	         | };
	        \*/
                        this[0] = this.node = node;
                        /*\
	         * Element.raphael
	         [ property (object) ]
	         **
	         * Internal reference to @Raphael object. In case it is not available.
	         > Usage
	         | Raphael.el.red = function () {
	         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
	         |     hsb.h = 1;
	         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
	         | }
	        \*/
                        node.raphael = true;
                        /*\
	         * Element.id
	         [ property (number) ]
	         **
	         * Unique id of the element. Especially useful when you want to listen to events of the element,
	         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
	        \*/
                        this.id = guid();
                        node.raphaelid = this.id;

                        /**
                         * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
                         * @returns {string} id
                         */
                        function guid() {
                            return ("0000" + (Math.random() * Math.pow(36, 5) << 0).toString(36)).slice(-5);
                        }

                        this.matrix = R.matrix();
                        this.realPath = null;
                        /*\
	         * Element.paper
	         [ property (object) ]
	         **
	         * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.
	         > Usage
	         | Raphael.el.cross = function () {
	         |     this.attr({fill: "red"});
	         |     this.paper.path("M10,10L50,50M50,10L10,50")
	         |         .attr({stroke: "red"});
	         | }
	        \*/
                        this.paper = svg;
                        this.attrs = this.attrs || {};
                        this._ = {
                            transform: [],
                            sx: 1,
                            sy: 1,
                            deg: 0,
                            dx: 0,
                            dy: 0,
                            dirty: 1
                        };
                        !svg.bottom && (svg.bottom = this);
                        /*\
	         * Element.prev
	         [ property (object) ]
	         **
	         * Reference to the previous element in the hierarchy.
	        \*/
                        this.prev = svg.top;
                        svg.top && (svg.top.next = this);
                        svg.top = this;
                        /*\
	         * Element.next
	         [ property (object) ]
	         **
	         * Reference to the next element in the hierarchy.
	        \*/
                        this.next = null;
                    },
                    elproto = R.el;

                Element.prototype = elproto;
                elproto.constructor = Element;

                R._engine.path = function (pathString, SVG) {
                    var el = $("path");
                    SVG.canvas && SVG.canvas.appendChild(el);
                    var p = new Element(el, SVG);
                    p.type = "path";
                    setFillAndStroke(p, {
                        fill: "none",
                        stroke: "#000",
                        path: pathString
                    });
                    return p;
                };
                /*\
	     * Element.rotate
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds rotation by given angle around given point to the list of
	     * transformations of the element.
	     > Parameters
	     - deg (number) angle in degrees
	     - cx (number) #optional x coordinate of the centre of rotation
	     - cy (number) #optional y coordinate of the centre of rotation
	     * If cx & cy arent specified centre of the shape is used as a point of rotation.
	     = (object) @Element
	    \*/
                elproto.rotate = function (deg, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    deg = Str(deg).split(separator);
                    if (deg.length - 1) {
                        cx = toFloat(deg[1]);
                        cy = toFloat(deg[2]);
                    }
                    deg = toFloat(deg[0]);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                        cx = bbox.x + bbox.width / 2;
                        cy = bbox.y + bbox.height / 2;
                    }
                    this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                    return this;
                };
                /*\
	     * Element.scale
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds scale by given amount relative to given point to the list of
	     * transformations of the element.
	     > Parameters
	     - sx (number) horisontal scale amount
	     - sy (number) vertical scale amount
	     - cx (number) #optional x coordinate of the centre of scale
	     - cy (number) #optional y coordinate of the centre of scale
	     * If cx & cy arent specified centre of the shape is used instead.
	     = (object) @Element
	    \*/
                elproto.scale = function (sx, sy, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    sx = Str(sx).split(separator);
                    if (sx.length - 1) {
                        sy = toFloat(sx[1]);
                        cx = toFloat(sx[2]);
                        cy = toFloat(sx[3]);
                    }
                    sx = toFloat(sx[0]);
                    (sy == null) && (sy = sx);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                    }
                    cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                    cy = cy == null ? bbox.y + bbox.height / 2 : cy;
                    this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                    return this;
                };
                /*\
	     * Element.translate
	     [ method ]
	     **
	     * Deprecated! Use @Element.transform instead.
	     * Adds translation by given amount to the list of transformations of the element.
	     > Parameters
	     - dx (number) horisontal shift
	     - dy (number) vertical shift
	     = (object) @Element
	    \*/
                elproto.translate = function (dx, dy) {
                    if (this.removed) {
                        return this;
                    }
                    dx = Str(dx).split(separator);
                    if (dx.length - 1) {
                        dy = toFloat(dx[1]);
                    }
                    dx = toFloat(dx[0]) || 0;
                    dy = +dy || 0;
                    this.transform(this._.transform.concat([["t", dx, dy]]));
                    return this;
                };
                /*\
	     * Element.transform
	     [ method ]
	     **
	     * Adds transformation to the element which is separate to other attributes,
	     * i.e. translation doesnt change `x` or `y` of the rectange. The format
	     * of transformation string is similar to the path string syntax:
	     | "t100,100r30,100,100s2,2,100,100r45s1.5"
	     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
	     * scale and `m` is for matrix.
	     *
	     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
	     *
	     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;
	     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin
	     * coordinates as optional parameters, the default is the centre point of the element.
	     * Matrix accepts six parameters.
	     > Usage
	     | var el = paper.rect(10, 20, 300, 200);
	     | // translate 100, 100, rotate 45, translate -100, 0
	     | el.transform("t100,100r45t-100,0");
	     | // if you want you can append or prepend transformations
	     | el.transform("...t50,50");
	     | el.transform("s2...");
	     | // or even wrap
	     | el.transform("t50,50...t-50-50");
	     | // to reset transformation call method with empty string
	     | el.transform("");
	     | // to get current value call it without parameters
	     | console.log(el.transform());
	     > Parameters
	     - tstr (string) #optional transformation string
	     * If tstr isnt specified
	     = (string) current transformation string
	     * else
	     = (object) @Element
	    \*/
                elproto.transform = function (tstr) {
                    var _ = this._;
                    if (tstr == null) {
                        return _.transform;
                    }
                    R._extractTransform(this, tstr);

                    this.clip && $(this.clip, {transform: this.matrix.invert()});
                    this.pattern && updatePosition(this);
                    this.node && $(this.node, {transform: this.matrix});

                    if (_.sx != 1 || _.sy != 1) {
                        var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
                        this.attr({"stroke-width": sw});
                    }

                    return this;
                };
                /*\
	     * Element.hide
	     [ method ]
	     **
	     * Makes element invisible. See @Element.show.
	     = (object) @Element
	    \*/
                elproto.hide = function () {
                    if (!this.removed) this.node.style.display = "none";
                    return this;
                };
                /*\
	     * Element.show
	     [ method ]
	     **
	     * Makes element visible. See @Element.hide.
	     = (object) @Element
	    \*/
                elproto.show = function () {
                    if (!this.removed) this.node.style.display = "";
                    return this;
                };
                /*\
	     * Element.remove
	     [ method ]
	     **
	     * Removes element from the paper.
	    \*/
                elproto.remove = function () {
                    var node = getRealNode(this.node);
                    if (this.removed || !node.parentNode) {
                        return;
                    }
                    var paper = this.paper;
                    paper.__set__ && paper.__set__.exclude(this);
                    eve.unbind("raphael.*.*." + this.id);
                    if (this.gradient) {
                        paper.defs.removeChild(this.gradient);
                    }
                    R._tear(this, paper);

                    node.parentNode.removeChild(node);

                    // Remove custom data for element
                    this.removeData();

                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    this.removed = true;
                };
                elproto._getBBox = function () {
                    if (this.node.style.display == "none") {
                        this.show();
                        var hide = true;
                    }
                    var canvasHidden = false,
                        containerStyle;
                    if (this.paper.canvas.parentElement) {
                        containerStyle = this.paper.canvas.parentElement.style;
                    } //IE10+ can't find parentElement
                    else if (this.paper.canvas.parentNode) {
                        containerStyle = this.paper.canvas.parentNode.style;
                    }

                    if (containerStyle && containerStyle.display == "none") {
                        canvasHidden = true;
                        containerStyle.display = "";
                    }
                    var bbox = {};
                    try {
                        bbox = this.node.getBBox();
                    } catch (e) {
                        // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
                        bbox = {
                            x: this.node.clientLeft,
                            y: this.node.clientTop,
                            width: this.node.clientWidth,
                            height: this.node.clientHeight
                        }
                    } finally {
                        bbox = bbox || {};
                        if (canvasHidden) {
                            containerStyle.display = "none";
                        }
                    }
                    hide && this.hide();
                    return bbox;
                };
                /*\
	     * Element.attr
	     [ method ]
	     **
	     * Sets the attributes of the element.
	     > Parameters
	     - attrName (string) attributes name
	     - value (string) value
	     * or
	     - params (object) object of name/value pairs
	     * or
	     - attrName (string) attributes name
	     * or
	     - attrNames (array) in this case method returns array of current values for given attribute names
	     = (object) @Element if attrsName & value or params are passed in.
	     = (...) value of the attribute if only attrsName is passed in.
	     = (array) array of values of the attribute if attrsNames is passed in.
	     = (object) object of attributes if nothing is passed in.
	     > Possible parameters
	     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
	     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
	     o clip-rect (string) comma or space separated values: x, y, width and height
	     o cursor (string) CSS type of the cursor
	     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
	     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
	     o fill (string) colour, gradient or image
	     o fill-opacity (number)
	     o font (string)
	     o font-family (string)
	     o font-size (number) font size in pixels
	     o font-weight (string)
	     o height (number)
	     o href (string) URL, if specified element behaves as hyperlink
	     o opacity (number)
	     o path (string) SVG path string format
	     o r (number) radius of the circle, ellipse or rounded corner on the rect
	     o rx (number) horisontal radius of the ellipse
	     o ry (number) vertical radius of the ellipse
	     o src (string) image URL, only works for @Element.image element
	     o stroke (string) stroke colour
	     o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]
	     o stroke-linecap (string) [`butt`, `square`, `round`]
	     o stroke-linejoin (string) [`bevel`, `round`, `miter`]
	     o stroke-miterlimit (number)
	     o stroke-opacity (number)
	     o stroke-width (number) stroke width in pixels, default is '1'
	     o target (string) used with href
	     o text (string) contents of the text element. Use `\n` for multiline text
	     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`
	     o title (string) will create tooltip with a given text
	     o transform (string) see @Element.transform
	     o width (number)
	     o x (number)
	     o y (number)
	     > Gradients
	     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90
	     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.
	     *
	     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` 
	     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point
	     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
	     > Path String
	     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a paths data attributes format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphal fully supports it.</p>
	     > Colour Parsing
	     # <ul>
	     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
	     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
	     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
	     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
	     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
	     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>
	     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>
	     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
	     #     <li>hsb(%, %, %)  same as above, but in %</li>
	     #     <li>hsba(, , , )  same as above, but with opacity</li>
	     #     <li>hsl(, , )  almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
	     #     <li>hsl(%, %, %)  same as above, but in %</li>
	     #     <li>hsla(, , , )  same as above, but with opacity</li>
	     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>
	     # </ul>
	    \*/
                elproto.attr = function (name, value) {
                    if (this.removed) {
                        return this;
                    }
                    if (name == null) {
                        var res = {};
                        for (var a in this.attrs) if (this.attrs[has](a)) {
                            res[a] = this.attrs[a];
                        }
                        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                        res.transform = this._.transform;
                        return res;
                    }
                    if (value == null && R.is(name, "string")) {
                        if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                            return this.attrs.gradient;
                        }
                        if (name == "transform") {
                            return this._.transform;
                        }
                        var names = name.split(separator),
                            out = {};
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            name = names[i];
                            if (name in this.attrs) {
                                out[name] = this.attrs[name];
                            } else if (R.is(this.paper.customAttributes[name], "function")) {
                                out[name] = this.paper.customAttributes[name].def;
                            } else {
                                out[name] = R._availableAttrs[name];
                            }
                        }
                        return ii - 1 ? out : out[names[0]];
                    }
                    if (value == null && R.is(name, "array")) {
                        out = {};
                        for (i = 0, ii = name.length; i < ii; i++) {
                            out[name[i]] = this.attr(name[i]);
                        }
                        return out;
                    }
                    if (value != null) {
                        var params = {};
                        params[name] = value;
                    } else if (name != null && R.is(name, "object")) {
                        params = name;
                    }
                    for (var key in params) {
                        eve("raphael.attr." + key + "." + this.id, this, params[key]);
                    }
                    for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                        var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                        this.attrs[key] = params[key];
                        for (var subkey in par) if (par[has](subkey)) {
                            params[subkey] = par[subkey];
                        }
                    }
                    setFillAndStroke(this, params);
                    return this;
                };
                /*\
	     * Element.toFront
	     [ method ]
	     **
	     * Moves the element so it is the closest to the viewers eyes, on top of other elements.
	     = (object) @Element
	    \*/
                elproto.toFront = function () {
                    if (this.removed) {
                        return this;
                    }
                    var node = getRealNode(this.node);
                    node.parentNode.appendChild(node);
                    var svg = this.paper;
                    svg.top != this && R._tofront(this, svg);
                    return this;
                };
                /*\
	     * Element.toBack
	     [ method ]
	     **
	     * Moves the element so it is the furthest from the viewers eyes, behind other elements.
	     = (object) @Element
	    \*/
                elproto.toBack = function () {
                    if (this.removed) {
                        return this;
                    }
                    var node = getRealNode(this.node);
                    var parentNode = node.parentNode;
                    parentNode.insertBefore(node, parentNode.firstChild);
                    R._toback(this, this.paper);
                    var svg = this.paper;
                    return this;
                };
                /*\
	     * Element.insertAfter
	     [ method ]
	     **
	     * Inserts current object after the given one.
	     = (object) @Element
	    \*/
                elproto.insertAfter = function (element) {
                    if (this.removed || !element) {
                        return this;
                    }

                    var node = getRealNode(this.node);
                    var afterNode = getRealNode(element.node || element[element.length - 1].node);
                    if (afterNode.nextSibling) {
                        afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
                    } else {
                        afterNode.parentNode.appendChild(node);
                    }
                    R._insertafter(this, element, this.paper);
                    return this;
                };
                /*\
	     * Element.insertBefore
	     [ method ]
	     **
	     * Inserts current object before the given one.
	     = (object) @Element
	    \*/
                elproto.insertBefore = function (element) {
                    if (this.removed || !element) {
                        return this;
                    }

                    var node = getRealNode(this.node);
                    var beforeNode = getRealNode(element.node || element[0].node);
                    beforeNode.parentNode.insertBefore(node, beforeNode);
                    R._insertbefore(this, element, this.paper);
                    return this;
                };
                elproto.blur = function (size) {
                    // Experimental. No Safari support. Use it on your own risk.
                    var t = this;
                    if (+size !== 0) {
                        var fltr = $("filter"),
                            blur = $("feGaussianBlur");
                        t.attrs.blur = size;
                        fltr.id = R.createUUID();
                        $(blur, {stdDeviation: +size || 1.5});
                        fltr.appendChild(blur);
                        t.paper.defs.appendChild(fltr);
                        t._blur = fltr;
                        $(t.node, {filter: "url(#" + fltr.id + ")"});
                    } else {
                        if (t._blur) {
                            t._blur.parentNode.removeChild(t._blur);
                            delete t._blur;
                            delete t.attrs.blur;
                        }
                        t.node.removeAttribute("filter");
                    }
                    return t;
                };
                R._engine.circle = function (svg, x, y, r) {
                    var el = $("circle");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
                    res.type = "circle";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.rect = function (svg, x, y, w, h, r) {
                    var el = $("rect");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
                    res.type = "rect";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.ellipse = function (svg, x, y, rx, ry) {
                    var el = $("ellipse");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
                    res.type = "ellipse";
                    $(el, res.attrs);
                    return res;
                };
                R._engine.image = function (svg, src, x, y, w, h) {
                    var el = $("image");
                    $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
                    el.setAttributeNS(xlink, "href", src);
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {x: x, y: y, width: w, height: h, src: src};
                    res.type = "image";
                    return res;
                };
                R._engine.text = function (svg, x, y, text) {
                    var el = $("text");
                    svg.canvas && svg.canvas.appendChild(el);
                    var res = new Element(el, svg);
                    res.attrs = {
                        x: x,
                        y: y,
                        "text-anchor": "middle",
                        text: text,
                        "font-family": R._availableAttrs["font-family"],
                        "font-size": R._availableAttrs["font-size"],
                        stroke: "none",
                        fill: "#000"
                    };
                    res.type = "text";
                    setFillAndStroke(res, res.attrs);
                    return res;
                };
                R._engine.setSize = function (width, height) {
                    this.width = width || this.width;
                    this.height = height || this.height;
                    this.canvas.setAttribute("width", this.width);
                    this.canvas.setAttribute("height", this.height);
                    if (this._viewBox) {
                        this.setViewBox.apply(this, this._viewBox);
                    }
                    return this;
                };
                R._engine.create = function () {
                    var con = R._getContainer.apply(0, arguments),
                        container = con && con.container,
                        x = con.x,
                        y = con.y,
                        width = con.width,
                        height = con.height;
                    if (!container) {
                        throw new Error("SVG container not found.");
                    }
                    var cnvs = $("svg"),
                        css = "overflow:hidden;",
                        isFloating;
                    x = x || 0;
                    y = y || 0;
                    width = width || 512;
                    height = height || 342;
                    $(cnvs, {
                        height: height,
                        version: 1.1,
                        width: width,
                        xmlns: "http://www.w3.org/2000/svg",
                        "xmlns:xlink": "http://www.w3.org/1999/xlink"
                    });
                    if (container == 1) {
                        cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
                        R._g.doc.body.appendChild(cnvs);
                        isFloating = 1;
                    } else {
                        cnvs.style.cssText = css + "position:relative";
                        if (container.firstChild) {
                            container.insertBefore(cnvs, container.firstChild);
                        } else {
                            container.appendChild(cnvs);
                        }
                    }
                    container = new R._Paper;
                    container.width = width;
                    container.height = height;
                    container.canvas = cnvs;
                    container.clear();
                    container._left = container._top = 0;
                    isFloating && (container.renderfix = function () {
                    });
                    container.renderfix();
                    return container;
                };
                R._engine.setViewBox = function (x, y, w, h, fit) {
                    eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                    var paperSize = this.getSize(),
                        size = mmax(w / paperSize.width, h / paperSize.height),
                        top = this.top,
                        aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
                        vb,
                        sw;
                    if (x == null) {
                        if (this._vbSize) {
                            size = 1;
                        }
                        delete this._vbSize;
                        vb = "0 0 " + this.width + S + this.height;
                    } else {
                        this._vbSize = size;
                        vb = x + S + y + S + w + S + h;
                    }
                    $(this.canvas, {
                        viewBox: vb,
                        preserveAspectRatio: aspectRatio
                    });
                    while (size && top) {
                        sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
                        top.attr({"stroke-width": sw});
                        top._.dirty = 1;
                        top._.dirtyT = 1;
                        top = top.prev;
                    }
                    this._viewBox = [x, y, w, h, !!fit];
                    return this;
                };
                /*\
	     * Paper.renderfix
	     [ method ]
	     **
	     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
	     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
	     * This method fixes the issue.
	     **
	       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
	    \*/
                R.prototype.renderfix = function () {
                    var cnvs = this.canvas,
                        s = cnvs.style,
                        pos;
                    try {
                        pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
                    } catch (e) {
                        pos = cnvs.createSVGMatrix();
                    }
                    var left = -pos.e % 1,
                        top = -pos.f % 1;
                    if (left || top) {
                        if (left) {
                            this._left = (this._left + left) % 1;
                            s.left = this._left + "px";
                        }
                        if (top) {
                            this._top = (this._top + top) % 1;
                            s.top = this._top + "px";
                        }
                    }
                };
                /*\
	     * Paper.clear
	     [ method ]
	     **
	     * Clears the paper, i.e. removes all the elements.
	    \*/
                R.prototype.clear = function () {
                    R.eve("raphael.clear", this);
                    var c = this.canvas;
                    while (c.firstChild) {
                        c.removeChild(c.firstChild);
                    }
                    this.bottom = this.top = null;
                    (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
                    c.appendChild(this.desc);
                    c.appendChild(this.defs = $("defs"));
                };
                /*\
	     * Paper.remove
	     [ method ]
	     **
	     * Removes the paper from the DOM.
	    \*/
                R.prototype.remove = function () {
                    eve("raphael.remove", this);
                    this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                };
                var setproto = R.st;
                for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname].apply(el, arg);
                            });
                        };
                    })(method);
                }
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        },
        /* 4 */
        /***/ function (module, exports, __webpack_require__) {

            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (R) {
                if (R && !R.vml) {
                    return;
                }

                var has = "hasOwnProperty",
                    Str = String,
                    toFloat = parseFloat,
                    math = Math,
                    round = math.round,
                    mmax = math.max,
                    mmin = math.min,
                    abs = math.abs,
                    fillString = "fill",
                    separator = /[, ]+/,
                    eve = R.eve,
                    ms = " progid:DXImageTransform.Microsoft",
                    S = " ",
                    E = "",
                    map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
                    bites = /([clmz]),?([^clmz]*)/gi,
                    blurregexp = / progid:\S+Blur\([^\)]+\)/g,
                    val = /-?[^,\s-]+/g,
                    cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
                    zoom = 21600,
                    pathTypes = {path: 1, rect: 1, image: 1},
                    ovalTypes = {circle: 1, ellipse: 1},
                    path2vml = function (path) {
                        var total = /[ahqstv]/ig,
                            command = R._pathToAbsolute;
                        Str(path).match(total) && (command = R._path2curve);
                        total = /[clmz]/g;
                        if (command == R._pathToAbsolute && !Str(path).match(total)) {
                            var res = Str(path).replace(bites, function (all, command, args) {
                                var vals = [],
                                    isMove = command.toLowerCase() == "m",
                                    res = map[command];
                                args.replace(val, function (value) {
                                    if (isMove && vals.length == 2) {
                                        res += vals + map[command == "m" ? "l" : "L"];
                                        vals = [];
                                    }
                                    vals.push(round(value * zoom));
                                });
                                return res + vals;
                            });
                            return res;
                        }
                        var pa = command(path), p, r;
                        res = [];
                        for (var i = 0, ii = pa.length; i < ii; i++) {
                            p = pa[i];
                            r = pa[i][0].toLowerCase();
                            r == "z" && (r = "x");
                            for (var j = 1, jj = p.length; j < jj; j++) {
                                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                            }
                            res.push(r);
                        }
                        return res.join(S);
                    },
                    compensation = function (deg, dx, dy) {
                        var m = R.matrix();
                        m.rotate(-deg, .5, .5);
                        return {
                            dx: m.x(dx, dy),
                            dy: m.y(dx, dy)
                        };
                    },
                    setCoords = function (p, sx, sy, dx, dy, deg) {
                        var _ = p._,
                            m = p.matrix,
                            fillpos = _.fillpos,
                            o = p.node,
                            s = o.style,
                            y = 1,
                            flip = "",
                            dxdy,
                            kx = zoom / sx,
                            ky = zoom / sy;
                        s.visibility = "hidden";
                        if (!sx || !sy) {
                            return;
                        }
                        o.coordsize = abs(kx) + S + abs(ky);
                        s.rotation = deg * (sx * sy < 0 ? -1 : 1);
                        if (deg) {
                            var c = compensation(deg, dx, dy);
                            dx = c.dx;
                            dy = c.dy;
                        }
                        sx < 0 && (flip += "x");
                        sy < 0 && (flip += " y") && (y = -1);
                        s.flip = flip;
                        o.coordorigin = (dx * -kx) + S + (dy * -ky);
                        if (fillpos || _.fillsize) {
                            var fill = o.getElementsByTagName(fillString);
                            fill = fill && fill[0];
                            o.removeChild(fill);
                            if (fillpos) {
                                c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                                fill.position = c.dx * y + S + c.dy * y;
                            }
                            if (_.fillsize) {
                                fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                            }
                            o.appendChild(fill);
                        }
                        s.visibility = "visible";
                    };
                R.toString = function () {
                    return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
                };
                var addArrow = function (o, value, isEnd) {
                        var values = Str(value).toLowerCase().split("-"),
                            se = isEnd ? "end" : "start",
                            i = values.length,
                            type = "classic",
                            w = "medium",
                            h = "medium";
                        while (i--) {
                            switch (values[i]) {
                                case "block":
                                case "classic":
                                case "oval":
                                case "diamond":
                                case "open":
                                case "none":
                                    type = values[i];
                                    break;
                                case "wide":
                                case "narrow":
                                    h = values[i];
                                    break;
                                case "long":
                                case "short":
                                    w = values[i];
                                    break;
                            }
                        }
                        var stroke = o.node.getElementsByTagName("stroke")[0];
                        stroke[se + "arrow"] = type;
                        stroke[se + "arrowlength"] = w;
                        stroke[se + "arrowwidth"] = h;
                    },
                    setFillAndStroke = function (o, params) {
                        // o.paper.canvas.style.display = "none";
                        o.attrs = o.attrs || {};
                        var node = o.node,
                            a = o.attrs,
                            s = node.style,
                            xy,
                            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                            res = o;


                        for (var par in params) if (params[has](par)) {
                            a[par] = params[par];
                        }
                        if (newpath) {
                            a.path = R._getPath[o.type](o);
                            o._.dirty = 1;
                        }
                        params.href && (node.href = params.href);
                        params.title && (node.title = params.title);
                        params.target && (node.target = params.target);
                        params.cursor && (s.cursor = params.cursor);
                        "blur" in params && o.blur(params.blur);
                        if (params.path && o.type == "path" || newpath) {
                            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                            o._.dirty = 1;
                            if (o.type == "image") {
                                o._.fillpos = [a.x, a.y];
                                o._.fillsize = [a.width, a.height];
                                setCoords(o, 1, 1, 0, 0, 0);
                            }
                        }
                        "transform" in params && o.transform(params.transform);
                        if (isOval) {
                            var cx = +a.cx,
                                cy = +a.cy,
                                rx = +a.rx || +a.r || 0,
                                ry = +a.ry || +a.r || 0;
                            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                            o._.dirty = 1;
                        }
                        if ("clip-rect" in params) {
                            var rect = Str(params["clip-rect"]).split(separator);
                            if (rect.length == 4) {
                                rect[2] = +rect[2] + (+rect[0]);
                                rect[3] = +rect[3] + (+rect[1]);
                                var div = node.clipRect || R._g.doc.createElement("div"),
                                    dstyle = div.style;
                                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                                if (!node.clipRect) {
                                    dstyle.position = "absolute";
                                    dstyle.top = 0;
                                    dstyle.left = 0;
                                    dstyle.width = o.paper.width + "px";
                                    dstyle.height = o.paper.height + "px";
                                    node.parentNode.insertBefore(div, node);
                                    div.appendChild(node);
                                    node.clipRect = div;
                                }
                            }
                            if (!params["clip-rect"]) {
                                node.clipRect && (node.clipRect.style.clip = "auto");
                            }
                        }
                        if (o.textpath) {
                            var textpathStyle = o.textpath.style;
                            params.font && (textpathStyle.font = params.font);
                            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
                        }
                        if ("arrow-start" in params) {
                            addArrow(res, params["arrow-start"]);
                        }
                        if ("arrow-end" in params) {
                            addArrow(res, params["arrow-end"], 1);
                        }
                        if (params.opacity != null ||
                            params.fill != null ||
                            params.src != null ||
                            params.stroke != null ||
                            params["stroke-width"] != null ||
                            params["stroke-opacity"] != null ||
                            params["fill-opacity"] != null ||
                            params["stroke-dasharray"] != null ||
                            params["stroke-miterlimit"] != null ||
                            params["stroke-linejoin"] != null ||
                            params["stroke-linecap"] != null) {
                            var fill = node.getElementsByTagName(fillString),
                                newfill = false;
                            fill = fill && fill[0];
                            !fill && (newfill = fill = createNode(fillString));
                            if (o.type == "image" && params.src) {
                                fill.src = params.src;
                            }
                            params.fill && (fill.on = true);
                            if (fill.on == null || params.fill == "none" || params.fill === null) {
                                fill.on = false;
                            }
                            if (fill.on && params.fill) {
                                var isURL = Str(params.fill).match(R._ISURL);
                                if (isURL) {
                                    fill.parentNode == node && node.removeChild(fill);
                                    fill.rotate = true;
                                    fill.src = isURL[1];
                                    fill.type = "tile";
                                    var bbox = o.getBBox(1);
                                    fill.position = bbox.x + S + bbox.y;
                                    o._.fillpos = [bbox.x, bbox.y];

                                    R._preload(isURL[1], function () {
                                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                                    });
                                } else {
                                    fill.color = R.getRGB(params.fill).hex;
                                    fill.src = E;
                                    fill.type = "solid";
                                    if (R.getRGB(params.fill).error && (res.type in {
                                            circle: 1,
                                            ellipse: 1
                                        } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                                        a.fill = "none";
                                        a.gradient = params.fill;
                                        fill.rotate = false;
                                    }
                                }
                            }
                            if ("fill-opacity" in params || "opacity" in params) {
                                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                                opacity = mmin(mmax(opacity, 0), 1);
                                fill.opacity = opacity;
                                if (fill.src) {
                                    fill.color = "none";
                                }
                            }
                            node.appendChild(fill);
                            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                                newstroke = false;
                            !stroke && (newstroke = stroke = createNode("stroke"));
                            if ((params.stroke && params.stroke != "none") ||
                                params["stroke-width"] ||
                                params["stroke-opacity"] != null ||
                                params["stroke-dasharray"] ||
                                params["stroke-miterlimit"] ||
                                params["stroke-linejoin"] ||
                                params["stroke-linecap"]) {
                                stroke.on = true;
                            }
                            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                            var strokeColor = R.getRGB(params.stroke);
                            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                            var width = (toFloat(params["stroke-width"]) || 1) * .75;
                            opacity = mmin(mmax(opacity, 0), 1);
                            params["stroke-width"] == null && (width = a["stroke-width"]);
                            params["stroke-width"] && (stroke.weight = width);
                            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                            stroke.opacity = opacity;

                            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                            stroke.miterlimit = params["stroke-miterlimit"] || 8;
                            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                            if ("stroke-dasharray" in params) {
                                var dasharray = {
                                    "-": "shortdash",
                                    ".": "shortdot",
                                    "-.": "shortdashdot",
                                    "-..": "shortdashdotdot",
                                    ". ": "dot",
                                    "- ": "dash",
                                    "--": "longdash",
                                    "- .": "dashdot",
                                    "--.": "longdashdot",
                                    "--..": "longdashdotdot"
                                };
                                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                            }
                            newstroke && node.appendChild(stroke);
                        }
                        if (res.type == "text") {
                            res.paper.canvas.style.display = E;
                            var span = res.paper.span,
                                m = 100,
                                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                            s = span.style;
                            a.font && (s.font = a.font);
                            a["font-family"] && (s.fontFamily = a["font-family"]);
                            a["font-weight"] && (s.fontWeight = a["font-weight"]);
                            a["font-style"] && (s.fontStyle = a["font-style"]);
                            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                            s.fontSize = fontSize * m + "px";
                            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                            var brect = span.getBoundingClientRect();
                            res.W = a.w = (brect.right - brect.left) / m;
                            res.H = a.h = (brect.bottom - brect.top) / m;
                            // res.paper.canvas.style.display = "none";
                            res.X = a.x;
                            res.Y = a.y + res.H / 2;

                            ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                                res._.dirty = 1;
                                break;
                            }

                            // text-anchor emulation
                            switch (a["text-anchor"]) {
                                case "start":
                                    res.textpath.style["v-text-align"] = "left";
                                    res.bbx = res.W / 2;
                                    break;
                                case "end":
                                    res.textpath.style["v-text-align"] = "right";
                                    res.bbx = -res.W / 2;
                                    break;
                                default:
                                    res.textpath.style["v-text-align"] = "center";
                                    res.bbx = 0;
                                    break;
                            }
                            res.textpath.style["v-text-kern"] = true;
                        }
                        // res.paper.canvas.style.display = E;
                    },
                    addGradientFill = function (o, gradient, fill) {
                        o.attrs = o.attrs || {};
                        var attrs = o.attrs,
                            pow = Math.pow,
                            opacity,
                            oindex,
                            type = "linear",
                            fxfy = ".5 .5";
                        o.attrs.gradient = gradient;
                        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                            type = "radial";
                            if (fx && fy) {
                                fx = toFloat(fx);
                                fy = toFloat(fy);
                                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                                fxfy = fx + S + fy;
                            }
                            return E;
                        });
                        gradient = gradient.split(/\s*\-\s*/);
                        if (type == "linear") {
                            var angle = gradient.shift();
                            angle = -toFloat(angle);
                            if (isNaN(angle)) {
                                return null;
                            }
                        }
                        var dots = R._parseDots(gradient);
                        if (!dots) {
                            return null;
                        }
                        o = o.shape || o.node;
                        if (dots.length) {
                            o.removeChild(fill);
                            fill.on = true;
                            fill.method = "none";
                            fill.color = dots[0].color;
                            fill.color2 = dots[dots.length - 1].color;
                            var clrs = [];
                            for (var i = 0, ii = dots.length; i < ii; i++) {
                                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                            }
                            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                            if (type == "radial") {
                                fill.type = "gradientTitle";
                                fill.focus = "100%";
                                fill.focussize = "0 0";
                                fill.focusposition = fxfy;
                                fill.angle = 0;
                            } else {
                                // fill.rotate= true;
                                fill.type = "gradient";
                                fill.angle = (270 - angle) % 360;
                            }
                            o.appendChild(fill);
                        }
                        return 1;
                    },
                    Element = function (node, vml) {
                        this[0] = this.node = node;
                        node.raphael = true;
                        this.id = R._oid++;
                        node.raphaelid = this.id;
                        this.X = 0;
                        this.Y = 0;
                        this.attrs = {};
                        this.paper = vml;
                        this.matrix = R.matrix();
                        this._ = {
                            transform: [],
                            sx: 1,
                            sy: 1,
                            dx: 0,
                            dy: 0,
                            deg: 0,
                            dirty: 1,
                            dirtyT: 1
                        };
                        !vml.bottom && (vml.bottom = this);
                        this.prev = vml.top;
                        vml.top && (vml.top.next = this);
                        vml.top = this;
                        this.next = null;
                    };
                var elproto = R.el;

                Element.prototype = elproto;
                elproto.constructor = Element;
                elproto.transform = function (tstr) {
                    if (tstr == null) {
                        return this._.transform;
                    }
                    var vbs = this.paper._viewBoxShift,
                        vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
                        oldt;
                    if (vbs) {
                        oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
                    }
                    R._extractTransform(this, vbt + tstr);
                    var matrix = this.matrix.clone(),
                        skew = this.skew,
                        o = this.node,
                        split,
                        isGrad = ~Str(this.attrs.fill).indexOf("-"),
                        isPatt = !Str(this.attrs.fill).indexOf("url(");
                    matrix.translate(1, 1);
                    if (isPatt || isGrad || this.type == "image") {
                        skew.matrix = "1 0 0 1";
                        skew.offset = "0 0";
                        split = matrix.split();
                        if ((isGrad && split.noRotation) || !split.isSimple) {
                            o.style.filter = matrix.toFilter();
                            var bb = this.getBBox(),
                                bbt = this.getBBox(1),
                                dx = bb.x - bbt.x,
                                dy = bb.y - bbt.y;
                            o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                            setCoords(this, 1, 1, dx, dy, 0);
                        } else {
                            o.style.filter = E;
                            setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
                        }
                    } else {
                        o.style.filter = E;
                        skew.matrix = Str(matrix);
                        skew.offset = matrix.offset();
                    }
                    if (oldt !== null) { // empty string value is true as well
                        this._.transform = oldt;
                        R._extractTransform(this, oldt);
                    }
                    return this;
                };
                elproto.rotate = function (deg, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    if (deg == null) {
                        return;
                    }
                    deg = Str(deg).split(separator);
                    if (deg.length - 1) {
                        cx = toFloat(deg[1]);
                        cy = toFloat(deg[2]);
                    }
                    deg = toFloat(deg[0]);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                        cx = bbox.x + bbox.width / 2;
                        cy = bbox.y + bbox.height / 2;
                    }
                    this._.dirtyT = 1;
                    this.transform(this._.transform.concat([["r", deg, cx, cy]]));
                    return this;
                };
                elproto.translate = function (dx, dy) {
                    if (this.removed) {
                        return this;
                    }
                    dx = Str(dx).split(separator);
                    if (dx.length - 1) {
                        dy = toFloat(dx[1]);
                    }
                    dx = toFloat(dx[0]) || 0;
                    dy = +dy || 0;
                    if (this._.bbox) {
                        this._.bbox.x += dx;
                        this._.bbox.y += dy;
                    }
                    this.transform(this._.transform.concat([["t", dx, dy]]));
                    return this;
                };
                elproto.scale = function (sx, sy, cx, cy) {
                    if (this.removed) {
                        return this;
                    }
                    sx = Str(sx).split(separator);
                    if (sx.length - 1) {
                        sy = toFloat(sx[1]);
                        cx = toFloat(sx[2]);
                        cy = toFloat(sx[3]);
                        isNaN(cx) && (cx = null);
                        isNaN(cy) && (cy = null);
                    }
                    sx = toFloat(sx[0]);
                    (sy == null) && (sy = sx);
                    (cy == null) && (cx = cy);
                    if (cx == null || cy == null) {
                        var bbox = this.getBBox(1);
                    }
                    cx = cx == null ? bbox.x + bbox.width / 2 : cx;
                    cy = cy == null ? bbox.y + bbox.height / 2 : cy;

                    this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
                    this._.dirtyT = 1;
                    return this;
                };
                elproto.hide = function () {
                    !this.removed && (this.node.style.display = "none");
                    return this;
                };
                elproto.show = function () {
                    !this.removed && (this.node.style.display = E);
                    return this;
                };
                // Needed to fix the vml setViewBox issues
                elproto.auxGetBBox = R.el.getBBox;
                elproto.getBBox = function () {
                    var b = this.auxGetBBox();
                    if (this.paper && this.paper._viewBoxShift) {
                        var c = {};
                        var z = 1 / this.paper._viewBoxShift.scale;
                        c.x = b.x - this.paper._viewBoxShift.dx;
                        c.x *= z;
                        c.y = b.y - this.paper._viewBoxShift.dy;
                        c.y *= z;
                        c.width = b.width * z;
                        c.height = b.height * z;
                        c.x2 = c.x + c.width;
                        c.y2 = c.y + c.height;
                        return c;
                    }
                    return b;
                };
                elproto._getBBox = function () {
                    if (this.removed) {
                        return {};
                    }
                    return {
                        x: this.X + (this.bbx || 0) - this.W / 2,
                        y: this.Y - this.H,
                        width: this.W,
                        height: this.H
                    };
                };
                elproto.remove = function () {
                    if (this.removed || !this.node.parentNode) {
                        return;
                    }
                    this.paper.__set__ && this.paper.__set__.exclude(this);
                    R.eve.unbind("raphael.*.*." + this.id);
                    R._tear(this, this.paper);
                    this.node.parentNode.removeChild(this.node);
                    this.shape && this.shape.parentNode.removeChild(this.shape);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    this.removed = true;
                };
                elproto.attr = function (name, value) {
                    if (this.removed) {
                        return this;
                    }
                    if (name == null) {
                        var res = {};
                        for (var a in this.attrs) if (this.attrs[has](a)) {
                            res[a] = this.attrs[a];
                        }
                        res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                        res.transform = this._.transform;
                        return res;
                    }
                    if (value == null && R.is(name, "string")) {
                        if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                            return this.attrs.gradient;
                        }
                        var names = name.split(separator),
                            out = {};
                        for (var i = 0, ii = names.length; i < ii; i++) {
                            name = names[i];
                            if (name in this.attrs) {
                                out[name] = this.attrs[name];
                            } else if (R.is(this.paper.customAttributes[name], "function")) {
                                out[name] = this.paper.customAttributes[name].def;
                            } else {
                                out[name] = R._availableAttrs[name];
                            }
                        }
                        return ii - 1 ? out : out[names[0]];
                    }
                    if (this.attrs && value == null && R.is(name, "array")) {
                        out = {};
                        for (i = 0, ii = name.length; i < ii; i++) {
                            out[name[i]] = this.attr(name[i]);
                        }
                        return out;
                    }
                    var params;
                    if (value != null) {
                        params = {};
                        params[name] = value;
                    }
                    value == null && R.is(name, "object") && (params = name);
                    for (var key in params) {
                        eve("raphael.attr." + key + "." + this.id, this, params[key]);
                    }
                    if (params) {
                        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                            this.attrs[key] = params[key];
                            for (var subkey in par) if (par[has](subkey)) {
                                params[subkey] = par[subkey];
                            }
                        }
                        // this.paper.canvas.style.display = "none";
                        if (params.text && this.type == "text") {
                            this.textpath.string = params.text;
                        }
                        setFillAndStroke(this, params);
                        // this.paper.canvas.style.display = E;
                    }
                    return this;
                };
                elproto.toFront = function () {
                    !this.removed && this.node.parentNode.appendChild(this.node);
                    this.paper && this.paper.top != this && R._tofront(this, this.paper);
                    return this;
                };
                elproto.toBack = function () {
                    if (this.removed) {
                        return this;
                    }
                    if (this.node.parentNode.firstChild != this.node) {
                        this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                        R._toback(this, this.paper);
                    }
                    return this;
                };
                elproto.insertAfter = function (element) {
                    if (this.removed) {
                        return this;
                    }
                    if (element.constructor == R.st.constructor) {
                        element = element[element.length - 1];
                    }
                    if (element.node.nextSibling) {
                        element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
                    } else {
                        element.node.parentNode.appendChild(this.node);
                    }
                    R._insertafter(this, element, this.paper);
                    return this;
                };
                elproto.insertBefore = function (element) {
                    if (this.removed) {
                        return this;
                    }
                    if (element.constructor == R.st.constructor) {
                        element = element[0];
                    }
                    element.node.parentNode.insertBefore(this.node, element.node);
                    R._insertbefore(this, element, this.paper);
                    return this;
                };
                elproto.blur = function (size) {
                    var s = this.node.runtimeStyle,
                        f = s.filter;
                    f = f.replace(blurregexp, E);
                    if (+size !== 0) {
                        this.attrs.blur = size;
                        s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                        s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
                    } else {
                        s.filter = f;
                        s.margin = 0;
                        delete this.attrs.blur;
                    }
                    return this;
                };

                R._engine.path = function (pathString, vml) {
                    var el = createNode("shape");
                    el.style.cssText = cssDot;
                    el.coordsize = zoom + S + zoom;
                    el.coordorigin = vml.coordorigin;
                    var p = new Element(el, vml),
                        attr = {fill: "none", stroke: "#000"};
                    pathString && (attr.path = pathString);
                    p.type = "path";
                    p.path = [];
                    p.Path = E;
                    setFillAndStroke(p, attr);
                    vml.canvas && vml.canvas.appendChild(el);
                    var skew = createNode("skew");
                    skew.on = true;
                    el.appendChild(skew);
                    p.skew = skew;
                    p.transform(E);
                    return p;
                };
                R._engine.rect = function (vml, x, y, w, h, r) {
                    var path = R._rectPath(x, y, w, h, r),
                        res = vml.path(path),
                        a = res.attrs;
                    res.X = a.x = x;
                    res.Y = a.y = y;
                    res.W = a.width = w;
                    res.H = a.height = h;
                    a.r = r;
                    a.path = path;
                    res.type = "rect";
                    return res;
                };
                R._engine.ellipse = function (vml, x, y, rx, ry) {
                    var res = vml.path(),
                        a = res.attrs;
                    res.X = x - rx;
                    res.Y = y - ry;
                    res.W = rx * 2;
                    res.H = ry * 2;
                    res.type = "ellipse";
                    setFillAndStroke(res, {
                        cx: x,
                        cy: y,
                        rx: rx,
                        ry: ry
                    });
                    return res;
                };
                R._engine.circle = function (vml, x, y, r) {
                    var res = vml.path(),
                        a = res.attrs;
                    res.X = x - r;
                    res.Y = y - r;
                    res.W = res.H = r * 2;
                    res.type = "circle";
                    setFillAndStroke(res, {
                        cx: x,
                        cy: y,
                        r: r
                    });
                    return res;
                };
                R._engine.image = function (vml, src, x, y, w, h) {
                    var path = R._rectPath(x, y, w, h),
                        res = vml.path(path).attr({stroke: "none"}),
                        a = res.attrs,
                        node = res.node,
                        fill = node.getElementsByTagName(fillString)[0];
                    a.src = src;
                    res.X = a.x = x;
                    res.Y = a.y = y;
                    res.W = a.width = w;
                    res.H = a.height = h;
                    a.path = path;
                    res.type = "image";
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = src;
                    fill.type = "tile";
                    res._.fillpos = [x, y];
                    res._.fillsize = [w, h];
                    node.appendChild(fill);
                    setCoords(res, 1, 1, 0, 0, 0);
                    return res;
                };
                R._engine.text = function (vml, x, y, text) {
                    var el = createNode("shape"),
                        path = createNode("path"),
                        o = createNode("textpath");
                    x = x || 0;
                    y = y || 0;
                    text = text || "";
                    path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
                    path.textpathok = true;
                    o.string = Str(text);
                    o.on = true;
                    el.style.cssText = cssDot;
                    el.coordsize = zoom + S + zoom;
                    el.coordorigin = "0 0";
                    var p = new Element(el, vml),
                        attr = {
                            fill: "#000",
                            stroke: "none",
                            font: R._availableAttrs.font,
                            text: text
                        };
                    p.shape = el;
                    p.path = path;
                    p.textpath = o;
                    p.type = "text";
                    p.attrs.text = Str(text);
                    p.attrs.x = x;
                    p.attrs.y = y;
                    p.attrs.w = 1;
                    p.attrs.h = 1;
                    setFillAndStroke(p, attr);
                    el.appendChild(o);
                    el.appendChild(path);
                    vml.canvas.appendChild(el);
                    var skew = createNode("skew");
                    skew.on = true;
                    el.appendChild(skew);
                    p.skew = skew;
                    p.transform(E);
                    return p;
                };
                R._engine.setSize = function (width, height) {
                    var cs = this.canvas.style;
                    this.width = width;
                    this.height = height;
                    width == +width && (width += "px");
                    height == +height && (height += "px");
                    cs.width = width;
                    cs.height = height;
                    cs.clip = "rect(0 " + width + " " + height + " 0)";
                    if (this._viewBox) {
                        R._engine.setViewBox.apply(this, this._viewBox);
                    }
                    return this;
                };
                R._engine.setViewBox = function (x, y, w, h, fit) {
                    R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
                    var paperSize = this.getSize(),
                        width = paperSize.width,
                        height = paperSize.height,
                        H, W;
                    if (fit) {
                        H = height / h;
                        W = width / w;
                        if (w * H < width) {
                            x -= (width - w * H) / 2 / H;
                        }
                        if (h * W < height) {
                            y -= (height - h * W) / 2 / W;
                        }
                    }
                    this._viewBox = [x, y, w, h, !!fit];
                    this._viewBoxShift = {
                        dx: -x,
                        dy: -y,
                        scale: paperSize
                    };
                    this.forEach(function (el) {
                        el.transform("...");
                    });
                    return this;
                };
                var createNode;
                R._engine.initWin = function (win) {
                    var doc = win.document;
                    if (doc.styleSheets.length < 31) {
                        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
                    } else {
                        // no more room, add to the existing one
                        // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
                        doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
                    }
                    try {
                        !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                        createNode = function (tagName) {
                            return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                        };
                    } catch (e) {
                        createNode = function (tagName) {
                            return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                        };
                    }
                };
                R._engine.initWin(R._g.win);
                R._engine.create = function () {
                    var con = R._getContainer.apply(0, arguments),
                        container = con.container,
                        height = con.height,
                        s,
                        width = con.width,
                        x = con.x,
                        y = con.y;
                    if (!container) {
                        throw new Error("VML container not found.");
                    }
                    var res = new R._Paper,
                        c = res.canvas = R._g.doc.createElement("div"),
                        cs = c.style;
                    x = x || 0;
                    y = y || 0;
                    width = width || 512;
                    height = height || 342;
                    res.width = width;
                    res.height = height;
                    width == +width && (width += "px");
                    height == +height && (height += "px");
                    res.coordsize = zoom * 1e3 + S + zoom * 1e3;
                    res.coordorigin = "0 0";
                    res.span = R._g.doc.createElement("span");
                    res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
                    c.appendChild(res.span);
                    cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
                    if (container == 1) {
                        R._g.doc.body.appendChild(c);
                        cs.left = x + "px";
                        cs.top = y + "px";
                        cs.position = "absolute";
                    } else {
                        if (container.firstChild) {
                            container.insertBefore(c, container.firstChild);
                        } else {
                            container.appendChild(c);
                        }
                    }
                    res.renderfix = function () {
                    };
                    return res;
                };
                R.prototype.clear = function () {
                    R.eve("raphael.clear", this);
                    this.canvas.innerHTML = E;
                    this.span = R._g.doc.createElement("span");
                    this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
                    this.canvas.appendChild(this.span);
                    this.bottom = this.top = null;
                };
                R.prototype.remove = function () {
                    R.eve("raphael.remove", this);
                    this.canvas.parentNode.removeChild(this.canvas);
                    for (var i in this) {
                        this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
                    }
                    return true;
                };

                var setproto = R.st;
                for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
                    setproto[method] = (function (methodname) {
                        return function () {
                            var arg = arguments;
                            return this.forEach(function (el) {
                                el[methodname].apply(el, arg);
                            });
                        };
                    })(method);
                }
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


            /***/
        }
        /******/])
});
;
/*!
 * Pusher JavaScript Library v3.0.0
 * http://pusher.com/
 *
 * Copyright 2014, Pusher
 * Released under the MIT licence.
 */

// Uses Node, AMD or browser globals to create a module. This example creates
// a global even when AMD is used. This is useful if you have some scripts
// that are loaded by an AMD loader, but they still want access to globals.
// If you do not need to export a global for the AMD case,
// see returnExports.js.

// If you want something that will work in other stricter CommonJS environments,
// or if you need to create a circular dependency, see commonJsStrictGlobal.js

// Defines a module "Pusher".

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return (root.Pusher = factory());
        });
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.Pusher = factory();
    }
}(this, function () {

    ;(function () {
        function Pusher(app_key, options) {
            checkAppKey(app_key);
            options = options || {};

            var self = this;

            this.key = app_key;
            this.config = Pusher.Util.extend(
                Pusher.getGlobalConfig(),
                options.cluster ? Pusher.getClusterConfig(options.cluster) : {},
                options
            );

            this.channels = new Pusher.Channels();
            this.global_emitter = new Pusher.EventsDispatcher();
            this.sessionID = Math.floor(Math.random() * 1000000000);

            this.timeline = new Pusher.Timeline(this.key, this.sessionID, {
                cluster: this.config.cluster,
                features: Pusher.Util.getClientFeatures(),
                params: this.config.timelineParams || {},
                limit: 50,
                level: Pusher.Timeline.INFO,
                version: Pusher.VERSION
            });
            if (!this.config.disableStats) {
                this.timelineSender = new Pusher.TimelineSender(this.timeline, {
                    host: this.config.statsHost,
                    path: "/timeline/v2/jsonp"
                });
            }

            var getStrategy = function (options) {
                var config = Pusher.Util.extend({}, self.config, options);
                return Pusher.StrategyBuilder.build(
                    Pusher.getDefaultStrategy(config), config
                );
            };

            this.connection = new Pusher.ConnectionManager(
                this.key,
                Pusher.Util.extend(
                    {
                        getStrategy: getStrategy,
                        timeline: this.timeline,
                        activityTimeout: this.config.activity_timeout,
                        pongTimeout: this.config.pong_timeout,
                        unavailableTimeout: this.config.unavailable_timeout
                    },
                    this.config,
                    {encrypted: this.isEncrypted()}
                )
            );

            this.connection.bind('connected', function () {
                self.subscribeAll();
                if (self.timelineSender) {
                    self.timelineSender.send(self.connection.isEncrypted());
                }
            });
            this.connection.bind('message', function (params) {
                var internal = (params.event.indexOf('pusher_internal:') === 0);
                if (params.channel) {
                    var channel = self.channel(params.channel);
                    if (channel) {
                        channel.handleEvent(params.event, params.data);
                    }
                }
                // Emit globally [deprecated]
                if (!internal) {
                    self.global_emitter.emit(params.event, params.data);
                }
            });
            this.connection.bind('disconnected', function () {
                self.channels.disconnect();
            });
            this.connection.bind('error', function (err) {
                Pusher.warn('Error', err);
            });

            Pusher.instances.push(this);
            this.timeline.info({instances: Pusher.instances.length});

            if (Pusher.isReady) {
                self.connect();
            }
        }

        var prototype = Pusher.prototype;

        Pusher.instances = [];
        Pusher.isReady = false;

        // To receive log output provide a Pusher.log function, for example
        // Pusher.log = function(m){console.log(m)}
        Pusher.debug = function () {
            if (!Pusher.log) {
                return;
            }
            Pusher.log(Pusher.Util.stringify.apply(this, arguments));
        };

        Pusher.warn = function () {
            var message = Pusher.Util.stringify.apply(this, arguments);
            if (window.console) {
                if (window.console.warn) {
                    window.console.warn(message);
                } else if (window.console.log) {
                    window.console.log(message);
                }
            }
            if (Pusher.log) {
                Pusher.log(message);
            }
        };

        Pusher.ready = function () {
            Pusher.isReady = true;
            for (var i = 0, l = Pusher.instances.length; i < l; i++) {
                Pusher.instances[i].connect();
            }
        };

        prototype.channel = function (name) {
            return this.channels.find(name);
        };

        prototype.allChannels = function () {
            return this.channels.all();
        };

        prototype.connect = function () {
            this.connection.connect();

            if (this.timelineSender) {
                if (!this.timelineSenderTimer) {
                    var encrypted = this.connection.isEncrypted();
                    var timelineSender = this.timelineSender;
                    this.timelineSenderTimer = new Pusher.PeriodicTimer(60000, function () {
                        timelineSender.send(encrypted);
                    });
                }
            }
        };

        prototype.disconnect = function () {
            this.connection.disconnect();

            if (this.timelineSenderTimer) {
                this.timelineSenderTimer.ensureAborted();
                this.timelineSenderTimer = null;
            }
        };

        prototype.bind = function (event_name, callback) {
            this.global_emitter.bind(event_name, callback);
            return this;
        };

        prototype.bind_all = function (callback) {
            this.global_emitter.bind_all(callback);
            return this;
        };

        prototype.subscribeAll = function () {
            var channelName;
            for (channelName in this.channels.channels) {
                if (this.channels.channels.hasOwnProperty(channelName)) {
                    this.subscribe(channelName);
                }
            }
        };

        prototype.subscribe = function (channel_name) {
            var channel = this.channels.add(channel_name, this);
            if (this.connection.state === 'connected') {
                channel.subscribe();
            }
            return channel;
        };

        prototype.unsubscribe = function (channel_name) {
            var channel = this.channels.remove(channel_name);
            if (channel && this.connection.state === 'connected') {
                channel.unsubscribe();
            }
        };

        prototype.send_event = function (event_name, data, channel) {
            return this.connection.send_event(event_name, data, channel);
        };

        prototype.isEncrypted = function () {
            if (Pusher.Util.getDocument().location.protocol === "https:") {
                return true;
            } else {
                return Boolean(this.config.encrypted);
            }
        };

        function checkAppKey(key) {
            if (key === null || key === undefined) {
                Pusher.warn(
                    'Warning', 'You must pass your app key when you instantiate Pusher.'
                );
            }
        }

        Pusher.HTTP = {};

        this.Pusher = Pusher;
    }).call(this);

    ;(function () {
        // We need to bind clear functions this way to avoid exceptions on IE8
        function clearTimeout(timer) {
            window.clearTimeout(timer);
        }

        function clearInterval(timer) {
            window.clearInterval(timer);
        }

        function GenericTimer(set, clear, delay, callback) {
            var self = this;

            this.clear = clear;
            this.timer = set(function () {
                if (self.timer !== null) {
                    self.timer = callback(self.timer);
                }
            }, delay);
        }

        var prototype = GenericTimer.prototype;

        /** Returns whether the timer is still running.
         *
         * @return {Boolean}
         */
        prototype.isRunning = function () {
            return this.timer !== null;
        };

        /** Aborts a timer when it's running. */
        prototype.ensureAborted = function () {
            if (this.timer) {
                // Clear function is already bound
                this.clear(this.timer);
                this.timer = null;
            }
        };

        /** Cross-browser compatible one-off timer abstraction.
         *
         * @param {Number} delay
         * @param {Function} callback
         */
        Pusher.Timer = function (delay, callback) {
            return new GenericTimer(setTimeout, clearTimeout, delay, function (timer) {
                callback();
                return null;
            });
        };
        /** Cross-browser compatible periodic timer abstraction.
         *
         * @param {Number} delay
         * @param {Function} callback
         */
        Pusher.PeriodicTimer = function (delay, callback) {
            return new GenericTimer(setInterval, clearInterval, delay, function (timer) {
                callback();
                return timer;
            });
        };
    }).call(this);

    ;(function () {
        Pusher.Util = {
            now: function () {
                if (Date.now) {
                    return Date.now();
                } else {
                    return new Date().valueOf();
                }
            },

            defer: function (callback) {
                return new Pusher.Timer(0, callback);
            },

            /** Merges multiple objects into the target argument.
             *
             * For properties that are plain Objects, performs a deep-merge. For the
             * rest it just copies the value of the property.
             *
             * To extend prototypes use it as following:
             *   Pusher.Util.extend(Target.prototype, Base.prototype)
             *
             * You can also use it to merge objects without altering them:
             *   Pusher.Util.extend({}, object1, object2)
             *
             * @param  {Object} target
             * @return {Object} the target argument
             */
            extend: function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var extensions = arguments[i];
                    for (var property in extensions) {
                        if (extensions[property] && extensions[property].constructor &&
                            extensions[property].constructor === Object) {
                            target[property] = Pusher.Util.extend(
                                target[property] || {}, extensions[property]
                            );
                        } else {
                            target[property] = extensions[property];
                        }
                    }
                }
                return target;
            },

            stringify: function () {
                var m = ["Pusher"];
                for (var i = 0; i < arguments.length; i++) {
                    if (typeof arguments[i] === "string") {
                        m.push(arguments[i]);
                    } else {
                        if (window.JSON === undefined) {
                            m.push(arguments[i].toString());
                        } else {
                            m.push(JSON.stringify(arguments[i]));
                        }
                    }
                }
                return m.join(" : ");
            },

            arrayIndexOf: function (array, item) { // MSIE doesn't have array.indexOf
                var nativeIndexOf = Array.prototype.indexOf;
                if (array === null) {
                    return -1;
                }
                if (nativeIndexOf && array.indexOf === nativeIndexOf) {
                    return array.indexOf(item);
                }
                for (var i = 0, l = array.length; i < l; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            },

            /** Applies a function f to all properties of an object.
             *
             * Function f gets 3 arguments passed:
             * - element from the object
             * - key of the element
             * - reference to the object
             *
             * @param {Object} object
             * @param {Function} f
             */
            objectApply: function (object, f) {
                for (var key in object) {
                    if (Object.prototype.hasOwnProperty.call(object, key)) {
                        f(object[key], key, object);
                    }
                }
            },

            /** Return a list of object's own property keys
             *
             * @param {Object} object
             * @returns {Array}
             */
            keys: function (object) {
                var keys = [];
                Pusher.Util.objectApply(object, function (_, key) {
                    keys.push(key);
                });
                return keys;
            },

            /** Return a list of object's own property values
             *
             * @param {Object} object
             * @returns {Array}
             */
            values: function (object) {
                var values = [];
                Pusher.Util.objectApply(object, function (value) {
                    values.push(value);
                });
                return values;
            },

            /** Applies a function f to all elements of an array.
             *
             * Function f gets 3 arguments passed:
             * - element from the array
             * - index of the element
             * - reference to the array
             *
             * @param {Array} array
             * @param {Function} f
             */
            apply: function (array, f, context) {
                for (var i = 0; i < array.length; i++) {
                    f.call(context || window, array[i], i, array);
                }
            },

            /** Maps all elements of the array and returns the result.
             *
             * Function f gets 4 arguments passed:
             * - element from the array
             * - index of the element
             * - reference to the source array
             * - reference to the destination array
             *
             * @param {Array} array
             * @param {Function} f
             */
            map: function (array, f) {
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    result.push(f(array[i], i, array, result));
                }
                return result;
            },

            /** Maps all elements of the object and returns the result.
             *
             * Function f gets 4 arguments passed:
             * - element from the object
             * - key of the element
             * - reference to the source object
             * - reference to the destination object
             *
             * @param {Object} object
             * @param {Function} f
             */
            mapObject: function (object, f) {
                var result = {};
                Pusher.Util.objectApply(object, function (value, key) {
                    result[key] = f(value);
                });
                return result;
            },

            /** Filters elements of the array using a test function.
             *
             * Function test gets 4 arguments passed:
             * - element from the array
             * - index of the element
             * - reference to the source array
             * - reference to the destination array
             *
             * @param {Array} array
             * @param {Function} f
             */
            filter: function (array, test) {
                test = test || function (value) {
                    return !!value;
                };

                var result = [];
                for (var i = 0; i < array.length; i++) {
                    if (test(array[i], i, array, result)) {
                        result.push(array[i]);
                    }
                }
                return result;
            },

            /** Filters properties of the object using a test function.
             *
             * Function test gets 4 arguments passed:
             * - element from the object
             * - key of the element
             * - reference to the source object
             * - reference to the destination object
             *
             * @param {Object} object
             * @param {Function} f
             */
            filterObject: function (object, test) {
                var result = {};
                Pusher.Util.objectApply(object, function (value, key) {
                    if ((test && test(value, key, object, result)) || Boolean(value)) {
                        result[key] = value;
                    }
                });
                return result;
            },

            /** Flattens an object into a two-dimensional array.
             *
             * @param  {Object} object
             * @return {Array} resulting array of [key, value] pairs
             */
            flatten: function (object) {
                var result = [];
                Pusher.Util.objectApply(object, function (value, key) {
                    result.push([key, value]);
                });
                return result;
            },

            /** Checks whether any element of the array passes the test.
             *
             * Function test gets 3 arguments passed:
             * - element from the array
             * - index of the element
             * - reference to the source array
             *
             * @param {Array} array
             * @param {Function} f
             */
            any: function (array, test) {
                for (var i = 0; i < array.length; i++) {
                    if (test(array[i], i, array)) {
                        return true;
                    }
                }
                return false;
            },

            /** Checks whether all elements of the array pass the test.
             *
             * Function test gets 3 arguments passed:
             * - element from the array
             * - index of the element
             * - reference to the source array
             *
             * @param {Array} array
             * @param {Function} f
             */
            all: function (array, test) {
                for (var i = 0; i < array.length; i++) {
                    if (!test(array[i], i, array)) {
                        return false;
                    }
                }
                return true;
            },

            /** Builds a function that will proxy a method call to its first argument.
             *
             * Allows partial application of arguments, so additional arguments are
             * prepended to the argument list.
             *
             * @param  {String} name method name
             * @return {Function} proxy function
             */
            method: function (name) {
                var boundArguments = Array.prototype.slice.call(arguments, 1);
                return function (object) {
                    return object[name].apply(object, boundArguments.concat(arguments));
                };
            },

            getWindow: function () {
                return window;
            },

            getDocument: function () {
                return document;
            },

            getLocalStorage: function () {
                try {
                    return window.localStorage;
                } catch (e) {
                    return undefined;
                }
            },

            getClientFeatures: function () {
                return Pusher.Util.keys(
                    Pusher.Util.filterObject(
                        {"ws": Pusher.WSTransport},
                        function (t) {
                            return t.isSupported({});
                        }
                    )
                );
            },

            addWindowListener: function (event, listener) {
                var _window = Pusher.Util.getWindow();
                if (_window.addEventListener !== undefined) {
                    _window.addEventListener(event, listener, false);
                } else {
                    _window.attachEvent("on" + event, listener);
                }
            },

            removeWindowListener: function (event, listener) {
                var _window = Pusher.Util.getWindow();
                if (_window.addEventListener !== undefined) {
                    _window.removeEventListener(event, listener, false);
                } else {
                    _window.detachEvent("on" + event, listener);
                }
            },

            isXHRSupported: function () {
                var XHR = window.XMLHttpRequest;
                return Boolean(XHR) && (new XHR()).withCredentials !== undefined;
            },

            isXDRSupported: function (encrypted) {
                var protocol = encrypted ? "https:" : "http:";
                var documentProtocol = Pusher.Util.getDocument().location.protocol;
                return Boolean(window.XDomainRequest) && documentProtocol === protocol;
            }
        };
    }).call(this);

    ;(function () {
        Pusher.VERSION = '3.0.0';
        Pusher.PROTOCOL = 7;

        // DEPRECATED: WS connection parameters
        Pusher.host = 'ws.pusherapp.com';
        Pusher.ws_port = 80;
        Pusher.wss_port = 443;
        // DEPRECATED: SockJS fallback parameters
        Pusher.sockjs_host = 'sockjs.pusher.com';
        Pusher.sockjs_http_port = 80;
        Pusher.sockjs_https_port = 443;
        Pusher.sockjs_path = "/pusher";
        // DEPRECATED: Stats
        Pusher.stats_host = 'stats.pusher.com';
        // DEPRECATED: Other settings
        Pusher.channel_auth_endpoint = '/pusher/auth';
        Pusher.channel_auth_transport = 'ajax';
        Pusher.activity_timeout = 120000;
        Pusher.pong_timeout = 30000;
        Pusher.unavailable_timeout = 10000;
        // CDN configuration
        Pusher.cdn_http = 'http://js.pusher.com/';
        Pusher.cdn_https = 'https://js.pusher.com/';
        Pusher.dependency_suffix = '';

        Pusher.getDefaultStrategy = function (config) {
            var wsStrategy;
            if (config.encrypted) {
                wsStrategy = [
                    ":best_connected_ever",
                    ":ws_loop",
                    [":delayed", 2000, [":http_fallback_loop"]]
                ];
            } else {
                wsStrategy = [
                    ":best_connected_ever",
                    ":ws_loop",
                    [":delayed", 2000, [":wss_loop"]],
                    [":delayed", 5000, [":http_fallback_loop"]]
                ];
            }

            return [
                [":def", "ws_options", {
                    hostUnencrypted: config.wsHost + ":" + config.wsPort,
                    hostEncrypted: config.wsHost + ":" + config.wssPort
                }],
                [":def", "wss_options", [":extend", ":ws_options", {
                    encrypted: true
                }]],
                [":def", "sockjs_options", {
                    hostUnencrypted: config.httpHost + ":" + config.httpPort,
                    hostEncrypted: config.httpHost + ":" + config.httpsPort,
                    httpPath: config.httpPath
                }],
                [":def", "timeouts", {
                    loop: true,
                    timeout: 15000,
                    timeoutLimit: 60000
                }],

                [":def", "ws_manager", [":transport_manager", {
                    lives: 2,
                    minPingDelay: 10000,
                    maxPingDelay: config.activity_timeout
                }]],
                [":def", "streaming_manager", [":transport_manager", {
                    lives: 2,
                    minPingDelay: 10000,
                    maxPingDelay: config.activity_timeout
                }]],

                [":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager"],
                [":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager"],
                [":def_transport", "sockjs", "sockjs", 1, ":sockjs_options"],
                [":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager"],
                [":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager"],
                [":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options"],
                [":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options"],

                [":def", "ws_loop", [":sequential", ":timeouts", ":ws"]],
                [":def", "wss_loop", [":sequential", ":timeouts", ":wss"]],
                [":def", "sockjs_loop", [":sequential", ":timeouts", ":sockjs"]],

                [":def", "streaming_loop", [":sequential", ":timeouts",
                    [":if", [":is_supported", ":xhr_streaming"],
                        ":xhr_streaming",
                        ":xdr_streaming"
                    ]
                ]],
                [":def", "polling_loop", [":sequential", ":timeouts",
                    [":if", [":is_supported", ":xhr_polling"],
                        ":xhr_polling",
                        ":xdr_polling"
                    ]
                ]],

                [":def", "http_loop", [":if", [":is_supported", ":streaming_loop"], [
                    ":best_connected_ever",
                    ":streaming_loop",
                    [":delayed", 4000, [":polling_loop"]]
                ], [
                    ":polling_loop"
                ]]],

                [":def", "http_fallback_loop",
                    [":if", [":is_supported", ":http_loop"], [
                        ":http_loop"
                    ], [
                        ":sockjs_loop"
                    ]]
                ],

                [":def", "strategy",
                    [":cached", 1800000,
                        [":first_connected",
                            [":if", [":is_supported", ":ws"],
                                wsStrategy,
                                ":http_fallback_loop"
                            ]
                        ]
                    ]
                ]
            ];
        };
    }).call(this);

    ;(function () {
        Pusher.getGlobalConfig = function () {
            return {
                wsHost: Pusher.host,
                wsPort: Pusher.ws_port,
                wssPort: Pusher.wss_port,
                httpHost: Pusher.sockjs_host,
                httpPort: Pusher.sockjs_http_port,
                httpsPort: Pusher.sockjs_https_port,
                httpPath: Pusher.sockjs_path,
                statsHost: Pusher.stats_host,
                authEndpoint: Pusher.channel_auth_endpoint,
                authTransport: Pusher.channel_auth_transport,
                // TODO make this consistent with other options in next major version
                activity_timeout: Pusher.activity_timeout,
                pong_timeout: Pusher.pong_timeout,
                unavailable_timeout: Pusher.unavailable_timeout
            };
        };

        Pusher.getClusterConfig = function (clusterName) {
            return {
                wsHost: "ws-" + clusterName + ".pusher.com",
                httpHost: "sockjs-" + clusterName + ".pusher.com"
            };
        };
    }).call(this);

    ;(function () {
        function buildExceptionClass(name) {
            var constructor = function (message) {
                Error.call(this, message);
                this.name = name;
            };
            Pusher.Util.extend(constructor.prototype, Error.prototype);

            return constructor;
        }

        /** Error classes used throughout pusher-js library. */
        Pusher.Errors = {
            BadEventName: buildExceptionClass("BadEventName"),
            RequestTimedOut: buildExceptionClass("RequestTimedOut"),
            TransportPriorityTooLow: buildExceptionClass("TransportPriorityTooLow"),
            TransportClosed: buildExceptionClass("TransportClosed"),
            UnsupportedTransport: buildExceptionClass("UnsupportedTransport"),
            UnsupportedStrategy: buildExceptionClass("UnsupportedStrategy")
        };
    }).call(this);

    ;(function () {
        /** Manages callback bindings and event emitting.
         *
         * @param Function failThrough called when no listeners are bound to an event
         */
        function EventsDispatcher(failThrough) {
            this.callbacks = new CallbackRegistry();
            this.global_callbacks = [];
            this.failThrough = failThrough;
        }

        var prototype = EventsDispatcher.prototype;

        prototype.bind = function (eventName, callback, context) {
            this.callbacks.add(eventName, callback, context);
            return this;
        };

        prototype.bind_all = function (callback) {
            this.global_callbacks.push(callback);
            return this;
        };

        prototype.unbind = function (eventName, callback, context) {
            this.callbacks.remove(eventName, callback, context);
            return this;
        };

        prototype.unbind_all = function (eventName, callback) {
            this.callbacks.remove(eventName, callback);
            return this;
        };

        prototype.emit = function (eventName, data) {
            var i;

            for (i = 0; i < this.global_callbacks.length; i++) {
                this.global_callbacks[i](eventName, data);
            }

            var callbacks = this.callbacks.get(eventName);
            if (callbacks && callbacks.length > 0) {
                for (i = 0; i < callbacks.length; i++) {
                    callbacks[i].fn.call(callbacks[i].context || window, data);
                }
            } else if (this.failThrough) {
                this.failThrough(eventName, data);
            }

            return this;
        };

        /** Callback registry helper. */

        function CallbackRegistry() {
            this._callbacks = {};
        }

        CallbackRegistry.prototype.get = function (name) {
            return this._callbacks[prefix(name)];
        };

        CallbackRegistry.prototype.add = function (name, callback, context) {
            var prefixedEventName = prefix(name);
            this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
            this._callbacks[prefixedEventName].push({
                fn: callback,
                context: context
            });
        };

        CallbackRegistry.prototype.remove = function (name, callback, context) {
            if (!name && !callback && !context) {
                this._callbacks = {};
                return;
            }

            var names = name ? [prefix(name)] : Pusher.Util.keys(this._callbacks);

            if (callback || context) {
                Pusher.Util.apply(names, function (name) {
                    this._callbacks[name] = Pusher.Util.filter(
                        this._callbacks[name] || [],
                        function (binding) {
                            return (callback && callback !== binding.fn) ||
                                (context && context !== binding.context);
                        }
                    );
                    if (this._callbacks[name].length === 0) {
                        delete this._callbacks[name];
                    }
                }, this);
            } else {
                Pusher.Util.apply(names, function (name) {
                    delete this._callbacks[name];
                }, this);
            }
        };

        function prefix(name) {
            return "_" + name;
        }

        Pusher.EventsDispatcher = EventsDispatcher;
    }).call(this);

    (function () {
        /** Builds receivers for JSONP and Script requests.
         *
         * Each receiver is an object with following fields:
         * - number - unique (for the factory instance), numerical id of the receiver
         * - id - a string ID that can be used in DOM attributes
         * - name - name of the function triggering the receiver
         * - callback - callback function
         *
         * Receivers are triggered only once, on the first callback call.
         *
         * Receivers can be called by their name or by accessing factory object
         * by the number key.
         *
         * @param {String} prefix the prefix used in ids
         * @param {String} name the name of the object
         */
        function ScriptReceiverFactory(prefix, name) {
            this.lastId = 0;
            this.prefix = prefix;
            this.name = name;
        }

        var prototype = ScriptReceiverFactory.prototype;

        /** Creates a script receiver.
         *
         * @param {Function} callback
         * @return {ScriptReceiver}
         */
        prototype.create = function (callback) {
            this.lastId++;

            var number = this.lastId;
            var id = this.prefix + number;
            var name = this.name + "[" + number + "]";

            var called = false;
            var callbackWrapper = function () {
                if (!called) {
                    callback.apply(null, arguments);
                    called = true;
                }
            };

            this[number] = callbackWrapper;
            return {number: number, id: id, name: name, callback: callbackWrapper};
        };

        /** Removes the script receiver from the list.
         *
         * @param {ScriptReceiver} receiver
         */
        prototype.remove = function (receiver) {
            delete this[receiver.number];
        };

        Pusher.ScriptReceiverFactory = ScriptReceiverFactory;
        Pusher.ScriptReceivers = new ScriptReceiverFactory(
            "_pusher_script_", "Pusher.ScriptReceivers"
        );
    }).call(this);

    (function () {
        /** Sends a generic HTTP GET request using a script tag.
         *
         * By constructing URL in a specific way, it can be used for loading
         * JavaScript resources or JSONP requests. It can notify about errors, but
         * only in certain environments. Please take care of monitoring the state of
         * the request yourself.
         *
         * @param {String} src
         */
        function ScriptRequest(src) {
            this.src = src;
        }

        var prototype = ScriptRequest.prototype;

        /** Sends the actual script request.
         *
         * @param {ScriptReceiver} receiver
         */
        prototype.send = function (receiver) {
            var self = this;
            var errorString = "Error loading " + self.src;

            self.script = document.createElement("script");
            self.script.id = receiver.id;
            self.script.src = self.src;
            self.script.type = "text/javascript";
            self.script.charset = "UTF-8";

            if (self.script.addEventListener) {
                self.script.onerror = function () {
                    receiver.callback(errorString);
                };
                self.script.onload = function () {
                    receiver.callback(null);
                };
            } else {
                self.script.onreadystatechange = function () {
                    if (self.script.readyState === 'loaded' ||
                        self.script.readyState === 'complete') {
                        receiver.callback(null);
                    }
                };
            }

            // Opera<11.6 hack for missing onerror callback
            if (self.script.async === undefined && document.attachEvent &&
                /opera/i.test(navigator.userAgent)) {
                self.errorScript = document.createElement("script");
                self.errorScript.id = receiver.id + "_error";
                self.errorScript.text = receiver.name + "('" + errorString + "');";
                self.script.async = self.errorScript.async = false;
            } else {
                self.script.async = true;
            }

            var head = document.getElementsByTagName('head')[0];
            head.insertBefore(self.script, head.firstChild);
            if (self.errorScript) {
                head.insertBefore(self.errorScript, self.script.nextSibling);
            }
        };

        /** Cleans up the DOM remains of the script request. */
        prototype.cleanup = function () {
            if (this.script) {
                this.script.onload = this.script.onerror = null;
                this.script.onreadystatechange = null;
            }
            if (this.script && this.script.parentNode) {
                this.script.parentNode.removeChild(this.script);
            }
            if (this.errorScript && this.errorScript.parentNode) {
                this.errorScript.parentNode.removeChild(this.errorScript);
            }
            this.script = null;
            this.errorScript = null;
        };

        Pusher.ScriptRequest = ScriptRequest;
    }).call(this);

    ;(function () {
        /** Handles loading dependency files.
         *
         * Dependency loaders don't remember whether a resource has been loaded or
         * not. It is caller's responsibility to make sure the resource is not loaded
         * twice. This is because it's impossible to detect resource loading status
         * without knowing its content.
         *
         * Options:
         * - cdn_http - url to HTTP CND
         * - cdn_https - url to HTTPS CDN
         * - version - version of pusher-js
         * - suffix - suffix appended to all names of dependency files
         *
         * @param {Object} options
         */
        function DependencyLoader(options) {
            this.options = options;
            this.receivers = options.receivers || Pusher.ScriptReceivers;
            this.loading = {};
        }

        var prototype = DependencyLoader.prototype;

        /** Loads the dependency from CDN.
         *
         * @param  {String} name
         * @param  {Function} callback
         */
        prototype.load = function (name, options, callback) {
            var self = this;

            if (self.loading[name] && self.loading[name].length > 0) {
                self.loading[name].push(callback);
            } else {
                self.loading[name] = [callback];

                var request = new Pusher.ScriptRequest(self.getPath(name, options));
                var receiver = self.receivers.create(function (error) {
                    self.receivers.remove(receiver);

                    if (self.loading[name]) {
                        var callbacks = self.loading[name];
                        delete self.loading[name];

                        var successCallback = function (wasSuccessful) {
                            if (!wasSuccessful) {
                                request.cleanup();
                            }
                        };
                        for (var i = 0; i < callbacks.length; i++) {
                            callbacks[i](error, successCallback);
                        }
                    }
                });
                request.send(receiver);
            }
        };

        /** Returns a root URL for pusher-js CDN.
         *
         * @returns {String}
         */
        prototype.getRoot = function (options) {
            var cdn;
            var protocol = Pusher.Util.getDocument().location.protocol;
            if ((options && options.encrypted) || protocol === "https:") {
                cdn = this.options.cdn_https;
            } else {
                cdn = this.options.cdn_http;
            }
            // make sure there are no double slashes
            return cdn.replace(/\/*$/, "") + "/" + this.options.version;
        };

        /** Returns a full path to a dependency file.
         *
         * @param {String} name
         * @returns {String}
         */
        prototype.getPath = function (name, options) {
            return this.getRoot(options) + '/' + name + this.options.suffix + '.js';
        };

        Pusher.DependencyLoader = DependencyLoader;
    }).call(this);

    ;(function () {
        Pusher.DependenciesReceivers = new Pusher.ScriptReceiverFactory(
            "_pusher_dependencies", "Pusher.DependenciesReceivers"
        );
        Pusher.Dependencies = new Pusher.DependencyLoader({
            cdn_http: Pusher.cdn_http,
            cdn_https: Pusher.cdn_https,
            version: Pusher.VERSION,
            suffix: Pusher.dependency_suffix,
            receivers: Pusher.DependenciesReceivers
        });

        function initialize() {
            Pusher.ready();
        }

        // Allows calling a function when the document body is available
        function onDocumentBody(callback) {
            if (document.body) {
                callback();
            } else {
                setTimeout(function () {
                    onDocumentBody(callback);
                }, 0);
            }
        }

        function initializeOnDocumentBody() {
            onDocumentBody(initialize);
        }

        if (!window.JSON) {
            Pusher.Dependencies.load("json2", {}, initializeOnDocumentBody);
        } else {
            initializeOnDocumentBody();
        }
    })();

    (function () {

        var Base64 = {
            encode: function (s) {
                return btoa(utob(s));
            }
        };

        var fromCharCode = String.fromCharCode;

        var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        var b64tab = {};

        for (var i = 0, l = b64chars.length; i < l; i++) {
            b64tab[b64chars.charAt(i)] = i;
        }

        var cb_utob = function (c) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? fromCharCode(0xc0 | (cc >>> 6)) +
                    fromCharCode(0x80 | (cc & 0x3f))
                    : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +
                    fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +
                    fromCharCode(0x80 | ( cc & 0x3f));
        };

        var utob = function (u) {
            return u.replace(/[^\x00-\x7F]/g, cb_utob);
        };

        var cb_encode = function (ccc) {
            var padlen = [0, 2, 1][ccc.length % 3];
            var ord = ccc.charCodeAt(0) << 16
                | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
                | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0));
            var chars = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt((ord >>> 12) & 63),
                padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
                padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
            ];
            return chars.join('');
        };

        var btoa = window.btoa || function (b) {
            return b.replace(/[\s\S]{1,3}/g, cb_encode);
        };

        Pusher.Base64 = Base64;

    }).call(this);

    (function () {
        /** Sends data via JSONP.
         *
         * Data is a key-value map. Its values are JSON-encoded and then passed
         * through base64. Finally, keys and encoded values are appended to the query
         * string.
         *
         * The class itself does not guarantee raising errors on failures, as it's not
         * possible to support such feature on all browsers. Instead, JSONP endpoint
         * should call back in a way that's easy to distinguish from browser calls,
         * for example by passing a second argument to the receiver.
         *
         * @param {String} url
         * @param {Object} data key-value map of data to be submitted
         */
        function JSONPRequest(url, data) {
            this.url = url;
            this.data = data;
        }

        var prototype = JSONPRequest.prototype;

        /** Sends the actual JSONP request.
         *
         * @param {ScriptReceiver} receiver
         */
        prototype.send = function (receiver) {
            if (this.request) {
                return;
            }

            var params = Pusher.Util.filterObject(this.data, function (value) {
                return value !== undefined;
            });
            var query = Pusher.Util.map(
                Pusher.Util.flatten(encodeParamsObject(params)),
                Pusher.Util.method("join", "=")
            ).join("&");
            var url = this.url + "/" + receiver.number + "?" + query;

            this.request = new Pusher.ScriptRequest(url);
            this.request.send(receiver);
        };

        /** Cleans up the DOM remains of the JSONP request. */
        prototype.cleanup = function () {
            if (this.request) {
                this.request.cleanup();
            }
        };

        function encodeParamsObject(data) {
            return Pusher.Util.mapObject(data, function (value) {
                if (typeof value === "object") {
                    value = JSON.stringify(value);
                }
                return encodeURIComponent(Pusher.Base64.encode(value.toString()));
            });
        }

        Pusher.JSONPRequest = JSONPRequest;
    }).call(this);

    (function () {
        function Timeline(key, session, options) {
            this.key = key;
            this.session = session;
            this.events = [];
            this.options = options || {};
            this.sent = 0;
            this.uniqueID = 0;
        }

        var prototype = Timeline.prototype;

        // Log levels
        Timeline.ERROR = 3;
        Timeline.INFO = 6;
        Timeline.DEBUG = 7;

        prototype.log = function (level, event) {
            if (level <= this.options.level) {
                this.events.push(
                    Pusher.Util.extend({}, event, {timestamp: Pusher.Util.now()})
                );
                if (this.options.limit && this.events.length > this.options.limit) {
                    this.events.shift();
                }
            }
        };

        prototype.error = function (event) {
            this.log(Timeline.ERROR, event);
        };

        prototype.info = function (event) {
            this.log(Timeline.INFO, event);
        };

        prototype.debug = function (event) {
            this.log(Timeline.DEBUG, event);
        };

        prototype.isEmpty = function () {
            return this.events.length === 0;
        };

        prototype.send = function (sendJSONP, callback) {
            var self = this;

            var data = Pusher.Util.extend({
                session: self.session,
                bundle: self.sent + 1,
                key: self.key,
                lib: "js",
                version: self.options.version,
                cluster: self.options.cluster,
                features: self.options.features,
                timeline: self.events
            }, self.options.params);

            self.events = [];
            sendJSONP(data, function (error, result) {
                if (!error) {
                    self.sent++;
                }
                if (callback) {
                    callback(error, result);
                }
            });

            return true;
        };

        prototype.generateUniqueID = function () {
            this.uniqueID++;
            return this.uniqueID;
        };

        Pusher.Timeline = Timeline;
    }).call(this);

    (function () {
        function TimelineSender(timeline, options) {
            this.timeline = timeline;
            this.options = options || {};
        }

        var prototype = TimelineSender.prototype;

        prototype.send = function (encrypted, callback) {
            var self = this;

            if (self.timeline.isEmpty()) {
                return;
            }

            var sendJSONP = function (data, callback) {
                var scheme = "http" + (encrypted ? "s" : "") + "://";
                var url = scheme + (self.host || self.options.host) + self.options.path;
                var request = new Pusher.JSONPRequest(url, data);

                var receiver = Pusher.ScriptReceivers.create(function (error, result) {
                    Pusher.ScriptReceivers.remove(receiver);
                    request.cleanup();

                    if (result && result.host) {
                        self.host = result.host;
                    }
                    if (callback) {
                        callback(error, result);
                    }
                });
                request.send(receiver);
            };
            self.timeline.send(sendJSONP, callback);
        };

        Pusher.TimelineSender = TimelineSender;
    }).call(this);

    ;(function () {
        /** Launches all substrategies and emits prioritized connected transports.
         *
         * @param {Array} strategies
         */
        function BestConnectedEverStrategy(strategies) {
            this.strategies = strategies;
        }

        var prototype = BestConnectedEverStrategy.prototype;

        prototype.isSupported = function () {
            return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
        };

        prototype.connect = function (minPriority, callback) {
            return connect(this.strategies, minPriority, function (i, runners) {
                return function (error, handshake) {
                    runners[i].error = error;
                    if (error) {
                        if (allRunnersFailed(runners)) {
                            callback(true);
                        }
                        return;
                    }
                    Pusher.Util.apply(runners, function (runner) {
                        runner.forceMinPriority(handshake.transport.priority);
                    });
                    callback(null, handshake);
                };
            });
        };

        /** Connects to all strategies in parallel.
         *
         * Callback builder should be a function that takes two arguments: index
         * and a list of runners. It should return another function that will be
         * passed to the substrategy with given index. Runners can be aborted using
         * abortRunner(s) functions from this class.
         *
         * @param  {Array} strategies
         * @param  {Function} callbackBuilder
         * @return {Object} strategy runner
         */
        function connect(strategies, minPriority, callbackBuilder) {
            var runners = Pusher.Util.map(strategies, function (strategy, i, _, rs) {
                return strategy.connect(minPriority, callbackBuilder(i, rs));
            });
            return {
                abort: function () {
                    Pusher.Util.apply(runners, abortRunner);
                },
                forceMinPriority: function (p) {
                    Pusher.Util.apply(runners, function (runner) {
                        runner.forceMinPriority(p);
                    });
                }
            };
        }

        function allRunnersFailed(runners) {
            return Pusher.Util.all(runners, function (runner) {
                return Boolean(runner.error);
            });
        }

        function abortRunner(runner) {
            if (!runner.error && !runner.aborted) {
                runner.abort();
                runner.aborted = true;
            }
        }

        Pusher.BestConnectedEverStrategy = BestConnectedEverStrategy;
    }).call(this);

    ;(function () {
        /** Caches last successful transport and uses it for following attempts.
         *
         * @param {Strategy} strategy
         * @param {Object} transports
         * @param {Object} options
         */
        function CachedStrategy(strategy, transports, options) {
            this.strategy = strategy;
            this.transports = transports;
            this.ttl = options.ttl || 1800 * 1000;
            this.encrypted = options.encrypted;
            this.timeline = options.timeline;
        }

        var prototype = CachedStrategy.prototype;

        prototype.isSupported = function () {
            return this.strategy.isSupported();
        };

        prototype.connect = function (minPriority, callback) {
            var encrypted = this.encrypted;
            var info = fetchTransportCache(encrypted);

            var strategies = [this.strategy];
            if (info && info.timestamp + this.ttl >= Pusher.Util.now()) {
                var transport = this.transports[info.transport];
                if (transport) {
                    this.timeline.info({
                        cached: true,
                        transport: info.transport,
                        latency: info.latency
                    });
                    strategies.push(new Pusher.SequentialStrategy([transport], {
                        timeout: info.latency * 2 + 1000,
                        failFast: true
                    }));
                }
            }

            var startTimestamp = Pusher.Util.now();
            var runner = strategies.pop().connect(
                minPriority,
                function cb(error, handshake) {
                    if (error) {
                        flushTransportCache(encrypted);
                        if (strategies.length > 0) {
                            startTimestamp = Pusher.Util.now();
                            runner = strategies.pop().connect(minPriority, cb);
                        } else {
                            callback(error);
                        }
                    } else {
                        storeTransportCache(
                            encrypted,
                            handshake.transport.name,
                            Pusher.Util.now() - startTimestamp
                        );
                        callback(null, handshake);
                    }
                }
            );

            return {
                abort: function () {
                    runner.abort();
                },
                forceMinPriority: function (p) {
                    minPriority = p;
                    if (runner) {
                        runner.forceMinPriority(p);
                    }
                }
            };
        };

        function getTransportCacheKey(encrypted) {
            return "pusherTransport" + (encrypted ? "Encrypted" : "Unencrypted");
        }

        function fetchTransportCache(encrypted) {
            var storage = Pusher.Util.getLocalStorage();
            if (storage) {
                try {
                    var serializedCache = storage[getTransportCacheKey(encrypted)];
                    if (serializedCache) {
                        return JSON.parse(serializedCache);
                    }
                } catch (e) {
                    flushTransportCache(encrypted);
                }
            }
            return null;
        }

        function storeTransportCache(encrypted, transport, latency) {
            var storage = Pusher.Util.getLocalStorage();
            if (storage) {
                try {
                    storage[getTransportCacheKey(encrypted)] = JSON.stringify({
                        timestamp: Pusher.Util.now(),
                        transport: transport,
                        latency: latency
                    });
                } catch (e) {
                    // catch over quota exceptions raised by localStorage
                }
            }
        }

        function flushTransportCache(encrypted) {
            var storage = Pusher.Util.getLocalStorage();
            if (storage) {
                try {
                    delete storage[getTransportCacheKey(encrypted)];
                } catch (e) {
                    // catch exceptions raised by localStorage
                }
            }
        }

        Pusher.CachedStrategy = CachedStrategy;
    }).call(this);

    ;(function () {
        /** Runs substrategy after specified delay.
         *
         * Options:
         * - delay - time in miliseconds to delay the substrategy attempt
         *
         * @param {Strategy} strategy
         * @param {Object} options
         */
        function DelayedStrategy(strategy, options) {
            this.strategy = strategy;
            this.options = {delay: options.delay};
        }

        var prototype = DelayedStrategy.prototype;

        prototype.isSupported = function () {
            return this.strategy.isSupported();
        };

        prototype.connect = function (minPriority, callback) {
            var strategy = this.strategy;
            var runner;
            var timer = new Pusher.Timer(this.options.delay, function () {
                runner = strategy.connect(minPriority, callback);
            });

            return {
                abort: function () {
                    timer.ensureAborted();
                    if (runner) {
                        runner.abort();
                    }
                },
                forceMinPriority: function (p) {
                    minPriority = p;
                    if (runner) {
                        runner.forceMinPriority(p);
                    }
                }
            };
        };

        Pusher.DelayedStrategy = DelayedStrategy;
    }).call(this);

    ;(function () {
        /** Launches the substrategy and terminates on the first open connection.
         *
         * @param {Strategy} strategy
         */
        function FirstConnectedStrategy(strategy) {
            this.strategy = strategy;
        }

        var prototype = FirstConnectedStrategy.prototype;

        prototype.isSupported = function () {
            return this.strategy.isSupported();
        };

        prototype.connect = function (minPriority, callback) {
            var runner = this.strategy.connect(
                minPriority,
                function (error, handshake) {
                    if (handshake) {
                        runner.abort();
                    }
                    callback(error, handshake);
                }
            );
            return runner;
        };

        Pusher.FirstConnectedStrategy = FirstConnectedStrategy;
    }).call(this);

    ;(function () {
        /** Proxies method calls to one of substrategies basing on the test function.
         *
         * @param {Function} test
         * @param {Strategy} trueBranch strategy used when test returns true
         * @param {Strategy} falseBranch strategy used when test returns false
         */
        function IfStrategy(test, trueBranch, falseBranch) {
            this.test = test;
            this.trueBranch = trueBranch;
            this.falseBranch = falseBranch;
        }

        var prototype = IfStrategy.prototype;

        prototype.isSupported = function () {
            var branch = this.test() ? this.trueBranch : this.falseBranch;
            return branch.isSupported();
        };

        prototype.connect = function (minPriority, callback) {
            var branch = this.test() ? this.trueBranch : this.falseBranch;
            return branch.connect(minPriority, callback);
        };

        Pusher.IfStrategy = IfStrategy;
    }).call(this);

    ;(function () {
        /** Loops through strategies with optional timeouts.
         *
         * Options:
         * - loop - whether it should loop through the substrategy list
         * - timeout - initial timeout for a single substrategy
         * - timeoutLimit - maximum timeout
         *
         * @param {Strategy[]} strategies
         * @param {Object} options
         */
        function SequentialStrategy(strategies, options) {
            this.strategies = strategies;
            this.loop = Boolean(options.loop);
            this.failFast = Boolean(options.failFast);
            this.timeout = options.timeout;
            this.timeoutLimit = options.timeoutLimit;
        }

        var prototype = SequentialStrategy.prototype;

        prototype.isSupported = function () {
            return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
        };

        prototype.connect = function (minPriority, callback) {
            var self = this;

            var strategies = this.strategies;
            var current = 0;
            var timeout = this.timeout;
            var runner = null;

            var tryNextStrategy = function (error, handshake) {
                if (handshake) {
                    callback(null, handshake);
                } else {
                    current = current + 1;
                    if (self.loop) {
                        current = current % strategies.length;
                    }

                    if (current < strategies.length) {
                        if (timeout) {
                            timeout = timeout * 2;
                            if (self.timeoutLimit) {
                                timeout = Math.min(timeout, self.timeoutLimit);
                            }
                        }
                        runner = self.tryStrategy(
                            strategies[current],
                            minPriority,
                            {timeout: timeout, failFast: self.failFast},
                            tryNextStrategy
                        );
                    } else {
                        callback(true);
                    }
                }
            };

            runner = this.tryStrategy(
                strategies[current],
                minPriority,
                {timeout: timeout, failFast: this.failFast},
                tryNextStrategy
            );

            return {
                abort: function () {
                    runner.abort();
                },
                forceMinPriority: function (p) {
                    minPriority = p;
                    if (runner) {
                        runner.forceMinPriority(p);
                    }
                }
            };
        };

        /** @private */
        prototype.tryStrategy = function (strategy, minPriority, options, callback) {
            var timer = null;
            var runner = null;

            if (options.timeout > 0) {
                timer = new Pusher.Timer(options.timeout, function () {
                    runner.abort();
                    callback(true);
                });
            }

            runner = strategy.connect(minPriority, function (error, handshake) {
                if (error && timer && timer.isRunning() && !options.failFast) {
                    // advance to the next strategy after the timeout
                    return;
                }
                if (timer) {
                    timer.ensureAborted();
                }
                callback(error, handshake);
            });

            return {
                abort: function () {
                    if (timer) {
                        timer.ensureAborted();
                    }
                    runner.abort();
                },
                forceMinPriority: function (p) {
                    runner.forceMinPriority(p);
                }
            };
        };

        Pusher.SequentialStrategy = SequentialStrategy;
    }).call(this);

    ;(function () {
        /** Provides a strategy interface for transports.
         *
         * @param {String} name
         * @param {Number} priority
         * @param {Class} transport
         * @param {Object} options
         */
        function TransportStrategy(name, priority, transport, options) {
            this.name = name;
            this.priority = priority;
            this.transport = transport;
            this.options = options || {};
        }

        var prototype = TransportStrategy.prototype;

        /** Returns whether the transport is supported in the browser.
         *
         * @returns {Boolean}
         */
        prototype.isSupported = function () {
            return this.transport.isSupported({
                encrypted: this.options.encrypted
            });
        };

        /** Launches a connection attempt and returns a strategy runner.
         *
         * @param  {Function} callback
         * @return {Object} strategy runner
         */
        prototype.connect = function (minPriority, callback) {
            if (!this.isSupported()) {
                return failAttempt(new Pusher.Errors.UnsupportedStrategy(), callback);
            } else if (this.priority < minPriority) {
                return failAttempt(new Pusher.Errors.TransportPriorityTooLow(), callback);
            }

            var self = this;
            var connected = false;

            var transport = this.transport.createConnection(
                this.name, this.priority, this.options.key, this.options
            );
            var handshake = null;

            var onInitialized = function () {
                transport.unbind("initialized", onInitialized);
                transport.connect();
            };
            var onOpen = function () {
                handshake = new Pusher.Handshake(transport, function (result) {
                    connected = true;
                    unbindListeners();
                    callback(null, result);
                });
            };
            var onError = function (error) {
                unbindListeners();
                callback(error);
            };
            var onClosed = function () {
                unbindListeners();
                callback(new Pusher.Errors.TransportClosed(transport));
            };

            var unbindListeners = function () {
                transport.unbind("initialized", onInitialized);
                transport.unbind("open", onOpen);
                transport.unbind("error", onError);
                transport.unbind("closed", onClosed);
            };

            transport.bind("initialized", onInitialized);
            transport.bind("open", onOpen);
            transport.bind("error", onError);
            transport.bind("closed", onClosed);

            // connect will be called automatically after initialization
            transport.initialize();

            return {
                abort: function () {
                    if (connected) {
                        return;
                    }
                    unbindListeners();
                    if (handshake) {
                        handshake.close();
                    } else {
                        transport.close();
                    }
                },
                forceMinPriority: function (p) {
                    if (connected) {
                        return;
                    }
                    if (self.priority < p) {
                        if (handshake) {
                            handshake.close();
                        } else {
                            transport.close();
                        }
                    }
                }
            };
        };

        function failAttempt(error, callback) {
            Pusher.Util.defer(function () {
                callback(error);
            });
            return {
                abort: function () {
                },
                forceMinPriority: function () {
                }
            };
        }

        Pusher.TransportStrategy = TransportStrategy;
    }).call(this);

    (function () {
        function getGenericURL(baseScheme, params, path) {
            var scheme = baseScheme + (params.encrypted ? "s" : "");
            var host = params.encrypted ? params.hostEncrypted : params.hostUnencrypted;
            return scheme + "://" + host + path;
        }

        function getGenericPath(key, queryString) {
            var path = "/app/" + key;
            var query =
                "?protocol=" + Pusher.PROTOCOL +
                "&client=js" +
                "&version=" + Pusher.VERSION +
                (queryString ? ("&" + queryString) : "");
            return path + query;
        }

        /** URL schemes for different transport types. */
        Pusher.URLSchemes = {
            /** Standard WebSocket URL scheme. */
            ws: {
                getInitial: function (key, params) {
                    return getGenericURL("ws", params, getGenericPath(key, "flash=false"));
                }
            },
            /** SockJS URL scheme. Supplies the path separately from the initial URL. */
            sockjs: {
                getInitial: function (key, params) {
                    return getGenericURL("http", params, params.httpPath || "/pusher", "");
                },
                getPath: function (key, params) {
                    return getGenericPath(key);
                }
            },
            /** URL scheme for HTTP transports. Basically, WS scheme with a prefix. */
            http: {
                getInitial: function (key, params) {
                    var path = (params.httpPath || "/pusher") + getGenericPath(key);
                    return getGenericURL("http", params, path);
                }
            }
        };
    }).call(this);

    (function () {
        /** Provides universal API for transport connections.
         *
         * Transport connection is a low-level object that wraps a connection method
         * and exposes a simple evented interface for the connection state and
         * messaging. It does not implement Pusher-specific WebSocket protocol.
         *
         * Additionally, it fetches resources needed for transport to work and exposes
         * an interface for querying transport features.
         *
         * States:
         * - new - initial state after constructing the object
         * - initializing - during initialization phase, usually fetching resources
         * - intialized - ready to establish a connection
         * - connection - when connection is being established
         * - open - when connection ready to be used
         * - closed - after connection was closed be either side
         *
         * Emits:
         * - error - after the connection raised an error
         *
         * Options:
         * - encrypted - whether connection should use ssl
         * - hostEncrypted - host to connect to when connection is encrypted
         * - hostUnencrypted - host to connect to when connection is not encrypted
         *
         * @param {String} key application key
         * @param {Object} options
         */
        function TransportConnection(hooks, name, priority, key, options) {
            Pusher.EventsDispatcher.call(this);

            this.hooks = hooks;
            this.name = name;
            this.priority = priority;
            this.key = key;
            this.options = options;

            this.state = "new";
            this.timeline = options.timeline;
            this.activityTimeout = options.activityTimeout;
            this.id = this.timeline.generateUniqueID();
        }

        var prototype = TransportConnection.prototype;
        Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

        /** Checks whether the transport handles activity checks by itself.
         *
         * @return {Boolean}
         */
        prototype.handlesActivityChecks = function () {
            return Boolean(this.hooks.handlesActivityChecks);
        };

        /** Checks whether the transport supports the ping/pong API.
         *
         * @return {Boolean}
         */
        prototype.supportsPing = function () {
            return Boolean(this.hooks.supportsPing);
        };

        /** Initializes the transport.
         *
         * Fetches resources if needed and then transitions to initialized.
         */
        prototype.initialize = function () {
            var self = this;

            self.timeline.info(self.buildTimelineMessage({
                transport: self.name + (self.options.encrypted ? "s" : "")
            }));

            if (self.hooks.isInitialized()) {
                self.changeState("initialized");
            } else if (self.hooks.file) {
                self.changeState("initializing");
                Pusher.Dependencies.load(
                    self.hooks.file,
                    {encrypted: self.options.encrypted},
                    function (error, callback) {
                        if (self.hooks.isInitialized()) {
                            self.changeState("initialized");
                            callback(true);
                        } else {
                            if (error) {
                                self.onError(error);
                            }
                            self.onClose();
                            callback(false);
                        }
                    }
                );
            } else {
                self.onClose();
            }
        };

        /** Tries to establish a connection.
         *
         * @returns {Boolean} false if transport is in invalid state
         */
        prototype.connect = function () {
            var self = this;

            if (self.socket || self.state !== "initialized") {
                return false;
            }

            var url = self.hooks.urls.getInitial(self.key, self.options);
            try {
                self.socket = self.hooks.getSocket(url, self.options);
            } catch (e) {
                Pusher.Util.defer(function () {
                    self.onError(e);
                    self.changeState("closed");
                });
                return false;
            }

            self.bindListeners();

            Pusher.debug("Connecting", {transport: self.name, url: url});
            self.changeState("connecting");
            return true;
        };

        /** Closes the connection.
         *
         * @return {Boolean} true if there was a connection to close
         */
        prototype.close = function () {
            if (this.socket) {
                this.socket.close();
                return true;
            } else {
                return false;
            }
        };

        /** Sends data over the open connection.
         *
         * @param {String} data
         * @return {Boolean} true only when in the "open" state
         */
        prototype.send = function (data) {
            var self = this;

            if (self.state === "open") {
                // Workaround for MobileSafari bug (see https://gist.github.com/2052006)
                Pusher.Util.defer(function () {
                    if (self.socket) {
                        self.socket.send(data);
                    }
                });
                return true;
            } else {
                return false;
            }
        };

        /** Sends a ping if the connection is open and transport supports it. */
        prototype.ping = function () {
            if (this.state === "open" && this.supportsPing()) {
                this.socket.ping();
            }
        };

        /** @private */
        prototype.onOpen = function () {
            if (this.hooks.beforeOpen) {
                this.hooks.beforeOpen(
                    this.socket, this.hooks.urls.getPath(this.key, this.options)
                );
            }
            this.changeState("open");
            this.socket.onopen = undefined;
        };

        /** @private */
        prototype.onError = function (error) {
            this.emit("error", {type: 'WebSocketError', error: error});
            this.timeline.error(this.buildTimelineMessage({error: error.toString()}));
        };

        /** @private */
        prototype.onClose = function (closeEvent) {
            if (closeEvent) {
                this.changeState("closed", {
                    code: closeEvent.code,
                    reason: closeEvent.reason,
                    wasClean: closeEvent.wasClean
                });
            } else {
                this.changeState("closed");
            }
            this.unbindListeners();
            this.socket = undefined;
        };

        /** @private */
        prototype.onMessage = function (message) {
            this.emit("message", message);
        };

        /** @private */
        prototype.onActivity = function () {
            this.emit("activity");
        };

        /** @private */
        prototype.bindListeners = function () {
            var self = this;

            self.socket.onopen = function () {
                self.onOpen();
            };
            self.socket.onerror = function (error) {
                self.onError(error);
            };
            self.socket.onclose = function (closeEvent) {
                self.onClose(closeEvent);
            };
            self.socket.onmessage = function (message) {
                self.onMessage(message);
            };

            if (self.supportsPing()) {
                self.socket.onactivity = function () {
                    self.onActivity();
                };
            }
        };

        /** @private */
        prototype.unbindListeners = function () {
            if (this.socket) {
                this.socket.onopen = undefined;
                this.socket.onerror = undefined;
                this.socket.onclose = undefined;
                this.socket.onmessage = undefined;
                if (this.supportsPing()) {
                    this.socket.onactivity = undefined;
                }
            }
        };

        /** @private */
        prototype.changeState = function (state, params) {
            this.state = state;
            this.timeline.info(this.buildTimelineMessage({
                state: state,
                params: params
            }));
            this.emit(state, params);
        };

        /** @private */
        prototype.buildTimelineMessage = function (message) {
            return Pusher.Util.extend({cid: this.id}, message);
        };

        Pusher.TransportConnection = TransportConnection;
    }).call(this);

    (function () {
        /** Provides interface for transport connection instantiation.
         *
         * Takes transport-specific hooks as the only argument, which allow checking
         * for transport support and creating its connections.
         *
         * Supported hooks:
         * - file - the name of the file to be fetched during initialization
         * - urls - URL scheme to be used by transport
         * - handlesActivityCheck - true when the transport handles activity checks
         * - supportsPing - true when the transport has a ping/activity API
         * - isSupported - tells whether the transport is supported in the environment
         * - getSocket - creates a WebSocket-compatible transport socket
         *
         * See transports.js for specific implementations.
         *
         * @param {Object} hooks object containing all needed transport hooks
         */
        function Transport(hooks) {
            this.hooks = hooks;
        }

        var prototype = Transport.prototype;

        /** Returns whether the transport is supported in the environment.
         *
         * @param {Object} environment the environment details (encryption, settings)
         * @returns {Boolean} true when the transport is supported
         */
        prototype.isSupported = function (environment) {
            return this.hooks.isSupported(environment);
        };

        /** Creates a transport connection.
         *
         * @param {String} name
         * @param {Number} priority
         * @param {String} key the application key
         * @param {Object} options
         * @returns {TransportConnection}
         */
        prototype.createConnection = function (name, priority, key, options) {
            return new Pusher.TransportConnection(
                this.hooks, name, priority, key, options
            );
        };

        Pusher.Transport = Transport;
    }).call(this);

    (function () {
        /** WebSocket transport.
         *
         * Uses native WebSocket implementation, including MozWebSocket supported by
         * earlier Firefox versions.
         */
        Pusher.WSTransport = new Pusher.Transport({
            urls: Pusher.URLSchemes.ws,
            handlesActivityChecks: false,
            supportsPing: false,

            isInitialized: function () {
                return Boolean(window.WebSocket || window.MozWebSocket);
            },
            isSupported: function () {
                return Boolean(window.WebSocket || window.MozWebSocket);
            },
            getSocket: function (url) {
                var Constructor = window.WebSocket || window.MozWebSocket;
                return new Constructor(url);
            }
        });

        /** SockJS transport. */
        Pusher.SockJSTransport = new Pusher.Transport({
            file: "sockjs",
            urls: Pusher.URLSchemes.sockjs,
            handlesActivityChecks: true,
            supportsPing: false,

            isSupported: function () {
                return true;
            },
            isInitialized: function () {
                return window.SockJS !== undefined;
            },
            getSocket: function (url, options) {
                return new SockJS(url, null, {
                    js_path: Pusher.Dependencies.getPath("sockjs", {
                        encrypted: options.encrypted
                    }),
                    ignore_null_origin: options.ignoreNullOrigin
                });
            },
            beforeOpen: function (socket, path) {
                socket.send(JSON.stringify({
                    path: path
                }));
            }
        });

        var httpConfiguration = {
            urls: Pusher.URLSchemes.http,
            handlesActivityChecks: false,
            supportsPing: true,
            isInitialized: function () {
                return Boolean(Pusher.HTTP.Socket);
            }
        };

        var streamingConfiguration = Pusher.Util.extend(
            {
                getSocket: function (url) {
                    return Pusher.HTTP.getStreamingSocket(url);
                }
            },
            httpConfiguration
        );
        var pollingConfiguration = Pusher.Util.extend(
            {
                getSocket: function (url) {
                    return Pusher.HTTP.getPollingSocket(url);
                }
            },
            httpConfiguration
        );

        var xhrConfiguration = {
            file: "xhr",
            isSupported: Pusher.Util.isXHRSupported
        };
        var xdrConfiguration = {
            file: "xdr",
            isSupported: function (environment) {
                return Pusher.Util.isXDRSupported(environment.encrypted);
            }
        };

        /** HTTP streaming transport using CORS-enabled XMLHttpRequest. */
        Pusher.XHRStreamingTransport = new Pusher.Transport(
            Pusher.Util.extend({}, streamingConfiguration, xhrConfiguration)
        );
        /** HTTP streaming transport using XDomainRequest (IE 8,9). */
        Pusher.XDRStreamingTransport = new Pusher.Transport(
            Pusher.Util.extend({}, streamingConfiguration, xdrConfiguration)
        );
        /** HTTP long-polling transport using CORS-enabled XMLHttpRequest. */
        Pusher.XHRPollingTransport = new Pusher.Transport(
            Pusher.Util.extend({}, pollingConfiguration, xhrConfiguration)
        );
        /** HTTP long-polling transport using XDomainRequest (IE 8,9). */
        Pusher.XDRPollingTransport = new Pusher.Transport(
            Pusher.Util.extend({}, pollingConfiguration, xdrConfiguration)
        );
    }).call(this);

    ;(function () {
        /** Creates transport connections monitored by a transport manager.
         *
         * When a transport is closed, it might mean the environment does not support
         * it. It's possible that messages get stuck in an intermediate buffer or
         * proxies terminate inactive connections. To combat these problems,
         * assistants monitor the connection lifetime, report unclean exits and
         * adjust ping timeouts to keep the connection active. The decision to disable
         * a transport is the manager's responsibility.
         *
         * @param {TransportManager} manager
         * @param {TransportConnection} transport
         * @param {Object} options
         */
        function AssistantToTheTransportManager(manager, transport, options) {
            this.manager = manager;
            this.transport = transport;
            this.minPingDelay = options.minPingDelay;
            this.maxPingDelay = options.maxPingDelay;
            this.pingDelay = undefined;
        }

        var prototype = AssistantToTheTransportManager.prototype;

        /** Creates a transport connection.
         *
         * This function has the same API as Transport#createConnection.
         *
         * @param {String} name
         * @param {Number} priority
         * @param {String} key the application key
         * @param {Object} options
         * @returns {TransportConnection}
         */
        prototype.createConnection = function (name, priority, key, options) {
            var self = this;

            options = Pusher.Util.extend({}, options, {
                activityTimeout: self.pingDelay
            });
            var connection = self.transport.createConnection(
                name, priority, key, options
            );

            var openTimestamp = null;

            var onOpen = function () {
                connection.unbind("open", onOpen);
                connection.bind("closed", onClosed);
                openTimestamp = Pusher.Util.now();
            };
            var onClosed = function (closeEvent) {
                connection.unbind("closed", onClosed);

                if (closeEvent.code === 1002 || closeEvent.code === 1003) {
                    // we don't want to use transports not obeying the protocol
                    self.manager.reportDeath();
                } else if (!closeEvent.wasClean && openTimestamp) {
                    // report deaths only for short-living transport
                    var lifespan = Pusher.Util.now() - openTimestamp;
                    if (lifespan < 2 * self.maxPingDelay) {
                        self.manager.reportDeath();
                        self.pingDelay = Math.max(lifespan / 2, self.minPingDelay);
                    }
                }
            };

            connection.bind("open", onOpen);
            return connection;
        };

        /** Returns whether the transport is supported in the environment.
         *
         * This function has the same API as Transport#isSupported. Might return false
         * when the manager decides to kill the transport.
         *
         * @param {Object} environment the environment details (encryption, settings)
         * @returns {Boolean} true when the transport is supported
         */
        prototype.isSupported = function (environment) {
            return this.manager.isAlive() && this.transport.isSupported(environment);
        };

        Pusher.AssistantToTheTransportManager = AssistantToTheTransportManager;
    }).call(this);

    ;(function () {
        /** Keeps track of the number of lives left for a transport.
         *
         * In the beginning of a session, transports may be assigned a number of
         * lives. When an AssistantToTheTransportManager instance reports a transport
         * connection closed uncleanly, the transport loses a life. When the number
         * of lives drops to zero, the transport gets disabled by its manager.
         *
         * @param {Object} options
         */
        function TransportManager(options) {
            this.options = options || {};
            this.livesLeft = this.options.lives || Infinity;
        }

        var prototype = TransportManager.prototype;

        /** Creates a assistant for the transport.
         *
         * @param {Transport} transport
         * @returns {AssistantToTheTransportManager}
         */
        prototype.getAssistant = function (transport) {
            return new Pusher.AssistantToTheTransportManager(this, transport, {
                minPingDelay: this.options.minPingDelay,
                maxPingDelay: this.options.maxPingDelay
            });
        };

        /** Returns whether the transport has any lives left.
         *
         * @returns {Boolean}
         */
        prototype.isAlive = function () {
            return this.livesLeft > 0;
        };

        /** Takes one life from the transport. */
        prototype.reportDeath = function () {
            this.livesLeft -= 1;
        };

        Pusher.TransportManager = TransportManager;
    }).call(this);

    ;(function () {
        var StrategyBuilder = {
            /** Transforms a JSON scheme to a strategy tree.
             *
             * @param {Array} scheme JSON strategy scheme
             * @param {Object} options a hash of symbols to be included in the scheme
             * @returns {Strategy} strategy tree that's represented by the scheme
             */
            build: function (scheme, options) {
                var context = Pusher.Util.extend({}, globalContext, options);
                return evaluate(scheme, context)[1].strategy;
            }
        };

        var transports = {
            ws: Pusher.WSTransport,
            sockjs: Pusher.SockJSTransport,
            xhr_streaming: Pusher.XHRStreamingTransport,
            xdr_streaming: Pusher.XDRStreamingTransport,
            xhr_polling: Pusher.XHRPollingTransport,
            xdr_polling: Pusher.XDRPollingTransport
        };

        var UnsupportedStrategy = {
            isSupported: function () {
                return false;
            },
            connect: function (_, callback) {
                var deferred = Pusher.Util.defer(function () {
                    callback(new Pusher.Errors.UnsupportedStrategy());
                });
                return {
                    abort: function () {
                        deferred.ensureAborted();
                    },
                    forceMinPriority: function () {
                    }
                };
            }
        };

        // DSL bindings

        function returnWithOriginalContext(f) {
            return function (context) {
                return [f.apply(this, arguments), context];
            };
        }

        var globalContext = {
            extend: function (context, first, second) {
                return [Pusher.Util.extend({}, first, second), context];
            },

            def: function (context, name, value) {
                if (context[name] !== undefined) {
                    throw "Redefining symbol " + name;
                }
                context[name] = value;
                return [undefined, context];
            },

            def_transport: function (context, name, type, priority, options, manager) {
                var transportClass = transports[type];
                if (!transportClass) {
                    throw new Pusher.Errors.UnsupportedTransport(type);
                }

                var enabled =
                    (!context.enabledTransports ||
                        Pusher.Util.arrayIndexOf(context.enabledTransports, name) !== -1) &&
                    (!context.disabledTransports ||
                        Pusher.Util.arrayIndexOf(context.disabledTransports, name) === -1);

                var transport;
                if (enabled) {
                    transport = new Pusher.TransportStrategy(
                        name,
                        priority,
                        manager ? manager.getAssistant(transportClass) : transportClass,
                        Pusher.Util.extend({
                            key: context.key,
                            encrypted: context.encrypted,
                            timeline: context.timeline,
                            ignoreNullOrigin: context.ignoreNullOrigin
                        }, options)
                    );
                } else {
                    transport = UnsupportedStrategy;
                }

                var newContext = context.def(context, name, transport)[1];
                newContext.transports = context.transports || {};
                newContext.transports[name] = transport;
                return [undefined, newContext];
            },

            transport_manager: returnWithOriginalContext(function (_, options) {
                return new Pusher.TransportManager(options);
            }),

            sequential: returnWithOriginalContext(function (_, options) {
                var strategies = Array.prototype.slice.call(arguments, 2);
                return new Pusher.SequentialStrategy(strategies, options);
            }),

            cached: returnWithOriginalContext(function (context, ttl, strategy) {
                return new Pusher.CachedStrategy(strategy, context.transports, {
                    ttl: ttl,
                    timeline: context.timeline,
                    encrypted: context.encrypted
                });
            }),

            first_connected: returnWithOriginalContext(function (_, strategy) {
                return new Pusher.FirstConnectedStrategy(strategy);
            }),

            best_connected_ever: returnWithOriginalContext(function () {
                var strategies = Array.prototype.slice.call(arguments, 1);
                return new Pusher.BestConnectedEverStrategy(strategies);
            }),

            delayed: returnWithOriginalContext(function (_, delay, strategy) {
                return new Pusher.DelayedStrategy(strategy, {delay: delay});
            }),

            "if": returnWithOriginalContext(function (_, test, trueBranch, falseBranch) {
                return new Pusher.IfStrategy(test, trueBranch, falseBranch);
            }),

            is_supported: returnWithOriginalContext(function (_, strategy) {
                return function () {
                    return strategy.isSupported();
                };
            })
        };

        // DSL interpreter

        function isSymbol(expression) {
            return (typeof expression === "string") && expression.charAt(0) === ":";
        }

        function getSymbolValue(expression, context) {
            return context[expression.slice(1)];
        }

        function evaluateListOfExpressions(expressions, context) {
            if (expressions.length === 0) {
                return [[], context];
            }
            var head = evaluate(expressions[0], context);
            var tail = evaluateListOfExpressions(expressions.slice(1), head[1]);
            return [[head[0]].concat(tail[0]), tail[1]];
        }

        function evaluateString(expression, context) {
            if (!isSymbol(expression)) {
                return [expression, context];
            }
            var value = getSymbolValue(expression, context);
            if (value === undefined) {
                throw "Undefined symbol " + expression;
            }
            return [value, context];
        }

        function evaluateArray(expression, context) {
            if (isSymbol(expression[0])) {
                var f = getSymbolValue(expression[0], context);
                if (expression.length > 1) {
                    if (typeof f !== "function") {
                        throw "Calling non-function " + expression[0];
                    }
                    var args = [Pusher.Util.extend({}, context)].concat(
                        Pusher.Util.map(expression.slice(1), function (arg) {
                            return evaluate(arg, Pusher.Util.extend({}, context))[0];
                        })
                    );
                    return f.apply(this, args);
                } else {
                    return [f, context];
                }
            } else {
                return evaluateListOfExpressions(expression, context);
            }
        }

        function evaluate(expression, context) {
            var expressionType = typeof expression;
            if (typeof expression === "string") {
                return evaluateString(expression, context);
            } else if (typeof expression === "object") {
                if (expression instanceof Array && expression.length > 0) {
                    return evaluateArray(expression, context);
                }
            }
            return [expression, context];
        }

        Pusher.StrategyBuilder = StrategyBuilder;
    }).call(this);

    ;(function () {
        /**
         * Provides functions for handling Pusher protocol-specific messages.
         */
        var Protocol = {};

        /**
         * Decodes a message in a Pusher format.
         *
         * Throws errors when messages are not parse'able.
         *
         * @param  {Object} message
         * @return {Object}
         */
        Protocol.decodeMessage = function (message) {
            try {
                var params = JSON.parse(message.data);
                if (typeof params.data === 'string') {
                    try {
                        params.data = JSON.parse(params.data);
                    } catch (e) {
                        if (!(e instanceof SyntaxError)) {
                            // TODO looks like unreachable code
                            // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse
                            throw e;
                        }
                    }
                }
                return params;
            } catch (e) {
                throw {type: 'MessageParseError', error: e, data: message.data};
            }
        };

        /**
         * Encodes a message to be sent.
         *
         * @param  {Object} message
         * @return {String}
         */
        Protocol.encodeMessage = function (message) {
            return JSON.stringify(message);
        };

        /** Processes a handshake message and returns appropriate actions.
         *
         * Returns an object with an 'action' and other action-specific properties.
         *
         * There are three outcomes when calling this function. First is a successful
         * connection attempt, when pusher:connection_established is received, which
         * results in a 'connected' action with an 'id' property. When passed a
         * pusher:error event, it returns a result with action appropriate to the
         * close code and an error. Otherwise, it raises an exception.
         *
         * @param {String} message
         * @result Object
         */
        Protocol.processHandshake = function (message) {
            message = this.decodeMessage(message);

            if (message.event === "pusher:connection_established") {
                if (!message.data.activity_timeout) {
                    throw "No activity timeout specified in handshake";
                }
                return {
                    action: "connected",
                    id: message.data.socket_id,
                    activityTimeout: message.data.activity_timeout * 1000
                };
            } else if (message.event === "pusher:error") {
                // From protocol 6 close codes are sent only once, so this only
                // happens when connection does not support close codes
                return {
                    action: this.getCloseAction(message.data),
                    error: this.getCloseError(message.data)
                };
            } else {
                throw "Invalid handshake";
            }
        };

        /**
         * Dispatches the close event and returns an appropriate action name.
         *
         * See:
         * 1. https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/CloseEvent
         * 2. http://pusher.com/docs/pusher_protocol
         *
         * @param  {CloseEvent} closeEvent
         * @return {String} close action name
         */
        Protocol.getCloseAction = function (closeEvent) {
            if (closeEvent.code < 4000) {
                // ignore 1000 CLOSE_NORMAL, 1001 CLOSE_GOING_AWAY,
                //        1005 CLOSE_NO_STATUS, 1006 CLOSE_ABNORMAL
                // ignore 1007...3999
                // handle 1002 CLOSE_PROTOCOL_ERROR, 1003 CLOSE_UNSUPPORTED,
                //        1004 CLOSE_TOO_LARGE
                if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
                    return "backoff";
                } else {
                    return null;
                }
            } else if (closeEvent.code === 4000) {
                return "ssl_only";
            } else if (closeEvent.code < 4100) {
                return "refused";
            } else if (closeEvent.code < 4200) {
                return "backoff";
            } else if (closeEvent.code < 4300) {
                return "retry";
            } else {
                // unknown error
                return "refused";
            }
        };

        /**
         * Returns an error or null basing on the close event.
         *
         * Null is returned when connection was closed cleanly. Otherwise, an object
         * with error details is returned.
         *
         * @param  {CloseEvent} closeEvent
         * @return {Object} error object
         */
        Protocol.getCloseError = function (closeEvent) {
            if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {
                return {
                    type: 'PusherError',
                    data: {
                        code: closeEvent.code,
                        message: closeEvent.reason || closeEvent.message
                    }
                };
            } else {
                return null;
            }
        };

        Pusher.Protocol = Protocol;
    }).call(this);

    ;(function () {
        /**
         * Provides Pusher protocol interface for transports.
         *
         * Emits following events:
         * - message - on received messages
         * - ping - on ping requests
         * - pong - on pong responses
         * - error - when the transport emits an error
         * - closed - after closing the transport
         *
         * It also emits more events when connection closes with a code.
         * See Protocol.getCloseAction to get more details.
         *
         * @param {Number} id
         * @param {AbstractTransport} transport
         */
        function Connection(id, transport) {
            Pusher.EventsDispatcher.call(this);

            this.id = id;
            this.transport = transport;
            this.activityTimeout = transport.activityTimeout;
            this.bindListeners();
        }

        var prototype = Connection.prototype;
        Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

        /** Returns whether used transport handles activity checks by itself
         *
         * @returns {Boolean} true if activity checks are handled by the transport
         */
        prototype.handlesActivityChecks = function () {
            return this.transport.handlesActivityChecks();
        };

        /** Sends raw data.
         *
         * @param {String} data
         */
        prototype.send = function (data) {
            return this.transport.send(data);
        };

        /** Sends an event.
         *
         * @param {String} name
         * @param {String} data
         * @param {String} [channel]
         * @returns {Boolean} whether message was sent or not
         */
        prototype.send_event = function (name, data, channel) {
            var message = {event: name, data: data};
            if (channel) {
                message.channel = channel;
            }
            Pusher.debug('Event sent', message);
            return this.send(Pusher.Protocol.encodeMessage(message));
        };

        /** Sends a ping message to the server.
         *
         * Basing on the underlying transport, it might send either transport's
         * protocol-specific ping or pusher:ping event.
         */
        prototype.ping = function () {
            if (this.transport.supportsPing()) {
                this.transport.ping();
            } else {
                this.send_event('pusher:ping', {});
            }
        };

        /** Closes the connection. */
        prototype.close = function () {
            this.transport.close();
        };

        /** @private */
        prototype.bindListeners = function () {
            var self = this;

            var listeners = {
                message: function (m) {
                    var message;
                    try {
                        message = Pusher.Protocol.decodeMessage(m);
                    } catch (e) {
                        self.emit('error', {
                            type: 'MessageParseError',
                            error: e,
                            data: m.data
                        });
                    }

                    if (message !== undefined) {
                        Pusher.debug('Event recd', message);

                        switch (message.event) {
                            case 'pusher:error':
                                self.emit('error', {type: 'PusherError', data: message.data});
                                break;
                            case 'pusher:ping':
                                self.emit("ping");
                                break;
                            case 'pusher:pong':
                                self.emit("pong");
                                break;
                        }
                        self.emit('message', message);
                    }
                },
                activity: function () {
                    self.emit("activity");
                },
                error: function (error) {
                    self.emit("error", {type: "WebSocketError", error: error});
                },
                closed: function (closeEvent) {
                    unbindListeners();

                    if (closeEvent && closeEvent.code) {
                        self.handleCloseEvent(closeEvent);
                    }

                    self.transport = null;
                    self.emit("closed");
                }
            };

            var unbindListeners = function () {
                Pusher.Util.objectApply(listeners, function (listener, event) {
                    self.transport.unbind(event, listener);
                });
            };

            Pusher.Util.objectApply(listeners, function (listener, event) {
                self.transport.bind(event, listener);
            });
        };

        /** @private */
        prototype.handleCloseEvent = function (closeEvent) {
            var action = Pusher.Protocol.getCloseAction(closeEvent);
            var error = Pusher.Protocol.getCloseError(closeEvent);
            if (error) {
                this.emit('error', error);
            }
            if (action) {
                this.emit(action);
            }
        };

        Pusher.Connection = Connection;
    }).call(this);

    ;(function () {
        /**
         * Handles Pusher protocol handshakes for transports.
         *
         * Calls back with a result object after handshake is completed. Results
         * always have two fields:
         * - action - string describing action to be taken after the handshake
         * - transport - the transport object passed to the constructor
         *
         * Different actions can set different additional properties on the result.
         * In the case of 'connected' action, there will be a 'connection' property
         * containing a Connection object for the transport. Other actions should
         * carry an 'error' property.
         *
         * @param {AbstractTransport} transport
         * @param {Function} callback
         */
        function Handshake(transport, callback) {
            this.transport = transport;
            this.callback = callback;
            this.bindListeners();
        }

        var prototype = Handshake.prototype;

        prototype.close = function () {
            this.unbindListeners();
            this.transport.close();
        };

        /** @private */
        prototype.bindListeners = function () {
            var self = this;

            self.onMessage = function (m) {
                self.unbindListeners();

                try {
                    var result = Pusher.Protocol.processHandshake(m);
                    if (result.action === "connected") {
                        self.finish("connected", {
                            connection: new Pusher.Connection(result.id, self.transport),
                            activityTimeout: result.activityTimeout
                        });
                    } else {
                        self.finish(result.action, {error: result.error});
                        self.transport.close();
                    }
                } catch (e) {
                    self.finish("error", {error: e});
                    self.transport.close();
                }
            };

            self.onClosed = function (closeEvent) {
                self.unbindListeners();

                var action = Pusher.Protocol.getCloseAction(closeEvent) || "backoff";
                var error = Pusher.Protocol.getCloseError(closeEvent);
                self.finish(action, {error: error});
            };

            self.transport.bind("message", self.onMessage);
            self.transport.bind("closed", self.onClosed);
        };

        /** @private */
        prototype.unbindListeners = function () {
            this.transport.unbind("message", this.onMessage);
            this.transport.unbind("closed", this.onClosed);
        };

        /** @private */
        prototype.finish = function (action, params) {
            this.callback(
                Pusher.Util.extend({transport: this.transport, action: action}, params)
            );
        };

        Pusher.Handshake = Handshake;
    }).call(this);

    ;(function () {
        /** Manages connection to Pusher.
         *
         * Uses a strategy (currently only default), timers and network availability
         * info to establish a connection and export its state. In case of failures,
         * manages reconnection attempts.
         *
         * Exports state changes as following events:
         * - "state_change", { previous: p, current: state }
         * - state
         *
         * States:
         * - initialized - initial state, never transitioned to
         * - connecting - connection is being established
         * - connected - connection has been fully established
         * - disconnected - on requested disconnection
         * - unavailable - after connection timeout or when there's no network
         * - failed - when the connection strategy is not supported
         *
         * Options:
         * - unavailableTimeout - time to transition to unavailable state
         * - activityTimeout - time after which ping message should be sent
         * - pongTimeout - time for Pusher to respond with pong before reconnecting
         *
         * @param {String} key application key
         * @param {Object} options
         */
        function ConnectionManager(key, options) {
            Pusher.EventsDispatcher.call(this);

            this.key = key;
            this.options = options || {};
            this.state = "initialized";
            this.connection = null;
            this.encrypted = !!options.encrypted;
            this.timeline = this.options.timeline;

            this.connectionCallbacks = this.buildConnectionCallbacks();
            this.errorCallbacks = this.buildErrorCallbacks();
            this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);

            var self = this;

            Pusher.Network.bind("online", function () {
                self.timeline.info({netinfo: "online"});
                if (self.state === "connecting" || self.state === "unavailable") {
                    self.retryIn(0);
                }
            });
            Pusher.Network.bind("offline", function () {
                self.timeline.info({netinfo: "offline"});
                if (self.connection) {
                    self.sendActivityCheck();
                }
            });

            this.updateStrategy();
        }

        var prototype = ConnectionManager.prototype;

        Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

        /** Establishes a connection to Pusher.
         *
         * Does nothing when connection is already established. See top-level doc
         * to find events emitted on connection attempts.
         */
        prototype.connect = function () {
            if (this.connection || this.runner) {
                return;
            }
            if (!this.strategy.isSupported()) {
                this.updateState("failed");
                return;
            }
            this.updateState("connecting");
            this.startConnecting();
            this.setUnavailableTimer();
        };

        /** Sends raw data.
         *
         * @param {String} data
         */
        prototype.send = function (data) {
            if (this.connection) {
                return this.connection.send(data);
            } else {
                return false;
            }
        };

        /** Sends an event.
         *
         * @param {String} name
         * @param {String} data
         * @param {String} [channel]
         * @returns {Boolean} whether message was sent or not
         */
        prototype.send_event = function (name, data, channel) {
            if (this.connection) {
                return this.connection.send_event(name, data, channel);
            } else {
                return false;
            }
        };

        /** Closes the connection. */
        prototype.disconnect = function () {
            this.disconnectInternally();
            this.updateState("disconnected");
        };

        prototype.isEncrypted = function () {
            return this.encrypted;
        };

        /** @private */
        prototype.startConnecting = function () {
            var self = this;
            var callback = function (error, handshake) {
                if (error) {
                    self.runner = self.strategy.connect(0, callback);
                } else {
                    if (handshake.action === "error") {
                        self.emit("error", {type: "HandshakeError", error: handshake.error});
                        self.timeline.error({handshakeError: handshake.error});
                    } else {
                        self.abortConnecting(); // we don't support switching connections yet
                        self.handshakeCallbacks[handshake.action](handshake);
                    }
                }
            };
            self.runner = self.strategy.connect(0, callback);
        };

        /** @private */
        prototype.abortConnecting = function () {
            if (this.runner) {
                this.runner.abort();
                this.runner = null;
            }
        };

        /** @private */
        prototype.disconnectInternally = function () {
            this.abortConnecting();
            this.clearRetryTimer();
            this.clearUnavailableTimer();
            if (this.connection) {
                var connection = this.abandonConnection();
                connection.close();
            }
        };

        /** @private */
        prototype.updateStrategy = function () {
            this.strategy = this.options.getStrategy({
                key: this.key,
                timeline: this.timeline,
                encrypted: this.encrypted
            });
        };

        /** @private */
        prototype.retryIn = function (delay) {
            var self = this;
            self.timeline.info({action: "retry", delay: delay});
            if (delay > 0) {
                self.emit("connecting_in", Math.round(delay / 1000));
            }
            self.retryTimer = new Pusher.Timer(delay || 0, function () {
                self.disconnectInternally();
                self.connect();
            });
        };

        /** @private */
        prototype.clearRetryTimer = function () {
            if (this.retryTimer) {
                this.retryTimer.ensureAborted();
                this.retryTimer = null;
            }
        };

        /** @private */
        prototype.setUnavailableTimer = function () {
            var self = this;
            self.unavailableTimer = new Pusher.Timer(
                self.options.unavailableTimeout,
                function () {
                    self.updateState("unavailable");
                }
            );
        };

        /** @private */
        prototype.clearUnavailableTimer = function () {
            if (this.unavailableTimer) {
                this.unavailableTimer.ensureAborted();
            }
        };

        /** @private */
        prototype.sendActivityCheck = function () {
            var self = this;
            self.stopActivityCheck();
            self.connection.ping();
            // wait for pong response
            self.activityTimer = new Pusher.Timer(
                self.options.pongTimeout,
                function () {
                    self.timeline.error({pong_timed_out: self.options.pongTimeout});
                    self.retryIn(0);
                }
            );
        };

        /** @private */
        prototype.resetActivityCheck = function () {
            var self = this;
            self.stopActivityCheck();
            // send ping after inactivity
            if (!self.connection.handlesActivityChecks()) {
                self.activityTimer = new Pusher.Timer(self.activityTimeout, function () {
                    self.sendActivityCheck();
                });
            }
        };

        /** @private */
        prototype.stopActivityCheck = function () {
            if (this.activityTimer) {
                this.activityTimer.ensureAborted();
            }
        };

        /** @private */
        prototype.buildConnectionCallbacks = function () {
            var self = this;
            return {
                message: function (message) {
                    // includes pong messages from server
                    self.resetActivityCheck();
                    self.emit('message', message);
                },
                ping: function () {
                    self.send_event('pusher:pong', {});
                },
                activity: function () {
                    self.resetActivityCheck();
                },
                error: function (error) {
                    // just emit error to user - socket will already be closed by browser
                    self.emit("error", {type: "WebSocketError", error: error});
                },
                closed: function () {
                    self.abandonConnection();
                    if (self.shouldRetry()) {
                        self.retryIn(1000);
                    }
                }
            };
        };

        /** @private */
        prototype.buildHandshakeCallbacks = function (errorCallbacks) {
            var self = this;
            return Pusher.Util.extend({}, errorCallbacks, {
                connected: function (handshake) {
                    self.activityTimeout = Math.min(
                        self.options.activityTimeout,
                        handshake.activityTimeout,
                        handshake.connection.activityTimeout || Infinity
                    );
                    self.clearUnavailableTimer();
                    self.setConnection(handshake.connection);
                    self.socket_id = self.connection.id;
                    self.updateState("connected", {socket_id: self.socket_id});
                }
            });
        };

        /** @private */
        prototype.buildErrorCallbacks = function () {
            var self = this;

            function withErrorEmitted(callback) {
                return function (result) {
                    if (result.error) {
                        self.emit("error", {type: "WebSocketError", error: result.error});
                    }
                    callback(result);
                };
            }

            return {
                ssl_only: withErrorEmitted(function () {
                    self.encrypted = true;
                    self.updateStrategy();
                    self.retryIn(0);
                }),
                refused: withErrorEmitted(function () {
                    self.disconnect();
                }),
                backoff: withErrorEmitted(function () {
                    self.retryIn(1000);
                }),
                retry: withErrorEmitted(function () {
                    self.retryIn(0);
                })
            };
        };

        /** @private */
        prototype.setConnection = function (connection) {
            this.connection = connection;
            for (var event in this.connectionCallbacks) {
                this.connection.bind(event, this.connectionCallbacks[event]);
            }
            this.resetActivityCheck();
        };

        /** @private */
        prototype.abandonConnection = function () {
            if (!this.connection) {
                return;
            }
            this.stopActivityCheck();
            for (var event in this.connectionCallbacks) {
                this.connection.unbind(event, this.connectionCallbacks[event]);
            }
            var connection = this.connection;
            this.connection = null;
            return connection;
        };

        /** @private */
        prototype.updateState = function (newState, data) {
            var previousState = this.state;
            this.state = newState;
            if (previousState !== newState) {
                Pusher.debug('State changed', previousState + ' -> ' + newState);
                this.timeline.info({state: newState, params: data});
                this.emit('state_change', {previous: previousState, current: newState});
                this.emit(newState, data);
            }
        };

        /** @private */
        prototype.shouldRetry = function () {
            return this.state === "connecting" || this.state === "connected";
        };

        Pusher.ConnectionManager = ConnectionManager;
    }).call(this);

    ;(function () {
        /** Really basic interface providing network availability info.
         *
         * Emits:
         * - online - when browser goes online
         * - offline - when browser goes offline
         */
        function NetInfo() {
            Pusher.EventsDispatcher.call(this);

            var self = this;
            // This is okay, as IE doesn't support this stuff anyway.
            if (window.addEventListener !== undefined) {
                window.addEventListener("online", function () {
                    self.emit('online');
                }, false);
                window.addEventListener("offline", function () {
                    self.emit('offline');
                }, false);
            }
        }

        Pusher.Util.extend(NetInfo.prototype, Pusher.EventsDispatcher.prototype);

        var prototype = NetInfo.prototype;

        /** Returns whether browser is online or not
         *
         * Offline means definitely offline (no connection to router).
         * Inverse does NOT mean definitely online (only currently supported in Safari
         * and even there only means the device has a connection to the router).
         *
         * @return {Boolean}
         */
        prototype.isOnline = function () {
            if (window.navigator.onLine === undefined) {
                return true;
            } else {
                return window.navigator.onLine;
            }
        };

        Pusher.NetInfo = NetInfo;
        Pusher.Network = new NetInfo();
    }).call(this);

    ;(function () {
        /** Represents a collection of members of a presence channel. */
        function Members() {
            this.reset();
        }

        var prototype = Members.prototype;

        /** Returns member's info for given id.
         *
         * Resulting object containts two fields - id and info.
         *
         * @param {Number} id
         * @return {Object} member's info or null
         */
        prototype.get = function (id) {
            if (Object.prototype.hasOwnProperty.call(this.members, id)) {
                return {
                    id: id,
                    info: this.members[id]
                };
            } else {
                return null;
            }
        };

        /** Calls back for each member in unspecified order.
         *
         * @param  {Function} callback
         */
        prototype.each = function (callback) {
            var self = this;
            Pusher.Util.objectApply(self.members, function (member, id) {
                callback(self.get(id));
            });
        };

        /** Updates the id for connected member. For internal use only. */
        prototype.setMyID = function (id) {
            this.myID = id;
        };

        /** Handles subscription data. For internal use only. */
        prototype.onSubscription = function (subscriptionData) {
            this.members = subscriptionData.presence.hash;
            this.count = subscriptionData.presence.count;
            this.me = this.get(this.myID);
        };

        /** Adds a new member to the collection. For internal use only. */
        prototype.addMember = function (memberData) {
            if (this.get(memberData.user_id) === null) {
                this.count++;
            }
            this.members[memberData.user_id] = memberData.user_info;
            return this.get(memberData.user_id);
        };

        /** Adds a member from the collection. For internal use only. */
        prototype.removeMember = function (memberData) {
            var member = this.get(memberData.user_id);
            if (member) {
                delete this.members[memberData.user_id];
                this.count--;
            }
            return member;
        };

        /** Resets the collection to the initial state. For internal use only. */
        prototype.reset = function () {
            this.members = {};
            this.count = 0;
            this.myID = null;
            this.me = null;
        };

        Pusher.Members = Members;
    }).call(this);

    ;(function () {
        /** Provides base public channel interface with an event emitter.
         *
         * Emits:
         * - pusher:subscription_succeeded - after subscribing successfully
         * - other non-internal events
         *
         * @param {String} name
         * @param {Pusher} pusher
         */
        function Channel(name, pusher) {
            Pusher.EventsDispatcher.call(this, function (event, data) {
                Pusher.debug('No callbacks on ' + name + ' for ' + event);
            });

            this.name = name;
            this.pusher = pusher;
            this.subscribed = false;
        }

        var prototype = Channel.prototype;
        Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

        /** Skips authorization, since public channels don't require it.
         *
         * @param {Function} callback
         */
        prototype.authorize = function (socketId, callback) {
            return callback(false, {});
        };

        /** Triggers an event */
        prototype.trigger = function (event, data) {
            if (event.indexOf("client-") !== 0) {
                throw new Pusher.Errors.BadEventName(
                    "Event '" + event + "' does not start with 'client-'"
                );
            }
            return this.pusher.send_event(event, data, this.name);
        };

        /** Signals disconnection to the channel. For internal use only. */
        prototype.disconnect = function () {
            this.subscribed = false;
        };

        /** Handles an event. For internal use only.
         *
         * @param {String} event
         * @param {*} data
         */
        prototype.handleEvent = function (event, data) {
            if (event.indexOf("pusher_internal:") === 0) {
                if (event === "pusher_internal:subscription_succeeded") {
                    this.subscribed = true;
                    this.emit("pusher:subscription_succeeded", data);
                }
            } else {
                this.emit(event, data);
            }
        };

        /** Sends a subscription request. For internal use only. */
        prototype.subscribe = function () {
            var self = this;

            self.authorize(self.pusher.connection.socket_id, function (error, data) {
                if (error) {
                    self.handleEvent('pusher:subscription_error', data);
                } else {
                    self.pusher.send_event('pusher:subscribe', {
                        auth: data.auth,
                        channel_data: data.channel_data,
                        channel: self.name
                    });
                }
            });
        };

        /** Sends an unsubscription request. For internal use only. */
        prototype.unsubscribe = function () {
            this.pusher.send_event('pusher:unsubscribe', {
                channel: this.name
            });
        };

        Pusher.Channel = Channel;
    }).call(this);

    ;(function () {
        /** Extends public channels to provide private channel interface.
         *
         * @param {String} name
         * @param {Pusher} pusher
         */
        function PrivateChannel(name, pusher) {
            Pusher.Channel.call(this, name, pusher);
        }

        var prototype = PrivateChannel.prototype;
        Pusher.Util.extend(prototype, Pusher.Channel.prototype);

        /** Authorizes the connection to use the channel.
         *
         * @param  {String} socketId
         * @param  {Function} callback
         */
        prototype.authorize = function (socketId, callback) {
            var authorizer = new Pusher.Channel.Authorizer(this, this.pusher.config);
            return authorizer.authorize(socketId, callback);
        };

        Pusher.PrivateChannel = PrivateChannel;
    }).call(this);

    ;(function () {
        /** Adds presence channel functionality to private channels.
         *
         * @param {String} name
         * @param {Pusher} pusher
         */
        function PresenceChannel(name, pusher) {
            Pusher.PrivateChannel.call(this, name, pusher);
            this.members = new Pusher.Members();
        }

        var prototype = PresenceChannel.prototype;
        Pusher.Util.extend(prototype, Pusher.PrivateChannel.prototype);

        /** Authenticates the connection as a member of the channel.
         *
         * @param  {String} socketId
         * @param  {Function} callback
         */
        prototype.authorize = function (socketId, callback) {
            var _super = Pusher.PrivateChannel.prototype.authorize;
            var self = this;
            _super.call(self, socketId, function (error, authData) {
                if (!error) {
                    if (authData.channel_data === undefined) {
                        Pusher.warn(
                            "Invalid auth response for channel '" +
                            self.name +
                            "', expected 'channel_data' field"
                        );
                        callback("Invalid auth response");
                        return;
                    }
                    var channelData = JSON.parse(authData.channel_data);
                    self.members.setMyID(channelData.user_id);
                }
                callback(error, authData);
            });
        };

        /** Handles presence and subscription events. For internal use only.
         *
         * @param {String} event
         * @param {*} data
         */
        prototype.handleEvent = function (event, data) {
            switch (event) {
                case "pusher_internal:subscription_succeeded":
                    this.members.onSubscription(data);
                    this.subscribed = true;
                    this.emit("pusher:subscription_succeeded", this.members);
                    break;
                case "pusher_internal:member_added":
                    var addedMember = this.members.addMember(data);
                    this.emit('pusher:member_added', addedMember);
                    break;
                case "pusher_internal:member_removed":
                    var removedMember = this.members.removeMember(data);
                    if (removedMember) {
                        this.emit('pusher:member_removed', removedMember);
                    }
                    break;
                default:
                    Pusher.PrivateChannel.prototype.handleEvent.call(this, event, data);
            }
        };

        /** Resets the channel state, including members map. For internal use only. */
        prototype.disconnect = function () {
            this.members.reset();
            Pusher.PrivateChannel.prototype.disconnect.call(this);
        };

        Pusher.PresenceChannel = PresenceChannel;
    }).call(this);

    ;(function () {
        /** Handles a channel map. */
        function Channels() {
            this.channels = {};
        }

        var prototype = Channels.prototype;

        /** Creates or retrieves an existing channel by its name.
         *
         * @param {String} name
         * @param {Pusher} pusher
         * @return {Channel}
         */
        prototype.add = function (name, pusher) {
            if (!this.channels[name]) {
                this.channels[name] = createChannel(name, pusher);
            }
            return this.channels[name];
        };

        /** Returns a list of all channels
         *
         * @return {Array}
         */
        prototype.all = function (name) {
            return Pusher.Util.values(this.channels);
        };

        /** Finds a channel by its name.
         *
         * @param {String} name
         * @return {Channel} channel or null if it doesn't exist
         */
        prototype.find = function (name) {
            return this.channels[name];
        };

        /** Removes a channel from the map.
         *
         * @param {String} name
         */
        prototype.remove = function (name) {
            var channel = this.channels[name];
            delete this.channels[name];
            return channel;
        };

        /** Proxies disconnection signal to all channels. */
        prototype.disconnect = function () {
            Pusher.Util.objectApply(this.channels, function (channel) {
                channel.disconnect();
            });
        };

        function createChannel(name, pusher) {
            if (name.indexOf('private-') === 0) {
                return new Pusher.PrivateChannel(name, pusher);
            } else if (name.indexOf('presence-') === 0) {
                return new Pusher.PresenceChannel(name, pusher);
            } else {
                return new Pusher.Channel(name, pusher);
            }
        }

        Pusher.Channels = Channels;
    }).call(this);

    ;(function () {
        Pusher.Channel.Authorizer = function (channel, options) {
            this.channel = channel;
            this.type = options.authTransport;

            this.options = options;
            this.authOptions = (options || {}).auth || {};
        };

        Pusher.Channel.Authorizer.prototype = {
            composeQuery: function (socketId) {
                var query = 'socket_id=' + encodeURIComponent(socketId) +
                    '&channel_name=' + encodeURIComponent(this.channel.name);

                for (var i in this.authOptions.params) {
                    query += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(this.authOptions.params[i]);
                }

                return query;
            },

            authorize: function (socketId, callback) {
                return Pusher.authorizers[this.type].call(this, socketId, callback);
            }
        };

        var nextAuthCallbackID = 1;

        Pusher.auth_callbacks = {};
        Pusher.authorizers = {
            ajax: function (socketId, callback) {
                var self = this, xhr;

                if (Pusher.XHR) {
                    xhr = new Pusher.XHR();
                } else {
                    xhr = (window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
                }

                xhr.open("POST", self.options.authEndpoint, true);

                // add request headers
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                for (var headerName in this.authOptions.headers) {
                    xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
                }

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            var data, parsed = false;

                            try {
                                data = JSON.parse(xhr.responseText);
                                parsed = true;
                            } catch (e) {
                                callback(true, 'JSON returned from webapp was invalid, yet status code was 200. Data was: ' + xhr.responseText);
                            }

                            if (parsed) { // prevents double execution.
                                callback(false, data);
                            }
                        } else {
                            Pusher.warn("Couldn't get auth info from your webapp", xhr.status);
                            callback(true, xhr.status);
                        }
                    }
                };

                xhr.send(this.composeQuery(socketId));
                return xhr;
            },

            jsonp: function (socketId, callback) {
                if (this.authOptions.headers !== undefined) {
                    Pusher.warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
                }

                var callbackName = nextAuthCallbackID.toString();
                nextAuthCallbackID++;

                var document = Pusher.Util.getDocument();
                var script = document.createElement("script");
                // Hacked wrapper.
                Pusher.auth_callbacks[callbackName] = function (data) {
                    callback(false, data);
                };

                var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
                script.src = this.options.authEndpoint +
                    '?callback=' +
                    encodeURIComponent(callback_name) +
                    '&' +
                    this.composeQuery(socketId);

                var head = document.getElementsByTagName("head")[0] || document.documentElement;
                head.insertBefore(script, head.firstChild);
            }
        };
    }).call(this);

    return Pusher;
}));


!function (e) {
    e(["jquery"], function (e) {
        return function () {
            function t(e, t, n) {
                return g({type: O.error, iconClass: m().iconClasses.error, message: e, optionsOverride: n, title: t})
            }

            function n(t, n) {
                return t || (t = m()), v = e("#" + t.containerId), v.length ? v : (n && (v = d(t)), v)
            }

            function o(e, t, n) {
                return g({type: O.info, iconClass: m().iconClasses.info, message: e, optionsOverride: n, title: t})
            }

            function s(e) {
                C = e
            }

            function i(e, t, n) {
                return g({
                    type: O.success,
                    iconClass: m().iconClasses.success,
                    message: e,
                    optionsOverride: n,
                    title: t
                })
            }

            function a(e, t, n) {
                return g({
                    type: O.warning,
                    iconClass: m().iconClasses.warning,
                    message: e,
                    optionsOverride: n,
                    title: t
                })
            }

            function r(e, t) {
                var o = m();
                v || n(o), u(e, o, t) || l(o)
            }

            function c(t) {
                var o = m();
                return v || n(o), t && 0 === e(":focus", t).length ? void h(t) : void(v.children().length && v.remove())
            }

            function l(t) {
                for (var n = v.children(), o = n.length - 1; o >= 0; o--) u(e(n[o]), t)
            }

            function u(t, n, o) {
                var s = !(!o || !o.force) && o.force;
                return !(!t || !s && 0 !== e(":focus", t).length) && (t[n.hideMethod]({
                    duration: n.hideDuration,
                    easing: n.hideEasing,
                    complete: function () {
                        h(t)
                    }
                }), !0)
            }

            function d(t) {
                return v = e("<div/>").attr("id", t.containerId).addClass(t.positionClass), v.appendTo(e(t.target)), v
            }

            function p() {
                return {
                    tapToDismiss: !0,
                    toastClass: "toast",
                    containerId: "toast-container",
                    debug: !1,
                    showMethod: "fadeIn",
                    showDuration: 300,
                    showEasing: "swing",
                    onShown: void 0,
                    hideMethod: "fadeOut",
                    hideDuration: 1e3,
                    hideEasing: "swing",
                    onHidden: void 0,
                    closeMethod: !1,
                    closeDuration: !1,
                    closeEasing: !1,
                    closeOnHover: !0,
                    extendedTimeOut: 1e3,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    iconClass: "toast-info",
                    positionClass: "toast-top-right",
                    timeOut: 5e3,
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    escapeHtml: !1,
                    target: "body",
                    closeHtml: '<button type="button">&times;</button>',
                    closeClass: "toast-close-button",
                    newestOnTop: !0,
                    preventDuplicates: !1,
                    progressBar: !1,
                    progressClass: "toast-progress",
                    rtl: !1
                }
            }

            function f(e) {
                C && C(e)
            }

            function g(t) {
                function o(e) {
                    return null == e && (e = ""), e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }

                function s() {
                    c(), u(), d(), p(), g(), C(), l(), i()
                }

                function i() {
                    var e = "";
                    switch (t.iconClass) {
                        case"toast-success":
                        case"toast-info":
                            e = "polite";
                            break;
                        default:
                            e = "assertive"
                    }
                    I.attr("aria-live", e)
                }

                function a() {
                    E.closeOnHover && I.hover(H, D), !E.onclick && E.tapToDismiss && I.click(b), E.closeButton && j && j.click(function (e) {
                        e.stopPropagation ? e.stopPropagation() : void 0 !== e.cancelBubble && e.cancelBubble !== !0 && (e.cancelBubble = !0), E.onCloseClick && E.onCloseClick(e), b(!0)
                    }), E.onclick && I.click(function (e) {
                        E.onclick(e), b()
                    })
                }

                function r() {
                    I.hide(), I[E.showMethod]({
                        duration: E.showDuration,
                        easing: E.showEasing,
                        complete: E.onShown
                    }), E.timeOut > 0 && (k = setTimeout(b, E.timeOut), F.maxHideTime = parseFloat(E.timeOut), F.hideEta = (new Date).getTime() + F.maxHideTime, E.progressBar && (F.intervalId = setInterval(x, 10)))
                }

                function c() {
                    t.iconClass && I.addClass(E.toastClass).addClass(y)
                }

                function l() {
                    E.newestOnTop ? v.prepend(I) : v.append(I)
                }

                function u() {
                    if (t.title) {
                        var e = t.title;
                        E.escapeHtml && (e = o(t.title)), M.append(e).addClass(E.titleClass), I.append(M)
                    }
                }

                function d() {
                    if (t.message) {
                        var e = t.message;
                        E.escapeHtml && (e = o(t.message)), B.append(e).addClass(E.messageClass), I.append(B)
                    }
                }

                function p() {
                    E.closeButton && (j.addClass(E.closeClass).attr("role", "button"), I.prepend(j))
                }

                function g() {
                    E.progressBar && (q.addClass(E.progressClass), I.prepend(q))
                }

                function C() {
                    E.rtl && I.addClass("rtl")
                }

                function O(e, t) {
                    if (e.preventDuplicates) {
                        if (t.message === w) return !0;
                        w = t.message
                    }
                    return !1
                }

                function b(t) {
                    var n = t && E.closeMethod !== !1 ? E.closeMethod : E.hideMethod,
                        o = t && E.closeDuration !== !1 ? E.closeDuration : E.hideDuration,
                        s = t && E.closeEasing !== !1 ? E.closeEasing : E.hideEasing;
                    if (!e(":focus", I).length || t) return clearTimeout(F.intervalId), I[n]({
                        duration: o,
                        easing: s,
                        complete: function () {
                            h(I), clearTimeout(k), E.onHidden && "hidden" !== P.state && E.onHidden(), P.state = "hidden", P.endTime = new Date, f(P)
                        }
                    })
                }

                function D() {
                    (E.timeOut > 0 || E.extendedTimeOut > 0) && (k = setTimeout(b, E.extendedTimeOut), F.maxHideTime = parseFloat(E.extendedTimeOut), F.hideEta = (new Date).getTime() + F.maxHideTime)
                }

                function H() {
                    clearTimeout(k), F.hideEta = 0, I.stop(!0, !0)[E.showMethod]({
                        duration: E.showDuration,
                        easing: E.showEasing
                    })
                }

                function x() {
                    var e = (F.hideEta - (new Date).getTime()) / F.maxHideTime * 100;
                    q.width(e + "%")
                }

                var E = m(), y = t.iconClass || E.iconClass;
                if ("undefined" != typeof t.optionsOverride && (E = e.extend(E, t.optionsOverride), y = t.optionsOverride.iconClass || y), !O(E, t)) {
                    T++, v = n(E, !0);
                    var k = null, I = e("<div/>"), M = e("<div/>"), B = e("<div/>"), q = e("<div/>"),
                        j = e(E.closeHtml), F = {intervalId: null, hideEta: null, maxHideTime: null},
                        P = {toastId: T, state: "visible", startTime: new Date, options: E, map: t};
                    return s(), r(), a(), f(P), E.debug && console && console.log(P), I
                }
            }

            function m() {
                return e.extend({}, p(), b.options)
            }

            function h(e) {
                v || (v = n()), e.is(":visible") || (e.remove(), e = null, 0 === v.children().length && (v.remove(), w = void 0))
            }

            var v, C, w, T = 0, O = {error: "error", info: "info", success: "success", warning: "warning"}, b = {
                clear: r,
                remove: c,
                error: t,
                getContainer: n,
                info: o,
                options: {},
                subscribe: s,
                success: i,
                version: "2.1.3",
                warning: a
            };
            return b
        }()
    })
}("function" == typeof define && define.amd ? define : function (e, t) {
    "undefined" != typeof module && module.exports ? module.exports = t(require("jquery")) : window.toastr = t(window.jQuery)
});
//# sourceMappingURL=toastr.js.map

/*!
 * BootstrapValidator (http://bootstrapvalidator.com)
 * The best jQuery plugin to validate form fields. Designed to use with Bootstrap 3
 *
 * @version     v0.5.3, built on 2014-11-05 9:14:18 PM
 * @author      https://twitter.com/nghuuphuoc
 * @copyright   (c) 2013 - 2014 Nguyen Huu Phuoc
 * @license     Commercial: http://bootstrapvalidator.com/license/
 *              Non-commercial: http://creativecommons.org/licenses/by-nc-nd/3.0/
 */
if ("undefined" == typeof jQuery) throw new Error("BootstrapValidator requires jQuery");
!function (a) {
    var b = a.fn.jquery.split(" ")[0].split(".");
    if (+b[0] < 2 && +b[1] < 9 || 1 === +b[0] && 9 === +b[1] && +b[2] < 1) throw new Error("BootstrapValidator requires jQuery version 1.9.1 or higher")
}(window.jQuery), function (a) {
    var b = function (b, c) {
        this.$form = a(b), this.options = a.extend({}, a.fn.bootstrapValidator.DEFAULT_OPTIONS, c), this.$invalidFields = a([]), this.$submitButton = null, this.$hiddenButton = null, this.STATUS_NOT_VALIDATED = "NOT_VALIDATED", this.STATUS_VALIDATING = "VALIDATING", this.STATUS_INVALID = "INVALID", this.STATUS_VALID = "VALID";
        var d = function () {
            for (var a = 3, b = document.createElement("div"), c = b.all || []; b.innerHTML = "<!--[if gt IE " + ++a + "]><br><![endif]-->", c[0];) ;
            return a > 4 ? a : !a
        }(), e = document.createElement("div");
        this._changeEvent = 9 !== d && "oninput" in e ? "input" : "keyup", this._submitIfValid = null, this._cacheFields = {}, this._init()
    };
    b.prototype = {
        constructor: b, _init: function () {
            var b = this, c = {
                autoFocus: this.$form.attr("data-bv-autofocus"),
                container: this.$form.attr("data-bv-container"),
                events: {
                    formInit: this.$form.attr("data-bv-events-form-init"),
                    formError: this.$form.attr("data-bv-events-form-error"),
                    formSuccess: this.$form.attr("data-bv-events-form-success"),
                    fieldAdded: this.$form.attr("data-bv-events-field-added"),
                    fieldRemoved: this.$form.attr("data-bv-events-field-removed"),
                    fieldInit: this.$form.attr("data-bv-events-field-init"),
                    fieldError: this.$form.attr("data-bv-events-field-error"),
                    fieldSuccess: this.$form.attr("data-bv-events-field-success"),
                    fieldStatus: this.$form.attr("data-bv-events-field-status"),
                    validatorError: this.$form.attr("data-bv-events-validator-error"),
                    validatorSuccess: this.$form.attr("data-bv-events-validator-success")
                },
                excluded: this.$form.attr("data-bv-excluded"),
                feedbackIcons: {
                    valid: this.$form.attr("data-bv-feedbackicons-valid"),
                    invalid: this.$form.attr("data-bv-feedbackicons-invalid"),
                    validating: this.$form.attr("data-bv-feedbackicons-validating")
                },
                group: this.$form.attr("data-bv-group"),
                live: this.$form.attr("data-bv-live"),
                message: this.$form.attr("data-bv-message"),
                onError: this.$form.attr("data-bv-onerror"),
                onSuccess: this.$form.attr("data-bv-onsuccess"),
                submitButtons: this.$form.attr("data-bv-submitbuttons"),
                threshold: this.$form.attr("data-bv-threshold"),
                trigger: this.$form.attr("data-bv-trigger"),
                verbose: this.$form.attr("data-bv-verbose"),
                fields: {}
            };
            this.$form.attr("novalidate", "novalidate").addClass(this.options.elementClass).on("submit.bv", function (a) {
                a.preventDefault(), b.validate()
            }).on("click.bv", this.options.submitButtons, function () {
                b.$submitButton = a(this), b._submitIfValid = !0
            }).find("[name], [data-bv-field]").each(function () {
                var d = a(this), e = d.attr("name") || d.attr("data-bv-field"), f = b._parseOptions(d);
                f && (d.attr("data-bv-field", e), c.fields[e] = a.extend({}, f, c.fields[e]))
            }), this.options = a.extend(!0, this.options, c), this.$hiddenButton = a("<button/>").attr("type", "submit").prependTo(this.$form).addClass("bv-hidden-submit").css({
                display: "none",
                width: 0,
                height: 0
            }), this.$form.on("click.bv", '[type="submit"]', function (c) {
                if (!c.isDefaultPrevented()) {
                    var d = a(c.target), e = d.is('[type="submit"]') ? d.eq(0) : d.parent('[type="submit"]').eq(0);
                    !b.options.submitButtons || e.is(b.options.submitButtons) || e.is(b.$hiddenButton) || b.$form.off("submit.bv").submit()
                }
            });
            for (var d in this.options.fields) this._initField(d);
            this.$form.trigger(a.Event(this.options.events.formInit), {
                bv: this,
                options: this.options
            }), this.options.onSuccess && this.$form.on(this.options.events.formSuccess, function (c) {
                a.fn.bootstrapValidator.helpers.call(b.options.onSuccess, [c])
            }), this.options.onError && this.$form.on(this.options.events.formError, function (c) {
                a.fn.bootstrapValidator.helpers.call(b.options.onError, [c])
            })
        }, _parseOptions: function (b) {
            var c, d, e, f, g, h, i, j, k, l = b.attr("name") || b.attr("data-bv-field"), m = {};
            for (d in a.fn.bootstrapValidator.validators) if (c = a.fn.bootstrapValidator.validators[d], e = "data-bv-" + d.toLowerCase(), f = b.attr(e) + "", k = "function" == typeof c.enableByHtml5 ? c.enableByHtml5(b) : null, k && "false" !== f || k !== !0 && ("" === f || "true" === f || e === f.toLowerCase())) {
                c.html5Attributes = a.extend({}, {
                    message: "message",
                    onerror: "onError",
                    onsuccess: "onSuccess"
                }, c.html5Attributes), m[d] = a.extend({}, k === !0 ? {} : k, m[d]);
                for (j in c.html5Attributes) g = c.html5Attributes[j], h = "data-bv-" + d.toLowerCase() + "-" + j, i = b.attr(h), i && ("true" === i || h === i.toLowerCase() ? i = !0 : "false" === i && (i = !1), m[d][g] = i)
            }
            var n = {
                autoFocus: b.attr("data-bv-autofocus"),
                container: b.attr("data-bv-container"),
                excluded: b.attr("data-bv-excluded"),
                feedbackIcons: b.attr("data-bv-feedbackicons"),
                group: b.attr("data-bv-group"),
                message: b.attr("data-bv-message"),
                onError: b.attr("data-bv-onerror"),
                onStatus: b.attr("data-bv-onstatus"),
                onSuccess: b.attr("data-bv-onsuccess"),
                selector: b.attr("data-bv-selector"),
                threshold: b.attr("data-bv-threshold"),
                trigger: b.attr("data-bv-trigger"),
                verbose: b.attr("data-bv-verbose"),
                validators: m
            }, o = a.isEmptyObject(n), p = a.isEmptyObject(m);
            return !p || !o && this.options.fields && this.options.fields[l] ? (n.validators = m, n) : null
        }, _initField: function (b) {
            var c = a([]);
            switch (typeof b) {
                case"object":
                    c = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    c = this.getFieldElements(b), c.attr("data-bv-field", b)
            }
            if (0 !== c.length && null !== this.options.fields[b] && null !== this.options.fields[b].validators) {
                var d;
                for (d in this.options.fields[b].validators) a.fn.bootstrapValidator.validators[d] || delete this.options.fields[b].validators[d];
                null === this.options.fields[b].enabled && (this.options.fields[b].enabled = !0);
                for (var e = this, f = c.length, g = c.attr("type"), h = 1 === f || "radio" === g || "checkbox" === g, i = "radio" === g || "checkbox" === g || "file" === g || "SELECT" === c.eq(0).get(0).tagName ? "change" : this._changeEvent, j = (this.options.fields[b].trigger || this.options.trigger || i).split(" "), k = a.map(j, function (a) {
                    return a + ".update.bv"
                }).join(" "), l = 0; f > l; l++) {
                    var m = c.eq(l), n = this.options.fields[b].group || this.options.group, o = m.parents(n),
                        p = "function" == typeof(this.options.fields[b].container || this.options.container) ? (this.options.fields[b].container || this.options.container).call(this, m, this) : this.options.fields[b].container || this.options.container,
                        q = p && "tooltip" !== p && "popover" !== p ? a(p) : this._getMessageContainer(m, n);
                    p && "tooltip" !== p && "popover" !== p && q.addClass("has-error"), q.find('.help-block[data-bv-validator][data-bv-for="' + b + '"]').remove(), o.find('i[data-bv-icon-for="' + b + '"]').remove(), m.off(k).on(k, function () {
                        e.updateStatus(a(this), e.STATUS_NOT_VALIDATED)
                    }), m.data("bv.messages", q);
                    for (d in this.options.fields[b].validators) m.data("bv.result." + d, this.STATUS_NOT_VALIDATED), h && l !== f - 1 || a("<small/>").css("display", "none").addClass("help-block").attr("data-bv-validator", d).attr("data-bv-for", b).attr("data-bv-result", this.STATUS_NOT_VALIDATED).html(this._getMessage(b, d)).appendTo(q), "function" == typeof a.fn.bootstrapValidator.validators[d].init && a.fn.bootstrapValidator.validators[d].init(this, m, this.options.fields[b].validators[d]);
                    if (this.options.fields[b].feedbackIcons !== !1 && "false" !== this.options.fields[b].feedbackIcons && this.options.feedbackIcons && this.options.feedbackIcons.validating && this.options.feedbackIcons.invalid && this.options.feedbackIcons.valid && (!h || l === f - 1)) {
                        o.addClass("has-feedback");
                        var r = a("<i/>").css("display", "none").addClass("form-control-feedback").attr("data-bv-icon-for", b).insertAfter(m);
                        if ("checkbox" === g || "radio" === g) {
                            var s = m.parent();
                            s.hasClass(g) ? r.insertAfter(s) : s.parent().hasClass(g) && r.insertAfter(s.parent())
                        }
                        0 === o.find("label").length && r.addClass("bv-no-label"), 0 !== o.find(".input-group").length && r.addClass("bv-icon-input-group").insertAfter(o.find(".input-group").eq(0)), h ? l === f - 1 && c.data("bv.icon", r) : m.data("bv.icon", r), p && m.off("focus.container.bv").on("focus.container.bv", function () {
                            switch (p) {
                                case"tooltip":
                                    a(this).data("bv.icon").tooltip("show");
                                    break;
                                case"popover":
                                    a(this).data("bv.icon").popover("show")
                            }
                        }).off("blur.container.bv").on("blur.container.bv", function () {
                            switch (p) {
                                case"tooltip":
                                    a(this).data("bv.icon").tooltip("hide");
                                    break;
                                case"popover":
                                    a(this).data("bv.icon").popover("hide")
                            }
                        })
                    }
                }
                switch (c.on(this.options.events.fieldSuccess, function (b, c) {
                    var d = e.getOptions(c.field, null, "onSuccess");
                    d && a.fn.bootstrapValidator.helpers.call(d, [b, c])
                }).on(this.options.events.fieldError, function (b, c) {
                    var d = e.getOptions(c.field, null, "onError");
                    d && a.fn.bootstrapValidator.helpers.call(d, [b, c])
                }).on(this.options.events.fieldStatus, function (b, c) {
                    var d = e.getOptions(c.field, null, "onStatus");
                    d && a.fn.bootstrapValidator.helpers.call(d, [b, c])
                }).on(this.options.events.validatorError, function (b, c) {
                    var d = e.getOptions(c.field, c.validator, "onError");
                    d && a.fn.bootstrapValidator.helpers.call(d, [b, c])
                }).on(this.options.events.validatorSuccess, function (b, c) {
                    var d = e.getOptions(c.field, c.validator, "onSuccess");
                    d && a.fn.bootstrapValidator.helpers.call(d, [b, c])
                }), k = a.map(j, function (a) {
                    return a + ".live.bv"
                }).join(" "), this.options.live) {
                    case"submitted":
                        break;
                    case"disabled":
                        c.off(k);
                        break;
                    case"enabled":
                    default:
                        c.off(k).on(k, function () {
                            e._exceedThreshold(a(this)) && e.validateField(a(this))
                        })
                }
                c.trigger(a.Event(this.options.events.fieldInit), {bv: this, field: b, element: c})
            }
        }, _getMessage: function (b, c) {
            if (!(this.options.fields[b] && a.fn.bootstrapValidator.validators[c] && this.options.fields[b].validators && this.options.fields[b].validators[c])) return "";
            var d = this.options.fields[b].validators[c];
            switch (!0) {
                case!!d.message:
                    return d.message;
                case!!this.options.fields[b].message:
                    return this.options.fields[b].message;
                case!!a.fn.bootstrapValidator.i18n[c]:
                    return a.fn.bootstrapValidator.i18n[c]["default"];
                default:
                    return this.options.message
            }
        }, _getMessageContainer: function (a, b) {
            var c = a.parent();
            if (c.is(b)) return c;
            var d = c.attr("class");
            if (!d) return this._getMessageContainer(c, b);
            d = d.split(" ");
            for (var e = d.length, f = 0; e > f; f++) if (/^col-(xs|sm|md|lg)-\d+$/.test(d[f]) || /^col-(xs|sm|md|lg)-offset-\d+$/.test(d[f])) return c;
            return this._getMessageContainer(c, b)
        }, _submit: function () {
            var b = this.isValid(), c = b ? this.options.events.formSuccess : this.options.events.formError,
                d = a.Event(c);
            this.$form.trigger(d), this.$submitButton && (b ? this._onSuccess(d) : this._onError(d))
        }, _isExcluded: function (b) {
            var c = b.attr("data-bv-excluded"), d = b.attr("data-bv-field") || b.attr("name");
            switch (!0) {
                case!!d && this.options.fields && this.options.fields[d] && ("true" === this.options.fields[d].excluded || this.options.fields[d].excluded === !0):
                case"true" === c:
                case"" === c:
                    return !0;
                case!!d && this.options.fields && this.options.fields[d] && ("false" === this.options.fields[d].excluded || this.options.fields[d].excluded === !1):
                case"false" === c:
                    return !1;
                default:
                    if (this.options.excluded) {
                        "string" == typeof this.options.excluded && (this.options.excluded = a.map(this.options.excluded.split(","), function (b) {
                            return a.trim(b)
                        }));
                        for (var e = this.options.excluded.length, f = 0; e > f; f++) if ("string" == typeof this.options.excluded[f] && b.is(this.options.excluded[f]) || "function" == typeof this.options.excluded[f] && this.options.excluded[f].call(this, b, this) === !0) return !0
                    }
                    return !1
            }
        }, _exceedThreshold: function (b) {
            var c = b.attr("data-bv-field"), d = this.options.fields[c].threshold || this.options.threshold;
            if (!d) return !0;
            var e = -1 !== a.inArray(b.attr("type"), ["button", "checkbox", "file", "hidden", "image", "radio", "reset", "submit"]);
            return e || b.val().length >= d
        }, _onError: function (b) {
            if (!b.isDefaultPrevented()) {
                if ("submitted" === this.options.live) {
                    this.options.live = "enabled";
                    var c = this;
                    for (var d in this.options.fields) !function (b) {
                        var e = c.getFieldElements(b);
                        if (e.length) {
                            var f = a(e[0]).attr("type"),
                                g = "radio" === f || "checkbox" === f || "file" === f || "SELECT" === a(e[0]).get(0).tagName ? "change" : c._changeEvent,
                                h = c.options.fields[d].trigger || c.options.trigger || g,
                                i = a.map(h.split(" "), function (a) {
                                    return a + ".live.bv"
                                }).join(" ");
                            e.off(i).on(i, function () {
                                c._exceedThreshold(a(this)) && c.validateField(a(this))
                            })
                        }
                    }(d)
                }
                for (var e = 0; e < this.$invalidFields.length; e++) {
                    var f = this.$invalidFields.eq(e), g = this._isOptionEnabled(f.attr("data-bv-field"), "autoFocus");
                    if (g) {
                        var h, i = f.parents(".tab-pane");
                        i && (h = i.attr("id")) && a('a[href="#' + h + '"][data-toggle="tab"]').tab("show"), f.focus();
                        break
                    }
                }
            }
        }, _onSuccess: function (a) {
            a.isDefaultPrevented() || this.disableSubmitButtons(!0).defaultSubmit()
        }, _onFieldValidated: function (b, c) {
            var d = b.attr("data-bv-field"), e = this.options.fields[d].validators, f = {}, g = 0,
                h = {bv: this, field: d, element: b, validator: c, result: b.data("bv.response." + c)};
            if (c) switch (b.data("bv.result." + c)) {
                case this.STATUS_INVALID:
                    b.trigger(a.Event(this.options.events.validatorError), h);
                    break;
                case this.STATUS_VALID:
                    b.trigger(a.Event(this.options.events.validatorSuccess), h)
            }
            f[this.STATUS_NOT_VALIDATED] = 0, f[this.STATUS_VALIDATING] = 0, f[this.STATUS_INVALID] = 0, f[this.STATUS_VALID] = 0;
            for (var i in e) if (e[i].enabled !== !1) {
                g++;
                var j = b.data("bv.result." + i);
                j && f[j]++
            }
            f[this.STATUS_VALID] === g ? (this.$invalidFields = this.$invalidFields.not(b), b.trigger(a.Event(this.options.events.fieldSuccess), h)) : (0 === f[this.STATUS_NOT_VALIDATED] || !this._isOptionEnabled(d, "verbose")) && 0 === f[this.STATUS_VALIDATING] && f[this.STATUS_INVALID] > 0 && (this.$invalidFields = this.$invalidFields.add(b), b.trigger(a.Event(this.options.events.fieldError), h))
        }, _isOptionEnabled: function (a, b) {
            return !this.options.fields[a] || "true" !== this.options.fields[a][b] && this.options.fields[a][b] !== !0 ? !this.options.fields[a] || "false" !== this.options.fields[a][b] && this.options.fields[a][b] !== !1 ? "true" === this.options[b] || this.options[b] === !0 : !1 : !0
        }, getFieldElements: function (b) {
            return this._cacheFields[b] || (this._cacheFields[b] = this.options.fields[b] && this.options.fields[b].selector ? a(this.options.fields[b].selector) : this.$form.find('[name="' + b + '"]')), this._cacheFields[b]
        }, getOptions: function (a, b, c) {
            if (!a) return c ? this.options[c] : this.options;
            if ("object" == typeof a && (a = a.attr("data-bv-field")), !this.options.fields[a]) return null;
            var d = this.options.fields[a];
            return b ? d.validators && d.validators[b] ? c ? d.validators[b][c] : d.validators[b] : null : c ? d[c] : d
        }, disableSubmitButtons: function (a) {
            return a ? "disabled" !== this.options.live && this.$form.find(this.options.submitButtons).attr("disabled", "disabled") : this.$form.find(this.options.submitButtons).removeAttr("disabled"), this
        }, validate: function () {
            if (!this.options.fields) return this;
            this.disableSubmitButtons(!0), this._submitIfValid = !1;
            for (var a in this.options.fields) this.validateField(a);
            return this._submit(), this._submitIfValid = !0, this
        }, validateField: function (b) {
            var c = a([]);
            switch (typeof b) {
                case"object":
                    c = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    c = this.getFieldElements(b)
            }
            if (0 === c.length || !this.options.fields[b] || this.options.fields[b].enabled === !1) return this;
            for (var d, e, f = this, g = c.attr("type"), h = "radio" === g || "checkbox" === g ? 1 : c.length, i = "radio" === g || "checkbox" === g, j = this.options.fields[b].validators, k = this._isOptionEnabled(b, "verbose"), l = 0; h > l; l++) {
                var m = c.eq(l);
                if (!this._isExcluded(m)) {
                    var n = !1;
                    for (d in j) {
                        if (m.data("bv.dfs." + d) && m.data("bv.dfs." + d).reject(), n) break;
                        var o = m.data("bv.result." + d);
                        if (o !== this.STATUS_VALID && o !== this.STATUS_INVALID) if (j[d].enabled !== !1) {
                            if (m.data("bv.result." + d, this.STATUS_VALIDATING), e = a.fn.bootstrapValidator.validators[d].validate(this, m, j[d]), "object" == typeof e && e.resolve) this.updateStatus(i ? b : m, this.STATUS_VALIDATING, d), m.data("bv.dfs." + d, e), e.done(function (a, b, c) {
                                a.removeData("bv.dfs." + b).data("bv.response." + b, c), c.message && f.updateMessage(a, b, c.message), f.updateStatus(i ? a.attr("data-bv-field") : a, c.valid ? f.STATUS_VALID : f.STATUS_INVALID, b), c.valid && f._submitIfValid === !0 ? f._submit() : c.valid || k || (n = !0)
                            }); else if ("object" == typeof e && void 0 !== e.valid && void 0 !== e.message) {
                                if (m.data("bv.response." + d, e), this.updateMessage(i ? b : m, d, e.message), this.updateStatus(i ? b : m, e.valid ? this.STATUS_VALID : this.STATUS_INVALID, d), !e.valid && !k) break
                            } else if ("boolean" == typeof e && (m.data("bv.response." + d, e), this.updateStatus(i ? b : m, e ? this.STATUS_VALID : this.STATUS_INVALID, d), !e && !k)) break
                        } else this.updateStatus(i ? b : m, this.STATUS_VALID, d); else this._onFieldValidated(m, d)
                    }
                }
            }
            return this
        }, updateMessage: function (b, c, d) {
            var e = a([]);
            switch (typeof b) {
                case"object":
                    e = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    e = this.getFieldElements(b)
            }
            e.each(function () {
                a(this).data("bv.messages").find('.help-block[data-bv-validator="' + c + '"][data-bv-for="' + b + '"]').html(d)
            })
        }, updateStatus: function (b, c, d) {
            var e = a([]);
            switch (typeof b) {
                case"object":
                    e = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    e = this.getFieldElements(b)
            }
            c === this.STATUS_NOT_VALIDATED && (this._submitIfValid = !1);
            for (var f = this, g = e.attr("type"), h = this.options.fields[b].group || this.options.group, i = "radio" === g || "checkbox" === g ? 1 : e.length, j = 0; i > j; j++) {
                var k = e.eq(j);
                if (!this._isExcluded(k)) {
                    var l = k.parents(h), m = k.data("bv.messages"),
                        n = m.find('.help-block[data-bv-validator][data-bv-for="' + b + '"]'),
                        o = d ? n.filter('[data-bv-validator="' + d + '"]') : n, p = k.data("bv.icon"),
                        q = "function" == typeof(this.options.fields[b].container || this.options.container) ? (this.options.fields[b].container || this.options.container).call(this, k, this) : this.options.fields[b].container || this.options.container,
                        r = null;
                    if (d) k.data("bv.result." + d, c); else for (var s in this.options.fields[b].validators) k.data("bv.result." + s, c);
                    o.attr("data-bv-result", c);
                    var t, u, v = k.parents(".tab-pane");
                    switch (v && (t = v.attr("id")) && (u = a('a[href="#' + t + '"][data-toggle="tab"]').parent()), c) {
                        case this.STATUS_VALIDATING:
                            r = null, this.disableSubmitButtons(!0), l.removeClass("has-success").removeClass("has-error"), p && p.removeClass(this.options.feedbackIcons.valid).removeClass(this.options.feedbackIcons.invalid).addClass(this.options.feedbackIcons.validating).show(), u && u.removeClass("bv-tab-success").removeClass("bv-tab-error");
                            break;
                        case this.STATUS_INVALID:
                            r = !1, this.disableSubmitButtons(!0), l.removeClass("has-success").addClass("has-error"), p && p.removeClass(this.options.feedbackIcons.valid).removeClass(this.options.feedbackIcons.validating).addClass(this.options.feedbackIcons.invalid).show(), u && u.removeClass("bv-tab-success").addClass("bv-tab-error");
                            break;
                        case this.STATUS_VALID:
                            r = 0 === n.filter('[data-bv-result="' + this.STATUS_NOT_VALIDATED + '"]').length ? n.filter('[data-bv-result="' + this.STATUS_VALID + '"]').length === n.length : null, null !== r && (this.disableSubmitButtons(this.$submitButton ? !this.isValid() : !r), p && p.removeClass(this.options.feedbackIcons.invalid).removeClass(this.options.feedbackIcons.validating).removeClass(this.options.feedbackIcons.valid).addClass(r ? this.options.feedbackIcons.valid : this.options.feedbackIcons.invalid).show()), l.removeClass("has-error has-success").addClass(this.isValidContainer(l) ? "has-success" : "has-error"), u && u.removeClass("bv-tab-success").removeClass("bv-tab-error").addClass(this.isValidContainer(v) ? "bv-tab-success" : "bv-tab-error");
                            break;
                        case this.STATUS_NOT_VALIDATED:
                        default:
                            r = null, this.disableSubmitButtons(!1), l.removeClass("has-success").removeClass("has-error"), p && p.removeClass(this.options.feedbackIcons.valid).removeClass(this.options.feedbackIcons.invalid).removeClass(this.options.feedbackIcons.validating).hide(), u && u.removeClass("bv-tab-success").removeClass("bv-tab-error")
                    }
                    switch (!0) {
                        case p && "tooltip" === q:
                            r === !1 ? p.css("cursor", "pointer").tooltip("destroy").tooltip({
                                container: "body",
                                html: !0,
                                placement: "auto top",
                                title: n.filter('[data-bv-result="' + f.STATUS_INVALID + '"]').eq(0).html()
                            }) : p.css("cursor", "").tooltip("destroy");
                            break;
                        case p && "popover" === q:
                            r === !1 ? p.css("cursor", "pointer").popover("destroy").popover({
                                container: "body",
                                content: n.filter('[data-bv-result="' + f.STATUS_INVALID + '"]').eq(0).html(),
                                html: !0,
                                placement: "auto top",
                                trigger: "hover click"
                            }) : p.css("cursor", "").popover("destroy");
                            break;
                        default:
                            c === this.STATUS_INVALID ? o.show() : o.hide()
                    }
                    k.trigger(a.Event(this.options.events.fieldStatus), {
                        bv: this,
                        field: b,
                        element: k,
                        status: c
                    }), this._onFieldValidated(k, d)
                }
            }
            return this
        }, isValid: function () {
            for (var a in this.options.fields) if (!this.isValidField(a)) return !1;
            return !0
        }, isValidField: function (b) {
            var c = a([]);
            switch (typeof b) {
                case"object":
                    c = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    c = this.getFieldElements(b)
            }
            if (0 === c.length || !this.options.fields[b] || this.options.fields[b].enabled === !1) return !0;
            for (var d, e, f, g = c.attr("type"), h = "radio" === g || "checkbox" === g ? 1 : c.length, i = 0; h > i; i++) if (d = c.eq(i), !this._isExcluded(d)) for (e in this.options.fields[b].validators) if (this.options.fields[b].validators[e].enabled !== !1 && (f = d.data("bv.result." + e), f !== this.STATUS_VALID)) return !1;
            return !0
        }, isValidContainer: function (b) {
            var c = this, d = {}, e = "string" == typeof b ? a(b) : b;
            if (0 === e.length) return !0;
            e.find("[data-bv-field]").each(function () {
                var b = a(this), e = b.attr("data-bv-field");
                c._isExcluded(b) || d[e] || (d[e] = b)
            });
            for (var f in d) {
                var g = d[f];
                if (g.data("bv.messages").find('.help-block[data-bv-validator][data-bv-for="' + f + '"]').filter('[data-bv-result="' + this.STATUS_INVALID + '"]').length > 0) return !1
            }
            return !0
        }, defaultSubmit: function () {
            this.$submitButton && a("<input/>").attr("type", "hidden").attr("data-bv-submit-hidden", "").attr("name", this.$submitButton.attr("name")).val(this.$submitButton.val()).appendTo(this.$form), this.$form.off("submit.bv").submit()
        }, getInvalidFields: function () {
            return this.$invalidFields
        }, getSubmitButton: function () {
            return this.$submitButton
        }, getMessages: function (b, c) {
            var d = this, e = [], f = a([]);
            switch (!0) {
                case b && "object" == typeof b:
                    f = b;
                    break;
                case b && "string" == typeof b:
                    var g = this.getFieldElements(b);
                    if (g.length > 0) {
                        var h = g.attr("type");
                        f = "radio" === h || "checkbox" === h ? g.eq(0) : g
                    }
                    break;
                default:
                    f = this.$invalidFields
            }
            var i = c ? '[data-bv-validator="' + c + '"]' : "";
            return f.each(function () {
                e = e.concat(a(this).data("bv.messages").find('.help-block[data-bv-for="' + a(this).attr("data-bv-field") + '"][data-bv-result="' + d.STATUS_INVALID + '"]' + i).map(function () {
                    var b = a(this).attr("data-bv-validator"), c = a(this).attr("data-bv-for");
                    return d.options.fields[c].validators[b].enabled === !1 ? "" : a(this).html()
                }).get())
            }), e
        }, updateOption: function (a, b, c, d) {
            return "object" == typeof a && (a = a.attr("data-bv-field")), this.options.fields[a] && this.options.fields[a].validators[b] && (this.options.fields[a].validators[b][c] = d, this.updateStatus(a, this.STATUS_NOT_VALIDATED, b)), this
        }, addField: function (b, c) {
            var d = a([]);
            switch (typeof b) {
                case"object":
                    d = b, b = b.attr("data-bv-field") || b.attr("name");
                    break;
                case"string":
                    delete this._cacheFields[b], d = this.getFieldElements(b)
            }
            d.attr("data-bv-field", b);
            for (var e = d.attr("type"), f = "radio" === e || "checkbox" === e ? 1 : d.length, g = 0; f > g; g++) {
                var h = d.eq(g), i = this._parseOptions(h);
                i = null === i ? c : a.extend(!0, c, i), this.options.fields[b] = a.extend(!0, this.options.fields[b], i), this._cacheFields[b] = this._cacheFields[b] ? this._cacheFields[b].add(h) : h, this._initField("checkbox" === e || "radio" === e ? b : h)
            }
            return this.disableSubmitButtons(!1), this.$form.trigger(a.Event(this.options.events.fieldAdded), {
                field: b,
                element: d,
                options: this.options.fields[b]
            }), this
        }, removeField: function (b) {
            var c = a([]);
            switch (typeof b) {
                case"object":
                    c = b, b = b.attr("data-bv-field") || b.attr("name"), c.attr("data-bv-field", b);
                    break;
                case"string":
                    c = this.getFieldElements(b)
            }
            if (0 === c.length) return this;
            for (var d = c.attr("type"), e = "radio" === d || "checkbox" === d ? 1 : c.length, f = 0; e > f; f++) {
                var g = c.eq(f);
                this.$invalidFields = this.$invalidFields.not(g), this._cacheFields[b] = this._cacheFields[b].not(g)
            }
            return this._cacheFields[b] && 0 !== this._cacheFields[b].length || delete this.options.fields[b], ("checkbox" === d || "radio" === d) && this._initField(b), this.disableSubmitButtons(!1), this.$form.trigger(a.Event(this.options.events.fieldRemoved), {
                field: b,
                element: c
            }), this
        }, resetField: function (b, c) {
            var d = a([]);
            switch (typeof b) {
                case"object":
                    d = b, b = b.attr("data-bv-field");
                    break;
                case"string":
                    d = this.getFieldElements(b)
            }
            var e = d.length;
            if (this.options.fields[b]) for (var f = 0; e > f; f++) for (var g in this.options.fields[b].validators) d.eq(f).removeData("bv.dfs." + g);
            if (this.updateStatus(b, this.STATUS_NOT_VALIDATED), c) {
                var h = d.attr("type");
                "radio" === h || "checkbox" === h ? d.removeAttr("checked").removeAttr("selected") : d.val("")
            }
            return this
        }, resetForm: function (b) {
            for (var c in this.options.fields) this.resetField(c, b);
            return this.$invalidFields = a([]), this.$submitButton = null, this.disableSubmitButtons(!1), this
        }, revalidateField: function (a) {
            return this.updateStatus(a, this.STATUS_NOT_VALIDATED).validateField(a), this
        }, enableFieldValidators: function (a, b, c) {
            var d = this.options.fields[a].validators;
            if (c && d && d[c] && d[c].enabled !== b) this.options.fields[a].validators[c].enabled = b, this.updateStatus(a, this.STATUS_NOT_VALIDATED, c); else if (!c && this.options.fields[a].enabled !== b) {
                this.options.fields[a].enabled = b;
                for (var e in d) this.enableFieldValidators(a, b, e)
            }
            return this
        }, getDynamicOption: function (b, c) {
            var d = "string" == typeof b ? this.getFieldElements(b) : b, e = d.val();
            if ("function" == typeof c) return a.fn.bootstrapValidator.helpers.call(c, [e, this, d]);
            if ("string" == typeof c) {
                var f = this.getFieldElements(c);
                return f.length ? f.val() : a.fn.bootstrapValidator.helpers.call(c, [e, this, d]) || c
            }
            return null
        }, destroy: function () {
            var b, c, d, e, f, g;
            for (b in this.options.fields) {
                c = this.getFieldElements(b), g = this.options.fields[b].group || this.options.group;
                for (var h = 0; h < c.length; h++) {
                    if (d = c.eq(h), d.data("bv.messages").find('.help-block[data-bv-validator][data-bv-for="' + b + '"]').remove().end().end().removeData("bv.messages").parents(g).removeClass("has-feedback has-error has-success").end().off(".bv").removeAttr("data-bv-field"), f = d.data("bv.icon")) {
                        var i = "function" == typeof(this.options.fields[b].container || this.options.container) ? (this.options.fields[b].container || this.options.container).call(this, d, this) : this.options.fields[b].container || this.options.container;
                        switch (i) {
                            case"tooltip":
                                f.tooltip("destroy").remove();
                                break;
                            case"popover":
                                f.popover("destroy").remove();
                                break;
                            default:
                                f.remove()
                        }
                    }
                    d.removeData("bv.icon");
                    for (e in this.options.fields[b].validators) d.data("bv.dfs." + e) && d.data("bv.dfs." + e).reject(), d.removeData("bv.result." + e).removeData("bv.response." + e).removeData("bv.dfs." + e), "function" == typeof a.fn.bootstrapValidator.validators[e].destroy && a.fn.bootstrapValidator.validators[e].destroy(this, d, this.options.fields[b].validators[e])
                }
            }
            this.disableSubmitButtons(!1), this.$hiddenButton.remove(), this.$form.removeClass(this.options.elementClass).off(".bv").removeData("bootstrapValidator").find("[data-bv-submit-hidden]").remove().end().find('[type="submit"]').off("click.bv")
        }
    }, a.fn.bootstrapValidator = function (c) {
        var d = arguments;
        return this.each(function () {
            var e = a(this), f = e.data("bootstrapValidator"), g = "object" == typeof c && c;
            f || (f = new b(this, g), e.data("bootstrapValidator", f)), "string" == typeof c && f[c].apply(f, Array.prototype.slice.call(d, 1))
        })
    }, a.fn.bootstrapValidator.DEFAULT_OPTIONS = {
        autoFocus: !0,
        container: null,
        elementClass: "bv-form",
        events: {
            formInit: "init.form.bv",
            formError: "error.form.bv",
            formSuccess: "success.form.bv",
            fieldAdded: "added.field.bv",
            fieldRemoved: "removed.field.bv",
            fieldInit: "init.field.bv",
            fieldError: "error.field.bv",
            fieldSuccess: "success.field.bv",
            fieldStatus: "status.field.bv",
            validatorError: "error.validator.bv",
            validatorSuccess: "success.validator.bv"
        },
        excluded: [":disabled", ":hidden", ":not(:visible)"],
        feedbackIcons: {valid: null, invalid: null, validating: null},
        fields: null,
        group: ".form-group",
        live: "enabled",
        message: "This value is not valid",
        submitButtons: '[type="submit"]',
        threshold: null,
        verbose: !0
    }, a.fn.bootstrapValidator.validators = {}, a.fn.bootstrapValidator.i18n = {}, a.fn.bootstrapValidator.Constructor = b, a.fn.bootstrapValidator.helpers = {
        call: function (a, b) {
            if ("function" == typeof a) return a.apply(this, b);
            if ("string" == typeof a) {
                "()" === a.substring(a.length - 2) && (a = a.substring(0, a.length - 2));
                for (var c = a.split("."), d = c.pop(), e = window, f = 0; f < c.length; f++) e = e[c[f]];
                return "undefined" == typeof e[d] ? null : e[d].apply(this, b)
            }
        }, format: function (b, c) {
            a.isArray(c) || (c = [c]);
            for (var d in c) b = b.replace("%s", c[d]);
            return b
        }, date: function (a, b, c, d) {
            if (isNaN(a) || isNaN(b) || isNaN(c)) return !1;
            if (c.length > 2 || b.length > 2 || a.length > 4) return !1;
            if (c = parseInt(c, 10), b = parseInt(b, 10), a = parseInt(a, 10), 1e3 > a || a > 9999 || 0 >= b || b > 12) return !1;
            var e = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if ((a % 400 === 0 || a % 100 !== 0 && a % 4 === 0) && (e[1] = 29), 0 >= c || c > e[b - 1]) return !1;
            if (d === !0) {
                var f = new Date, g = f.getFullYear(), h = f.getMonth(), i = f.getDate();
                return g > a || a === g && h > b - 1 || a === g && b - 1 === h && i > c
            }
            return !0
        }, luhn: function (a) {
            for (var b = a.length, c = 0, d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], e = 0; b--;) e += d[c][parseInt(a.charAt(b), 10)], c ^= 1;
            return e % 10 === 0 && e > 0
        }, mod11And10: function (a) {
            for (var b = 5, c = a.length, d = 0; c > d; d++) b = (2 * (b || 10) % 11 + parseInt(a.charAt(d), 10)) % 10;
            return 1 === b
        }, mod37And36: function (a, b) {
            b = b || "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            for (var c = b.length, d = a.length, e = Math.floor(c / 2), f = 0; d > f; f++) e = (2 * (e || c) % (c + 1) + b.indexOf(a.charAt(f))) % c;
            return 1 === e
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.base64 = a.extend(a.fn.bootstrapValidator.i18n.base64 || {}, {"default": "Please enter a valid base 64 encoded"}), a.fn.bootstrapValidator.validators.base64 = {
        validate: function (a, b) {
            var c = b.val();
            return "" === c ? !0 : /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$/.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.between = a.extend(a.fn.bootstrapValidator.i18n.between || {}, {
        "default": "Please enter a value between %s and %s",
        notInclusive: "Please enter a value between %s and %s strictly"
    }), a.fn.bootstrapValidator.validators.between = {
        html5Attributes: {
            message: "message",
            min: "min",
            max: "max",
            inclusive: "inclusive"
        }, enableByHtml5: function (a) {
            return "range" === a.attr("type") ? {min: a.attr("min"), max: a.attr("max")} : !1
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            if (e = this._format(e), !a.isNumeric(e)) return !1;
            var f = a.isNumeric(d.min) ? d.min : b.getDynamicOption(c, d.min),
                g = a.isNumeric(d.max) ? d.max : b.getDynamicOption(c, d.max), h = this._format(f), i = this._format(g);
            return e = parseFloat(e), d.inclusive === !0 || void 0 === d.inclusive ? {
                valid: e >= h && i >= e,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.between["default"], [f, g])
            } : {
                valid: e > h && i > e,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.between.notInclusive, [f, g])
            }
        }, _format: function (a) {
            return (a + "").replace(",", ".")
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.validators.blank = {
        validate: function () {
            return !0
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.callback = a.extend(a.fn.bootstrapValidator.i18n.callback || {}, {"default": "Please enter a valid value"}), a.fn.bootstrapValidator.validators.callback = {
        html5Attributes: {
            message: "message",
            callback: "callback"
        }, validate: function (b, c, d) {
            var e = c.val(), f = new a.Deferred, g = {valid: !0};
            if (d.callback) {
                var h = a.fn.bootstrapValidator.helpers.call(d.callback, [e, b, c]);
                g = "boolean" == typeof h ? {valid: h} : h
            }
            return f.resolve(c, "callback", g), f
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.choice = a.extend(a.fn.bootstrapValidator.i18n.choice || {}, {
        "default": "Please enter a valid value",
        less: "Please choose %s options at minimum",
        more: "Please choose %s options at maximum",
        between: "Please choose %s - %s options"
    }), a.fn.bootstrapValidator.validators.choice = {
        html5Attributes: {message: "message", min: "min", max: "max"},
        validate: function (b, c, d) {
            var e = c.is("select") ? b.getFieldElements(c.attr("data-bv-field")).find("option").filter(":selected").length : b.getFieldElements(c.attr("data-bv-field")).filter(":checked").length,
                f = d.min ? a.isNumeric(d.min) ? d.min : b.getDynamicOption(c, d.min) : null,
                g = d.max ? a.isNumeric(d.max) ? d.max : b.getDynamicOption(c, d.max) : null, h = !0,
                i = d.message || a.fn.bootstrapValidator.i18n.choice["default"];
            switch ((f && e < parseInt(f, 10) || g && e > parseInt(g, 10)) && (h = !1), !0) {
                case!!f && !!g:
                    i = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.choice.between, [parseInt(f, 10), parseInt(g, 10)]);
                    break;
                case!!f:
                    i = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.choice.less, parseInt(f, 10));
                    break;
                case!!g:
                    i = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.choice.more, parseInt(g, 10))
            }
            return {valid: h, message: i}
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.color = a.extend(a.fn.bootstrapValidator.i18n.color || {}, {"default": "Please enter a valid color"}), a.fn.bootstrapValidator.validators.color = {
        SUPPORTED_TYPES: ["hex", "rgb", "rgba", "hsl", "hsla", "keyword"],
        KEYWORD_COLORS: ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "green", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "transparent", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = d.type || this.SUPPORTED_TYPES;
            a.isArray(f) || (f = f.replace(/s/g, "").split(","));
            for (var g, h, i = !1, j = 0; j < f.length; j++) if (h = f[j], g = "_" + h.toLowerCase(), i = i || this[g](e)) return !0;
            return !1
        },
        _hex: function (a) {
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)
        },
        _hsl: function (a) {
            return /^hsl\((\s*(-?\d+)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*)\)$/.test(a)
        },
        _hsla: function (a) {
            return /^hsla\((\s*(-?\d+)\s*,)(\s*(\b(0?\d{1,2}|100)\b%)\s*,){2}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/.test(a)
        },
        _keyword: function (b) {
            return a.inArray(b, this.KEYWORD_COLORS) >= 0
        },
        _rgb: function (a) {
            var b = /^rgb\((\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*,){2}(\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*)\)$/,
                c = /^rgb\((\s*(\b(0?\d{1,2}|100)\b%)\s*,){2}(\s*(\b(0?\d{1,2}|100)\b%)\s*)\)$/;
            return b.test(a) || c.test(a)
        },
        _rgba: function (a) {
            var b = /^rgba\((\s*(\b([01]?\d{1,2}|2[0-4]\d|25[0-5])\b)\s*,){3}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/,
                c = /^rgba\((\s*(\b(0?\d{1,2}|100)\b%)\s*,){3}(\s*(0?(\.\d+)?|1(\.0+)?)\s*)\)$/;
            return b.test(a) || c.test(a)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.creditCard = a.extend(a.fn.bootstrapValidator.i18n.creditCard || {}, {"default": "Please enter a valid credit card number"}), a.fn.bootstrapValidator.validators.creditCard = {
        validate: function (b, c) {
            var d = c.val();
            if ("" === d) return !0;
            if (/[^0-9-\s]+/.test(d)) return !1;
            if (d = d.replace(/\D/g, ""), !a.fn.bootstrapValidator.helpers.luhn(d)) return !1;
            var e, f, g = {
                AMERICAN_EXPRESS: {length: [15], prefix: ["34", "37"]},
                DINERS_CLUB: {length: [14], prefix: ["300", "301", "302", "303", "304", "305", "36"]},
                DINERS_CLUB_US: {length: [16], prefix: ["54", "55"]},
                DISCOVER: {
                    length: [16],
                    prefix: ["6011", "622126", "622127", "622128", "622129", "62213", "62214", "62215", "62216", "62217", "62218", "62219", "6222", "6223", "6224", "6225", "6226", "6227", "6228", "62290", "62291", "622920", "622921", "622922", "622923", "622924", "622925", "644", "645", "646", "647", "648", "649", "65"]
                },
                JCB: {length: [16], prefix: ["3528", "3529", "353", "354", "355", "356", "357", "358"]},
                LASER: {length: [16, 17, 18, 19], prefix: ["6304", "6706", "6771", "6709"]},
                MAESTRO: {
                    length: [12, 13, 14, 15, 16, 17, 18, 19],
                    prefix: ["5018", "5020", "5038", "6304", "6759", "6761", "6762", "6763", "6764", "6765", "6766"]
                },
                MASTERCARD: {length: [16], prefix: ["51", "52", "53", "54", "55"]},
                SOLO: {length: [16, 18, 19], prefix: ["6334", "6767"]},
                UNIONPAY: {
                    length: [16, 17, 18, 19],
                    prefix: ["622126", "622127", "622128", "622129", "62213", "62214", "62215", "62216", "62217", "62218", "62219", "6222", "6223", "6224", "6225", "6226", "6227", "6228", "62290", "62291", "622920", "622921", "622922", "622923", "622924", "622925"]
                },
                VISA: {length: [16], prefix: ["4"]}
            };
            for (e in g) for (f in g[e].prefix) if (d.substr(0, g[e].prefix[f].length) === g[e].prefix[f] && -1 !== a.inArray(d.length, g[e].length)) return !0;
            return !1
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.cusip = a.extend(a.fn.bootstrapValidator.i18n.cusip || {}, {"default": "Please enter a valid CUSIP number"}), a.fn.bootstrapValidator.validators.cusip = {
        validate: function (b, c) {
            var d = c.val();
            if ("" === d) return !0;
            if (d = d.toUpperCase(), !/^[0-9A-Z]{9}$/.test(d)) return !1;
            for (var e = a.map(d.split(""), function (a) {
                var b = a.charCodeAt(0);
                return b >= "A".charCodeAt(0) && b <= "Z".charCodeAt(0) ? b - "A".charCodeAt(0) + 10 : a
            }), f = e.length, g = 0, h = 0; f - 1 > h; h++) {
                var i = parseInt(e[h], 10);
                h % 2 !== 0 && (i *= 2), i > 9 && (i -= 9), g += i
            }
            return g = (10 - g % 10) % 10, g === e[f - 1]
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.cvv = a.extend(a.fn.bootstrapValidator.i18n.cvv || {}, {"default": "Please enter a valid CVV number"}), a.fn.bootstrapValidator.validators.cvv = {
        html5Attributes: {
            message: "message",
            ccfield: "creditCardField"
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            if (!/^[0-9]{3,4}$/.test(e)) return !1;
            if (!d.creditCardField) return !0;
            var f = b.getFieldElements(d.creditCardField).val();
            if ("" === f) return !0;
            f = f.replace(/\D/g, "");
            var g, h, i = {
                AMERICAN_EXPRESS: {length: [15], prefix: ["34", "37"]},
                DINERS_CLUB: {length: [14], prefix: ["300", "301", "302", "303", "304", "305", "36"]},
                DINERS_CLUB_US: {length: [16], prefix: ["54", "55"]},
                DISCOVER: {
                    length: [16],
                    prefix: ["6011", "622126", "622127", "622128", "622129", "62213", "62214", "62215", "62216", "62217", "62218", "62219", "6222", "6223", "6224", "6225", "6226", "6227", "6228", "62290", "62291", "622920", "622921", "622922", "622923", "622924", "622925", "644", "645", "646", "647", "648", "649", "65"]
                },
                JCB: {length: [16], prefix: ["3528", "3529", "353", "354", "355", "356", "357", "358"]},
                LASER: {length: [16, 17, 18, 19], prefix: ["6304", "6706", "6771", "6709"]},
                MAESTRO: {
                    length: [12, 13, 14, 15, 16, 17, 18, 19],
                    prefix: ["5018", "5020", "5038", "6304", "6759", "6761", "6762", "6763", "6764", "6765", "6766"]
                },
                MASTERCARD: {length: [16], prefix: ["51", "52", "53", "54", "55"]},
                SOLO: {length: [16, 18, 19], prefix: ["6334", "6767"]},
                UNIONPAY: {
                    length: [16, 17, 18, 19],
                    prefix: ["622126", "622127", "622128", "622129", "62213", "62214", "62215", "62216", "62217", "62218", "62219", "6222", "6223", "6224", "6225", "6226", "6227", "6228", "62290", "62291", "622920", "622921", "622922", "622923", "622924", "622925"]
                },
                VISA: {length: [16], prefix: ["4"]}
            }, j = null;
            for (g in i) for (h in i[g].prefix) if (f.substr(0, i[g].prefix[h].length) === i[g].prefix[h] && -1 !== a.inArray(f.length, i[g].length)) {
                j = g;
                break
            }
            return null === j ? !1 : "AMERICAN_EXPRESS" === j ? 4 === e.length : 3 === e.length
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.date = a.extend(a.fn.bootstrapValidator.i18n.date || {}, {
        "default": "Please enter a valid date",
        min: "Please enter a date after %s",
        max: "Please enter a date before %s",
        range: "Please enter a date in the range %s - %s"
    }), a.fn.bootstrapValidator.validators.date = {
        html5Attributes: {
            message: "message",
            format: "format",
            min: "min",
            max: "max",
            separator: "separator"
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            d.format = d.format || "MM/DD/YYYY", "date" === c.attr("type") && (d.format = "YYYY-MM-DD");
            var f = d.format.split(" "), g = f[0], h = f.length > 1 ? f[1] : null, i = f.length > 2 ? f[2] : null,
                j = e.split(" "), k = j[0], l = j.length > 1 ? j[1] : null;
            if (f.length !== j.length) return {
                valid: !1,
                message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
            };
            var m = d.separator;
            if (m || (m = -1 !== k.indexOf("/") ? "/" : -1 !== k.indexOf("-") ? "-" : null), null === m || -1 === k.indexOf(m)) return {
                valid: !1,
                message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
            };
            if (k = k.split(m), g = g.split(m), k.length !== g.length) return {
                valid: !1,
                message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
            };
            var n = k[a.inArray("YYYY", g)], o = k[a.inArray("MM", g)], p = k[a.inArray("DD", g)];
            if (!n || !o || !p || 4 !== n.length) return {
                valid: !1,
                message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
            };
            var q = null, r = null, s = null;
            if (h) {
                if (h = h.split(":"), l = l.split(":"), h.length !== l.length) return {
                    valid: !1,
                    message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                };
                if (r = l.length > 0 ? l[0] : null, q = l.length > 1 ? l[1] : null, s = l.length > 2 ? l[2] : null) {
                    if (isNaN(s) || s.length > 2) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    };
                    if (s = parseInt(s, 10), 0 > s || s > 60) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    }
                }
                if (r) {
                    if (isNaN(r) || r.length > 2) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    };
                    if (r = parseInt(r, 10), 0 > r || r >= 24 || i && r > 12) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    }
                }
                if (q) {
                    if (isNaN(q) || q.length > 2) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    };
                    if (q = parseInt(q, 10), 0 > q || q > 59) return {
                        valid: !1,
                        message: d.message || a.fn.bootstrapValidator.i18n.date["default"]
                    }
                }
            }
            var t = a.fn.bootstrapValidator.helpers.date(n, o, p),
                u = d.message || a.fn.bootstrapValidator.i18n.date["default"], v = null, w = null, x = d.min, y = d.max;
            switch (x && (isNaN(Date.parse(x)) && (x = b.getDynamicOption(c, x)), v = this._parseDate(x, g, m)), y && (isNaN(Date.parse(y)) && (y = b.getDynamicOption(c, y)), w = this._parseDate(y, g, m)), k = new Date(n, o, p, r, q, s), !0) {
                case x && !y && t:
                    t = k.getTime() >= v.getTime(), u = d.message || a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.date.min, x);
                    break;
                case y && !x && t:
                    t = k.getTime() <= w.getTime(), u = d.message || a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.date.max, y);
                    break;
                case y && x && t:
                    t = k.getTime() <= w.getTime() && k.getTime() >= v.getTime(), u = d.message || a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.date.range, [x, y])
            }
            return {valid: t, message: u}
        }, _parseDate: function (b, c, d) {
            var e = 0, f = 0, g = 0, h = b.split(" "), i = h[0], j = h.length > 1 ? h[1] : null;
            i = i.split(d);
            var k = i[a.inArray("YYYY", c)], l = i[a.inArray("MM", c)], m = i[a.inArray("DD", c)];
            return j && (j = j.split(":"), f = j.length > 0 ? j[0] : null, e = j.length > 1 ? j[1] : null, g = j.length > 2 ? j[2] : null), new Date(k, l, m, f, e, g)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.different = a.extend(a.fn.bootstrapValidator.i18n.different || {}, {"default": "Please enter a different value"}), a.fn.bootstrapValidator.validators.different = {
        html5Attributes: {
            message: "message",
            field: "field"
        }, validate: function (a, b, c) {
            var d = b.val();
            if ("" === d) return !0;
            for (var e = c.field.split(","), f = !0, g = 0; g < e.length; g++) {
                var h = a.getFieldElements(e[g]);
                if (null != h && 0 !== h.length) {
                    var i = h.val();
                    d === i ? f = !1 : "" !== i && a.updateStatus(h, a.STATUS_VALID, "different")
                }
            }
            return f
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.digits = a.extend(a.fn.bootstrapValidator.i18n.digits || {}, {"default": "Please enter only digits"}), a.fn.bootstrapValidator.validators.digits = {
        validate: function (a, b) {
            var c = b.val();
            return "" === c ? !0 : /^\d+$/.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.ean = a.extend(a.fn.bootstrapValidator.i18n.ean || {}, {"default": "Please enter a valid EAN number"}), a.fn.bootstrapValidator.validators.ean = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (!/^(\d{8}|\d{12}|\d{13})$/.test(c)) return !1;
            for (var d = c.length, e = 0, f = 8 === d ? [3, 1] : [1, 3], g = 0; d - 1 > g; g++) e += parseInt(c.charAt(g), 10) * f[g % 2];
            return e = (10 - e % 10) % 10, e + "" === c.charAt(d - 1)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.emailAddress = a.extend(a.fn.bootstrapValidator.i18n.emailAddress || {}, {"default": "Please enter a valid email address"}), a.fn.bootstrapValidator.validators.emailAddress = {
        html5Attributes: {
            message: "message",
            multiple: "multiple",
            separator: "separator"
        }, enableByHtml5: function (a) {
            return "email" === a.attr("type")
        }, validate: function (a, b, c) {
            var d = b.val();
            if ("" === d) return !0;
            var e = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
                f = c.multiple === !0 || "true" === c.multiple;
            if (f) {
                for (var g = c.separator || /[,;]/, h = this._splitEmailAddresses(d, g), i = 0; i < h.length; i++) if (!e.test(h[i])) return !1;
                return !0
            }
            return e.test(d)
        }, _splitEmailAddresses: function (a, b) {
            for (var c = a.split(/"/), d = c.length, e = [], f = "", g = 0; d > g; g++) if (g % 2 === 0) {
                var h = c[g].split(b), i = h.length;
                if (1 === i) f += h[0]; else {
                    e.push(f + h[0]);
                    for (var j = 1; i - 1 > j; j++) e.push(h[j]);
                    f = h[i - 1]
                }
            } else f += '"' + c[g], d - 1 > g && (f += '"');
            return e.push(f), e
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.file = a.extend(a.fn.bootstrapValidator.i18n.file || {}, {"default": "Please choose a valid file"}), a.fn.bootstrapValidator.validators.file = {
        html5Attributes: {
            extension: "extension",
            maxfiles: "maxFiles",
            minfiles: "minFiles",
            maxsize: "maxSize",
            minsize: "minSize",
            maxtotalsize: "maxTotalSize",
            mintotalsize: "minTotalSize",
            message: "message",
            type: "type"
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f, g = d.extension ? d.extension.toLowerCase().split(",") : null,
                h = d.type ? d.type.toLowerCase().split(",") : null,
                i = window.File && window.FileList && window.FileReader;
            if (i) {
                var j = c.get(0).files, k = j.length, l = 0;
                if (d.maxFiles && k > parseInt(d.maxFiles, 10) || d.minFiles && k < parseInt(d.minFiles, 10)) return !1;
                for (var m = 0; k > m; m++) if (l += j[m].size, f = j[m].name.substr(j[m].name.lastIndexOf(".") + 1), d.minSize && j[m].size < parseInt(d.minSize, 10) || d.maxSize && j[m].size > parseInt(d.maxSize, 10) || g && -1 === a.inArray(f.toLowerCase(), g) || j[m].type && h && -1 === a.inArray(j[m].type.toLowerCase(), h)) return !1;
                if (d.maxTotalSize && l > parseInt(d.maxTotalSize, 10) || d.minTotalSize && l < parseInt(d.minTotalSize, 10)) return !1
            } else if (f = e.substr(e.lastIndexOf(".") + 1), g && -1 === a.inArray(f.toLowerCase(), g)) return !1;
            return !0
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.greaterThan = a.extend(a.fn.bootstrapValidator.i18n.greaterThan || {}, {
        "default": "Please enter a value greater than or equal to %s",
        notInclusive: "Please enter a value greater than %s"
    }), a.fn.bootstrapValidator.validators.greaterThan = {
        html5Attributes: {
            message: "message",
            value: "value",
            inclusive: "inclusive"
        }, enableByHtml5: function (a) {
            var b = a.attr("type"), c = a.attr("min");
            return c && "date" !== b ? {value: c} : !1
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            if (e = this._format(e), !a.isNumeric(e)) return !1;
            var f = a.isNumeric(d.value) ? d.value : b.getDynamicOption(c, d.value), g = this._format(f);
            return e = parseFloat(e), d.inclusive === !0 || void 0 === d.inclusive ? {
                valid: e >= g,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.greaterThan["default"], f)
            } : {
                valid: e > g,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.greaterThan.notInclusive, f)
            }
        }, _format: function (a) {
            return (a + "").replace(",", ".")
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.grid = a.extend(a.fn.bootstrapValidator.i18n.grid || {}, {"default": "Please enter a valid GRId number"}), a.fn.bootstrapValidator.validators.grid = {
        validate: function (b, c) {
            var d = c.val();
            return "" === d ? !0 : (d = d.toUpperCase(), /^[GRID:]*([0-9A-Z]{2})[-\s]*([0-9A-Z]{5})[-\s]*([0-9A-Z]{10})[-\s]*([0-9A-Z]{1})$/g.test(d) ? (d = d.replace(/\s/g, "").replace(/-/g, ""), "GRID:" === d.substr(0, 5) && (d = d.substr(5)), a.fn.bootstrapValidator.helpers.mod37And36(d)) : !1)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.hex = a.extend(a.fn.bootstrapValidator.i18n.hex || {}, {"default": "Please enter a valid hexadecimal number"}), a.fn.bootstrapValidator.validators.hex = {
        validate: function (a, b) {
            var c = b.val();
            return "" === c ? !0 : /^[0-9a-fA-F]+$/.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.hexColor = a.extend(a.fn.bootstrapValidator.i18n.hexColor || {}, {"default": "Please enter a valid hex color"}), a.fn.bootstrapValidator.validators.hexColor = {
        enableByHtml5: function (a) {
            return "color" === a.attr("type")
        }, validate: function (a, b) {
            var c = b.val();
            return "" === c ? !0 : "color" === b.attr("type") ? /^#[0-9A-F]{6}$/i.test(c) : /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.iban = a.extend(a.fn.bootstrapValidator.i18n.iban || {}, {
        "default": "Please enter a valid IBAN number",
        countryNotSupported: "The country code %s is not supported",
        country: "Please enter a valid IBAN number in %s",
        countries: {
            AD: "Andorra",
            AE: "United Arab Emirates",
            AL: "Albania",
            AO: "Angola",
            AT: "Austria",
            AZ: "Azerbaijan",
            BA: "Bosnia and Herzegovina",
            BE: "Belgium",
            BF: "Burkina Faso",
            BG: "Bulgaria",
            BH: "Bahrain",
            BI: "Burundi",
            BJ: "Benin",
            BR: "Brazil",
            CH: "Switzerland",
            CI: "Ivory Coast",
            CM: "Cameroon",
            CR: "Costa Rica",
            CV: "Cape Verde",
            CY: "Cyprus",
            CZ: "Czech Republic",
            DE: "Germany",
            DK: "Denmark",
            DO: "Dominican Republic",
            DZ: "Algeria",
            EE: "Estonia",
            ES: "Spain",
            FI: "Finland",
            FO: "Faroe Islands",
            FR: "France",
            GB: "United Kingdom",
            GE: "Georgia",
            GI: "Gibraltar",
            GL: "Greenland",
            GR: "Greece",
            GT: "Guatemala",
            HR: "Croatia",
            HU: "Hungary",
            IE: "Ireland",
            IL: "Israel",
            IR: "Iran",
            IS: "Iceland",
            IT: "Italy",
            JO: "Jordan",
            KW: "Kuwait",
            KZ: "Kazakhstan",
            LB: "Lebanon",
            LI: "Liechtenstein",
            LT: "Lithuania",
            LU: "Luxembourg",
            LV: "Latvia",
            MC: "Monaco",
            MD: "Moldova",
            ME: "Montenegro",
            MG: "Madagascar",
            MK: "Macedonia",
            ML: "Mali",
            MR: "Mauritania",
            MT: "Malta",
            MU: "Mauritius",
            MZ: "Mozambique",
            NL: "Netherlands",
            NO: "Norway",
            PK: "Pakistan",
            PL: "Poland",
            PS: "Palestine",
            PT: "Portugal",
            QA: "Qatar",
            RO: "Romania",
            RS: "Serbia",
            SA: "Saudi Arabia",
            SE: "Sweden",
            SI: "Slovenia",
            SK: "Slovakia",
            SM: "San Marino",
            SN: "Senegal",
            TN: "Tunisia",
            TR: "Turkey",
            VG: "Virgin Islands, British"
        }
    }), a.fn.bootstrapValidator.validators.iban = {
        html5Attributes: {message: "message", country: "country"},
        REGEX: {
            AD: "AD[0-9]{2}[0-9]{4}[0-9]{4}[A-Z0-9]{12}",
            AE: "AE[0-9]{2}[0-9]{3}[0-9]{16}",
            AL: "AL[0-9]{2}[0-9]{8}[A-Z0-9]{16}",
            AO: "AO[0-9]{2}[0-9]{21}",
            AT: "AT[0-9]{2}[0-9]{5}[0-9]{11}",
            AZ: "AZ[0-9]{2}[A-Z]{4}[A-Z0-9]{20}",
            BA: "BA[0-9]{2}[0-9]{3}[0-9]{3}[0-9]{8}[0-9]{2}",
            BE: "BE[0-9]{2}[0-9]{3}[0-9]{7}[0-9]{2}",
            BF: "BF[0-9]{2}[0-9]{23}",
            BG: "BG[0-9]{2}[A-Z]{4}[0-9]{4}[0-9]{2}[A-Z0-9]{8}",
            BH: "BH[0-9]{2}[A-Z]{4}[A-Z0-9]{14}",
            BI: "BI[0-9]{2}[0-9]{12}",
            BJ: "BJ[0-9]{2}[A-Z]{1}[0-9]{23}",
            BR: "BR[0-9]{2}[0-9]{8}[0-9]{5}[0-9]{10}[A-Z][A-Z0-9]",
            CH: "CH[0-9]{2}[0-9]{5}[A-Z0-9]{12}",
            CI: "CI[0-9]{2}[A-Z]{1}[0-9]{23}",
            CM: "CM[0-9]{2}[0-9]{23}",
            CR: "CR[0-9]{2}[0-9]{3}[0-9]{14}",
            CV: "CV[0-9]{2}[0-9]{21}",
            CY: "CY[0-9]{2}[0-9]{3}[0-9]{5}[A-Z0-9]{16}",
            CZ: "CZ[0-9]{2}[0-9]{20}",
            DE: "DE[0-9]{2}[0-9]{8}[0-9]{10}",
            DK: "DK[0-9]{2}[0-9]{14}",
            DO: "DO[0-9]{2}[A-Z0-9]{4}[0-9]{20}",
            DZ: "DZ[0-9]{2}[0-9]{20}",
            EE: "EE[0-9]{2}[0-9]{2}[0-9]{2}[0-9]{11}[0-9]{1}",
            ES: "ES[0-9]{2}[0-9]{4}[0-9]{4}[0-9]{1}[0-9]{1}[0-9]{10}",
            FI: "FI[0-9]{2}[0-9]{6}[0-9]{7}[0-9]{1}",
            FO: "FO[0-9]{2}[0-9]{4}[0-9]{9}[0-9]{1}",
            FR: "FR[0-9]{2}[0-9]{5}[0-9]{5}[A-Z0-9]{11}[0-9]{2}",
            GB: "GB[0-9]{2}[A-Z]{4}[0-9]{6}[0-9]{8}",
            GE: "GE[0-9]{2}[A-Z]{2}[0-9]{16}",
            GI: "GI[0-9]{2}[A-Z]{4}[A-Z0-9]{15}",
            GL: "GL[0-9]{2}[0-9]{4}[0-9]{9}[0-9]{1}",
            GR: "GR[0-9]{2}[0-9]{3}[0-9]{4}[A-Z0-9]{16}",
            GT: "GT[0-9]{2}[A-Z0-9]{4}[A-Z0-9]{20}",
            HR: "HR[0-9]{2}[0-9]{7}[0-9]{10}",
            HU: "HU[0-9]{2}[0-9]{3}[0-9]{4}[0-9]{1}[0-9]{15}[0-9]{1}",
            IE: "IE[0-9]{2}[A-Z]{4}[0-9]{6}[0-9]{8}",
            IL: "IL[0-9]{2}[0-9]{3}[0-9]{3}[0-9]{13}",
            IR: "IR[0-9]{2}[0-9]{22}",
            IS: "IS[0-9]{2}[0-9]{4}[0-9]{2}[0-9]{6}[0-9]{10}",
            IT: "IT[0-9]{2}[A-Z]{1}[0-9]{5}[0-9]{5}[A-Z0-9]{12}",
            JO: "JO[0-9]{2}[A-Z]{4}[0-9]{4}[0]{8}[A-Z0-9]{10}",
            KW: "KW[0-9]{2}[A-Z]{4}[0-9]{22}",
            KZ: "KZ[0-9]{2}[0-9]{3}[A-Z0-9]{13}",
            LB: "LB[0-9]{2}[0-9]{4}[A-Z0-9]{20}",
            LI: "LI[0-9]{2}[0-9]{5}[A-Z0-9]{12}",
            LT: "LT[0-9]{2}[0-9]{5}[0-9]{11}",
            LU: "LU[0-9]{2}[0-9]{3}[A-Z0-9]{13}",
            LV: "LV[0-9]{2}[A-Z]{4}[A-Z0-9]{13}",
            MC: "MC[0-9]{2}[0-9]{5}[0-9]{5}[A-Z0-9]{11}[0-9]{2}",
            MD: "MD[0-9]{2}[A-Z0-9]{20}",
            ME: "ME[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}",
            MG: "MG[0-9]{2}[0-9]{23}",
            MK: "MK[0-9]{2}[0-9]{3}[A-Z0-9]{10}[0-9]{2}",
            ML: "ML[0-9]{2}[A-Z]{1}[0-9]{23}",
            MR: "MR13[0-9]{5}[0-9]{5}[0-9]{11}[0-9]{2}",
            MT: "MT[0-9]{2}[A-Z]{4}[0-9]{5}[A-Z0-9]{18}",
            MU: "MU[0-9]{2}[A-Z]{4}[0-9]{2}[0-9]{2}[0-9]{12}[0-9]{3}[A-Z]{3}",
            MZ: "MZ[0-9]{2}[0-9]{21}",
            NL: "NL[0-9]{2}[A-Z]{4}[0-9]{10}",
            NO: "NO[0-9]{2}[0-9]{4}[0-9]{6}[0-9]{1}",
            PK: "PK[0-9]{2}[A-Z]{4}[A-Z0-9]{16}",
            PL: "PL[0-9]{2}[0-9]{8}[0-9]{16}",
            PS: "PS[0-9]{2}[A-Z]{4}[A-Z0-9]{21}",
            PT: "PT[0-9]{2}[0-9]{4}[0-9]{4}[0-9]{11}[0-9]{2}",
            QA: "QA[0-9]{2}[A-Z]{4}[A-Z0-9]{21}",
            RO: "RO[0-9]{2}[A-Z]{4}[A-Z0-9]{16}",
            RS: "RS[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}",
            SA: "SA[0-9]{2}[0-9]{2}[A-Z0-9]{18}",
            SE: "SE[0-9]{2}[0-9]{3}[0-9]{16}[0-9]{1}",
            SI: "SI[0-9]{2}[0-9]{5}[0-9]{8}[0-9]{2}",
            SK: "SK[0-9]{2}[0-9]{4}[0-9]{6}[0-9]{10}",
            SM: "SM[0-9]{2}[A-Z]{1}[0-9]{5}[0-9]{5}[A-Z0-9]{12}",
            SN: "SN[0-9]{2}[A-Z]{1}[0-9]{23}",
            TN: "TN59[0-9]{2}[0-9]{3}[0-9]{13}[0-9]{2}",
            TR: "TR[0-9]{2}[0-9]{5}[A-Z0-9]{1}[A-Z0-9]{16}",
            VG: "VG[0-9]{2}[A-Z]{4}[0-9]{16}"
        },
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            e = e.replace(/[^a-zA-Z0-9]/g, "").toUpperCase();
            var f = d.country;
            if (f ? "string" == typeof f && this.REGEX[f] || (f = b.getDynamicOption(c, f)) : f = e.substr(0, 2), !this.REGEX[f]) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.iban.countryNotSupported, f)
            };
            if (!new RegExp("^" + this.REGEX[f] + "$").test(e)) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.iban.country, a.fn.bootstrapValidator.i18n.iban.countries[f])
            };
            e = e.substr(4) + e.substr(0, 4), e = a.map(e.split(""), function (a) {
                var b = a.charCodeAt(0);
                return b >= "A".charCodeAt(0) && b <= "Z".charCodeAt(0) ? b - "A".charCodeAt(0) + 10 : a
            }), e = e.join("");
            for (var g = parseInt(e.substr(0, 1), 10), h = e.length, i = 1; h > i; ++i) g = (10 * g + parseInt(e.substr(i, 1), 10)) % 97;
            return {
                valid: 1 === g,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.iban.country, a.fn.bootstrapValidator.i18n.iban.countries[f])
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.id = a.extend(a.fn.bootstrapValidator.i18n.id || {}, {
        "default": "Please enter a valid identification number",
        countryNotSupported: "The country code %s is not supported",
        country: "Please enter a valid identification number in %s",
        countries: {
            BA: "Bosnia and Herzegovina",
            BG: "Bulgaria",
            BR: "Brazil",
            CH: "Switzerland",
            CL: "Chile",
            CN: "China",
            CZ: "Czech Republic",
            DK: "Denmark",
            EE: "Estonia",
            ES: "Spain",
            FI: "Finland",
            HR: "Croatia",
            IE: "Ireland",
            IS: "Iceland",
            LT: "Lithuania",
            LV: "Latvia",
            ME: "Montenegro",
            MK: "Macedonia",
            NL: "Netherlands",
            RO: "Romania",
            RS: "Serbia",
            SE: "Sweden",
            SI: "Slovenia",
            SK: "Slovakia",
            SM: "San Marino",
            TH: "Thailand",
            ZA: "South Africa"
        }
    }), a.fn.bootstrapValidator.validators.id = {
        html5Attributes: {message: "message", country: "country"},
        COUNTRY_CODES: ["BA", "BG", "BR", "CH", "CL", "CN", "CZ", "DK", "EE", "ES", "FI", "HR", "IE", "IS", "LT", "LV", "ME", "MK", "NL", "RO", "RS", "SE", "SI", "SK", "SM", "TH", "ZA"],
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = d.country;
            if (f ? ("string" != typeof f || -1 === a.inArray(f.toUpperCase(), this.COUNTRY_CODES)) && (f = b.getDynamicOption(c, f)) : f = e.substr(0, 2), -1 === a.inArray(f, this.COUNTRY_CODES)) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.id.countryNotSupported, f)
            };
            var g = ["_", f.toLowerCase()].join("");
            return this[g](e) ? !0 : {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.id.country, a.fn.bootstrapValidator.i18n.id.countries[f.toUpperCase()])
            }
        },
        _validateJMBG: function (a, b) {
            if (!/^\d{13}$/.test(a)) return !1;
            var c = parseInt(a.substr(0, 2), 10), d = parseInt(a.substr(2, 2), 10),
                e = (parseInt(a.substr(4, 3), 10), parseInt(a.substr(7, 2), 10)), f = parseInt(a.substr(12, 1), 10);
            if (c > 31 || d > 12) return !1;
            for (var g = 0, h = 0; 6 > h; h++) g += (7 - h) * (parseInt(a.charAt(h), 10) + parseInt(a.charAt(h + 6), 10));
            if (g = 11 - g % 11, (10 === g || 11 === g) && (g = 0), g !== f) return !1;
            switch (b.toUpperCase()) {
                case"BA":
                    return e >= 10 && 19 >= e;
                case"MK":
                    return e >= 41 && 49 >= e;
                case"ME":
                    return e >= 20 && 29 >= e;
                case"RS":
                    return e >= 70 && 99 >= e;
                case"SI":
                    return e >= 50 && 59 >= e;
                default:
                    return !0
            }
        },
        _ba: function (a) {
            return this._validateJMBG(a, "BA")
        },
        _mk: function (a) {
            return this._validateJMBG(a, "MK")
        },
        _me: function (a) {
            return this._validateJMBG(a, "ME")
        },
        _rs: function (a) {
            return this._validateJMBG(a, "RS")
        },
        _si: function (a) {
            return this._validateJMBG(a, "SI")
        },
        _bg: function (b) {
            if (!/^\d{10}$/.test(b) && !/^\d{6}\s\d{3}\s\d{1}$/.test(b)) return !1;
            b = b.replace(/\s/g, "");
            var c = parseInt(b.substr(0, 2), 10) + 1900, d = parseInt(b.substr(2, 2), 10),
                e = parseInt(b.substr(4, 2), 10);
            if (d > 40 ? (c += 100, d -= 40) : d > 20 && (c -= 100, d -= 20), !a.fn.bootstrapValidator.helpers.date(c, d, e)) return !1;
            for (var f = 0, g = [2, 4, 8, 5, 10, 9, 7, 3, 6], h = 0; 9 > h; h++) f += parseInt(b.charAt(h), 10) * g[h];
            return f = f % 11 % 10, f + "" === b.substr(9, 1)
        },
        _br: function (a) {
            if (/^1{11}|2{11}|3{11}|4{11}|5{11}|6{11}|7{11}|8{11}|9{11}|0{11}$/.test(a)) return !1;
            if (!/^\d{11}$/.test(a) && !/^\d{3}\.\d{3}\.\d{3}-\d{2}$/.test(a)) return !1;
            a = a.replace(/\./g, "").replace(/-/g, "");
            for (var b = 0, c = 0; 9 > c; c++) b += (10 - c) * parseInt(a.charAt(c), 10);
            if (b = 11 - b % 11, (10 === b || 11 === b) && (b = 0), b + "" !== a.charAt(9)) return !1;
            var d = 0;
            for (c = 0; 10 > c; c++) d += (11 - c) * parseInt(a.charAt(c), 10);
            return d = 11 - d % 11, (10 === d || 11 === d) && (d = 0), d + "" === a.charAt(10)
        },
        _ch: function (a) {
            if (!/^756[\.]{0,1}[0-9]{4}[\.]{0,1}[0-9]{4}[\.]{0,1}[0-9]{2}$/.test(a)) return !1;
            a = a.replace(/\D/g, "").substr(3);
            for (var b = a.length, c = 0, d = 8 === b ? [3, 1] : [1, 3], e = 0; b - 1 > e; e++) c += parseInt(a.charAt(e), 10) * d[e % 2];
            return c = 10 - c % 10, c + "" === a.charAt(b - 1)
        },
        _cl: function (a) {
            if (!/^\d{7,8}[-]{0,1}[0-9K]$/i.test(a)) return !1;
            for (a = a.replace(/\-/g, ""); a.length < 9;) a = "0" + a;
            for (var b = 0, c = [3, 2, 7, 6, 5, 4, 3, 2], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = 11 - b % 11, 11 === b ? b = 0 : 10 === b && (b = "K"), b + "" === a.charAt(8).toUpperCase()
        },
        _cn: function (b) {
            if (b = b.trim(), !/^\d{15}$/.test(b) && !/^\d{17}[\dXx]{1}$/.test(b)) return !1;
            var c = {
                11: {0: [0], 1: [[0, 9], [11, 17]], 2: [0, 28, 29]},
                12: {0: [0], 1: [[0, 16]], 2: [0, 21, 23, 25]},
                13: {
                    0: [0],
                    1: [[0, 5], 7, 8, 21, [23, 33], [81, 85]],
                    2: [[0, 5], [7, 9], [23, 25], 27, 29, 30, 81, 83],
                    3: [[0, 4], [21, 24]],
                    4: [[0, 4], 6, 21, [23, 35], 81],
                    5: [[0, 3], [21, 35], 81, 82],
                    6: [[0, 4], [21, 38], [81, 84]],
                    7: [[0, 3], 5, 6, [21, 33]],
                    8: [[0, 4], [21, 28]],
                    9: [[0, 3], [21, 30], [81, 84]],
                    10: [[0, 3], [22, 26], 28, 81, 82],
                    11: [[0, 2], [21, 28], 81, 82]
                },
                14: {
                    0: [0],
                    1: [0, 1, [5, 10], [21, 23], 81],
                    2: [[0, 3], 11, 12, [21, 27]],
                    3: [[0, 3], 11, 21, 22],
                    4: [[0, 2], 11, 21, [23, 31], 81],
                    5: [[0, 2], 21, 22, 24, 25, 81],
                    6: [[0, 3], [21, 24]],
                    7: [[0, 2], [21, 29], 81],
                    8: [[0, 2], [21, 30], 81, 82],
                    9: [[0, 2], [21, 32], 81],
                    10: [[0, 2], [21, 34], 81, 82],
                    11: [[0, 2], [21, 30], 81, 82],
                    23: [[0, 3], 22, 23, [25, 30], 32, 33]
                },
                15: {
                    0: [0],
                    1: [[0, 5], [21, 25]],
                    2: [[0, 7], [21, 23]],
                    3: [[0, 4]],
                    4: [[0, 4], [21, 26], [28, 30]],
                    5: [[0, 2], [21, 26], 81],
                    6: [[0, 2], [21, 27]],
                    7: [[0, 3], [21, 27], [81, 85]],
                    8: [[0, 2], [21, 26]],
                    9: [[0, 2], [21, 29], 81],
                    22: [[0, 2], [21, 24]],
                    25: [[0, 2], [22, 31]],
                    26: [[0, 2], [24, 27], [29, 32], 34],
                    28: [0, 1, [22, 27]],
                    29: [0, [21, 23]]
                },
                21: {
                    0: [0],
                    1: [[0, 6], [11, 14], [22, 24], 81],
                    2: [[0, 4], [11, 13], 24, [81, 83]],
                    3: [[0, 4], 11, 21, 23, 81],
                    4: [[0, 4], 11, [21, 23]],
                    5: [[0, 5], 21, 22],
                    6: [[0, 4], 24, 81, 82],
                    7: [[0, 3], 11, 26, 27, 81, 82],
                    8: [[0, 4], 11, 81, 82],
                    9: [[0, 5], 11, 21, 22],
                    10: [[0, 5], 11, 21, 81],
                    11: [[0, 3], 21, 22],
                    12: [[0, 2], 4, 21, 23, 24, 81, 82],
                    13: [[0, 3], 21, 22, 24, 81, 82],
                    14: [[0, 4], 21, 22, 81]
                },
                22: {
                    0: [0],
                    1: [[0, 6], 12, 22, [81, 83]],
                    2: [[0, 4], 11, 21, [81, 84]],
                    3: [[0, 3], 22, 23, 81, 82],
                    4: [[0, 3], 21, 22],
                    5: [[0, 3], 21, 23, 24, 81, 82],
                    6: [[0, 2], 4, 5, [21, 23], 25, 81],
                    7: [[0, 2], [21, 24], 81],
                    8: [[0, 2], 21, 22, 81, 82],
                    24: [[0, 6], 24, 26]
                },
                23: {
                    0: [0],
                    1: [[0, 12], 21, [23, 29], [81, 84]],
                    2: [[0, 8], 21, [23, 25], 27, [29, 31], 81],
                    3: [[0, 7], 21, 81, 82],
                    4: [[0, 7], 21, 22],
                    5: [[0, 3], 5, 6, [21, 24]],
                    6: [[0, 6], [21, 24]],
                    7: [[0, 16], 22, 81],
                    8: [[0, 5], 11, 22, 26, 28, 33, 81, 82],
                    9: [[0, 4], 21],
                    10: [[0, 5], 24, 25, 81, [83, 85]],
                    11: [[0, 2], 21, 23, 24, 81, 82],
                    12: [[0, 2], [21, 26], [81, 83]],
                    27: [[0, 4], [21, 23]]
                },
                31: {0: [0], 1: [0, 1, [3, 10], [12, 20]], 2: [0, 30]},
                32: {
                    0: [0],
                    1: [[0, 7], 11, [13, 18], 24, 25],
                    2: [[0, 6], 11, 81, 82],
                    3: [[0, 5], 11, 12, [21, 24], 81, 82],
                    4: [[0, 2], 4, 5, 11, 12, 81, 82],
                    5: [[0, 9], [81, 85]],
                    6: [[0, 2], 11, 12, 21, 23, [81, 84]],
                    7: [0, 1, 3, 5, 6, [21, 24]],
                    8: [[0, 4], 11, 26, [29, 31]],
                    9: [[0, 3], [21, 25], 28, 81, 82],
                    10: [[0, 3], 11, 12, 23, 81, 84, 88],
                    11: [[0, 2], 11, 12, [81, 83]],
                    12: [[0, 4], [81, 84]],
                    13: [[0, 2], 11, [21, 24]]
                },
                33: {
                    0: [0],
                    1: [[0, 6], [8, 10], 22, 27, 82, 83, 85],
                    2: [0, 1, [3, 6], 11, 12, 25, 26, [81, 83]],
                    3: [[0, 4], 22, 24, [26, 29], 81, 82],
                    4: [[0, 2], 11, 21, 24, [81, 83]],
                    5: [[0, 3], [21, 23]],
                    6: [[0, 2], 21, 24, [81, 83]],
                    7: [[0, 3], 23, 26, 27, [81, 84]],
                    8: [[0, 3], 22, 24, 25, 81],
                    9: [[0, 3], 21, 22],
                    10: [[0, 4], [21, 24], 81, 82],
                    11: [[0, 2], [21, 27], 81]
                },
                34: {
                    0: [0],
                    1: [[0, 4], 11, [21, 24], 81],
                    2: [[0, 4], 7, 8, [21, 23], 25],
                    3: [[0, 4], 11, [21, 23]],
                    4: [[0, 6], 21],
                    5: [[0, 4], 6, [21, 23]],
                    6: [[0, 4], 21],
                    7: [[0, 3], 11, 21],
                    8: [[0, 3], 11, [22, 28], 81],
                    10: [[0, 4], [21, 24]],
                    11: [[0, 3], 22, [24, 26], 81, 82],
                    12: [[0, 4], 21, 22, 25, 26, 82],
                    13: [[0, 2], [21, 24]],
                    14: [[0, 2], [21, 24]],
                    15: [[0, 3], [21, 25]],
                    16: [[0, 2], [21, 23]],
                    17: [[0, 2], [21, 23]],
                    18: [[0, 2], [21, 25], 81]
                },
                35: {
                    0: [0],
                    1: [[0, 5], 11, [21, 25], 28, 81, 82],
                    2: [[0, 6], [11, 13]],
                    3: [[0, 5], 22],
                    4: [[0, 3], 21, [23, 30], 81],
                    5: [[0, 5], 21, [24, 27], [81, 83]],
                    6: [[0, 3], [22, 29], 81],
                    7: [[0, 2], [21, 25], [81, 84]],
                    8: [[0, 2], [21, 25], 81],
                    9: [[0, 2], [21, 26], 81, 82]
                },
                36: {
                    0: [0],
                    1: [[0, 5], 11, [21, 24]],
                    2: [[0, 3], 22, 81],
                    3: [[0, 2], 13, [21, 23]],
                    4: [[0, 3], 21, [23, 30], 81, 82],
                    5: [[0, 2], 21],
                    6: [[0, 2], 22, 81],
                    7: [[0, 2], [21, 35], 81, 82],
                    8: [[0, 3], [21, 30], 81],
                    9: [[0, 2], [21, 26], [81, 83]],
                    10: [[0, 2], [21, 30]],
                    11: [[0, 2], [21, 30], 81]
                },
                37: {
                    0: [0],
                    1: [[0, 5], 12, 13, [24, 26], 81],
                    2: [[0, 3], 5, [11, 14], [81, 85]],
                    3: [[0, 6], [21, 23]],
                    4: [[0, 6], 81],
                    5: [[0, 3], [21, 23]],
                    6: [[0, 2], [11, 13], 34, [81, 87]],
                    7: [[0, 5], 24, 25, [81, 86]],
                    8: [[0, 2], 11, [26, 32], [81, 83]],
                    9: [[0, 3], 11, 21, 23, 82, 83],
                    10: [[0, 2], [81, 83]],
                    11: [[0, 3], 21, 22],
                    12: [[0, 3]],
                    13: [[0, 2], 11, 12, [21, 29]],
                    14: [[0, 2], [21, 28], 81, 82],
                    15: [[0, 2], [21, 26], 81],
                    16: [[0, 2], [21, 26]],
                    17: [[0, 2], [21, 28]]
                },
                41: {
                    0: [0],
                    1: [[0, 6], 8, 22, [81, 85]],
                    2: [[0, 5], 11, [21, 25]],
                    3: [[0, 7], 11, [22, 29], 81],
                    4: [[0, 4], 11, [21, 23], 25, 81, 82],
                    5: [[0, 3], 5, 6, 22, 23, 26, 27, 81],
                    6: [[0, 3], 11, 21, 22],
                    7: [[0, 4], 11, 21, [24, 28], 81, 82],
                    8: [[0, 4], 11, [21, 23], 25, [81, 83]],
                    9: [[0, 2], 22, 23, [26, 28]],
                    10: [[0, 2], [23, 25], 81, 82],
                    11: [[0, 4], [21, 23]],
                    12: [[0, 2], 21, 22, 24, 81, 82],
                    13: [[0, 3], [21, 30], 81],
                    14: [[0, 3], [21, 26], 81],
                    15: [[0, 3], [21, 28]],
                    16: [[0, 2], [21, 28], 81],
                    17: [[0, 2], [21, 29]],
                    90: [0, 1]
                },
                42: {
                    0: [0],
                    1: [[0, 7], [11, 17]],
                    2: [[0, 5], 22, 81],
                    3: [[0, 3], [21, 25], 81],
                    5: [[0, 6], [25, 29], [81, 83]],
                    6: [[0, 2], 6, 7, [24, 26], [82, 84]],
                    7: [[0, 4]],
                    8: [[0, 2], 4, 21, 22, 81],
                    9: [[0, 2], [21, 23], 81, 82, 84],
                    10: [[0, 3], [22, 24], 81, 83, 87],
                    11: [[0, 2], [21, 27], 81, 82],
                    12: [[0, 2], [21, 24], 81],
                    13: [[0, 3], 21, 81],
                    28: [[0, 2], 22, 23, [25, 28]],
                    90: [0, [4, 6], 21]
                },
                43: {
                    0: [0],
                    1: [[0, 5], 11, 12, 21, 22, 24, 81],
                    2: [[0, 4], 11, 21, [23, 25], 81],
                    3: [[0, 2], 4, 21, 81, 82],
                    4: [0, 1, [5, 8], 12, [21, 24], 26, 81, 82],
                    5: [[0, 3], 11, [21, 25], [27, 29], 81],
                    6: [[0, 3], 11, 21, 23, 24, 26, 81, 82],
                    7: [[0, 3], [21, 26], 81],
                    8: [[0, 2], 11, 21, 22],
                    9: [[0, 3], [21, 23], 81],
                    10: [[0, 3], [21, 28], 81],
                    11: [[0, 3], [21, 29]],
                    12: [[0, 2], [21, 30], 81],
                    13: [[0, 2], 21, 22, 81, 82],
                    31: [0, 1, [22, 27], 30]
                },
                44: {
                    0: [0],
                    1: [[0, 7], [11, 16], 83, 84],
                    2: [[0, 5], 21, 22, 24, 29, 32, 33, 81, 82],
                    3: [0, 1, [3, 8]],
                    4: [[0, 4]],
                    5: [0, 1, [6, 15], 23, 82, 83],
                    6: [0, 1, [4, 8]],
                    7: [0, 1, [3, 5], 81, [83, 85]],
                    8: [[0, 4], 11, 23, 25, [81, 83]],
                    9: [[0, 3], 23, [81, 83]],
                    12: [[0, 3], [23, 26], 83, 84],
                    13: [[0, 3], [22, 24], 81],
                    14: [[0, 2], [21, 24], 26, 27, 81],
                    15: [[0, 2], 21, 23, 81],
                    16: [[0, 2], [21, 25]],
                    17: [[0, 2], 21, 23, 81],
                    18: [[0, 3], 21, 23, [25, 27], 81, 82],
                    19: [0],
                    20: [0],
                    51: [[0, 3], 21, 22],
                    52: [[0, 3], 21, 22, 24, 81],
                    53: [[0, 2], [21, 23], 81]
                },
                45: {
                    0: [0],
                    1: [[0, 9], [21, 27]],
                    2: [[0, 5], [21, 26]],
                    3: [[0, 5], 11, 12, [21, 32]],
                    4: [0, 1, [3, 6], 11, [21, 23], 81],
                    5: [[0, 3], 12, 21],
                    6: [[0, 3], 21, 81],
                    7: [[0, 3], 21, 22],
                    8: [[0, 4], 21, 81],
                    9: [[0, 3], [21, 24], 81],
                    10: [[0, 2], [21, 31]],
                    11: [[0, 2], [21, 23]],
                    12: [[0, 2], [21, 29], 81],
                    13: [[0, 2], [21, 24], 81],
                    14: [[0, 2], [21, 25], 81]
                },
                46: {0: [0], 1: [0, 1, [5, 8]], 2: [0, 1], 3: [0, [21, 23]], 90: [[0, 3], [5, 7], [21, 39]]},
                50: {0: [0], 1: [[0, 19]], 2: [0, [22, 38], [40, 43]], 3: [0, [81, 84]]},
                51: {
                    0: [0],
                    1: [0, 1, [4, 8], [12, 15], [21, 24], 29, 31, 32, [81, 84]],
                    3: [[0, 4], 11, 21, 22],
                    4: [[0, 3], 11, 21, 22],
                    5: [[0, 4], 21, 22, 24, 25],
                    6: [0, 1, 3, 23, 26, [81, 83]],
                    7: [0, 1, 3, 4, [22, 27], 81],
                    8: [[0, 2], 11, 12, [21, 24]],
                    9: [[0, 4], [21, 23]],
                    10: [[0, 2], 11, 24, 25, 28],
                    11: [[0, 2], [11, 13], 23, 24, 26, 29, 32, 33, 81],
                    13: [[0, 4], [21, 25], 81],
                    14: [[0, 2], [21, 25]],
                    15: [[0, 3], [21, 29]],
                    16: [[0, 3], [21, 23], 81],
                    17: [[0, 3], [21, 25], 81],
                    18: [[0, 3], [21, 27]],
                    19: [[0, 3], [21, 23]],
                    20: [[0, 2], 21, 22, 81],
                    32: [0, [21, 33]],
                    33: [0, [21, 38]],
                    34: [0, 1, [22, 37]]
                },
                52: {
                    0: [0],
                    1: [[0, 3], [11, 15], [21, 23], 81],
                    2: [0, 1, 3, 21, 22],
                    3: [[0, 3], [21, 30], 81, 82],
                    4: [[0, 2], [21, 25]],
                    5: [[0, 2], [21, 27]],
                    6: [[0, 3], [21, 28]],
                    22: [0, 1, [22, 30]],
                    23: [0, 1, [22, 28]],
                    24: [0, 1, [22, 28]],
                    26: [0, 1, [22, 36]],
                    27: [[0, 2], 22, 23, [25, 32]]
                },
                53: {
                    0: [0],
                    1: [[0, 3], [11, 14], 21, 22, [24, 29], 81],
                    3: [[0, 2], [21, 26], 28, 81],
                    4: [[0, 2], [21, 28]],
                    5: [[0, 2], [21, 24]],
                    6: [[0, 2], [21, 30]],
                    7: [[0, 2], [21, 24]],
                    8: [[0, 2], [21, 29]],
                    9: [[0, 2], [21, 27]],
                    23: [0, 1, [22, 29], 31],
                    25: [[0, 4], [22, 32]],
                    26: [0, 1, [21, 28]],
                    27: [0, 1, [22, 30]],
                    28: [0, 1, 22, 23],
                    29: [0, 1, [22, 32]],
                    31: [0, 2, 3, [22, 24]],
                    34: [0, [21, 23]],
                    33: [0, 21, [23, 25]],
                    35: [0, [21, 28]]
                },
                54: {
                    0: [0],
                    1: [[0, 2], [21, 27]],
                    21: [0, [21, 29], 32, 33],
                    22: [0, [21, 29], [31, 33]],
                    23: [0, 1, [22, 38]],
                    24: [0, [21, 31]],
                    25: [0, [21, 27]],
                    26: [0, [21, 27]]
                },
                61: {
                    0: [0],
                    1: [[0, 4], [11, 16], 22, [24, 26]],
                    2: [[0, 4], 22],
                    3: [[0, 4], [21, 24], [26, 31]],
                    4: [[0, 4], [22, 31], 81],
                    5: [[0, 2], [21, 28], 81, 82],
                    6: [[0, 2], [21, 32]],
                    7: [[0, 2], [21, 30]],
                    8: [[0, 2], [21, 31]],
                    9: [[0, 2], [21, 29]],
                    10: [[0, 2], [21, 26]]
                },
                62: {
                    0: [0],
                    1: [[0, 5], 11, [21, 23]],
                    2: [0, 1],
                    3: [[0, 2], 21],
                    4: [[0, 3], [21, 23]],
                    5: [[0, 3], [21, 25]],
                    6: [[0, 2], [21, 23]],
                    7: [[0, 2], [21, 25]],
                    8: [[0, 2], [21, 26]],
                    9: [[0, 2], [21, 24], 81, 82],
                    10: [[0, 2], [21, 27]],
                    11: [[0, 2], [21, 26]],
                    12: [[0, 2], [21, 28]],
                    24: [0, 21, [24, 29]],
                    26: [0, 21, [23, 30]],
                    29: [0, 1, [21, 27]],
                    30: [0, 1, [21, 27]]
                },
                63: {
                    0: [0],
                    1: [[0, 5], [21, 23]],
                    2: [0, 2, [21, 25]],
                    21: [0, [21, 23], [26, 28]],
                    22: [0, [21, 24]],
                    23: [0, [21, 24]],
                    25: [0, [21, 25]],
                    26: [0, [21, 26]],
                    27: [0, 1, [21, 26]],
                    28: [[0, 2], [21, 23]]
                },
                64: {
                    0: [0],
                    1: [0, 1, [4, 6], 21, 22, 81],
                    2: [[0, 3], 5, [21, 23]],
                    3: [[0, 3], [21, 24], 81],
                    4: [[0, 2], [21, 25]],
                    5: [[0, 2], 21, 22]
                },
                65: {
                    0: [0],
                    1: [[0, 9], 21],
                    2: [[0, 5]],
                    21: [0, 1, 22, 23],
                    22: [0, 1, 22, 23],
                    23: [[0, 3], [23, 25], 27, 28],
                    28: [0, 1, [22, 29]],
                    29: [0, 1, [22, 29]],
                    30: [0, 1, [22, 24]],
                    31: [0, 1, [21, 31]],
                    32: [0, 1, [21, 27]],
                    40: [0, 2, 3, [21, 28]],
                    42: [[0, 2], 21, [23, 26]],
                    43: [0, 1, [21, 26]],
                    90: [[0, 4]],
                    27: [[0, 2], 22, 23]
                },
                71: {0: [0]},
                81: {0: [0]},
                82: {0: [0]}
            }, d = parseInt(b.substr(0, 2), 10), e = parseInt(b.substr(2, 2), 10), f = parseInt(b.substr(4, 2), 10);
            if (!c[d] || !c[d][e]) return !1;
            for (var g = !1, h = c[d][e], i = 0; i < h.length; i++) if (a.isArray(h[i]) && h[i][0] <= f && f <= h[i][1] || !a.isArray(h[i]) && f === h[i]) {
                g = !0;
                break
            }
            if (!g) return !1;
            var j;
            j = 18 === b.length ? b.substr(6, 8) : "19" + b.substr(6, 6);
            var k = parseInt(j.substr(0, 4), 10), l = parseInt(j.substr(4, 2), 10), m = parseInt(j.substr(6, 2), 10);
            if (!a.fn.bootstrapValidator.helpers.date(k, l, m)) return !1;
            if (18 === b.length) {
                var n = 0, o = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
                for (i = 0; 17 > i; i++) n += parseInt(b.charAt(i), 10) * o[i];
                n = (12 - n % 11) % 11;
                var p = "X" !== b.charAt(17).toUpperCase() ? parseInt(b.charAt(17), 10) : 10;
                return p === n
            }
            return !0
        },
        _cz: function (b) {
            if (!/^\d{9,10}$/.test(b)) return !1;
            var c = 1900 + parseInt(b.substr(0, 2), 10), d = parseInt(b.substr(2, 2), 10) % 50 % 20,
                e = parseInt(b.substr(4, 2), 10);
            if (9 === b.length) {
                if (c >= 1980 && (c -= 100), c > 1953) return !1
            } else 1954 > c && (c += 100);
            if (!a.fn.bootstrapValidator.helpers.date(c, d, e)) return !1;
            if (10 === b.length) {
                var f = parseInt(b.substr(0, 9), 10) % 11;
                return 1985 > c && (f %= 10), f + "" === b.substr(9, 1)
            }
            return !0
        },
        _dk: function (b) {
            if (!/^[0-9]{6}[-]{0,1}[0-9]{4}$/.test(b)) return !1;
            b = b.replace(/-/g, "");
            var c = parseInt(b.substr(0, 2), 10), d = parseInt(b.substr(2, 2), 10), e = parseInt(b.substr(4, 2), 10);
            switch (!0) {
                case-1 !== "5678".indexOf(b.charAt(6)) && e >= 58:
                    e += 1800;
                    break;
                case-1 !== "0123".indexOf(b.charAt(6)):
                case-1 !== "49".indexOf(b.charAt(6)) && e >= 37:
                    e += 1900;
                    break;
                default:
                    e += 2e3
            }
            return a.fn.bootstrapValidator.helpers.date(e, d, c)
        },
        _ee: function (a) {
            return this._lt(a)
        },
        _es: function (a) {
            if (!/^[0-9A-Z]{8}[-]{0,1}[0-9A-Z]$/.test(a) && !/^[XYZ][-]{0,1}[0-9]{7}[-]{0,1}[0-9A-Z]$/.test(a)) return !1;
            a = a.replace(/-/g, "");
            var b = "XYZ".indexOf(a.charAt(0));
            -1 !== b && (a = b + a.substr(1) + "");
            var c = parseInt(a.substr(0, 8), 10);
            return c = "TRWAGMYFPDXBNJZSQVHLCKE"[c % 23], c === a.substr(8, 1)
        },
        _fi: function (b) {
            if (!/^[0-9]{6}[-+A][0-9]{3}[0-9ABCDEFHJKLMNPRSTUVWXY]$/.test(b)) return !1;
            var c = parseInt(b.substr(0, 2), 10), d = parseInt(b.substr(2, 2), 10), e = parseInt(b.substr(4, 2), 10),
                f = {"+": 1800, "-": 1900, A: 2e3};
            if (e = f[b.charAt(6)] + e, !a.fn.bootstrapValidator.helpers.date(e, d, c)) return !1;
            var g = parseInt(b.substr(7, 3), 10);
            if (2 > g) return !1;
            var h = b.substr(0, 6) + b.substr(7, 3) + "";
            return h = parseInt(h, 10), "0123456789ABCDEFHJKLMNPRSTUVWXY".charAt(h % 31) === b.charAt(10)
        },
        _hr: function (b) {
            return /^[0-9]{11}$/.test(b) ? a.fn.bootstrapValidator.helpers.mod11And10(b) : !1
        },
        _ie: function (a) {
            if (!/^\d{7}[A-W][AHWTX]?$/.test(a)) return !1;
            var b = function (a) {
                for (; a.length < 7;) a = "0" + a;
                for (var b = "WABCDEFGHIJKLMNOPQRSTUV", c = 0, d = 0; 7 > d; d++) c += parseInt(a.charAt(d), 10) * (8 - d);
                return c += 9 * b.indexOf(a.substr(7)), b[c % 23]
            };
            return 9 !== a.length || "A" !== a.charAt(8) && "H" !== a.charAt(8) ? a.charAt(7) === b(a.substr(0, 7)) : a.charAt(7) === b(a.substr(0, 7) + a.substr(8) + "")
        },
        _is: function (b) {
            if (!/^[0-9]{6}[-]{0,1}[0-9]{4}$/.test(b)) return !1;
            b = b.replace(/-/g, "");
            var c = parseInt(b.substr(0, 2), 10), d = parseInt(b.substr(2, 2), 10), e = parseInt(b.substr(4, 2), 10),
                f = parseInt(b.charAt(9), 10);
            if (e = 9 === f ? 1900 + e : 100 * (20 + f) + e, !a.fn.bootstrapValidator.helpers.date(e, d, c, !0)) return !1;
            for (var g = 0, h = [3, 2, 7, 6, 5, 4, 3, 2], i = 0; 8 > i; i++) g += parseInt(b.charAt(i), 10) * h[i];
            return g = 11 - g % 11, g + "" === b.charAt(8)
        },
        _lt: function (b) {
            if (!/^[0-9]{11}$/.test(b)) return !1;
            var c = parseInt(b.charAt(0), 10), d = parseInt(b.substr(1, 2), 10), e = parseInt(b.substr(3, 2), 10),
                f = parseInt(b.substr(5, 2), 10), g = c % 2 === 0 ? 17 + c / 2 : 17 + (c + 1) / 2;
            if (d = 100 * g + d, !a.fn.bootstrapValidator.helpers.date(d, e, f, !0)) return !1;
            for (var h = 0, i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1], j = 0; 10 > j; j++) h += parseInt(b.charAt(j), 10) * i[j];
            if (h %= 11, 10 !== h) return h + "" === b.charAt(10);
            for (h = 0, i = [3, 4, 5, 6, 7, 8, 9, 1, 2, 3], j = 0; 10 > j; j++) h += parseInt(b.charAt(j), 10) * i[j];
            return h %= 11, 10 === h && (h = 0), h + "" === b.charAt(10)
        },
        _lv: function (b) {
            if (!/^[0-9]{6}[-]{0,1}[0-9]{5}$/.test(b)) return !1;
            b = b.replace(/\D/g, "");
            var c = parseInt(b.substr(0, 2), 10), d = parseInt(b.substr(2, 2), 10), e = parseInt(b.substr(4, 2), 10);
            if (e = e + 1800 + 100 * parseInt(b.charAt(6), 10), !a.fn.bootstrapValidator.helpers.date(e, d, c, !0)) return !1;
            for (var f = 0, g = [10, 5, 8, 4, 2, 1, 6, 3, 7, 9], h = 0; 10 > h; h++) f += parseInt(b.charAt(h), 10) * g[h];
            return f = (f + 1) % 11 % 10, f + "" === b.charAt(10)
        },
        _nl: function (a) {
            for (; a.length < 9;) a = "0" + a;
            if (!/^[0-9]{4}[.]{0,1}[0-9]{2}[.]{0,1}[0-9]{3}$/.test(a)) return !1;
            if (a = a.replace(/\./g, ""), 0 === parseInt(a, 10)) return !1;
            for (var b = 0, c = a.length, d = 0; c - 1 > d; d++) b += (9 - d) * parseInt(a.charAt(d), 10);
            return b %= 11, 10 === b && (b = 0), b + "" === a.charAt(c - 1)
        },
        _ro: function (b) {
            if (!/^[0-9]{13}$/.test(b)) return !1;
            var c = parseInt(b.charAt(0), 10);
            if (0 === c || 7 === c || 8 === c) return !1;
            var d = parseInt(b.substr(1, 2), 10), e = parseInt(b.substr(3, 2), 10), f = parseInt(b.substr(5, 2), 10),
                g = {1: 1900, 2: 1900, 3: 1800, 4: 1800, 5: 2e3, 6: 2e3};
            if (f > 31 && e > 12) return !1;
            if (9 !== c && (d = g[c + ""] + d, !a.fn.bootstrapValidator.helpers.date(d, e, f))) return !1;
            for (var h = 0, i = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], j = b.length, k = 0; j - 1 > k; k++) h += parseInt(b.charAt(k), 10) * i[k];
            return h %= 11, 10 === h && (h = 1), h + "" === b.charAt(j - 1)
        },
        _se: function (b) {
            if (!/^[0-9]{10}$/.test(b) && !/^[0-9]{6}[-|+][0-9]{4}$/.test(b)) return !1;
            b = b.replace(/[^0-9]/g, "");
            var c = parseInt(b.substr(0, 2), 10) + 1900, d = parseInt(b.substr(2, 2), 10),
                e = parseInt(b.substr(4, 2), 10);
            return a.fn.bootstrapValidator.helpers.date(c, d, e) ? a.fn.bootstrapValidator.helpers.luhn(b) : !1
        },
        _sk: function (a) {
            return this._cz(a)
        },
        _sm: function (a) {
            return /^\d{5}$/.test(a)
        },
        _th: function (a) {
            if (13 !== a.length) return !1;
            for (var b = 0, c = 0; 12 > c; c++) b += parseInt(a.charAt(c), 10) * (13 - c);
            return (11 - b % 11) % 10 === parseInt(a.charAt(12), 10)
        },
        _za: function (b) {
            if (!/^[0-9]{10}[0|1][8|9][0-9]$/.test(b)) return !1;
            var c = parseInt(b.substr(0, 2), 10), d = (new Date).getFullYear() % 100, e = parseInt(b.substr(2, 2), 10),
                f = parseInt(b.substr(4, 2), 10);
            return c = c >= d ? c + 1900 : c + 2e3, a.fn.bootstrapValidator.helpers.date(c, e, f) ? a.fn.bootstrapValidator.helpers.luhn(b) : !1
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.identical = a.extend(a.fn.bootstrapValidator.i18n.identical || {}, {"default": "Please enter the same value"}), a.fn.bootstrapValidator.validators.identical = {
        html5Attributes: {
            message: "message",
            field: "field"
        }, validate: function (a, b, c) {
            var d = b.val();
            if ("" === d) return !0;
            var e = a.getFieldElements(c.field);
            return null === e || 0 === e.length ? !0 : d === e.val() ? (a.updateStatus(c.field, a.STATUS_VALID, "identical"), !0) : !1
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.imei = a.extend(a.fn.bootstrapValidator.i18n.imei || {}, {"default": "Please enter a valid IMEI number"}), a.fn.bootstrapValidator.validators.imei = {
        validate: function (b, c) {
            var d = c.val();
            if ("" === d) return !0;
            switch (!0) {
                case/^\d{15}$/.test(d):
                case/^\d{2}-\d{6}-\d{6}-\d{1}$/.test(d):
                case/^\d{2}\s\d{6}\s\d{6}\s\d{1}$/.test(d):
                    return d = d.replace(/[^0-9]/g, ""), a.fn.bootstrapValidator.helpers.luhn(d);
                case/^\d{14}$/.test(d):
                case/^\d{16}$/.test(d):
                case/^\d{2}-\d{6}-\d{6}(|-\d{2})$/.test(d):
                case/^\d{2}\s\d{6}\s\d{6}(|\s\d{2})$/.test(d):
                    return !0;
                default:
                    return !1
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.imo = a.extend(a.fn.bootstrapValidator.i18n.imo || {}, {"default": "Please enter a valid IMO number"}), a.fn.bootstrapValidator.validators.imo = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (!/^IMO \d{7}$/i.test(c)) return !1;
            for (var d = 0, e = c.replace(/^.*(\d{7})$/, "$1"), f = 6; f >= 1; f--) d += e.slice(6 - f, -f) * (f + 1);
            return d % 10 === parseInt(e.charAt(6), 10)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.integer = a.extend(a.fn.bootstrapValidator.i18n.integer || {}, {"default": "Please enter a valid number"}), a.fn.bootstrapValidator.validators.integer = {
        enableByHtml5: function (a) {
            return "number" === a.attr("type") && (void 0 === a.attr("step") || a.attr("step") % 1 === 0)
        }, validate: function (a, b) {
            if (this.enableByHtml5(b) && b.get(0).validity && b.get(0).validity.badInput === !0) return !1;
            var c = b.val();
            return "" === c ? !0 : /^(?:-?(?:0|[1-9][0-9]*))$/.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.ip = a.extend(a.fn.bootstrapValidator.i18n.ip || {}, {
        "default": "Please enter a valid IP address",
        ipv4: "Please enter a valid IPv4 address",
        ipv6: "Please enter a valid IPv6 address"
    }), a.fn.bootstrapValidator.validators.ip = {
        html5Attributes: {message: "message", ipv4: "ipv4", ipv6: "ipv6"},
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            d = a.extend({}, {ipv4: !0, ipv6: !0}, d);
            var f, g = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
                h = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
                i = !1;
            switch (!0) {
                case d.ipv4 && !d.ipv6:
                    i = g.test(e), f = d.message || a.fn.bootstrapValidator.i18n.ip.ipv4;
                    break;
                case!d.ipv4 && d.ipv6:
                    i = h.test(e), f = d.message || a.fn.bootstrapValidator.i18n.ip.ipv6;
                    break;
                case d.ipv4 && d.ipv6:
                default:
                    i = g.test(e) || h.test(e), f = d.message || a.fn.bootstrapValidator.i18n.ip["default"]
            }
            return {valid: i, message: f}
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.isbn = a.extend(a.fn.bootstrapValidator.i18n.isbn || {}, {"default": "Please enter a valid ISBN number"}), a.fn.bootstrapValidator.validators.isbn = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            var d;
            switch (!0) {
                case/^\d{9}[\dX]$/.test(c):
                case 13 === c.length && /^(\d+)-(\d+)-(\d+)-([\dX])$/.test(c):
                case 13 === c.length && /^(\d+)\s(\d+)\s(\d+)\s([\dX])$/.test(c):
                    d = "ISBN10";
                    break;
                case/^(978|979)\d{9}[\dX]$/.test(c):
                case 17 === c.length && /^(978|979)-(\d+)-(\d+)-(\d+)-([\dX])$/.test(c):
                case 17 === c.length && /^(978|979)\s(\d+)\s(\d+)\s(\d+)\s([\dX])$/.test(c):
                    d = "ISBN13";
                    break;
                default:
                    return !1
            }
            c = c.replace(/[^0-9X]/gi, "");
            var e, f, g = c.split(""), h = g.length, i = 0;
            switch (d) {
                case"ISBN10":
                    for (i = 0, e = 0; h - 1 > e; e++) i += parseInt(g[e], 10) * (10 - e);
                    return f = 11 - i % 11, 11 === f ? f = 0 : 10 === f && (f = "X"), f + "" === g[h - 1];
                case"ISBN13":
                    for (i = 0, e = 0; h - 1 > e; e++) i += e % 2 === 0 ? parseInt(g[e], 10) : 3 * parseInt(g[e], 10);
                    return f = 10 - i % 10, 10 === f && (f = "0"), f + "" === g[h - 1];
                default:
                    return !1
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.isin = a.extend(a.fn.bootstrapValidator.i18n.isin || {}, {"default": "Please enter a valid ISIN number"}), a.fn.bootstrapValidator.validators.isin = {
        COUNTRY_CODES: "AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AT|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BQ|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CW|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MK|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MN|ME|MS|MA|MZ|MM|NA|NR|NP|NL|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|BL|SH|KN|LC|MF|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SX|SK|SI|SB|SO|ZA|GS|SS|ES|LK|SD|SR|SJ|SZ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW",
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            c = c.toUpperCase();
            var d = new RegExp("^(" + this.COUNTRY_CODES + ")[0-9A-Z]{10}$");
            if (!d.test(c)) return !1;
            for (var e = "", f = c.length, g = 0; f - 1 > g; g++) {
                var h = c.charCodeAt(g);
                e += h > 57 ? (h - 55).toString() : c.charAt(g)
            }
            var i = "", j = e.length, k = j % 2 !== 0 ? 0 : 1;
            for (g = 0; j > g; g++) i += parseInt(e[g], 10) * (g % 2 === k ? 2 : 1) + "";
            var l = 0;
            for (g = 0; g < i.length; g++) l += parseInt(i.charAt(g), 10);
            return l = (10 - l % 10) % 10, l + "" === c.charAt(f - 1)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.ismn = a.extend(a.fn.bootstrapValidator.i18n.ismn || {}, {"default": "Please enter a valid ISMN number"}), a.fn.bootstrapValidator.validators.ismn = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            var d;
            switch (!0) {
                case/^M\d{9}$/.test(c):
                case/^M-\d{4}-\d{4}-\d{1}$/.test(c):
                case/^M\s\d{4}\s\d{4}\s\d{1}$/.test(c):
                    d = "ISMN10";
                    break;
                case/^9790\d{9}$/.test(c):
                case/^979-0-\d{4}-\d{4}-\d{1}$/.test(c):
                case/^979\s0\s\d{4}\s\d{4}\s\d{1}$/.test(c):
                    d = "ISMN13";
                    break;
                default:
                    return !1
            }
            "ISMN10" === d && (c = "9790" + c.substr(1)), c = c.replace(/[^0-9]/gi, "");
            for (var e = c.length, f = 0, g = [1, 3], h = 0; e - 1 > h; h++) f += parseInt(c.charAt(h), 10) * g[h % 2];
            return f = 10 - f % 10, f + "" === c.charAt(e - 1)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.issn = a.extend(a.fn.bootstrapValidator.i18n.issn || {}, {"default": "Please enter a valid ISSN number"}), a.fn.bootstrapValidator.validators.issn = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (!/^\d{4}\-\d{3}[\dX]$/.test(c)) return !1;
            c = c.replace(/[^0-9X]/gi, "");
            var d = c.split(""), e = d.length, f = 0;
            "X" === d[7] && (d[7] = 10);
            for (var g = 0; e > g; g++) f += parseInt(d[g], 10) * (8 - g);
            return f % 11 === 0
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.lessThan = a.extend(a.fn.bootstrapValidator.i18n.lessThan || {}, {
        "default": "Please enter a value less than or equal to %s",
        notInclusive: "Please enter a value less than %s"
    }), a.fn.bootstrapValidator.validators.lessThan = {
        html5Attributes: {
            message: "message",
            value: "value",
            inclusive: "inclusive"
        }, enableByHtml5: function (a) {
            var b = a.attr("type"), c = a.attr("max");
            return c && "date" !== b ? {value: c} : !1
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            if (e = this._format(e), !a.isNumeric(e)) return !1;
            var f = a.isNumeric(d.value) ? d.value : b.getDynamicOption(c, d.value), g = this._format(f);
            return e = parseFloat(e), d.inclusive === !0 || void 0 === d.inclusive ? {
                valid: g >= e,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.lessThan["default"], f)
            } : {
                valid: g > e,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.lessThan.notInclusive, f)
            }
        }, _format: function (a) {
            return (a + "").replace(",", ".")
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.mac = a.extend(a.fn.bootstrapValidator.i18n.mac || {}, {"default": "Please enter a valid MAC address"}), a.fn.bootstrapValidator.validators.mac = {
        validate: function (a, b) {
            var c = b.val();
            return "" === c ? !0 : /^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$/.test(c)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.meid = a.extend(a.fn.bootstrapValidator.i18n.meid || {}, {"default": "Please enter a valid MEID number"}), a.fn.bootstrapValidator.validators.meid = {
        validate: function (b, c) {
            var d = c.val();
            if ("" === d) return !0;
            switch (!0) {
                case/^[0-9A-F]{15}$/i.test(d):
                case/^[0-9A-F]{2}[- ][0-9A-F]{6}[- ][0-9A-F]{6}[- ][0-9A-F]$/i.test(d):
                case/^\d{19}$/.test(d):
                case/^\d{5}[- ]\d{5}[- ]\d{4}[- ]\d{4}[- ]\d$/.test(d):
                    var e = d.charAt(d.length - 1);
                    if (d = d.replace(/[- ]/g, ""), d.match(/^\d*$/i)) return a.fn.bootstrapValidator.helpers.luhn(d);
                    d = d.slice(0, -1);
                    for (var f = "", g = 1; 13 >= g; g += 2) f += (2 * parseInt(d.charAt(g), 16)).toString(16);
                    var h = 0;
                    for (g = 0; g < f.length; g++) h += parseInt(f.charAt(g), 16);
                    return h % 10 === 0 ? "0" === e : e === (2 * (10 * Math.floor((h + 10) / 10) - h)).toString(16);
                case/^[0-9A-F]{14}$/i.test(d):
                case/^[0-9A-F]{2}[- ][0-9A-F]{6}[- ][0-9A-F]{6}$/i.test(d):
                case/^\d{18}$/.test(d):
                case/^\d{5}[- ]\d{5}[- ]\d{4}[- ]\d{4}$/.test(d):
                    return !0;
                default:
                    return !1
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.notEmpty = a.extend(a.fn.bootstrapValidator.i18n.notEmpty || {}, {"default": "Please enter a value"}), a.fn.bootstrapValidator.validators.notEmpty = {
        enableByHtml5: function (a) {
            var b = a.attr("required") + "";
            return "required" === b || "true" === b
        }, validate: function (b, c) {
            var d = c.attr("type");
            return "radio" === d || "checkbox" === d ? b.getFieldElements(c.attr("data-bv-field")).filter(":checked").length > 0 : "number" === d && c.get(0).validity && c.get(0).validity.badInput === !0 ? !0 : "" !== a.trim(c.val())
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.numeric = a.extend(a.fn.bootstrapValidator.i18n.numeric || {}, {"default": "Please enter a valid float number"}), a.fn.bootstrapValidator.validators.numeric = {
        html5Attributes: {
            message: "message",
            separator: "separator"
        }, enableByHtml5: function (a) {
            return "number" === a.attr("type") && void 0 !== a.attr("step") && a.attr("step") % 1 !== 0
        }, validate: function (a, b, c) {
            if (this.enableByHtml5(b) && b.get(0).validity && b.get(0).validity.badInput === !0) return !1;
            var d = b.val();
            if ("" === d) return !0;
            var e = c.separator || ".";
            return "." !== e && (d = d.replace(e, ".")), !isNaN(parseFloat(d)) && isFinite(d)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.phone = a.extend(a.fn.bootstrapValidator.i18n.phone || {}, {
        "default": "Please enter a valid phone number",
        countryNotSupported: "The country code %s is not supported",
        country: "Please enter a valid phone number in %s",
        countries: {
            BR: "Brazil",
            CN: "China",
            CZ: "Czech Republic",
            DE: "Germany",
            DK: "Denmark",
            ES: "Spain",
            FR: "France",
            GB: "United Kingdom",
            MA: "Morocco",
            PK: "Pakistan",
            RO: "Romania",
            RU: "Russia",
            SK: "Slovakia",
            TH: "Thailand",
            US: "USA",
            VE: "Venezuela"
        }
    }), a.fn.bootstrapValidator.validators.phone = {
        html5Attributes: {message: "message", country: "country"},
        COUNTRY_CODES: ["BR", "CN", "CZ", "DE", "DK", "ES", "FR", "GB", "MA", "PK", "RO", "RU", "SK", "TH", "US", "VE"],
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = d.country;
            if (("string" != typeof f || -1 === a.inArray(f, this.COUNTRY_CODES)) && (f = b.getDynamicOption(c, f)), !f || -1 === a.inArray(f.toUpperCase(), this.COUNTRY_CODES)) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.phone.countryNotSupported, f)
            };
            var g = !0;
            switch (f.toUpperCase()) {
                case"BR":
                    e = a.trim(e), g = /^(([\d]{4}[-.\s]{1}[\d]{2,3}[-.\s]{1}[\d]{2}[-.\s]{1}[\d]{2})|([\d]{4}[-.\s]{1}[\d]{3}[-.\s]{1}[\d]{4})|((\(?\+?[0-9]{2}\)?\s?)?(\(?\d{2}\)?\s?)?\d{4,5}[-.\s]?\d{4}))$/.test(e);
                    break;
                case"CN":
                    e = a.trim(e), g = /^((00|\+)?(86(?:-| )))?((\d{11})|(\d{3}[- ]{1}\d{4}[- ]{1}\d{4})|((\d{2,4}[- ]){1}(\d{7,8}|(\d{3,4}[- ]{1}\d{4}))([- ]{1}\d{1,4})?))$/.test(e);
                    break;
                case"CZ":
                    g = /^(((00)([- ]?)|\+)(420)([- ]?))?((\d{3})([- ]?)){2}(\d{3})$/.test(e);
                    break;
                case"DE":
                    e = a.trim(e), g = /^(((((((00|\+)49[ \-/]?)|0)[1-9][0-9]{1,4})[ \-/]?)|((((00|\+)49\()|\(0)[1-9][0-9]{1,4}\)[ \-/]?))[0-9]{1,7}([ \-/]?[0-9]{1,5})?)$/.test(e);
                    break;
                case"DK":
                    e = a.trim(e), g = /^(\+45|0045|\(45\))?\s?[2-9](\s?\d){7}$/.test(e);
                    break;
                case"ES":
                    e = a.trim(e), g = /^(?:(?:(?:\+|00)34\D?))?(?:9|6)(?:\d\D?){8}$/.test(e);
                    break;
                case"FR":
                    e = a.trim(e), g = /^(?:(?:(?:\+|00)33[ ]?(?:\(0\)[ ]?)?)|0){1}[1-9]{1}([ .-]?)(?:\d{2}\1?){3}\d{2}$/.test(e);
                    break;
                case"GB":
                    e = a.trim(e), g = /^\(?(?:(?:0(?:0|11)\)?[\s-]?\(?|\+)44\)?[\s-]?\(?(?:0\)?[\s-]?\(?)?|0)(?:\d{2}\)?[\s-]?\d{4}[\s-]?\d{4}|\d{3}\)?[\s-]?\d{3}[\s-]?\d{3,4}|\d{4}\)?[\s-]?(?:\d{5}|\d{3}[\s-]?\d{3})|\d{5}\)?[\s-]?\d{4,5}|8(?:00[\s-]?11[\s-]?11|45[\s-]?46[\s-]?4\d))(?:(?:[\s-]?(?:x|ext\.?\s?|\#)\d+)?)$/.test(e);
                    break;
                case"MA":
                    e = a.trim(e), g = /^(?:(?:(?:\+|00)212[\s]?(?:[\s]?\(0\)[\s]?)?)|0){1}(?:5[\s.-]?[2-3]|6[\s.-]?[13-9]){1}[0-9]{1}(?:[\s.-]?\d{2}){3}$/.test(e);
                    break;
                case"PK":
                    e = a.trim(e), g = /^0?3[0-9]{2}[0-9]{7}$/.test(e);
                    break;
                case"RO":
                    g = /^(\+4|)?(07[0-8]{1}[0-9]{1}|02[0-9]{2}|03[0-9]{2}){1}?(\s|\.|\-)?([0-9]{3}(\s|\.|\-|)){2}$/g.test(e);
                    break;
                case"RU":
                    g = /^((8|\+7|007)[\-\.\/ ]?)?([\(\/\.]?\d{3}[\)\/\.]?[\-\.\/ ]?)?[\d\-\.\/ ]{7,10}$/g.test(e);
                    break;
                case"SK":
                    g = /^(((00)([- ]?)|\+)(420)([- ]?))?((\d{3})([- ]?)){2}(\d{3})$/.test(e);
                    break;
                case"TH":
                    g = /^0\(?([6|8-9]{2})*-([0-9]{3})*-([0-9]{4})$/.test(e);
                    break;
                case"VE":
                    e = a.trim(e), g = /^0(?:2(?:12|4[0-9]|5[1-9]|6[0-9]|7[0-8]|8[1-35-8]|9[1-5]|3[45789])|4(?:1[246]|2[46]))\d{7}$/.test(e);
                    break;
                case"US":
                default:
                    e = e.replace(/\D/g, ""), g = /^(?:(1\-?)|(\+1 ?))?\(?(\d{3})[\)\-\.]?(\d{3})[\-\.]?(\d{4})$/.test(e) && 10 === e.length
            }
            return {
                valid: g,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.phone.country, a.fn.bootstrapValidator.i18n.phone.countries[f])
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.regexp = a.extend(a.fn.bootstrapValidator.i18n.regexp || {}, {"default": "Please enter a value matching the pattern"}), a.fn.bootstrapValidator.validators.regexp = {
        html5Attributes: {
            message: "message",
            regexp: "regexp"
        }, enableByHtml5: function (a) {
            var b = a.attr("pattern");
            return b ? {regexp: b} : !1
        }, validate: function (a, b, c) {
            var d = b.val();
            if ("" === d) return !0;
            var e = "string" == typeof c.regexp ? new RegExp(c.regexp) : c.regexp;
            return e.test(d)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.remote = a.extend(a.fn.bootstrapValidator.i18n.remote || {}, {"default": "Please enter a valid value"}), a.fn.bootstrapValidator.validators.remote = {
        html5Attributes: {
            message: "message",
            name: "name",
            type: "type",
            url: "url",
            data: "data",
            delay: "delay"
        }, destroy: function (a, b) {
            b.data("bv.remote.timer") && (clearTimeout(b.data("bv.remote.timer")), b.removeData("bv.remote.timer"))
        }, validate: function (b, c, d) {
            function e() {
                var b = a.ajax({type: k, headers: l, url: j, dataType: "json", data: i});
                return b.then(function (a) {
                    a.valid = a.valid === !0 || "true" === a.valid, g.resolve(c, "remote", a)
                }), g.fail(function () {
                    b.abort()
                }), g
            }

            var f = c.val(), g = new a.Deferred;
            if ("" === f) return g.resolve(c, "remote", {valid: !0}), g;
            var h = c.attr("data-bv-field"), i = d.data || {}, j = d.url, k = d.type || "GET", l = d.headers || {};
            return "function" == typeof i && (i = i.call(this, b)), "string" == typeof i && (i = JSON.parse(i)), "function" == typeof j && (j = j.call(this, b)), i[d.name || h] = f, d.delay ? (c.data("bv.remote.timer") && clearTimeout(c.data("bv.remote.timer")), c.data("bv.remote.timer", setTimeout(e, d.delay)), g) : e()
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.rtn = a.extend(a.fn.bootstrapValidator.i18n.rtn || {}, {"default": "Please enter a valid RTN number"}), a.fn.bootstrapValidator.validators.rtn = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (!/^\d{9}$/.test(c)) return !1;
            for (var d = 0, e = 0; e < c.length; e += 3) d += 3 * parseInt(c.charAt(e), 10) + 7 * parseInt(c.charAt(e + 1), 10) + parseInt(c.charAt(e + 2), 10);
            return 0 !== d && d % 10 === 0
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.sedol = a.extend(a.fn.bootstrapValidator.i18n.sedol || {}, {"default": "Please enter a valid SEDOL number"}), a.fn.bootstrapValidator.validators.sedol = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (c = c.toUpperCase(), !/^[0-9A-Z]{7}$/.test(c)) return !1;
            for (var d = 0, e = [1, 3, 1, 7, 3, 9, 1], f = c.length, g = 0; f - 1 > g; g++) d += e[g] * parseInt(c.charAt(g), 36);
            return d = (10 - d % 10) % 10, d + "" === c.charAt(f - 1)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.siren = a.extend(a.fn.bootstrapValidator.i18n.siren || {}, {"default": "Please enter a valid SIREN number"}), a.fn.bootstrapValidator.validators.siren = {
        validate: function (b, c) {
            var d = c.val();
            return "" === d ? !0 : /^\d{9}$/.test(d) ? a.fn.bootstrapValidator.helpers.luhn(d) : !1
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.siret = a.extend(a.fn.bootstrapValidator.i18n.siret || {}, {"default": "Please enter a valid SIRET number"}), a.fn.bootstrapValidator.validators.siret = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            for (var d, e = 0, f = c.length, g = 0; f > g; g++) d = parseInt(c.charAt(g), 10), g % 2 === 0 && (d = 2 * d, d > 9 && (d -= 9)), e += d;
            return e % 10 === 0
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.step = a.extend(a.fn.bootstrapValidator.i18n.step || {}, {"default": "Please enter a valid step of %s"}), a.fn.bootstrapValidator.validators.step = {
        html5Attributes: {
            message: "message",
            base: "baseValue",
            step: "step"
        }, validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            if (d = a.extend({}, {baseValue: 0, step: 1}, d), e = parseFloat(e), !a.isNumeric(e)) return !1;
            var f = function (a, b) {
                var c = Math.pow(10, b);
                a *= c;
                var d = a > 0 | -(0 > a), e = a % 1 === .5 * d;
                return e ? (Math.floor(a) + (d > 0)) / c : Math.round(a) / c
            }, g = function (a, b) {
                if (0 === b) return 1;
                var c = (a + "").split("."), d = (b + "").split("."),
                    e = (1 === c.length ? 0 : c[1].length) + (1 === d.length ? 0 : d[1].length);
                return f(a - b * Math.floor(a / b), e)
            }, h = g(e - d.baseValue, d.step);
            return {
                valid: 0 === h || h === d.step,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.step["default"], [d.step])
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.stringCase = a.extend(a.fn.bootstrapValidator.i18n.stringCase || {}, {
        "default": "Please enter only lowercase characters",
        upper: "Please enter only uppercase characters"
    }), a.fn.bootstrapValidator.validators.stringCase = {
        html5Attributes: {message: "message", "case": "case"},
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = (d["case"] || "lower").toLowerCase();
            return {
                valid: "upper" === f ? e === e.toUpperCase() : e === e.toLowerCase(),
                message: d.message || ("upper" === f ? a.fn.bootstrapValidator.i18n.stringCase.upper : a.fn.bootstrapValidator.i18n.stringCase["default"])
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.stringLength = a.extend(a.fn.bootstrapValidator.i18n.stringLength || {}, {
        "default": "Please enter a value with valid length",
        less: "Please enter less than %s characters",
        more: "Please enter more than %s characters",
        between: "Please enter value between %s and %s characters long"
    }), a.fn.bootstrapValidator.validators.stringLength = {
        html5Attributes: {
            message: "message",
            min: "min",
            max: "max",
            trim: "trim",
            utf8bytes: "utf8Bytes"
        }, enableByHtml5: function (b) {
            var c = {}, d = b.attr("maxlength"), e = b.attr("minlength");
            return d && (c.max = parseInt(d, 10)), e && (c.min = parseInt(e, 10)), a.isEmptyObject(c) ? !1 : c
        }, validate: function (b, c, d) {
            var e = c.val();
            if ((d.trim === !0 || "true" === d.trim) && (e = a.trim(e)), "" === e) return !0;
            var f = a.isNumeric(d.min) ? d.min : b.getDynamicOption(c, d.min),
                g = a.isNumeric(d.max) ? d.max : b.getDynamicOption(c, d.max), h = function (a) {
                    for (var b = a.length, c = a.length - 1; c >= 0; c--) {
                        var d = a.charCodeAt(c);
                        d > 127 && 2047 >= d ? b++ : d > 2047 && 65535 >= d && (b += 2), d >= 56320 && 57343 >= d && c--
                    }
                    return b
                }, i = d.utf8Bytes ? h(e) : e.length, j = !0,
                k = d.message || a.fn.bootstrapValidator.i18n.stringLength["default"];
            switch ((f && i < parseInt(f, 10) || g && i > parseInt(g, 10)) && (j = !1), !0) {
                case!!f && !!g:
                    k = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.stringLength.between, [parseInt(f, 10), parseInt(g, 10)]);
                    break;
                case!!f:
                    k = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.stringLength.more, parseInt(f, 10));
                    break;
                case!!g:
                    k = a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.stringLength.less, parseInt(g, 10))
            }
            return {valid: j, message: k}
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.uri = a.extend(a.fn.bootstrapValidator.i18n.uri || {}, {"default": "Please enter a valid URI"}), a.fn.bootstrapValidator.validators.uri = {
        html5Attributes: {
            message: "message",
            allowlocal: "allowLocal",
            protocol: "protocol"
        }, enableByHtml5: function (a) {
            return "url" === a.attr("type")
        }, validate: function (a, b, c) {
            var d = b.val();
            if ("" === d) return !0;
            var e = c.allowLocal === !0 || "true" === c.allowLocal,
                f = (c.protocol || "http, https, ftp").split(",").join("|").replace(/\s/g, ""),
                g = new RegExp("^(?:(?:" + f + ")://)(?:\\S+(?::\\S*)?@)?(?:" + (e ? "" : "(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})") + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + (e ? "?" : "") + ")(?::\\d{2,5})?(?:/[^\\s]*)?$", "i");
            return g.test(d)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.uuid = a.extend(a.fn.bootstrapValidator.i18n.uuid || {}, {
        "default": "Please enter a valid UUID number",
        version: "Please enter a valid UUID version %s number"
    }), a.fn.bootstrapValidator.validators.uuid = {
        html5Attributes: {message: "message", version: "version"},
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = {
                3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
                4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
            }, g = d.version ? d.version + "" : "all";
            return {
                valid: null === f[g] ? !0 : f[g].test(e),
                message: d.version ? a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.uuid.version, d.version) : d.message || a.fn.bootstrapValidator.i18n.uuid["default"]
            }
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.vat = a.extend(a.fn.bootstrapValidator.i18n.vat || {}, {
        "default": "Please enter a valid VAT number",
        countryNotSupported: "The country code %s is not supported",
        country: "Please enter a valid VAT number in %s",
        countries: {
            AT: "Austria",
            BE: "Belgium",
            BG: "Bulgaria",
            BR: "Brazil",
            CH: "Switzerland",
            CY: "Cyprus",
            CZ: "Czech Republic",
            DE: "Germany",
            DK: "Denmark",
            EE: "Estonia",
            ES: "Spain",
            FI: "Finland",
            FR: "France",
            GB: "United Kingdom",
            GR: "Greek",
            EL: "Greek",
            HU: "Hungary",
            HR: "Croatia",
            IE: "Ireland",
            IS: "Iceland",
            IT: "Italy",
            LT: "Lithuania",
            LU: "Luxembourg",
            LV: "Latvia",
            MT: "Malta",
            NL: "Netherlands",
            NO: "Norway",
            PL: "Poland",
            PT: "Portugal",
            RO: "Romania",
            RU: "Russia",
            RS: "Serbia",
            SE: "Sweden",
            SI: "Slovenia",
            SK: "Slovakia",
            VE: "Venezuela",
            ZA: "South Africa"
        }
    }), a.fn.bootstrapValidator.validators.vat = {
        html5Attributes: {message: "message", country: "country"},
        COUNTRY_CODES: ["AT", "BE", "BG", "BR", "CH", "CY", "CZ", "DE", "DK", "EE", "EL", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT", "LT", "LU", "LV", "MT", "NL", "NO", "PL", "PT", "RO", "RU", "RS", "SE", "SK", "SI", "VE", "ZA"],
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e) return !0;
            var f = d.country;
            if (f ? ("string" != typeof f || -1 === a.inArray(f.toUpperCase(), this.COUNTRY_CODES)) && (f = b.getDynamicOption(c, f)) : f = e.substr(0, 2), -1 === a.inArray(f, this.COUNTRY_CODES)) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.vat.countryNotSupported, f)
            };
            var g = ["_", f.toLowerCase()].join("");
            return this[g](e) ? !0 : {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.vat.country, a.fn.bootstrapValidator.i18n.vat.countries[f.toUpperCase()])
            }
        },
        _at: function (a) {
            if (/^ATU[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^U[0-9]{8}$/.test(a)) return !1;
            a = a.substr(1);
            for (var b = 0, c = [1, 2, 1, 2, 1, 2, 1], d = 0, e = 0; 7 > e; e++) d = parseInt(a.charAt(e), 10) * c[e], d > 9 && (d = Math.floor(d / 10) + d % 10), b += d;
            return b = 10 - (b + 4) % 10, 10 === b && (b = 0), b + "" === a.substr(7, 1)
        },
        _be: function (a) {
            if (/^BE[0]{0,1}[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0]{0,1}[0-9]{9}$/.test(a)) return !1;
            if (9 === a.length && (a = "0" + a), "0" === a.substr(1, 1)) return !1;
            var b = parseInt(a.substr(0, 8), 10) + parseInt(a.substr(8, 2), 10);
            return b % 97 === 0
        },
        _bg: function (b) {
            if (/^BG[0-9]{9,10}$/.test(b) && (b = b.substr(2)), !/^[0-9]{9,10}$/.test(b)) return !1;
            var c = 0, d = 0;
            if (9 === b.length) {
                for (d = 0; 8 > d; d++) c += parseInt(b.charAt(d), 10) * (d + 1);
                if (c %= 11, 10 === c) for (c = 0, d = 0; 8 > d; d++) c += parseInt(b.charAt(d), 10) * (d + 3);
                return c %= 10, c + "" === b.substr(8)
            }
            if (10 === b.length) {
                var e = function (b) {
                    var c = parseInt(b.substr(0, 2), 10) + 1900, d = parseInt(b.substr(2, 2), 10),
                        e = parseInt(b.substr(4, 2), 10);
                    if (d > 40 ? (c += 100, d -= 40) : d > 20 && (c -= 100, d -= 20), !a.fn.bootstrapValidator.helpers.date(c, d, e)) return !1;
                    for (var f = 0, g = [2, 4, 8, 5, 10, 9, 7, 3, 6], h = 0; 9 > h; h++) f += parseInt(b.charAt(h), 10) * g[h];
                    return f = f % 11 % 10, f + "" === b.substr(9, 1)
                }, f = function (a) {
                    for (var b = 0, c = [21, 19, 17, 13, 11, 9, 7, 3, 1], d = 0; 9 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
                    return b %= 10, b + "" === a.substr(9, 1)
                }, g = function (a) {
                    for (var b = 0, c = [4, 3, 2, 7, 6, 5, 4, 3, 2], d = 0; 9 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
                    return b = 11 - b % 11, 10 === b ? !1 : (11 === b && (b = 0), b + "" === a.substr(9, 1))
                };
                return e(b) || f(b) || g(b)
            }
            return !1
        },
        _br: function (a) {
            if ("" === a) return !0;
            var b = a.replace(/[^\d]+/g, "");
            if ("" === b || 14 !== b.length) return !1;
            if ("00000000000000" === b || "11111111111111" === b || "22222222222222" === b || "33333333333333" === b || "44444444444444" === b || "55555555555555" === b || "66666666666666" === b || "77777777777777" === b || "88888888888888" === b || "99999999999999" === b) return !1;
            for (var c = b.length - 2, d = b.substring(0, c), e = b.substring(c), f = 0, g = c - 7, h = c; h >= 1; h--) f += parseInt(d.charAt(c - h), 10) * g--, 2 > g && (g = 9);
            var i = 2 > f % 11 ? 0 : 11 - f % 11;
            if (i !== parseInt(e.charAt(0), 10)) return !1;
            for (c += 1, d = b.substring(0, c), f = 0, g = c - 7, h = c; h >= 1; h--) f += parseInt(d.charAt(c - h), 10) * g--, 2 > g && (g = 9);
            return i = 2 > f % 11 ? 0 : 11 - f % 11, i === parseInt(e.charAt(1), 10)
        },
        _ch: function (a) {
            if (/^CHE[0-9]{9}(MWST)?$/.test(a) && (a = a.substr(2)), !/^E[0-9]{9}(MWST)?$/.test(a)) return !1;
            a = a.substr(1);
            for (var b = 0, c = [5, 4, 3, 2, 7, 6, 5, 4], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = 11 - b % 11, 10 === b ? !1 : (11 === b && (b = 0), b + "" === a.substr(8, 1))
        },
        _cy: function (a) {
            if (/^CY[0-5|9]{1}[0-9]{7}[A-Z]{1}$/.test(a) && (a = a.substr(2)), !/^[0-5|9]{1}[0-9]{7}[A-Z]{1}$/.test(a)) return !1;
            if ("12" === a.substr(0, 2)) return !1;
            for (var b = 0, c = {0: 1, 1: 0, 2: 5, 3: 7, 4: 9, 5: 13, 6: 15, 7: 17, 8: 19, 9: 21}, d = 0; 8 > d; d++) {
                var e = parseInt(a.charAt(d), 10);
                d % 2 === 0 && (e = c[e + ""]), b += e
            }
            return b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[b % 26], b + "" === a.substr(8, 1)
        },
        _cz: function (b) {
            if (/^CZ[0-9]{8,10}$/.test(b) && (b = b.substr(2)), !/^[0-9]{8,10}$/.test(b)) return !1;
            var c = 0, d = 0;
            if (8 === b.length) {
                if (b.charAt(0) + "" == "9") return !1;
                for (c = 0, d = 0; 7 > d; d++) c += parseInt(b.charAt(d), 10) * (8 - d);
                return c = 11 - c % 11, 10 === c && (c = 0), 11 === c && (c = 1), c + "" === b.substr(7, 1)
            }
            if (9 === b.length && b.charAt(0) + "" == "6") {
                for (c = 0, d = 0; 7 > d; d++) c += parseInt(b.charAt(d + 1), 10) * (8 - d);
                return c = 11 - c % 11, 10 === c && (c = 0), 11 === c && (c = 1), c = [8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 10][c - 1], c + "" === b.substr(8, 1)
            }
            if (9 === b.length || 10 === b.length) {
                var e = 1900 + parseInt(b.substr(0, 2), 10), f = parseInt(b.substr(2, 2), 10) % 50 % 20,
                    g = parseInt(b.substr(4, 2), 10);
                if (9 === b.length) {
                    if (e >= 1980 && (e -= 100), e > 1953) return !1
                } else 1954 > e && (e += 100);
                if (!a.fn.bootstrapValidator.helpers.date(e, f, g)) return !1;
                if (10 === b.length) {
                    var h = parseInt(b.substr(0, 9), 10) % 11;
                    return 1985 > e && (h %= 10), h + "" === b.substr(9, 1)
                }
                return !0
            }
            return !1
        },
        _de: function (b) {
            return /^DE[0-9]{9}$/.test(b) && (b = b.substr(2)), /^[0-9]{9}$/.test(b) ? a.fn.bootstrapValidator.helpers.mod11And10(b) : !1
        },
        _dk: function (a) {
            if (/^DK[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^[0-9]{8}$/.test(a)) return !1;
            for (var b = 0, c = [2, 7, 6, 5, 4, 3, 2, 1], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 11 === 0
        },
        _ee: function (a) {
            if (/^EE[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}$/.test(a)) return !1;
            for (var b = 0, c = [3, 7, 1, 3, 7, 1, 3, 7, 1], d = 0; 9 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 10 === 0
        },
        _es: function (a) {
            if (/^ES[0-9A-Z][0-9]{7}[0-9A-Z]$/.test(a) && (a = a.substr(2)), !/^[0-9A-Z][0-9]{7}[0-9A-Z]$/.test(a)) return !1;
            var b = function (a) {
                var b = parseInt(a.substr(0, 8), 10);
                return b = "TRWAGMYFPDXBNJZSQVHLCKE"[b % 23], b + "" === a.substr(8, 1)
            }, c = function (a) {
                var b = ["XYZ".indexOf(a.charAt(0)), a.substr(1)].join("");
                return b = parseInt(b, 10), b = "TRWAGMYFPDXBNJZSQVHLCKE"[b % 23], b + "" === a.substr(8, 1)
            }, d = function (a) {
                var b, c = a.charAt(0);
                if (-1 !== "KLM".indexOf(c)) return b = parseInt(a.substr(1, 8), 10), b = "TRWAGMYFPDXBNJZSQVHLCKE"[b % 23], b + "" === a.substr(8, 1);
                if (-1 !== "ABCDEFGHJNPQRSUVW".indexOf(c)) {
                    for (var d = 0, e = [2, 1, 2, 1, 2, 1, 2], f = 0, g = 0; 7 > g; g++) f = parseInt(a.charAt(g + 1), 10) * e[g], f > 9 && (f = Math.floor(f / 10) + f % 10), d += f;
                    return d = 10 - d % 10, d + "" === a.substr(8, 1) || "JABCDEFGHI"[d] === a.substr(8, 1)
                }
                return !1
            }, e = a.charAt(0);
            return /^[0-9]$/.test(e) ? b(a) : /^[XYZ]$/.test(e) ? c(a) : d(a)
        },
        _fi: function (a) {
            if (/^FI[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^[0-9]{8}$/.test(a)) return !1;
            for (var b = 0, c = [7, 9, 10, 5, 8, 4, 2, 1], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 11 === 0
        },
        _fr: function (b) {
            if (/^FR[0-9A-Z]{2}[0-9]{9}$/.test(b) && (b = b.substr(2)), !/^[0-9A-Z]{2}[0-9]{9}$/.test(b)) return !1;
            if (!a.fn.bootstrapValidator.helpers.luhn(b.substr(2))) return !1;
            if (/^[0-9]{2}$/.test(b.substr(0, 2))) return b.substr(0, 2) === parseInt(b.substr(2) + "12", 10) % 97 + "";
            var c, d = "0123456789ABCDEFGHJKLMNPQRSTUVWXYZ";
            return c = /^[0-9]{1}$/.test(b.charAt(0)) ? 24 * d.indexOf(b.charAt(0)) + d.indexOf(b.charAt(1)) - 10 : 34 * d.indexOf(b.charAt(0)) + d.indexOf(b.charAt(1)) - 100, (parseInt(b.substr(2), 10) + 1 + Math.floor(c / 11)) % 11 === c % 11
        },
        _gb: function (a) {
            if ((/^GB[0-9]{9}$/.test(a) || /^GB[0-9]{12}$/.test(a) || /^GBGD[0-9]{3}$/.test(a) || /^GBHA[0-9]{3}$/.test(a) || /^GB(GD|HA)8888[0-9]{5}$/.test(a)) && (a = a.substr(2)), !(/^[0-9]{9}$/.test(a) || /^[0-9]{12}$/.test(a) || /^GD[0-9]{3}$/.test(a) || /^HA[0-9]{3}$/.test(a) || /^(GD|HA)8888[0-9]{5}$/.test(a))) return !1;
            var b = a.length;
            if (5 === b) {
                var c = a.substr(0, 2), d = parseInt(a.substr(2), 10);
                return "GD" === c && 500 > d || "HA" === c && d >= 500
            }
            if (11 === b && ("GD8888" === a.substr(0, 6) || "HA8888" === a.substr(0, 6))) return "GD" === a.substr(0, 2) && parseInt(a.substr(6, 3), 10) >= 500 || "HA" === a.substr(0, 2) && parseInt(a.substr(6, 3), 10) < 500 ? !1 : parseInt(a.substr(6, 3), 10) % 97 === parseInt(a.substr(9, 2), 10);
            if (9 === b || 12 === b) {
                for (var e = 0, f = [8, 7, 6, 5, 4, 3, 2, 10, 1], g = 0; 9 > g; g++) e += parseInt(a.charAt(g), 10) * f[g];
                return e %= 97, parseInt(a.substr(0, 3), 10) >= 100 ? 0 === e || 42 === e || 55 === e : 0 === e
            }
            return !0
        },
        _gr: function (a) {
            if (/^(GR|EL)[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}$/.test(a)) return !1;
            8 === a.length && (a = "0" + a);
            for (var b = 0, c = [256, 128, 64, 32, 16, 8, 4, 2], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = b % 11 % 10, b + "" === a.substr(8, 1)
        },
        _el: function (a) {
            return this._gr(a)
        },
        _hu: function (a) {
            if (/^HU[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^[0-9]{8}$/.test(a)) return !1;
            for (var b = 0, c = [9, 7, 3, 1, 9, 7, 3, 1], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 10 === 0
        },
        _hr: function (b) {
            return /^HR[0-9]{11}$/.test(b) && (b = b.substr(2)), /^[0-9]{11}$/.test(b) ? a.fn.bootstrapValidator.helpers.mod11And10(b) : !1
        },
        _ie: function (a) {
            if (/^IE[0-9]{1}[0-9A-Z\*\+]{1}[0-9]{5}[A-Z]{1,2}$/.test(a) && (a = a.substr(2)), !/^[0-9]{1}[0-9A-Z\*\+]{1}[0-9]{5}[A-Z]{1,2}$/.test(a)) return !1;
            var b = function (a) {
                for (; a.length < 7;) a = "0" + a;
                for (var b = "WABCDEFGHIJKLMNOPQRSTUV", c = 0, d = 0; 7 > d; d++) c += parseInt(a.charAt(d), 10) * (8 - d);
                return c += 9 * b.indexOf(a.substr(7)), b[c % 23]
            };
            return /^[0-9]+$/.test(a.substr(0, 7)) ? a.charAt(7) === b(a.substr(0, 7) + a.substr(8) + "") : -1 !== "ABCDEFGHIJKLMNOPQRSTUVWXYZ+*".indexOf(a.charAt(1)) ? a.charAt(7) === b(a.substr(2, 5) + a.substr(0, 1) + "") : !0
        },
        _is: function (a) {
            return /^IS[0-9]{5,6}$/.test(a) && (a = a.substr(2)), /^[0-9]{5,6}$/.test(a)
        },
        _it: function (b) {
            if (/^IT[0-9]{11}$/.test(b) && (b = b.substr(2)), !/^[0-9]{11}$/.test(b)) return !1;
            if (0 === parseInt(b.substr(0, 7), 10)) return !1;
            var c = parseInt(b.substr(7, 3), 10);
            return 1 > c || c > 201 && 999 !== c && 888 !== c ? !1 : a.fn.bootstrapValidator.helpers.luhn(b)
        },
        _lt: function (a) {
            if (/^LT([0-9]{7}1[0-9]{1}|[0-9]{10}1[0-9]{1})$/.test(a) && (a = a.substr(2)), !/^([0-9]{7}1[0-9]{1}|[0-9]{10}1[0-9]{1})$/.test(a)) return !1;
            var b, c = a.length, d = 0;
            for (b = 0; c - 1 > b; b++) d += parseInt(a.charAt(b), 10) * (1 + b % 9);
            var e = d % 11;
            if (10 === e) for (d = 0, b = 0; c - 1 > b; b++) d += parseInt(a.charAt(b), 10) * (1 + (b + 2) % 9);
            return e = e % 11 % 10, e + "" === a.charAt(c - 1)
        },
        _lu: function (a) {
            return /^LU[0-9]{8}$/.test(a) && (a = a.substr(2)), /^[0-9]{8}$/.test(a) ? parseInt(a.substr(0, 6), 10) % 89 + "" === a.substr(6, 2) : !1
        },
        _lv: function (b) {
            if (/^LV[0-9]{11}$/.test(b) && (b = b.substr(2)), !/^[0-9]{11}$/.test(b)) return !1;
            var c, d = parseInt(b.charAt(0), 10), e = 0, f = [], g = b.length;
            if (d > 3) {
                for (e = 0, f = [9, 1, 4, 8, 3, 10, 2, 5, 7, 6, 1], c = 0; g > c; c++) e += parseInt(b.charAt(c), 10) * f[c];
                return e %= 11, 3 === e
            }
            var h = parseInt(b.substr(0, 2), 10), i = parseInt(b.substr(2, 2), 10), j = parseInt(b.substr(4, 2), 10);
            if (j = j + 1800 + 100 * parseInt(b.charAt(6), 10), !a.fn.bootstrapValidator.helpers.date(j, i, h)) return !1;
            for (e = 0, f = [10, 5, 8, 4, 2, 1, 6, 3, 7, 9], c = 0; g - 1 > c; c++) e += parseInt(b.charAt(c), 10) * f[c];
            return e = (e + 1) % 11 % 10, e + "" === b.charAt(g - 1)
        },
        _mt: function (a) {
            if (/^MT[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^[0-9]{8}$/.test(a)) return !1;
            for (var b = 0, c = [3, 4, 6, 7, 8, 9, 10, 1], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 37 === 0
        },
        _nl: function (a) {
            if (/^NL[0-9]{9}B[0-9]{2}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}B[0-9]{2}$/.test(a)) return !1;
            for (var b = 0, c = [9, 8, 7, 6, 5, 4, 3, 2], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b %= 11, b > 9 && (b = 0), b + "" === a.substr(8, 1)
        },
        _no: function (a) {
            if (/^NO[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}$/.test(a)) return !1;
            for (var b = 0, c = [3, 2, 7, 6, 5, 4, 3, 2], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = 11 - b % 11, 11 === b && (b = 0), b + "" === a.substr(8, 1)
        },
        _pl: function (a) {
            if (/^PL[0-9]{10}$/.test(a) && (a = a.substr(2)), !/^[0-9]{10}$/.test(a)) return !1;
            for (var b = 0, c = [6, 5, 7, 2, 3, 4, 5, 6, 7, -1], d = 0; 10 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b % 11 === 0
        },
        _pt: function (a) {
            if (/^PT[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}$/.test(a)) return !1;
            for (var b = 0, c = [9, 8, 7, 6, 5, 4, 3, 2], d = 0; 8 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = 11 - b % 11, b > 9 && (b = 0), b + "" === a.substr(8, 1)
        },
        _ro: function (a) {
            if (/^RO[1-9][0-9]{1,9}$/.test(a) && (a = a.substr(2)), !/^[1-9][0-9]{1,9}$/.test(a)) return !1;
            for (var b = a.length, c = [7, 5, 3, 2, 1, 7, 5, 3, 2].slice(10 - b), d = 0, e = 0; b - 1 > e; e++) d += parseInt(a.charAt(e), 10) * c[e];
            return d = 10 * d % 11 % 10, d + "" === a.substr(b - 1, 1)
        },
        _ru: function (a) {
            if (/^RU([0-9]{10}|[0-9]{12})$/.test(a) && (a = a.substr(2)), !/^([0-9]{10}|[0-9]{12})$/.test(a)) return !1;
            var b = 0;
            if (10 === a.length) {
                var c = 0, d = [2, 4, 10, 3, 5, 9, 4, 6, 8, 0];
                for (b = 0; 10 > b; b++) c += parseInt(a.charAt(b), 10) * d[b];
                return c %= 11, c > 9 && (c %= 10), c + "" === a.substr(9, 1)
            }
            if (12 === a.length) {
                var e = 0, f = [7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0], g = 0, h = [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0];
                for (b = 0; 11 > b; b++) e += parseInt(a.charAt(b), 10) * f[b], g += parseInt(a.charAt(b), 10) * h[b];
                return e %= 11, e > 9 && (e %= 10), g %= 11, g > 9 && (g %= 10), e + "" === a.substr(10, 1) && g + "" === a.substr(11, 1)
            }
            return !1
        },
        _rs: function (a) {
            if (/^RS[0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[0-9]{9}$/.test(a)) return !1;
            for (var b = 10, c = 0, d = 0; 8 > d; d++) c = (parseInt(a.charAt(d), 10) + b) % 10, 0 === c && (c = 10), b = 2 * c % 11;
            return (b + parseInt(a.substr(8, 1), 10)) % 10 === 1
        },
        _se: function (b) {
            return /^SE[0-9]{10}01$/.test(b) && (b = b.substr(2)), /^[0-9]{10}01$/.test(b) ? (b = b.substr(0, 10), a.fn.bootstrapValidator.helpers.luhn(b)) : !1
        },
        _si: function (a) {
            if (/^SI[0-9]{8}$/.test(a) && (a = a.substr(2)), !/^[0-9]{8}$/.test(a)) return !1;
            for (var b = 0, c = [8, 7, 6, 5, 4, 3, 2], d = 0; 7 > d; d++) b += parseInt(a.charAt(d), 10) * c[d];
            return b = 11 - b % 11, 10 === b && (b = 0), b + "" === a.substr(7, 1)
        },
        _sk: function (a) {
            return /^SK[1-9][0-9][(2-4)|(6-9)][0-9]{7}$/.test(a) && (a = a.substr(2)), /^[1-9][0-9][(2-4)|(6-9)][0-9]{7}$/.test(a) ? parseInt(a, 10) % 11 === 0 : !1
        },
        _ve: function (a) {
            if (/^VE[VEJPG][0-9]{9}$/.test(a) && (a = a.substr(2)), !/^[VEJPG][0-9]{9}$/.test(a)) return !1;
            for (var b = {
                V: 4,
                E: 8,
                J: 12,
                P: 16,
                G: 20
            }, c = b[a.charAt(0)], d = [3, 2, 7, 6, 5, 4, 3, 2], e = 0; 8 > e; e++) c += parseInt(a.charAt(e + 1), 10) * d[e];
            return c = 11 - c % 11, (11 === c || 10 === c) && (c = 0), c + "" === a.substr(9, 1)
        },
        _za: function (a) {
            return /^ZA4[0-9]{9}$/.test(a) && (a = a.substr(2)), /^4[0-9]{9}$/.test(a)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.vin = a.extend(a.fn.bootstrapValidator.i18n.vin || {}, {"default": "Please enter a valid VIN number"}), a.fn.bootstrapValidator.validators.vin = {
        validate: function (a, b) {
            var c = b.val();
            if ("" === c) return !0;
            if (!/^[a-hj-npr-z0-9]{8}[0-9xX][a-hj-npr-z0-9]{8}$/i.test(c)) return !1;
            c = c.toUpperCase();
            for (var d = {
                A: 1,
                B: 2,
                C: 3,
                D: 4,
                E: 5,
                F: 6,
                G: 7,
                H: 8,
                J: 1,
                K: 2,
                L: 3,
                M: 4,
                N: 5,
                P: 7,
                R: 9,
                S: 2,
                T: 3,
                U: 4,
                V: 5,
                W: 6,
                X: 7,
                Y: 8,
                Z: 9,
                1: 1,
                2: 2,
                3: 3,
                4: 4,
                5: 5,
                6: 6,
                7: 7,
                8: 8,
                9: 9,
                0: 0
            }, e = [8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2], f = 0, g = c.length, h = 0; g > h; h++) f += d[c.charAt(h) + ""] * e[h];
            var i = f % 11;
            return 10 === i && (i = "X"), i + "" === c.charAt(8)
        }
    }
}(window.jQuery), function (a) {
    a.fn.bootstrapValidator.i18n.zipCode = a.extend(a.fn.bootstrapValidator.i18n.zipCode || {}, {
        "default": "Please enter a valid postal code",
        countryNotSupported: "The country code %s is not supported",
        country: "Please enter a valid postal code in %s",
        countries: {
            AT: "Austria",
            BR: "Brazil",
            CA: "Canada",
            CH: "Switzerland",
            CZ: "Czech Republic",
            DE: "Germany",
            DK: "Denmark",
            FR: "France",
            GB: "United Kingdom",
            IE: "Ireland",
            IT: "Italy",
            MA: "Morocco",
            NL: "Netherlands",
            PT: "Portugal",
            RO: "Romania",
            RU: "Russia",
            SE: "Sweden",
            SG: "Singapore",
            SK: "Slovakia",
            US: "USA"
        }
    }), a.fn.bootstrapValidator.validators.zipCode = {
        html5Attributes: {message: "message", country: "country"},
        COUNTRY_CODES: ["AT", "BR", "CA", "CH", "CZ", "DE", "DK", "FR", "GB", "IE", "IT", "MA", "NL", "PT", "RO", "RU", "SE", "SG", "SK", "US"],
        validate: function (b, c, d) {
            var e = c.val();
            if ("" === e || !d.country) return !0;
            var f = d.country;
            if (("string" != typeof f || -1 === a.inArray(f, this.COUNTRY_CODES)) && (f = b.getDynamicOption(c, f)), !f || -1 === a.inArray(f.toUpperCase(), this.COUNTRY_CODES)) return {
                valid: !1,
                message: a.fn.bootstrapValidator.helpers.format(a.fn.bootstrapValidator.i18n.zipCode.countryNotSupported, f)
            };
            var g = !1;
            switch (f = f.toUpperCase()) {
                case"AT":
                    g = /^([1-9]{1})(\d{3})$/.test(e);
                    break;
                case"BR":
                    g = /^(\d{2})([\.]?)(\d{3})([\-]?)(\d{3})$/.test(e);
                    break;
                case"CA":
                    g = /^(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|X|Y){1}[0-9]{1}(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|W|X|Y|Z){1}\s?[0-9]{1}(?:A|B|C|E|G|H|J|K|L|M|N|P|R|S|T|V|W|X|Y|Z){1}[0-9]{1}$/i.test(e);
                    break;
                case"CH":
                    g = /^([1-9]{1})(\d{3})$/.test(e);
                    break;
                case"CZ":
                    g = /^(\d{3})([ ]?)(\d{2})$/.test(e);
                    break;
                case"DE":
                    g = /^(?!01000|99999)(0[1-9]\d{3}|[1-9]\d{4})$/.test(e);
                    break;
                case"DK":
                    g = /^(DK(-|\s)?)?\d{4}$/i.test(e);
                    break;
                case"FR":
                    g = /^[0-9]{5}$/i.test(e);
                    break;
                case"GB":
                    g = this._gb(e);
                    break;
                case"IE":
                    g = /^(D6W|[ACDEFHKNPRTVWXY]\d{2})\s[0-9ACDEFHKNPRTVWXY]{4}$/.test(e);
                    break;
                case"IT":
                    g = /^(I-|IT-)?\d{5}$/i.test(e);
                    break;
                case"MA":
                    g = /^[1-9][0-9]{4}$/i.test(e);
                    break;
                case"NL":
                    g = /^[1-9][0-9]{3} ?(?!sa|sd|ss)[a-z]{2}$/i.test(e);
                    break;
                case"PT":
                    g = /^[1-9]\d{3}-\d{3}$/.test(e);
                    break;
                case"RO":
                    g = /^(0[1-8]{1}|[1-9]{1}[0-5]{1})?[0-9]{4}$/i.test(e);
                    break;
                case"RU":
                    g = /^[0-9]{6}$/i.test(e);
                    break;
                case"SE":
                    g = /^(S-)?\d{3}\s?\d{2}$/i.test(e);
                    break;
                case"SG":
                    g = /^([0][1-9]|[1-6][0-9]|[7]([0-3]|[5-9])|[8][0-2])(\d{4})$/i.test(e);
                    break;
                case"SK":
                    g = /^(\d{3})([ ]?)(\d{2})$/.test(e);
                    break;
                case"US":
                default:
                    g = /^\d{4,5}([\-]?\d{4})?$/.test(e)
            }
            return {
                valid: g,
                message: a.fn.bootstrapValidator.helpers.format(d.message || a.fn.bootstrapValidator.i18n.zipCode.country, a.fn.bootstrapValidator.i18n.zipCode.countries[f])
            }
        },
        _gb: function (a) {
            for (var b = "[ABCDEFGHIJKLMNOPRSTUWYZ]", c = "[ABCDEFGHKLMNOPQRSTUVWXY]", d = "[ABCDEFGHJKPMNRSTUVWXY]", e = "[ABEHMNPRVWXY]", f = "[ABDEFGHJLNPQRSTUWXYZ]", g = [new RegExp("^(" + b + "{1}" + c + "?[0-9]{1,2})(\\s*)([0-9]{1}" + f + "{2})$", "i"), new RegExp("^(" + b + "{1}[0-9]{1}" + d + "{1})(\\s*)([0-9]{1}" + f + "{2})$", "i"), new RegExp("^(" + b + "{1}" + c + "{1}?[0-9]{1}" + e + "{1})(\\s*)([0-9]{1}" + f + "{2})$", "i"), new RegExp("^(BF1)(\\s*)([0-6]{1}[ABDEFGHJLNPQRST]{1}[ABDEFGHJLNPQRSTUWZYZ]{1})$", "i"), /^(GIR)(\s*)(0AA)$/i, /^(BFPO)(\s*)([0-9]{1,4})$/i, /^(BFPO)(\s*)(c\/o\s*[0-9]{1,3})$/i, /^([A-Z]{4})(\s*)(1ZZ)$/i, /^(AI-2640)$/i], h = 0; h < g.length; h++) if (g[h].test(a)) return !0;
            return !1
        }
    }
}(window.jQuery);
/*!
 * Jasny Bootstrap v3.1.3 (http://jasny.github.io/bootstrap)
 * Copyright 2012-2014 Arnold Daniels
 * Licensed under Apache-2.0 (https://github.com/jasny/bootstrap/blob/master/LICENSE)
 */
if ("undefined" == typeof jQuery) throw new Error("Jasny Bootstrap's JavaScript requires jQuery");
+function (a) {
    "use strict";

    function b() {
        var a = document.createElement("bootstrap"), b = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var c in b) if (void 0 !== a.style[c]) return {end: b[c]};
        return !1
    }

    void 0 === a.support.transition && (a.fn.emulateTransitionEnd = function (b) {
        var c = !1, d = this;
        a(this).one(a.support.transition.end, function () {
            c = !0
        });
        var e = function () {
            c || a(d).trigger(a.support.transition.end)
        };
        return setTimeout(e, b), this
    }, a(function () {
        a.support.transition = b()
    }))
}(window.jQuery), +function (a) {
    "use strict";
    var b = function (c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.state = null, this.placement = null, this.options.recalc && (this.calcClone(), a(window).on("resize", a.proxy(this.recalc, this))), this.options.autohide && a(document).on("click", a.proxy(this.autohide, this)), this.options.toggle && this.toggle(), this.options.disablescrolling && (this.options.disableScrolling = this.options.disablescrolling, delete this.options.disablescrolling)
    };
    b.DEFAULTS = {
        toggle: !0,
        placement: "auto",
        autohide: !0,
        recalc: !0,
        disableScrolling: !0
    }, b.prototype.offset = function () {
        switch (this.placement) {
            case"left":
            case"right":
                return this.$element.outerWidth();
            case"top":
            case"bottom":
                return this.$element.outerHeight()
        }
    }, b.prototype.calcPlacement = function () {
        function b(a, b) {
            if ("auto" === e.css(b)) return a;
            if ("auto" === e.css(a)) return b;
            var c = parseInt(e.css(a), 10), d = parseInt(e.css(b), 10);
            return c > d ? b : a
        }

        if ("auto" !== this.options.placement) return void(this.placement = this.options.placement);
        this.$element.hasClass("in") || this.$element.css("visiblity", "hidden !important").addClass("in");
        var c = a(window).width() / this.$element.width(), d = a(window).height() / this.$element.height(),
            e = this.$element;
        this.placement = c >= d ? b("left", "right") : b("top", "bottom"), "hidden !important" === this.$element.css("visibility") && this.$element.removeClass("in").css("visiblity", "")
    }, b.prototype.opposite = function (a) {
        switch (a) {
            case"top":
                return "bottom";
            case"left":
                return "right";
            case"bottom":
                return "top";
            case"right":
                return "left"
        }
    }, b.prototype.getCanvasElements = function () {
        var b = this.options.canvas ? a(this.options.canvas) : this.$element, c = b.find("*").filter(function () {
            return "fixed" === a(this).css("position")
        }).not(this.options.exclude);
        return b.add(c)
    }, b.prototype.slide = function (b, c, d) {
        if (!a.support.transition) {
            var e = {};
            return e[this.placement] = "+=" + c, b.animate(e, 350, d)
        }
        var f = this.placement, g = this.opposite(f);
        b.each(function () {
            "auto" !== a(this).css(f) && a(this).css(f, (parseInt(a(this).css(f), 10) || 0) + c), "auto" !== a(this).css(g) && a(this).css(g, (parseInt(a(this).css(g), 10) || 0) - c)
        }), this.$element.one(a.support.transition.end, d).emulateTransitionEnd(350)
    }, b.prototype.disableScrolling = function () {
        var b = a("body").width(), c = "padding-" + this.opposite(this.placement);
        if (void 0 === a("body").data("offcanvas-style") && a("body").data("offcanvas-style", a("body").attr("style") || ""), a("body").css("overflow", "hidden"), a("body").width() > b) {
            var d = parseInt(a("body").css(c), 10) + a("body").width() - b;
            setTimeout(function () {
                a("body").css(c, d)
            }, 1)
        }
    }, b.prototype.show = function () {
        if (!this.state) {
            var b = a.Event("show.bs.offcanvas");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                this.state = "slide-in", this.calcPlacement();
                var c = this.getCanvasElements(), d = this.placement, e = this.opposite(d), f = this.offset();
                -1 !== c.index(this.$element) && (a(this.$element).data("offcanvas-style", a(this.$element).attr("style") || ""), this.$element.css(d, -1 * f), this.$element.css(d)), c.addClass("canvas-sliding").each(function () {
                    void 0 === a(this).data("offcanvas-style") && a(this).data("offcanvas-style", a(this).attr("style") || ""), "static" === a(this).css("position") && a(this).css("position", "relative"), "auto" !== a(this).css(d) && "0px" !== a(this).css(d) || "auto" !== a(this).css(e) && "0px" !== a(this).css(e) || a(this).css(d, 0)
                }), this.options.disableScrolling && this.disableScrolling();
                var g = function () {
                    "slide-in" == this.state && (this.state = "slid", c.removeClass("canvas-sliding").addClass("canvas-slid"), this.$element.trigger("shown.bs.offcanvas"))
                };
                setTimeout(a.proxy(function () {
                    this.$element.addClass("in"), this.slide(c, f, a.proxy(g, this))
                }, this), 1)
            }
        }
    }, b.prototype.hide = function () {
        if ("slid" === this.state) {
            var b = a.Event("hide.bs.offcanvas");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                this.state = "slide-out";
                var c = a(".canvas-slid"), d = (this.placement, -1 * this.offset()), e = function () {
                    "slide-out" == this.state && (this.state = null, this.placement = null, this.$element.removeClass("in"), c.removeClass("canvas-sliding"), c.add(this.$element).add("body").each(function () {
                        a(this).attr("style", a(this).data("offcanvas-style")).removeData("offcanvas-style")
                    }), this.$element.trigger("hidden.bs.offcanvas"))
                };
                c.removeClass("canvas-slid").addClass("canvas-sliding"), setTimeout(a.proxy(function () {
                    this.slide(c, d, a.proxy(e, this))
                }, this), 1)
            }
        }
    }, b.prototype.toggle = function () {
        "slide-in" !== this.state && "slide-out" !== this.state && this["slid" === this.state ? "hide" : "show"]()
    }, b.prototype.calcClone = function () {
        this.$calcClone = this.$element.clone().html("").addClass("offcanvas-clone").removeClass("in").appendTo(a("body"))
    }, b.prototype.recalc = function () {
        if ("none" !== this.$calcClone.css("display") && ("slid" === this.state || "slide-in" === this.state)) {
            this.state = null, this.placement = null;
            var b = this.getCanvasElements();
            this.$element.removeClass("in"), b.removeClass("canvas-slid"), b.add(this.$element).add("body").each(function () {
                a(this).attr("style", a(this).data("offcanvas-style")).removeData("offcanvas-style")
            })
        }
    }, b.prototype.autohide = function (b) {
        0 === a(b.target).closest(this.$element).length && this.hide()
    };
    var c = a.fn.offcanvas;
    a.fn.offcanvas = function (c) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.offcanvas"),
                f = a.extend({}, b.DEFAULTS, d.data(), "object" == typeof c && c);
            e || d.data("bs.offcanvas", e = new b(this, f)), "string" == typeof c && e[c]()
        })
    }, a.fn.offcanvas.Constructor = b, a.fn.offcanvas.noConflict = function () {
        return a.fn.offcanvas = c, this
    }, a(document).on("click.bs.offcanvas.data-api", "[data-toggle=offcanvas]", function (b) {
        var c, d = a(this),
            e = d.attr("data-target") || b.preventDefault() || (c = d.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, ""),
            f = a(e), g = f.data("bs.offcanvas"), h = g ? "toggle" : d.data();
        b.stopPropagation(), g ? g.toggle() : f.offcanvas(h)
    })
}(window.jQuery), +function (a) {
    "use strict";
    var b = function (c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.$element.on("click.bs.rowlink", "td:not(.rowlink-skip)", a.proxy(this.click, this))
    };
    b.DEFAULTS = {target: "a"}, b.prototype.click = function (b) {
        var c = a(b.currentTarget).closest("tr").find(this.options.target)[0];
        if (a(b.target)[0] !== c) if (b.preventDefault(), c.click) c.click(); else if (document.createEvent) {
            var d = document.createEvent("MouseEvents");
            d.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), c.dispatchEvent(d)
        }
    };
    var c = a.fn.rowlink;
    a.fn.rowlink = function (c) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.rowlink");
            e || d.data("bs.rowlink", e = new b(this, c))
        })
    }, a.fn.rowlink.Constructor = b, a.fn.rowlink.noConflict = function () {
        return a.fn.rowlink = c, this
    }, a(document).on("click.bs.rowlink.data-api", '[data-link="row"]', function (b) {
        if (0 === a(b.target).closest(".rowlink-skip").length) {
            var c = a(this);
            c.data("bs.rowlink") || (c.rowlink(c.data()), a(b.target).trigger("click.bs.rowlink"))
        }
    })
}(window.jQuery), +function (a) {
    "use strict";
    var b = void 0 !== window.orientation, c = navigator.userAgent.toLowerCase().indexOf("android") > -1,
        d = "Microsoft Internet Explorer" == window.navigator.appName, e = function (b, d) {
            c || (this.$element = a(b), this.options = a.extend({}, e.DEFAULTS, d), this.mask = String(this.options.mask), this.init(), this.listen(), this.checkVal())
        };
    e.DEFAULTS = {
        mask: "",
        placeholder: "_",
        definitions: {9: "[0-9]", a: "[A-Za-z]", w: "[A-Za-z0-9]", "*": "."}
    }, e.prototype.init = function () {
        var b = this.options.definitions, c = this.mask.length;
        this.tests = [], this.partialPosition = this.mask.length, this.firstNonMaskPos = null, a.each(this.mask.split(""), a.proxy(function (a, d) {
            "?" == d ? (c--, this.partialPosition = a) : b[d] ? (this.tests.push(new RegExp(b[d])), null === this.firstNonMaskPos && (this.firstNonMaskPos = this.tests.length - 1)) : this.tests.push(null)
        }, this)), this.buffer = a.map(this.mask.split(""), a.proxy(function (a) {
            return "?" != a ? b[a] ? this.options.placeholder : a : void 0
        }, this)), this.focusText = this.$element.val(), this.$element.data("rawMaskFn", a.proxy(function () {
            return a.map(this.buffer, function (a, b) {
                return this.tests[b] && a != this.options.placeholder ? a : null
            }).join("")
        }, this))
    }, e.prototype.listen = function () {
        if (!this.$element.attr("readonly")) {
            var b = (d ? "paste" : "input") + ".mask";
            this.$element.on("unmask.bs.inputmask", a.proxy(this.unmask, this)).on("focus.bs.inputmask", a.proxy(this.focusEvent, this)).on("blur.bs.inputmask", a.proxy(this.blurEvent, this)).on("keydown.bs.inputmask", a.proxy(this.keydownEvent, this)).on("keypress.bs.inputmask", a.proxy(this.keypressEvent, this)).on(b, a.proxy(this.pasteEvent, this))
        }
    }, e.prototype.caret = function (a, b) {
        if (0 !== this.$element.length) {
            if ("number" == typeof a) return b = "number" == typeof b ? b : a, this.$element.each(function () {
                if (this.setSelectionRange) this.setSelectionRange(a, b); else if (this.createTextRange) {
                    var c = this.createTextRange();
                    c.collapse(!0), c.moveEnd("character", b), c.moveStart("character", a), c.select()
                }
            });
            if (this.$element[0].setSelectionRange) a = this.$element[0].selectionStart, b = this.$element[0].selectionEnd; else if (document.selection && document.selection.createRange) {
                var c = document.selection.createRange();
                a = 0 - c.duplicate().moveStart("character", -1e5), b = a + c.text.length
            }
            return {begin: a, end: b}
        }
    }, e.prototype.seekNext = function (a) {
        for (var b = this.mask.length; ++a <= b && !this.tests[a];) ;
        return a
    }, e.prototype.seekPrev = function (a) {
        for (; --a >= 0 && !this.tests[a];) ;
        return a
    }, e.prototype.shiftL = function (a, b) {
        var c = this.mask.length;
        if (!(0 > a)) {
            for (var d = a, e = this.seekNext(b); c > d; d++) if (this.tests[d]) {
                if (!(c > e && this.tests[d].test(this.buffer[e]))) break;
                this.buffer[d] = this.buffer[e], this.buffer[e] = this.options.placeholder, e = this.seekNext(e)
            }
            this.writeBuffer(), this.caret(Math.max(this.firstNonMaskPos, a))
        }
    }, e.prototype.shiftR = function (a) {
        for (var b = this.mask.length, c = a, d = this.options.placeholder; b > c; c++) if (this.tests[c]) {
            var e = this.seekNext(c), f = this.buffer[c];
            if (this.buffer[c] = d, !(b > e && this.tests[e].test(f))) break;
            d = f
        }
    }, e.prototype.unmask = function () {
        this.$element.unbind(".mask").removeData("inputmask")
    }, e.prototype.focusEvent = function () {
        this.focusText = this.$element.val();
        var a = this.mask.length, b = this.checkVal();
        this.writeBuffer();
        var c = this, d = function () {
            b == a ? c.caret(0, b) : c.caret(b)
        };
        d(), setTimeout(d, 50)
    }, e.prototype.blurEvent = function () {
        this.checkVal(), this.$element.val() !== this.focusText && this.$element.trigger("change")
    }, e.prototype.keydownEvent = function (a) {
        var c = a.which;
        if (8 == c || 46 == c || b && 127 == c) {
            var d = this.caret(), e = d.begin, f = d.end;
            return f - e === 0 && (e = 46 != c ? this.seekPrev(e) : f = this.seekNext(e - 1), f = 46 == c ? this.seekNext(f) : f), this.clearBuffer(e, f), this.shiftL(e, f - 1), !1
        }
        return 27 == c ? (this.$element.val(this.focusText), this.caret(0, this.checkVal()), !1) : void 0
    }, e.prototype.keypressEvent = function (a) {
        var b = this.mask.length, c = a.which, d = this.caret();
        if (a.ctrlKey || a.altKey || a.metaKey || 32 > c) return !0;
        if (c) {
            d.end - d.begin !== 0 && (this.clearBuffer(d.begin, d.end), this.shiftL(d.begin, d.end - 1));
            var e = this.seekNext(d.begin - 1);
            if (b > e) {
                var f = String.fromCharCode(c);
                if (this.tests[e].test(f)) {
                    this.shiftR(e), this.buffer[e] = f, this.writeBuffer();
                    var g = this.seekNext(e);
                    this.caret(g)
                }
            }
            return !1
        }
    }, e.prototype.pasteEvent = function () {
        var a = this;
        setTimeout(function () {
            a.caret(a.checkVal(!0))
        }, 0)
    }, e.prototype.clearBuffer = function (a, b) {
        for (var c = this.mask.length, d = a; b > d && c > d; d++) this.tests[d] && (this.buffer[d] = this.options.placeholder)
    }, e.prototype.writeBuffer = function () {
        return this.$element.val(this.buffer.join("")).val()
    }, e.prototype.checkVal = function (a) {
        for (var b = this.mask.length, c = this.$element.val(), d = -1, e = 0, f = 0; b > e; e++) if (this.tests[e]) {
            for (this.buffer[e] = this.options.placeholder; f++ < c.length;) {
                var g = c.charAt(f - 1);
                if (this.tests[e].test(g)) {
                    this.buffer[e] = g, d = e;
                    break
                }
            }
            if (f > c.length) break
        } else this.buffer[e] == c.charAt(f) && e != this.partialPosition && (f++, d = e);
        return !a && d + 1 < this.partialPosition ? (this.$element.val(""), this.clearBuffer(0, b)) : (a || d + 1 >= this.partialPosition) && (this.writeBuffer(), a || this.$element.val(this.$element.val().substring(0, d + 1))), this.partialPosition ? e : this.firstNonMaskPos
    };
    var f = a.fn.inputmask;
    a.fn.inputmask = function (b) {
        return this.each(function () {
            var c = a(this), d = c.data("bs.inputmask");
            d || c.data("bs.inputmask", d = new e(this, b))
        })
    }, a.fn.inputmask.Constructor = e, a.fn.inputmask.noConflict = function () {
        return a.fn.inputmask = f, this
    }, a(document).on("focus.bs.inputmask.data-api", "[data-mask]", function () {
        var b = a(this);
        b.data("bs.inputmask") || b.inputmask(b.data())
    })
}(window.jQuery), +function (a) {
    "use strict";
    var b = "Microsoft Internet Explorer" == window.navigator.appName, c = function (b, c) {
        if (this.$element = a(b), this.$input = this.$element.find(":file"), 0 !== this.$input.length) {
            this.name = this.$input.attr("name") || c.name, this.$hidden = this.$element.find('input[type=hidden][name="' + this.name + '"]'), 0 === this.$hidden.length && (this.$hidden = a('<input type="hidden">').insertBefore(this.$input)), this.$preview = this.$element.find(".fileinput-preview");
            var d = this.$preview.css("height");
            "inline" !== this.$preview.css("display") && "0px" !== d && "none" !== d && this.$preview.css("line-height", d), this.original = {
                exists: this.$element.hasClass("fileinput-exists"),
                preview: this.$preview.html(),
                hiddenVal: this.$hidden.val()
            }, this.listen()
        }
    };
    c.prototype.listen = function () {
        this.$input.on("change.bs.fileinput", a.proxy(this.change, this)), a(this.$input[0].form).on("reset.bs.fileinput", a.proxy(this.reset, this)), this.$element.find('[data-trigger="fileinput"]').on("click.bs.fileinput", a.proxy(this.trigger, this)), this.$element.find('[data-dismiss="fileinput"]').on("click.bs.fileinput", a.proxy(this.clear, this))
    }, c.prototype.change = function (b) {
        var c = void 0 === b.target.files ? b.target && b.target.value ? [{name: b.target.value.replace(/^.+\\/, "")}] : [] : b.target.files;
        if (b.stopPropagation(), 0 === c.length) return void this.clear();
        this.$hidden.val(""), this.$hidden.attr("name", ""), this.$input.attr("name", this.name);
        var d = c[0];
        if (this.$preview.length > 0 && ("undefined" != typeof d.type ? d.type.match(/^image\/(gif|png|jpeg)$/) : d.name.match(/\.(gif|png|jpe?g)$/i)) && "undefined" != typeof FileReader) {
            var e = new FileReader, f = this.$preview, g = this.$element;
            e.onload = function (b) {
                var e = a("<img>");
                e[0].src = b.target.result, c[0].result = b.target.result, g.find(".fileinput-filename").text(d.name), "none" != f.css("max-height") && e.css("max-height", parseInt(f.css("max-height"), 10) - parseInt(f.css("padding-top"), 10) - parseInt(f.css("padding-bottom"), 10) - parseInt(f.css("border-top"), 10) - parseInt(f.css("border-bottom"), 10)), f.html(e), g.addClass("fileinput-exists").removeClass("fileinput-new"), g.trigger("change.bs.fileinput", c)
            }, e.readAsDataURL(d)
        } else this.$element.find(".fileinput-filename").text(d.name), this.$preview.text(d.name), this.$element.addClass("fileinput-exists").removeClass("fileinput-new"), this.$element.trigger("change.bs.fileinput")
    }, c.prototype.clear = function (a) {
        if (a && a.preventDefault(), this.$hidden.val(""), this.$hidden.attr("name", this.name), this.$input.attr("name", ""), b) {
            var c = this.$input.clone(!0);
            this.$input.after(c), this.$input.remove(), this.$input = c
        } else this.$input.val("");
        this.$preview.html(""), this.$element.find(".fileinput-filename").text(""), this.$element.addClass("fileinput-new").removeClass("fileinput-exists"), void 0 !== a && (this.$input.trigger("change"), this.$element.trigger("clear.bs.fileinput"))
    }, c.prototype.reset = function () {
        this.clear(), this.$hidden.val(this.original.hiddenVal), this.$preview.html(this.original.preview), this.$element.find(".fileinput-filename").text(""), this.original.exists ? this.$element.addClass("fileinput-exists").removeClass("fileinput-new") : this.$element.addClass("fileinput-new").removeClass("fileinput-exists"), this.$element.trigger("reset.bs.fileinput")
    }, c.prototype.trigger = function (a) {
        this.$input.trigger("click"), a.preventDefault()
    };
    var d = a.fn.fileinput;
    a.fn.fileinput = function (b) {
        return this.each(function () {
            var d = a(this), e = d.data("bs.fileinput");
            e || d.data("bs.fileinput", e = new c(this, b)), "string" == typeof b && e[b]()
        })
    }, a.fn.fileinput.Constructor = c, a.fn.fileinput.noConflict = function () {
        return a.fn.fileinput = d, this
    }, a(document).on("click.fileinput.data-api", '[data-provides="fileinput"]', function (b) {
        var c = a(this);
        if (!c.data("bs.fileinput")) {
            c.fileinput(c.data());
            var d = a(b.target).closest('[data-dismiss="fileinput"],[data-trigger="fileinput"]');
            d.length > 0 && (b.preventDefault(), d.trigger("click.bs.fileinput"))
        }
    })
}(window.jQuery);
